/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./engine/src/Application.js":
/*!***********************************!*\
  !*** ./engine/src/Application.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Application": () => (/* binding */ Application),
/* harmony export */   "application": () => (/* binding */ application),
/* harmony export */   "stage": () => (/* binding */ stage)
/* harmony export */ });
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Stage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Stage */ "./engine/src/Stage.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");








const MAX_UPDATE_PER_LOGIC_TICK = 5;


/**
 * 
 *
 * @export
 * @class Application
 */
class Application extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {
    constructor() {
        super();
        console.log( "🎮 Application start." );
        this.stage = new _Stage__WEBPACK_IMPORTED_MODULE_3__.Stage();
        this.lastUpdate = performance.now();
        onmessage = this.onRenderMessage.bind( this );
        this.paused = false;
        this.inputEnabled = true;
        this.physicsReady = false;
        this.physicsWorker = new Worker( "physics.js" );
        this.physicsWorker.onmessage = this.onPhysicsMessage.bind( this );
        this.physicsWorker.postMessage( { msg: "setStageBound",args: [640,480,true,true,true,true] } );

        this.touchEnabled = self._deviceInfo.touchEnabled;
        /** 
         * 논리적인 뷰포트를 얻는다
         * position은 renderViewport로부터의 위치
         * size는 논리 뷰포트 크기 
         */
        this.logicalViewport = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( 0,0,0,0 );
        /** 
         * 렌더 뷰포트의 좌상단 지점에서 로지컬 뷰포트의 원점까지의 로지컬 좌표계로 거리 
         */
        this.logicalViewportOffset = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( self._deviceInfo.logicalViewportOffset );
        /**
         * 렌더 뷰포트 크기:로직 뷰포트 크기
         * 로직이 렌더보다 크면 1 미만
         * 렌더가 로직보다 크면 1 초과 
         */
        this.logicalViewportScale = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( self._deviceInfo.logicalViewportScale );
        /**
         * 디바이스상의 해상도를 얻는다
         * position은 html콘텍스트 상에서의 좌표
         * size 디바이스 뷰포트 크기
         */
        this.deviceViewport = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( self._deviceInfo.deviceViewport );
        

        this.init( 640,480,60,Application.ScaleModes.LETTERBOX );
    }

    init( width,height,fps = 60,scaleMode = Application.ScaleModes.LETTERBOX ) {
        this.logicalViewport = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( 0,0,width,height );
        this.setUpdateFPS( fps );
        this.postMessageToRender( { msg: "addCommand",class: "Application",method: "setLogicalViewport",args: [this.logicalViewport.xywh,scaleMode] } );
    }

    onPhysicsMessage( msg ) {
        const data = msg.data;

        if ( data.msg == "ready" ) {
            console.log( "👍 Physics ready." );       
            this.physicsReady = true;
        } else if ( data.msg == "deviceInfo" ) {
            self._deviceInfo = msg.data.info;
            this.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_6__.Event.RESIZE );
        }
    }

    onRenderMessage( msg ) {
        const data = msg.data;

        if ( data.msg == "render" ) {
            this.renderTick();
        } else if ( data.msg == "deviceInfo" ) {
            this.deviceViewport = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( data.info.deviceViewport );
            this.logicalViewportOffset = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( data.info.logicalViewportOffset );
            this.logicalViewportScale = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( data.info.logicalViewportScale );
            this.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_6__.Event.RESIZE );
        } else if ( data.msg == "Asset_loadCompleted" ) {
            _Asset__WEBPACK_IMPORTED_MODULE_0__.Asset.dispatchLoadedEvent( data.id );
        } else if ( data.msg == "input" && this.enableInput ) {
            this.onInputMessage( data.inputType,data.secondlyInputType,data.inputData );
        } else {
            console.log( "onRenderMessage",msg );
        }
    }

    /** 
     * 로직 뷰포트에서의 렌더 뷰포트의 범위
     * 이 범위로 박스를 생성하면 화면을 모두 가릴 수 있다 
     */
    get logicalRenderBounds() {
        return new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( -this.logicalViewportOffset.x,-this.logicalViewportOffset.y,this.logicalViewport.width + this.logicalViewportOffset.x * 2,this.logicalViewport.height + this.logicalViewportOffset.y * 2 );
    }

    onInputMessage( inputType, secondlyInputType, inputData ) {
        const e = new _Event__WEBPACK_IMPORTED_MODULE_6__.Event( inputType );

        Object.assign( e,inputData );
        this.stage.dispatchEventWithChildren( e );
        if ( !e.stopped && secondlyInputType ) {
            e.name = secondlyInputType;
            this.stage.dispatchEventWithChildren( e );
        }
    }

    renderTick() {
        const now = performance.now();
        const delta =  ( now - this.lastUpdate ) / ( 1000 / this.updateFPS );
        // 프레임 경계에서 안맞을까봐 round처리 해봄
        const numOfUpdate = Math.round( delta );

        if ( !this.paused ) {
            for ( let i = 0; i < Math.min( MAX_UPDATE_PER_LOGIC_TICK,numOfUpdate ); i++ ) {
                this.update();
            }
        }
        this.lastUpdate += ( 1000 / this.updateFPS ) * numOfUpdate;
    }

    /**
     * stage에 update메시지를 발송하고
     * sprite 상태를 main thread로 보낸다
     *
     * @memberof Application
     */
    update() {
        this.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_6__.Event.BEFORE_UPDATE );
        _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.doEnterFrame();
        let [buf,transferList] = this.stage.encodeRenderingInfoWithChildren();

        // console.log( buf,extraBuf,strings );
        if ( this.physicsReady ) {
            this.physicsWorker.postMessage( { msg: "update" } );
        } 
        //@ts-ignore
        this.postMessageToRender( { msg: "update",renderingInfo: buf }, transferList );
        this.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_6__.Event.AFTER_UPDATE );
    }

    setUpdateFPS( FPS ) {
        this.updateFPS = FPS;
        this.postMessageToRender( { msg: "addCommand", class: "Application",method: "setUpdateFPS",args: [this.updateFPS] } );
    }


    /**
     * 엔진을 완전히 정지시키거나 다시 켠다.
     * ENTER_FRAME과 입력 이벤트를 멈추는 것
     *
     * @param {*} v
     * @memberof Application
     */
    setPaused( v ) {
        this.paused = v;
        this.enableInput( !v );
    }

    enableInput( v ) {
        this.inputEnabled = v;
    }

    setBackgroundColor( c ) {
        this.postMessageToRender( { msg: "addCommand", class: "Application", method: "setBackgroundColor",args: [_Utils__WEBPACK_IMPORTED_MODULE_5__.Utils.hex2rgba( c )] } );
    }

    postMessageToRender( msg,transfer ) {
        postMessage( msg,transfer );
    }

    preload( assetFilenames,progressCallback ) {
        return _Asset__WEBPACK_IMPORTED_MODULE_0__.Asset.preload( assetFilenames,progressCallback );
    }
}

Application.ScaleModes = {
    NO_SCALE:   "NO_SCALE",
    CENTER:     "CENTER",
    CROP:       "CROP",
    LETTERBOX:  "LETTERBOX",
    STRETCH:    "STRETCH",
    FIT_WIDTH:  "FIT_WIDTH",
    FIT_HEIGHT: "FIT_HEIGHT",
};


//@ts-ignore
if ( self.application == null ) {
    //@ts-ignore
    self.application = new Application();
} 

/** @type {Application} */
//@ts-ignore
const application = self.application;
/** @type {Stage} */
//@ts-ignore
const stage = self.application.stage;

console.assert( _Utils__WEBPACK_IMPORTED_MODULE_5__.Utils.isWebWorker(),`Application을 메인쓰레드에 만들려고 하고 있음` );


/***/ }),

/***/ "./engine/src/Asset.js":
/*!*****************************!*\
  !*** ./engine/src/Asset.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Asset": () => (/* binding */ Asset)
/* harmony export */ });
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Application */ "./engine/src/Application.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");





const fontInfoCache = {};


class Asset extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {
    /**
     * Creates an instance of AssetProxy.
     * @param {string=} name 관리되는 이름. 이름이 같으면 같은 어셋으로 간주된다.
     * @param {string=} assetType 어셋의 종류
     * @memberof AssetProxy
     */
    constructor( name, assetType ) {
        super();
        this.id = Asset.lastId++;
        if ( name != null && name.indexOf( "*" ) >= 0 ) {
            this.name = name.replace( "*",this.id.toString() );
        } else {
            this.name = name == null ? "" : name;
        }
        this.type = assetType == null ? Asset.guessType( this.name ) : assetType;

        Asset.finalizationRegistry.register( this,{ thisObjId: this.id, thisType: this.type } );

        this.loaded = undefined;
        this.onLoadedHandler = this.onLoaded.bind( this, [this.id] );

        if ( this.type == Asset.AssetTypes.TrueTypeFont
            || this.type == Asset.AssetTypes.BitmapFont
            || this.type == Asset.AssetTypes.Sound
            || this.type == Asset.AssetTypes.Texture ) {
            //LOADED 이벤트를 받아야 하는 타입만 걸어준다
            Asset.loadedEventDispatcher.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED,this.onLoadedHandler );
        }
        this.loadFontInfo( name );
    }

    /**
     * 폰트를 로딩하는 경우 폰트 정보가 따로 필요하다
     *
     * @param {*} name
     * @memberof Asset
     */
    loadFontInfo( name ) {
        if ( this.type == Asset.AssetTypes.TrueTypeFont ) {
            if ( fontInfoCache[name] ) {
                // 캐시에 있는 경우
                this.fontInfo = fontInfoCache[name];
                console.log( `폰트 ${this.name} 로드 완료.(캐시)` );
                this.loaded = true;
                this.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED );
            } else {
                fetch( `asset/${name}.json` )
                    .then( response => {
                        console.assert( response.ok,`asset/${name}.json 로드하지 못했음.` );
                        return response.json();
                    } )
                    .then( data => {
                        this.fontInfo = data;
                        if ( this.fontLoaded ) {
                            fontInfoCache[this.name] = this.fontInfo;
                            console.log( `폰트 ${this.name} 로드 완료.(json을 늦게 로딩)` );
                            this.loaded = true;
                            this.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED );
                        }
                    } );
            }
        } else if ( this.type == Asset.AssetTypes.BitmapFont || this.type == Asset.AssetTypes.MsdfFont ) {
            // 비트맵도 json을 따로 로딩하는 처리 필요
            const json = _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.getEmbeddedFile( name + ".json" );

            this.fontInfo = JSON.parse( json );
            this.loaded = true;
        }
    }


    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @param {boolean} [isOnce=false]
     * @returns {Asset}
     * @memberof Asset
     */
    addEventListener( eventName, func, context = null, isOnce = false ) {
        //@ts-ignore
        return super.addEventListener( eventName, func, context, isOnce );
    }

    release() {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand", class: "Asset", method: "release",args: [this.id] } );
    }

    load( extraData ) {
        // asset.extraData = extraData;
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { 
            msg:    "executeCommand",
            class:  "Asset",
            method: "load",
            args:   [
                { 
                    id:        this.id,
                    type:      this.type,
                    name:      this.name,
                    extraData: extraData,
                }
            ] } );
    }

    update( extraData ) {
        // asset.extraData = extraData;
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { 
            msg:    "addCommand",
            class:  "Asset",
            method: "load",
            args:   [
                { 
                    id:        this.id,
                    type:      this.type,
                    name:      this.name,
                    extraData: extraData,
                }
            ] } );
    }

    onLoaded( id, event ) {
        if ( id == event.id ) {
            // 내 것과 같은 id인 경우에만 이벤트를 부른다
            Asset.loadedEventDispatcher.removeEventListener( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED,this.onLoadedHandler );
            // console.log( Asset.loadedEventDispatcher.eventEmitter );
            if ( this.type == Asset.AssetTypes.TrueTypeFont ) {
                this.fontLoaded = true;
                if ( this.fontInfo ) {
                    fontInfoCache[this.name] = this.fontInfo;
                    console.log( `폰트 ${this.name} 로드 완료.(ttf늦게 로딩)` );
                    this.loaded = true;
                    this.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED );
                }
            } else {
                this.loaded = true;
                this.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED );
            }
        }
    }

    static finalizeHandler( obj ) {
        // GC에 의해 수거되었으면 릴리즈를 보낸다.
        // console.log( `GC ${obj.thisObjId}` );
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand", class: "Asset", method: "release",args: [obj.thisObjId] } );
    }

    static dispatchLoadedEvent( id ) {
        Asset.loadedEventDispatcher.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED,{ id } );
    }

    static guessType( name ) {
        const extMatch = /\.[^.]+$/.exec( name );
        const ext = extMatch != null ? extMatch[0].toLowerCase() : "";


        if ( ext == ".png" || ext == ".jpg" ) {
            return Asset.AssetTypes.Texture;
        } else if ( ext == ".wav" || ext == ".mp3" ) {
            return Asset.AssetTypes.Sound;
        } else if ( ext == ".ttf" ) {
            return Asset.AssetTypes.TrueTypeFont;
        // } else if ( ext == ".fnt") {
        //     return Asset.AssetTypes.BitmapFont;
        // } else if ( ext == ".msdf") {
        //     return Asset.AssetTypes.MsdfFont;
        } return null;
    }

    static findPreloadedAsset( name ) {
        for ( let asset of Asset.preloadAssets ) {
            if ( asset.name == name ) return asset;
        } 
        return null;
    }

    static preload( assetFilenames,progressCallback ) {
        return new Promise( ( resolve,reject )=>{
            for ( let name of assetFilenames ) {
                const asset = new Asset( name );

                asset.load();
                Asset.preloadAssets.push( asset );
                Asset.preloadAssetPromises.push( asset.eventToPromise( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED ) );
            }
            Promise.all( Asset.preloadAssetPromises ).then( resolve );
        } );
    }
}
Asset.AssetTypes = {
    Texture:           "Texture",
    RenderTarget:      "RenderTarget",
    Sound:             "Sound",
    Shader:            "Shader",
    TrueTypeFont:      "TrueTypeFont",
    MsdfFont:          "MsdfFont",
    BitmapFont:        "BitmapFont",
    PostProcessFilter: "PostProcessFilter",
};
Asset.lastId = 1;
Asset.finalizationRegistry = new FinalizationRegistry( Asset.finalizeHandler );
Asset.loadedEventDispatcher = new _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher();

Asset.preloadAssets = [];
Asset.preloadAssetPromises = [];


/***/ }),

/***/ "./engine/src/Bitmap.js":
/*!******************************!*\
  !*** ./engine/src/Bitmap.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bitmap": () => (/* binding */ Bitmap)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _TextureBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextureBase */ "./engine/src/TextureBase.js");



class Bitmap extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    /**
     * Creates an instance of Bitmap.
     * @param {TextureBase} texture
     * @memberof Bitmap
     */
    constructor( texture ) {
        super();
        this._$$spriteType = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.SpriteTypes.BITMAP;
        this._$$updateCode = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.texture = texture;
        this._$$localBounds.x = 0;
        this._$$localBounds.y = 0;
        this._$$localBounds.width = texture.width;
        this._$$localBounds.height = texture.height;
    }

    encodeExtraRenderingInfo() {
        let encodedBuffer = new Float32Array( 9 );

        encodedBuffer[0] = this.texture.asset.id;
        encodedBuffer.set( this.texture.uvRect.getCornerPoints(),1 );
        return [encodedBuffer];
    }

    /**
     * 비트맵의 텍스쳐를 교체한다.
     * 텍스쳐만 바뀌고 비트맵의 크기는 변하지 않는다.
     *
     * @param {TextureBase} texture
     * @memberof Bitmap
     */
    setTexture( texture ) {
        this.texture = texture;
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
    }
}


/***/ }),

/***/ "./engine/src/BitmapFont.js":
/*!**********************************!*\
  !*** ./engine/src/BitmapFont.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitmapFont": () => (/* binding */ BitmapFont)
/* harmony export */ });
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _FontBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FontBase */ "./engine/src/FontBase.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");




class BitmapFont extends _FontBase__WEBPACK_IMPORTED_MODULE_1__.FontBase {
    constructor( bitmapFontName,referenceSize, styles, filter ) {
        super( bitmapFontName, referenceSize, styles );
        // Bitmap
        this.asset = new _Asset__WEBPACK_IMPORTED_MODULE_0__.Asset( bitmapFontName,_Asset__WEBPACK_IMPORTED_MODULE_0__.Asset.AssetTypes.BitmapFont );
        // 페이지가 여러개 있는 폰트는 아직 처리 못함
        const page = this.asset.fontInfo.pages[0];
        const pngSize = _Utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getImageSize( page.file );

        this.asset.load( { 
            bitmap:        page.file, 
            width:         pngSize.width,
            height:        pngSize.height,
            referenceSize: this.referenceSize,
            styles:        this.styles,
            fontInfo:      this.asset.fontInfo,
            filter:        filter
        } );
        this.fontLoaded = false;
    }    

    measureTextWidth( str,size ) {
        super.measureTextWidth( str,size );

        const fontInfo = this.asset.fontInfo;
        const scale = size ? size / fontInfo.info.size : 1;

        let width = 0;

        for ( let i = 0; i < str.length; i++ ) {
            const char = str.charCodeAt( i );
            const charInfo = fontInfo.chars[char];

            width += charInfo.xadvance * scale;
        }
        return width;        
    }
}




/***/ }),

/***/ "./engine/src/Component.js":
/*!*********************************!*\
  !*** ./engine/src/Component.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _ComponentHolder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComponentHolder */ "./engine/src/ComponentHolder.js");






/**
 * 이 클래스를 상속해서 기능을 구현한다.
 * 컴포넌트는 ComponentHolder에 자유롭게 add, remove할 수 있다.
 * add 될 때는 onAdd( holder )가 remove 될 때는 onRemove( holder )가 호출된다.
 * 
 * @class Component
 * 
 */
class Component {
    constructor() {
        // /** 
        //  * 컴포넌트가 holder에 추가될 때 호출된다.
        //  * @callback
        //  * @param {ComponentHolder=} holder
        //  * @memberof Component
        //  */
        // this.onAdded = undefined;
        // /** 
        //  * 컴포넌트가 holder에서 분리될 때 호출된다.
        //  * @callback
        //  * @param {ComponentHolder=} holder
        //  * @memberof Component
        //  */
        // this.onRemoved = undefined;

        /** 
         * 이 컴포넌트가 붙은 ComponentHolder 개체.
         * 이 개체는 addEventListener를 후킹해서 저장해두고 있으므로
         * 명시적으로 분리하지 않아도 자동으로 처리된다.
         * 
         * @readonly
         * @type {ComponentHolder}
         * 
         */
        this.holder = undefined;

        /** @type {Object.<string,[]>} */
        this.__savedHandlers = undefined;

        this.__name = this.constructor.name;
    }
   
    /**
     * 이 개체에 트리거를 추가할 수 있도록 Triggerable Proxy를 반환한다
     * 
     * @returns {Component} - EventDispatcher의 Proxy를 리턴한다
     * @memberof Component
     */
    triggerable() {
        // EventDispatcher의 triggerable을 빌려서 쓴다.
        // dispatchEvent를 구현했기 때문에 빌려써도 괜찮다.
        return _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.prototype.triggerable.call( this );
    }

    /**
     * 이 개체의 holder가 소유한 이벤트를 생성한다.
     * 
     * @param {object=} extenedValues 
     * @param {string=} eventName 
     * @returns {Event}
     * @memberof Component
     */
    newEvent( extenedValues,eventName ) {
        return _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.prototype.newEvent.call( this.holder, extenedValues, eventName );
    }

    /**
     * 
     * 이 개체의 holder가 소유한 트리거를 생성한다.
     * 트리거는 이 개체의 특정 프로퍼티값이 바뀔 때 자동으로 이벤트가 발생되도록 할 수 있다.
     * 
     * @param {object} props - 트리거를 걸 프로퍼티의 목록. { a:true, b:false } 로 하면 a에는 걸고 b에는 지운다.
     * @param {function=} filterFunction - true를 리턴한 경우에만 이벤트가 실행된다
     * @param {string=} eventName - 생략하면 자동으로 이벤트 이름이 부여된다
     * @returns {Event}
     * @memberof Component
     */
    newTrigger( props, filterFunction, eventName ) {
        return _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.prototype.newTrigger.call( this, props, filterFunction, eventName );
    }

    /**
     * 컴포넌트의 이름을 돌려준다
     * 
     * @returns {string}
     * @memberof Component
     */
    getName() {
        return this.__name;
    }

    /**
     * 컴포넌트의 이름을 설정한다. 기본 값은 클래스 이름이다.
     * 이 값을 바꿔서 같은 타입의 컴포넌트를 여러개 붙일 수 있다.
     * 만약 이름이 같다면 원래 있던 컴포넌트는 분리된다.
     * 
     * @param {string} v
     * @memberof Component
     */
    setName( v ) {
        this.__name = v;
    }

    /**
     *
     *
     * @param {Event|string} eventOrName
     * @param {object=} extendedValues
     * @returns {boolean}
     * @memberof Component
     */
    dispatchEvent( eventOrName, extendedValues ) {
        console.assert( this.holder, `컴포넌트 홀더가 없는데 이벤트를 발생시키려고 한다` );
        let event;

        if ( typeof eventOrName == "string" ) {
            event = new _Event__WEBPACK_IMPORTED_MODULE_0__.Event( eventOrName );
        } else {
            event = eventOrName;
        }

        event.target = this.holder;
        event.component = this;
        Object.assign( event,extendedValues );

        return this.holder.dispatchEvent( event );
    }


    isAdded() {
        return this.holder != null;
    }

    removeFromHolder() {
        console.assert( this.holder, `컴포넌트 홀더가 없는데 제거하려고 한다` );
        this.holder.removeComponent( this );
    }
}



/***/ }),

/***/ "./engine/src/ComponentHolder.js":
/*!***************************************!*\
  !*** ./engine/src/ComponentHolder.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComponentHolder": () => (/* binding */ ComponentHolder)
/* harmony export */ });
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");



const searchMap = new WeakMap();


class ComponentHolder extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {
    constructor() {
        super();
        this.__components = {};
    }

    addComponent( com ) {
        const comName = com.getName();

        if ( com.holder != null ) {
            // 붙이려는 컴포넌트가 다른데 붙어있었던 경우 제거
            com.removeFromHolder();
        }
        if ( this.__components[comName] != null ) {
            // 같은 이름의 컴포넌트가 붙어있던 경우 이전 컴포넌트를 제거
            this.__components[comName].removeFromHolder();
        }
        this.__components[comName] = com;
        const arr = searchMap.get( com.constructor ) || [];

        if ( !arr.includes( com ) ) {
            arr.push( com );
            searchMap.set( com.constructor,arr );
        }
        com.holder = new Proxy( this, {
            get: ( t,k ) => {
                if ( k == "addEventListener" ) {
                    return function( eventName, func, context, isOnce ) {
                        // console.log( `${comName}의 ${eventName}이벤트 핸들러를 후킹해서 저장한다` );
                        com.__savedHandlers = com.__savedHandlers || {};
                        com.__savedHandlers[eventName] = com.__savedHandlers[eventName] || [];
                        com.__savedHandlers[eventName].push( [func,context] );
                        //원본을 실행해준다
                        //@ts-ignore
                        t.addEventListener( ...arguments );
                    };
                } else return t[k];
            }
        } );
        if ( com.onAdded ) {
            com.onAdded.call( com, com.holder );
        } else if ( Object.getPrototypeOf( com ).onAdded ) {
            Object.getPrototypeOf( com ).onAdded.call( com, com.holder );
        }

        return com;
    }

    createComponent( classType,obj ) {
        const newCom = new classType();

        this.addComponent( Object.assign( newCom,obj ) );

        return newCom;
    }


    removeComponent( com ) {
        if ( typeof com == "function" && com.prototype != null ) {
            // ClassType으로 삭제를 시도하는 경우
            // 해당 타입의 컴포넌트를 모두 삭제한다
            for ( const key in this.__components ) {
                if ( com.getName() == key ) {
                    this.removeComponent( this.__components[key] );
                }
            }

            return;
        }
        const comName = com.getName();

        if ( com.onRemoved ) {
            com.onRemoved.call( com, com.holder );
        } else if ( Object.getPrototypeOf( com ).onRemoved ) {
            Object.getPrototypeOf( com ).onRemoved.call( com, com.holder );
        }
        delete this.__components[comName];

        if ( com.__savedHandlers ) {
            console.log( `${comName}의 이벤트 핸들러를 정리한다` );
            for ( const eventName in com.__savedHandlers ) {
                for ( const [func,context] of com.__savedHandlers[eventName] ) {
                    console.log( `${eventName} 이벤트 핸들러 삭제` );
                    this.removeEventListener( eventName,func,context );
                }
            }
        }

        const arr = searchMap.get( com.constructor );

        console.assert( Array.isArray( arr ) );
        const i = arr.indexOf( com );

        if ( i >= 0 ) {
            arr.splice( i,1 );
            if ( arr.length > 0 ) {
                searchMap.set( com.constructor,arr );
            } else {
                searchMap.delete( com.constructor );
            }
        }
    }

    hasComponent( comType ) {
        return this.__components[comType.name] != null;
    }

    get components() {
        return this.__components;
    }

    getComponent( comType ) {
        return this.__components[typeof comType == "string" ? comType : comType.name];
    }

    getCompatibleComponents( comType ) {
        const r = [];

        for ( const comName in this.__components ) {
            const com = this.__components[comName];

            if ( com instanceof comType ) {
                r.push( com );
            }
        }

        return r;
    }

    static getAllComponents( comType ) {
        return searchMap.get( comType );
    }

    static getAllComponentHolders( ...comTypes ) {
        let arr;

        arr = this.getAllComponents( comTypes[0] );
        for ( let i = 1; i < comTypes.length; i++ ) {
            const arr2 = this.getAllComponents( comTypes[i] );

            arr = arr2.filter( ( v,i,a ) => arr.includes( v ) );
        }
 
        const r = [];

        for ( const n of arr ) {
            r.push( n.holder );
        }

        return r;
    }

    hasAllComponents( ...comTypes ) {
        for ( const comType of comTypes ) {
            if ( !this.hasComponent( comType ) ) return false;
        }

        return true;
    }
}
ComponentHolder.registeredHolders = {};



/***/ }),

/***/ "./engine/src/Event.js":
/*!*****************************!*\
  !*** ./engine/src/Event.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": () => (/* binding */ Event)
/* harmony export */ });

/** @typedef {import("./Component").Component} Component */
/** @typedef {import("./Sprite").Sprite} Sprite */
/** @typedef {import("./EventDispatcher").EventDispatcher} EventDispatcher */

/**
 * 
 * @class Event
  */
class Event {
    /**
     *Creates an instance of Event.
     * @param {string=} name
     * @param {object=} extendedValues
     * @param {EventDispatcher=} owner
     * @memberof Event
     */
    constructor( name = "@EVENT" + ( ++Event.nextId ), extendedValues,owner ) {
        this.name = name;
        this.stopped = false;
        /** @type {EventDispatcher} */
        this.target = undefined;
        /** @type {Component} */
        this.component = undefined;
        /** @type {EventDispatcher} */
        this.owner = owner;
        this.forwarded = false;

        if ( extendedValues ) {
            Object.assign( this, extendedValues );
        }
    }

    /**
     *
     *
     * @param {function} func
     * @param {object=} context
     * @returns {Event}
     * @memberof Event
     */
    on( func, context ) {
        if ( this.owner == null ) this.owner = new Event.EventDispatcher();
        this.owner.on( this.name, func, context );

        return this;
    }

    /**
     *
     *
     * @param {function} func
     * @param {object=} context
     * @returns {Event}
     * @memberof Event
     */
    once( func, context ) {
        if ( this.owner == null ) this.owner = new Event.EventDispatcher();
        this.owner.once( this.name, func, context );

        return this;
    }

    /**
     *
     *
     * @param {function} func
     * @param {object=} context
     * @param {Sprite=} refSprite
     * @returns {Event}
     * @memberof Event
     */
    onStage( func, context,refSprite ) {
        //@ts-ignore
        console.assert( this.owner && this.owner.addChild, "Sprite가 아니면 onStage를 할 수 없습니다." );
        this.owner.onStage( this.name, func, context, refSprite );

        return this;
    }

    /**
     *
     *
     * @param {function} func
     * @param {object=} context
     * @returns {Event}
     * @memberof Event
     */
    remove( func, context ) {
        if ( this.owner == null ) this.owner = new Event.EventDispatcher();
        this.owner.removeEventListener( this.name, func, context );

        return this;
    }

    /**
     *
     *
     * @param {object=} extendedValues
     * @returns {Event}
     * @memberof Event
     */
    dispatch( extendedValues ) {
        if ( this.owner == null ) this.owner = new Event.EventDispatcher();
        Object.assign( this, extendedValues );
        this.owner.dispatchEvent( this );

        return this;
    }
    

    stopPropagation() {
        this.stopped = true;
    }

    getTarget() {
        return this.target;
    }

    static isInputEvent( eventName ) {
        const att = Event.eventAttribs[eventName];

        if ( att != null ) {
            return att.isInput == true;
        }
    }
}

Event.STAGE_VISIBLE = "stageVisible";
Event.STAGE_FOCUS = "stageFocus";
Event.ENTER_FRAME = "enterFrame";
Event.RENDER = "render";
Event.ADDED_TO_STAGE = "addedToStage";
Event.REMOVED_FROM_STAGE = "removedFromStage";
Event.POINTER_DOWN = "pointerDown";
Event.POINTER_UP = "pointerUp";
Event.POINTER_MOVE = "pointerMove";
Event.MOUSE_DOWN = "mouseDown";
Event.MOUSE_UP = "mouseUp";
Event.MOUSE_MOVE = "mouseMove";
Event.MOUSE_WHEEL = "mouseWheel";
Event.TOUCHES_BEGIN = "touchesBegin";
Event.TOUCHES_MOVE = "touchesMove";
Event.TOUCHES_END = "touchesEnd";
Event.TOUCHES_CANCEL = "touchesCancel";
Event.KEY_UP = "keyUp";
Event.KEY_DOWN = "keyDown";
Event.TIMER = "timer";
Event.TEXTURE_UPDATE = "textureUpdate";
Event.RESIZE = "resize";
Event.READY = "ready";
Event.COMPLETE = "complete";
Event.ERROR = "error";
Event.BEFORE_UPDATE = "beforeUpdate";
Event.AFTER_UPDATE = "afterUpdate";
Event.LOADED = "loaded";
Event.ALL = "*";
Event.APPLICATION_INIT = "APPLICATION_INIT";
Event.APPLICATION_START = "APPLICATION_START";

Event.eventAttribs = {
    [Event.POINTER_DOWN]:   { isInput: true },
    [Event.POINTER_UP]:     { isInput: true },
    [Event.POINTER_MOVE]:   { isInput: true },
    [Event.MOUSE_DOWN]:     { isInput: true, device: "mouse" },
    [Event.MOUSE_UP]:       { isInput: true, device: "mouse" },
    [Event.MOUSE_MOVE]:     { isInput: true, device: "mouse" },
    [Event.MOUSE_WHEEL]:    { isInput: true, device: "mouse" },
    [Event.TOUCHES_BEGIN]:  { isInput: true, device: "touch" },
    [Event.TOUCHES_END]:    { isInput: true, device: "touch" },
    [Event.TOUCHES_MOVE]:   { isInput: true, device: "touch" },
    [Event.TOUCHES_CANCEL]: { isInput: true, device: "touch" },
    [Event.KEY_UP]:         { isInput: true, device: "keyboard" },
    [Event.KEY_DOWN]:       { isInput: true, device: "keyboard" },
};

Event.EventDispatcher = undefined;
Event.nextId = 0;




/***/ }),

/***/ "./engine/src/EventDispatcher.js":
/*!***************************************!*\
  !*** ./engine/src/EventDispatcher.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventDispatcher": () => (/* binding */ EventDispatcher)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");



// eventemitter3에서 _events 폴더에 이벤트를 보관한다고 가정하고 쓰여진 코드임


class EventDispatcher {
    constructor() {
        this.eventEmitter = new (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default())();
    }

    /**
     * 이 개체에 트리거를 추가할 수 있도록 Triggerable Proxy를 반환한다
     * 
     * @returns {EventDispatcher} - EventDispatcher의 Proxy를 리턴한다
     * @memberof EventDispatcher
     */
    triggerable() {
        this.__triggers = {};

        return new Proxy( this, {
            set( target, key, value, receiver ) {
                const r = Reflect.set( target, key, value, receiver );
                const triggers = target.__triggers[key];

                if ( triggers ) {
                    for ( const [eventName, func] of triggers ) {
                        if ( func == null || func( target, key ) ) target.dispatchEvent( eventName, { key } );
                    }
                }

                return r;
            }
        } );
    }

    /**
     * 이 개체가 소유한 이벤트를 생성한다.
     * 
     * @param {object=} extenedValues 
     * @param {string=} eventName 
     * @returns {Event}
     */
    newEvent( extenedValues,eventName ) {
        return new _Event__WEBPACK_IMPORTED_MODULE_1__.Event( eventName, extenedValues, this );
    }

    
    /**
     * 
     * 이 개체가 소유한 트리거를 생성한다.
     * 트리거는 이 개체의 특정 프로퍼티값이 바뀔 때 자동으로 이벤트가 발생되도록 할 수 있다.
     * 
     * @param {object} props - 트리거를 걸 프로퍼티의 목록. { a:true, b:false } 로 하면 a에는 걸고 b에는 지운다.
     * @param {function=} filterFunction - true를 리턴한 경우에만 이벤트가 실행된다
     * @param {string=} eventName - 생략하면 자동으로 이벤트 이름이 부여된다
     * @returns {Event}
     */
    newTrigger( props, filterFunction, eventName ) {
        console.assert( this.__triggers != null, "이 개체는 triggerable이 아닙니다." );
        const e = new _Event__WEBPACK_IMPORTED_MODULE_1__.Event( eventName );

        for ( const prop in props ) {
            if ( props[prop] ) {
                this.__triggers[prop] = this.__triggers[prop] != null ? this.__triggers[prop] : [];
                this.__triggers[prop].push( [e.name, filterFunction] );
            } else {
                delete this.__triggers[prop];
            }
        }

        return e;
    }

    hasEventListener( eventName ) {
        return this.eventEmitter.listeners( eventName ).length > 0;
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @param {boolean} [isOnce=false]
     * @returns {EventDispatcher}
     * @memberof EventDispatcher
     */
    addEventListener( eventName, func, context = null, isOnce = false ) {
        if ( isOnce ) {
            //@ts-ignore
            this.eventEmitter.once( eventName, func, context || this );
        } else {
            //@ts-ignore
            this.eventEmitter.on( eventName, func, context || this );
        }

        if ( eventName == _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ENTER_FRAME || eventName == _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RENDER ) {
            this.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ADDED_TO_STAGE, () => {
                //@ts-ignore
                EventDispatcher.enterFrameList.set( this,this.eventEmitter._events[eventName] != null ? this.eventEmitter._events[eventName].length : 1 );
            } );
            this.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.REMOVED_FROM_STAGE, () => {
                EventDispatcher.enterFrameList.delete( this );
            } );

            // @ts-ignore   this가 sprite로 가정
            if ( this.isOnStage() ) {
                //@ts-ignore
                EventDispatcher.enterFrameList.set( this,this.eventEmitter._events[eventName] != null ? this.eventEmitter._events[eventName].length : 1 );
            }
        } else {
            if ( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.isInputEvent( eventName ) ) {
                this.hasInputEvents = true;
            }
        }

        return this;
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @param {boolean} [isOnce=false]
     * @returns {EventDispatcher}
     * @memberof EventDispatcher
     */
    addUniqueEventListener( eventName, func, context, isOnce = false ) {
        this.removeEventListener( eventName, func, context );
        this.addEventListener( eventName, func, context, isOnce );

        return this;
    }
    
    /**
     *
     *
     * @param {Event|string} eventOrName
     * @param {object=} extendedValues
     * @returns {boolean} - 이벤트 핸들러가 있으면 true
     * @memberof EventDispatcher
     */
    dispatchEvent( eventOrName,extendedValues ) {
        let event;

        if ( typeof eventOrName == "string" ) {
            event = new _Event__WEBPACK_IMPORTED_MODULE_1__.Event( eventOrName );
        } else {
            event = eventOrName;
        }

        event.target = this;
        Object.assign( event,extendedValues );

        if ( !event.forwarded ) this.eventEmitter.emit( "*",event );

        return this.eventEmitter.emit( event.name, event );
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @memberof EventDispatcher
     */
    removeEventListener( eventName, func, context ) {
        //@ts-ignore
        this.eventEmitter.removeListener( eventName, func, context || this );

        //@ts-ignore
        if ( ( eventName == _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ENTER_FRAME || eventName == _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RENDER ) && ( this.eventEmitter._events[eventName] == null || this.eventEmitter._events[eventName].length == 0 ) ) {
            EventDispatcher.enterFrameList.delete( this );
        }

        if ( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.isInputEvent( eventName ) ) {
            //@ts-ignore
            for ( const i in this.eventEmitter._events ) {
                if ( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.isInputEvent( i ) ) {
                    this.hasInputEvents = true;
                    break;
                }
            }
        }
    }

    /**
     *
     *
     * @param {string=} eventName
     * @memberof EventDispatcher
     */
    removeAllEventListeners( eventName ) {
        this.eventEmitter.removeAllListeners( eventName );

        //@ts-ignore
        if ( ( eventName == _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ENTER_FRAME || eventName == _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RENDER ) && ( eventName && this.eventEmitter._events[eventName] == null || this.eventEmitter._events[eventName].length == 0 ) ) {
            EventDispatcher.enterFrameList.delete( this );
        }

        if ( eventName && _Event__WEBPACK_IMPORTED_MODULE_1__.Event.isInputEvent( eventName ) ) {
            //@ts-ignore
            for ( const i in this.eventEmitter._events ) {
                if ( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.isInputEvent( i ) ) {
                    this.hasInputEvents = true;
                    break;
                }
            }
        }
    }


    /**
     *
     *
     * @param {string} event
     * @param {function} func
     * @param {any=} context
     * @param {EventDispatcher} [refSprite=this]
     * @param {boolean} [isOnce=false]
     * @returns {EventDispatcher}
     * @memberof EventDispatcher
     */
    addEventListenerOnStage( event, func, context, refSprite = this, isOnce = false ) {
        const self = this;

        const onAdded = () => {
            self.addEventListener( event, func, context, isOnce );
        };

        const onRemoved = () => {
            self.removeEventListener( event, func, context );
        };

        refSprite.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ADDED_TO_STAGE, onAdded, this );
        refSprite.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.REMOVED_FROM_STAGE, onRemoved, this );

        return this;
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @returns {EventDispatcher}
     * @memberof EventDispatcher
     */
    on( eventName, func, context ) {
        return this.addEventListener( eventName, func, context );
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @returns {EventDispatcher}
     * @memberof EventDispatcher
     */
    once( eventName, func, context ) {
        return this.addEventListener( eventName, func, context, true );
    }

    /**
     *
     *
     * @param {string} event
     * @param {function} func
     * @param {any=} context
     * @param {EventDispatcher} [refSprite=this]
     * @returns {EventDispatcher}
     * @memberof EventDispatcher
     */
    onStage( event, func, context, refSprite = this ) {
        return this.addEventListenerOnStage( event, func, context, refSprite );
    }

    beforeRender( func, context, isUnique = true ) {
        if ( isUnique ) {
            this.removeEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RENDER, func, context );
        }

        this.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RENDER, func, context, true );
    }

    startForwardEvents( eventList,dstEventDispatcher ) {
        for ( let i = 0; i < eventList.length; i++ ) {
            const event = eventList[i];

            this.addEventListener( event,dstEventDispatcher.dispatchEvent.bind( dstEventDispatcher,[event] ) );
        }
    }

    stopForwardEvents( eventList,dstEventDispatcher ) {
        for ( let i = 0; i < eventList.length; i++ ) {
            const event = eventList[i];

            this.removeEventListener( event,dstEventDispatcher.dispatchEvent.bind( dstEventDispatcher,[event] ) );
        }
    }


    /**
     * 이벤트를 모두 기다려서 딱한번 func를 실행한다.
     * 이벤트 목록은 <이벤트이름> 혹은 [이벤트이름, 대상 EventDispatcher]
     *
     * @param {any[]} events
     * @param {function} func
     * @param {any=} context
     * @memberof EventDispatcher
     */
    waitEvents( events, func, context ) {
        const counts = [];
        let waitHandler;

        const removeAll = () => {
            let count = 0;

            for ( const i in events ) {
                let eventName;
                let target = this;

                if ( Array.isArray( events[i] ) ) {
                    [eventName, target] = events[i];
                } else eventName = events[i];
                target.removeEventListener( eventName, waitHandler, count );
                count++;
            }
        };

        waitHandler = function() {
            // this로 받았음
            // @ts-ignore
            counts[this - 1]++;

            for ( let j = 0; j < counts.length; j++ ) {
                if ( counts[j] == 0 ) return;
            }

            removeAll();
            func.call( context );
        };

        for ( const i in events ) {
            let eventName;
            let target = this;

            if ( Array.isArray( events[i] ) ) {
                [eventName, target] = events[i];
            } else eventName = events[i];
            // 0이면 EventEmitter3 내부에서 || 로 걸러지기 때문에 +1 해준다
            const countIndex = counts.length + 1;

            target.addEventListener( eventName, waitHandler, countIndex );
            counts.push( 0 );
        }
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {any[]} events
     * @returns {EventDispatcher}
     * @memberof EventDispatcher
     */
    addCombinedEvents( eventName, events ) {
        this.waitEvents( events, () => {
            this.dispatchEvent( eventName );
        } );

        return this;
    }


    eventToPromise( eventName ) {
        return new Promise( ( resolve, reject ) => {
            this.addEventListener( eventName, resolve );
        } );
    }

    static doEnterFrame() {
        if ( EventDispatcher.enterFramePaused ) return 0;
        let totalEventCount = 0;

        for ( const [spr, count] of EventDispatcher.enterFrameList.entries() ) {
            // if (spr.isVisibleDeeply()) {
            spr.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ENTER_FRAME );
            spr.dispatchEvent( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RENDER );
            totalEventCount += count;
            // }
        }

        return totalEventCount;
    }
}


/**
 * @callback tween
 * @param {number} duration
 * @param {object} values
 * @param {string|function|import("./tween.js").Prop=} props
 * @returns {import("./tween.js").prototype}
 * @memberof EventDispatcher
 * @type {tween}
 */

EventDispatcher.prototype.tween = undefined;

/**
 * @callback move
 * @param {number} x
 * @param {number} y
 * @param {number} [duration=0]
 * @param {string|function|import("./tween.js").Prop=} props
 * @returns {Tween}
 * @memberof EventDispatcher
 * @type {move}
 */

EventDispatcher.prototype.move = undefined;

/**
 * @callback wait
 * @param {number} [duration=0]
 * @param {function=} func
 * @param {object=} context
 * @returns {import("./tween.js").prototype}
 * @memberof EventDispatcher
 * @type {wait}
 */

EventDispatcher.prototype.wait = undefined;


/** 
 * @callback getTweens
 * @param {boolean=} playingOnly
 * @returns {import("./tween.js").prototype[]}
 * @memberof EventDispatcher
 * 
 */

EventDispatcher.prototype.getTweens = undefined;

/**
 * @callback stopAllTweens
 * @memberof EventDispatcher
 */
EventDispatcher.prototype.stopAllTweens = undefined;

EventDispatcher.enterFramePaused = false;


_Event__WEBPACK_IMPORTED_MODULE_1__.Event.EventDispatcher = EventDispatcher;
EventDispatcher.enterFrameList = new Map();




/***/ }),

/***/ "./engine/src/FontBase.js":
/*!********************************!*\
  !*** ./engine/src/FontBase.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FontBase": () => (/* binding */ FontBase)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Texture */ "./engine/src/Texture.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");








class FontBase extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_3__.EventDispatcher {
    constructor( name, referenceSize, styles ) {
        super();
        this.name = name;
        this.referenceSize = referenceSize || 1;
        this.styles = styles;
        /** @type {Asset} */
        this.asset;
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @param {boolean} [isOnce=false]
     * @returns {FontBase}
     * @memberof FontBase
     */
    addEventListener( eventName, func, context = null, isOnce = false ) {
        if ( eventName == _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED ) {
            this.asset.addEventListener( eventName, this.dispatchEvent.bind( this,_Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED ), null, isOnce );
        } 
        //@ts-ignore
        return super.addEventListener( eventName, func, context, isOnce );
    }

    getAscender( size ) {
        if ( !this.asset.loaded ) {
            console.log( `로딩이 안된 상태로 사이즈를 구하려고 한다. ${this.asset.name}` );
            return 0;
        }
        const fontInfo = this.asset.fontInfo;

        return fontInfo.ascender / fontInfo.unitsPerEm * ( size || this.referenceSize ); 
    }


    measureTextWidth( str,size ) {
        if ( !this.asset.loaded ) {
            console.log( `로딩이 안된 상태로 사이즈를 구하려고 한다. ${this.asset.name}` );
            return 0;
        }
        // 상속 받은 클래스에서 구현
    }
}



/***/ }),

/***/ "./engine/src/KeyCode.js":
/*!*******************************!*\
  !*** ./engine/src/KeyCode.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyCode": () => (/* binding */ KeyCode)
/* harmony export */ });

const KeyCode = {
    ESC:    "Escape",
    ENTER:  "Enter",
    SPACE:  "Space",
    LEFT:   "ArrowLeft",
    RIGHT:  "ArrowRight",
    UP:     "ArrowUp",
    DOWN:   "ArrowDown",
    CTRL:   "ControlLeft",
    A:      "KeyA",
    B:      "KeyB",
    C:      "KeyC",
    D:      "KeyD",
    E:      "KeyE",
    F:      "KeyF",
    G:      "KeyG",
    H:      "KeyH",
    I:      "KeyI",
    J:      "KeyJ",
    K:      "KeyK",
    L:      "KeyL",
    M:      "KeyM",
    N:      "KeyN",
    O:      "KeyO",
    P:      "KeyP",
    Q:      "KeyQ",
    R:      "KeyR",
    S:      "KeyS",
    T:      "KeyT",
    U:      "KeyU",
    V:      "KeyV",
    W:      "KeyW",
    X:      "KeyX",
    Y:      "KeyY",
    Z:      "KeyZ",
    Digit0: "Digit0",
    Digit1: "Digit1",
    Digit2: "Digit2",
    Digit3: "Digit3",
    Digit4: "Digit4",
    Digit5: "Digit5",
    Digit6: "Digit6",
    Digit7: "Digit7",
    Digit8: "Digit8",
    Digit9: "Digit9",
};





/***/ }),

/***/ "./engine/src/Layout.js":
/*!******************************!*\
  !*** ./engine/src/Layout.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Layout": () => (/* binding */ Layout)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Application */ "./engine/src/Application.js");









class Layout extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor( x = 0,y = 0,w = 0,h = 0 ) {
        super();
        this.__locations = {};
        this.__width = w;
        this.__height = h;
        this.x = x;
        this.y = y;
    }

    resize( w, h ) {
        this.__width = w;
        this.__height = h;
        this._onResizeEvent();
    }

    setRect( x, y, w, h ) {
        this.x = x;
        this.y = y;
        this.resize( w, h );
    }

    _onResizeEvent() {
        for ( const key in this.__locations ) {
            const locSpr = this.__locations[key];

            if ( key == "origin" ) {
                locSpr.x = -this.x;
                locSpr.y = -this.y;
            } else {
                const [x, y] = key.split( "," );

                locSpr.x = this.__width * parseFloat( x );
                locSpr.y = this.__height * parseFloat( y );
            }
        }

        this.dispatchEvent( new _Event__WEBPACK_IMPORTED_MODULE_1__.Event( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RESIZE, { width: this.__width, height: this.__height } ) );
    }

    get origin() {
        return this.location( "origin" );
    }

    get topLeft() {
        return this.location( 0, 0 );
    }

    get topMiddle() {
        return this.location( 0.5, 0 );
    }

    get topRight() {
        return this.location( 1, 0 );
    }

    get bottomLeft() {
        return this.location( 0, 1 );
    }

    get bottomMiddle() {
        return this.location( 0.5, 1 );
    }

    get bottomRight() {
        return this.location( 1, 1 );
    }

    get leftMiddle() {
        return this.location( 0, 0.5 );
    }

    get rightMiddle() {
        return this.location( 1, 0.5 );
    }

    get center() {
        return this.location( 0.5, 0.5 );
    }


    /**
     *
     *
     * @param {string|number} x
     * @param {number} [y=null]
     * @returns {Layout}
     * @memberof Layout
     */
    location( x, y = null ) {
        const id = y != null ? x + "," + y : x;
        let locSpr = this.__locations[id];

        if ( locSpr != null ) return locSpr;
        locSpr = ( this.__locations[id] = new Layout() );

        if ( y == null ) {
            if ( id == "origin" ) {
                locSpr.x = -this.x;
                locSpr.y = -this.y;
            }
        } else {
            // @ts-ignore
            locSpr.x = this.__width * x;
            locSpr.y = this.__height * y;
        }

        this.addChild( locSpr );

        return locSpr;
    }

    get width() {
        return this.__width;
    }

    set width( v ) {
        this.__width = v;
        this._onResizeEvent();
    }

    get height() {
        return this.__height;
    }

    set height( v ) {
        this.__height = v;
        this._onResizeEvent();
    }

    /**
     * 
     * @returns {Point}
     * @memberof Layout
     */
    get size() {
        return new _Types__WEBPACK_IMPORTED_MODULE_2__.Point( this.__width, this.__height );
    }

    /**
     * @param {Point} v
     *
     * @memberof Layout
     */
    set size( v ) {
        this.__width = v.x;
        this.__height = v.y;
        this._onResizeEvent();
    }


    static fromRenderViewport() {
        const layout = new Layout( _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalRenderBounds.x, _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalRenderBounds.y,_Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalRenderBounds.width, _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalRenderBounds.height );

        _Application__WEBPACK_IMPORTED_MODULE_3__.application.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RESIZE, () => {
            layout.x = _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalRenderBounds.x;
            layout.y = _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalRenderBounds.y;
            layout.resize( _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalRenderBounds.width, _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalRenderBounds.height );
        } );

        return layout;
    }

    static fromLogicalViewpoer() {
        const layout = new Layout( 0,0,_Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalViewport.width, _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalViewport.height );

        _Application__WEBPACK_IMPORTED_MODULE_3__.application.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.RESIZE, () => {
            layout.resize( _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalViewport.width, _Application__WEBPACK_IMPORTED_MODULE_3__.application.logicalViewport.height );
        } );

        return layout;
    }
}




/***/ }),

/***/ "./engine/src/Matrix.js":
/*!******************************!*\
  !*** ./engine/src/Matrix.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix": () => (/* binding */ Matrix)
/* harmony export */ });



class Matrix {
    constructor( m11 = 1, m12 = 0, m21 = 0, m22 = 1, tx = 0, ty = 0 ) {
        this.__pixi = new PIXI.Matrix( m11, m12, m21, m22, tx, ty );
    }
}


/***/ }),

/***/ "./engine/src/Mesh.js":
/*!****************************!*\
  !*** ./engine/src/Mesh.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mesh": () => (/* binding */ Mesh)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Texture */ "./engine/src/Texture.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");





class Mesh extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    /**
     * Creates an instance of Mesh.
     * @memberof Mesh
     */
    constructor() {
        super();
        this._$$spriteType = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.SpriteTypes.MESH;
        this._$$updateCode = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_NOTHING;
        this.dirty = {
            positionOffset: 0,
            positionLength: 0,
            texCoordOffset: 0,
            texCoordLength: 0,
            colorOffset:    0,
            colorLength:    0,
            indexOffset:    0,
            indexLength:    0,
            textureReset:   false,
            positionReset:  false,
            texCoordReset:  false,
            colorReset:     false,
            indexReset:     false,
        };
        this.a_position = undefined;
        this.a_texCoord = undefined;
        this.a_color = undefined;
        this.indices = undefined;
        this.a_genericArray = undefined;
    }

    setTexture( texture ) {
        this.texture = texture;
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.dirty.textureReset = true;
    }

    setTextureCoordinateArray( arr ) {
        this.dirty.texCoordReset = !( this.a_texCoord && this.a_texCoord.length >= arr.length );
        this.a_texCoord = new Float32Array( arr );
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.dirty.texCoordOffset = 0;
        this.dirty.texCoordLength = this.a_texCoord.length;
    }

    /**
     * @param {...number} args
     * @memberof Mesh
     */
    setTextureCoordinates( ...args ) {
        let minIndex = Infinity;
        let maxIndex = -Infinity;

        for ( let i = 0; i < args.length; i += 3 ) {
            const index = args[i];
            const x = args[i + 1];
            const y = args[i + 2];

            this.a_texCoord[index * 2] = x;
            this.a_texCoord[index * 2 + 1] = y;
            minIndex = Math.min( minIndex,index );
            maxIndex = Math.max( maxIndex,index );
        }
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.dirty.texCoordOffset = Math.min( this.dirty.texCoordOffset / 2,minIndex ) * 2;
        this.dirty.texCoordLength = Math.max( ( this.dirty.texCoordOffset + this.dirty.texCoordLength ) / 2 ,maxIndex ) * 2;
    }

    setTextureCoordinate( i,x,y ) {
        this.a_texCoord[i * 2] = x;
        this.a_texCoord[i * 2 + 1] = y;
    }

    getTextureCoordinate( i ) {
        return new _Types__WEBPACK_IMPORTED_MODULE_2__.Point( this.a_texCoord[i * 2],this.a_texCoord[i * 2 + 1] );
    }

    _calculateLocalBounds( startIndex = 0,endIndex = this.a_position.length / 2 ) {
        let minX = Infinity,maxX = -Infinity,minY = Infinity ,maxY = -Infinity;

        for ( let i = startIndex; i < endIndex * 2; i += 2 ) {
            const x = this.a_position[i];
            const y = this.a_position[i + 1];

            minX = Math.min( x,minX );
            maxX = Math.max( x,maxX );
            minY = Math.min( y,minY );
            maxY = Math.max( y,maxY );
        }
        this._$$localBounds.x = minX;
        this._$$localBounds.y = minY;
        this._$$localBounds.width = maxX - minX;
        this._$$localBounds.height = maxY - minY;
    }

    setVertexArray( arr ) {
        this.dirty.positionReset = !( this.a_position && this.a_position.length >= arr.length );
        this.a_position = new Float32Array( arr );
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        if ( !this.useCustomLocalBounds ) this._calculateLocalBounds();
        this.dirty.positionOffset = 0;
        this.dirty.positionLength = this.a_position.length;
    }

    /**
     * @param {...number} args
     * @memberof Mesh
     */
    setVertices( ...args ) {
        let minIndex = Infinity;
        let maxIndex = -Infinity;

        let minX = this._$$localBounds.left;
        let maxX = this._$$localBounds.right;
        let minY = this._$$localBounds.top;
        let maxY = this._$$localBounds.bottom;

        for ( let i = 0; i < args.length; i += 3 ) {
            const index = args[i];
            const x = args[i + 1];
            const y = args[i + 2];

            this.a_position[index * 2] = x;
            this.a_position[index * 2 + 1] = y;
            minX = Math.min( x,minX );
            maxX = Math.max( x,maxX );
            minY = Math.min( y,minY );
            maxY = Math.min( y,maxY );
            minIndex = Math.min( minIndex,index );
            maxIndex = Math.max( maxIndex,index );
        }
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;

        if ( !this.useCustomLocalBounds ) {
            this._$$localBounds.x = minX;
            this._$$localBounds.y = minY;
            this._$$localBounds.width = maxX - minX;
            this._$$localBounds.height = maxY - minY;
        }

        this.dirty.positionOffset = Math.min( this.dirty.positionOffset / 2,minIndex ) * 2;
        this.dirty.positionLength = Math.max( ( this.dirty.positionOffset + this.dirty.positionLength ) / 2,maxIndex ) * 2;
    }

    setVertex( i,x,y ) {
        this.a_position[i * 2] = x;
        this.a_position[i * 2 + 1] = y;
    }

    getVertex( i ) {
        return new _Types__WEBPACK_IMPORTED_MODULE_2__.Point( this.a_position[i * 2],this.a_position[i * 2 + 1] );
    }


    setColorArray( arr ) {
        this.dirty.colorReset = !( this.a_color && this.a_color.length >= arr.length * 2 );
        this.a_color = new Uint8Array( arr.length * 2 );
        for ( let i = 0; i < arr.length; i += 2 ) {
            this.a_color[i * 2 + 0] = ( arr[i] >> 16 ) & 0xff;
            this.a_color[i * 2 + 1] = ( arr[i] >> 8 ) & 0xff;
            this.a_color[i * 2 + 2] = ( arr[i] ) & 0xff;
            this.a_color[i * 2 + 3] =  arr[i + 1] * 255;
        }
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.dirty.colorOffset = 0;
        this.dirty.colorLength = this.a_color.length;
    }

    /**
     * @param {...number} args
     * @memberof Mesh
     */
    setColors( ...args ) {
        let minIndex = Infinity;
        let maxIndex = -Infinity;

        for ( let i = 0; i < args.length; i += 3 ) {
            const index = args[i];
            const c = args[i + 1];
            const a = args[i + 2];

            this.a_color[index * 4] = ( c >> 16 ) & 0xff;
            this.a_color[index * 4 + 1] = ( c >> 8 ) & 0xff;
            this.a_color[index * 4 + 2] = c & 0xff;
            this.a_color[index * 4 + 3] = a * 255;
            minIndex = Math.min( minIndex,index );
            maxIndex = Math.max( maxIndex,index );
        }
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.dirty.colorOffset = Math.min( this.dirty.colorOffset / 4,minIndex ) * 4;
        this.dirty.colorLength = Math.max( ( this.dirty.colorOffset + this.dirty.colorLength ) / 4,maxIndex ) * 4;
    }


    getColorArraySize() {
        // Utils.legacy();
        return this.a_color.length / 4;
    }

    setRgbaColorArray( arr ) {
        this.dirty.colorReset = !( this.a_color && this.a_color.length >= arr.length );
        this.a_color = new Uint8Array( arr.map( v=>v * 255 ) );
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.dirty.colorOffset = 0;
        this.dirty.colorLength = this.a_color.length;
    }

    setColor( i,c,a ) {
        const arr = _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.hex2rgba( c,a );

        this.a_color[i * 4] = arr[0];
        this.a_color[i * 4 + 1] = arr[1];
        this.a_color[i * 4 + 2] = arr[2];
        this.a_color[i * 4 + 3] = arr[3];
    }

    getColor( i ) {
        const c = _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.rgba2hex( this.a_color,i * 4 );

        return { color: c & 0xffffff,alpha: this.a_color[i * 4 + 3] };
    }


    setIndexArray( arr ) {
        this.dirty.indexReset = true;
        this.indices = new Uint16Array( Math.ceil( arr.length / 2 ) * 2 ); // float32로 바꿔야 하기 때문에 정렬
        this.indices.set( arr );
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.dirty.indexOffset = 0;
        this.dirty.indexLength = this.indices.length;
    }

    /**
     * @param {...number} args
     * @memberof Mesh
     */
    setIndices( ...args ) {
        let minIndex = Infinity;
        let maxIndex = -Infinity;

        for ( let i = 0; i < args.length; i += 2 ) {
            const index = args[i];
            const vi = args[i + 1];

            this.indices[index] = vi;
            minIndex = Math.min( minIndex,index );
            maxIndex = Math.max( maxIndex,index );
        }
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.dirty.indexOffset = Math.min( this.dirty.indexOffset,minIndex );
        this.dirty.indexLength = Math.max( this.dirty.indexOffset + this.dirty.indexLength,maxIndex );
    }

    getIndex( i ) {
        return this.indices[i];
    }

    setIndex( i,v ) {
        this.indices[i] = v;
    }

    /**
     *
     *
     * @param {string} attribName
     * @param {number[]} arr
     * @param {Mesh.ArrayTypes} arrayType
     * @param {number} [size=1]
     * @param {boolean} [normalize = false]
     * @memberof Mesh
     */
    setGenericArray( attribName, arr, arrayType = Mesh.ArrayTypes.FLOAT32, size = 1, normalize = false ) {
        this.a_genericArray = this.a_genericArray || {};
        this.a_genericArray[attribName] = { 
            data:          new arrayType( arr ),
            numComponents: size,
            normalize:     normalize 
        };
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
    }

    static createBox( x, y, w, h, color = 0xffffff, alpha = 1 ) {
        const m = new Mesh();

        m.setVertexArray( [x, y, x + w, y, x, y + h, x + w, y + h] );
        m.setColorArray( [color, alpha, color, alpha, color, alpha, color, alpha] );
        m.setIndexArray( [0, 1, 2, 1, 3, 2] );

        return m;
    }


    encodeExtraRenderingInfo() {
        const encodedBuffer = new Float32Array( 
            14 + 
             this.dirty.positionLength + 
             this.dirty.texCoordLength + 
             Math.ceil( this.dirty.colorLength / 4 ) + 
             Math.ceil( this.dirty.indexLength / 2 ) );

        encodedBuffer.set( [
            this.texture != null ? this.texture.asset.id : 0,
            this.dirty.positionOffset,
            this.dirty.positionLength,
            this.dirty.texCoordOffset,
            this.dirty.texCoordLength,
            this.dirty.colorOffset,
            this.dirty.colorLength,
            this.dirty.indexOffset,
            this.dirty.indexLength,
            +this.dirty.textureReset,
            +this.dirty.positionReset,
            +this.dirty.texCoordReset,
            +this.dirty.colorReset,
            +this.dirty.indexReset,
        ] );
        let offset = 14;

        if ( this.dirty.positionLength > 0 ) {
            encodedBuffer.set( _Types__WEBPACK_IMPORTED_MODULE_2__.TypedArrayHelper.subarray( this.a_position,this.dirty.positionOffset, this.dirty.positionLength ),offset );
            offset +=  this.dirty.positionLength;
        }
        if ( this.dirty.texCoordLength > 0 ) {
            encodedBuffer.set( _Types__WEBPACK_IMPORTED_MODULE_2__.TypedArrayHelper.subarray( this.a_texCoord,this.dirty.texCoordOffset, this.dirty.texCoordLength ),offset );
            offset +=  this.dirty.texCoordLength;
        }
        if ( this.dirty.colorLength > 0 ) {
            encodedBuffer.set( _Types__WEBPACK_IMPORTED_MODULE_2__.TypedArrayHelper.Uint8ToFloat32( this.a_color,this.dirty.colorOffset, this.dirty.colorLength ),offset );
            offset +=  this.dirty.colorLength / 4;
        }
        if ( this.dirty.indexLength > 0 ) {
            encodedBuffer.set( _Types__WEBPACK_IMPORTED_MODULE_2__.TypedArrayHelper.Uint16ToFloat32( this.indices,this.dirty.indexOffset, this.dirty.indexLength ),offset );
        }

        this.dirty.textureReset = false;
        this.dirty.positionReset = false;
        this.dirty.texCoordReset = false;
        this.dirty.colorReset = false;
        this.dirty.indexReset = false;

        let genericData;
        let transfer;

        if ( this.a_genericArray ) {
            genericData = this.a_genericArray;
            transfer = [];
            for ( let name in this.a_genericArray ) {
                transfer.push( this.a_genericArray[name].data.buffer );
            }            
        }

        return [encodedBuffer,null,genericData,transfer];
    }
}
/** 
 * 
 * @enum {object} 
 */
Mesh.ArrayTypes = {
    UINT32:  Uint32Array,
    UINT16:  Uint16Array,
    UINT8:   Uint8Array,
    FLOAT32: Float32Array,
};



/***/ }),

/***/ "./engine/src/MovieClip.js":
/*!*********************************!*\
  !*** ./engine/src/MovieClip.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MovieClip": () => (/* binding */ MovieClip)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _easing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./easing */ "./engine/src/easing.js");




const EMPTY_KEY = "$";
const STOP_MARK = -1;

/** 
 * @typedef {object} Options 
 * @param {boolean} autoPlay
*/

/** @type {Options} */
const defaultOptions = {
    autoPlay: true
};

// 
/*
    스테이지에 붙어 있을 때만 작동한다.
    일반 개체의 값을 조정할 때도 사용할 수 있다.

    "ease",
    [0,10,target,{x:[0,100,ease]}]
    [0,"goto","event"]
    [0,"stop"]

*/

//  * @typedef {Object.<string,Range>} Props

/**
 * @typedef {number|*[]} Range
 * @typedef {Object.<string,Range>} Props
 * @typedef {[number,number,object|string]|[number,number,object|string,Props]|[number,string,string|number]|[number,string]} Line
 * @typedef {Line[]} Timeline
 * @typedef {Object.<string,Timeline>} TimelineGroup
 */

/**
 *
 * @this MovieClip
 * @param {Event} e
 */
function onEnterFrame( e ) {
    /** @type {{timeline:object,action:object,lastFrame:number}} */
    const ani = this.__mc.animations[this.__mc.currentAnimation];

    if ( ani == null ) return;
    for ( let [target, timeline] of ani.timeline.entries() ) {
        let noKey = true;

        //console.assert(targetSprite instanceof Sprite);
        if ( typeof target == "string" ) {
            target = this.__mc.targets[target];
            console.assert( target != null, `MovieClip의 타겟을 찾을 수 없습니다.` );
        }

        for ( const param in timeline ) {
            const value = timeline[param][this.__mc.currentFrame];

            if ( param == EMPTY_KEY ) {
                noKey = false;
            } else if ( value != null ) {
                target[param] = value;
                noKey = false;
            }
        }

        if ( target instanceof _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite ) {
            if ( noKey ) {
                if ( this.contains( target ) ) this.removeChild( target );
            } else {
                if ( !this.contains( target ) ) this.addChild( target );
            }
        }
    }

    const action = ani.action[this.__mc.currentFrame];

    if ( action != null ) {
        if ( action == STOP_MARK ) {
            this.stop();
        } else if ( typeof action == "string" ) {
            const [header, value, extra] = action.split( ":" );

            if ( header == "ani" ) {
                this.gotoAndPlay( extra != null ? value + ":" + extra : value );
            } else if ( header == "sound" ) {
                //TODO:
            } else if ( header == "event" ) {
                //TODO:
            }
        } else {
            this.__mc.currentFrame = parseInt( action );
        }
    } else {
        if ( this.__mc.playing == false || this.__mc.currentFrame >= ani.lastFrame ) this.stop();
        else this.__mc.currentFrame++;
    }
}

/**
 * @this MovieClip
 * @param {Timeline} tl
 * @returns {{timeline:object,action:object,lastFrame:number}}
 */
function parseTimeline( tl ) {
    const timeline = new Map();
    const action = {};
    let paramTimeline;
    let lastFrame = 0;

    for ( const i in tl ) {
        const line = tl[i];

        if ( typeof line[1] == "string" ) {
            const [frame, command, label] = line;

            if ( command == "stop" ) {
                action[frame] = STOP_MARK;
            } else if ( command == "goto" ) {
                action[frame] = typeof label == "number" ? label : "ani:" + label;
            } else if ( command == "event" ) {
                action[frame] = "event:" + label;
            } else if ( command == "sound" ) {
                action[frame] = "sound:" + label;
            }
        } else {
            const [startFrame, endFrame, targetObject, props] = line;

            paramTimeline = timeline.get( targetObject ) || {};

            if ( props == null ) {
                paramTimeline[EMPTY_KEY] = paramTimeline[EMPTY_KEY] || {};
            
                //@ts-ignore
                for ( let frame = startFrame; frame <= endFrame; frame++ ) {
                    paramTimeline[EMPTY_KEY][frame] = 1;
                }
            } else {
            //@ts-ignore
                for ( const key in props ) {
                    paramTimeline[key] = paramTimeline[key] || {};

                    if ( Array.isArray( props[key] ) ) {
                        const [startValue, endValue, ease] = props[key];
                        const easingFunc = ( typeof ease == "function" ? ease : _easing__WEBPACK_IMPORTED_MODULE_2__.easing[ease] ) || _easing__WEBPACK_IMPORTED_MODULE_2__.easing.linear;

                        for ( let frame = startFrame; frame <= endFrame; frame++ ) {
                        //@ts-ignore
                            paramTimeline[key][frame] = easingFunc( ( frame - startFrame ) / ( endFrame - startFrame ) ) * ( endValue - startValue ) + startValue;
                        }
                    } else {
                        const value = props[key];

                        for ( let frame = startFrame; frame <= endFrame; frame++ ) {
                            paramTimeline[key][frame] = value;
                        }
                    }
                }
            }

            timeline.set( targetObject, paramTimeline );
            //@ts-ignore
            lastFrame = Math.max( lastFrame, endFrame );
        }
    }

    return { action,timeline,lastFrame };
}


class MovieClip extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    /**
     * 자동으로 애니메이션을 하는 MovieClip 개체를 만든다.
     * MovieClip은 Tween이나 show,hide를 시간순에 맞게 보여줄 수 있다.
     * 
     * 예제1) Array를 사용한 경우
     * 
     * new MovieClip([
     *     [0,10,targetSpr,{ x:[0,100,"outCubic"], y:20, alpha:[0.5,1] }],
     *     [11,20,targetSpr,{ x:[100,0,easing.inBounce] }]
     *     [20,"goto",0] // 이렇게 루프를 시킬 수도 있다. 없으면 마지막 프레임에서 멈춤. "stop", "event", "sound" 등을 쓸 수 있다.
     * ])
     * 
     * 예제2) Object를 사용한 경우
     * 
     * new MovieClip({
     *      default: [
     *          [0,10,targetSpr, { y: 10 }]
     *          :
     *      ],
     *      show: [
     *          [0,20,targetSpr, { x: 5 }]
     *          [20,"goto","default"]
     *      ]
     * });
     * 
     * @param {Timeline|TimelineGroup=} timelineData - 하나의 타임라인 애니메이션을 Array로 넣거나 다수의 애니메이션을 Object로 넣을 수 있다
     * @param {Options=} options
     * @memberof MovieClip
     */
    constructor( timelineData, options  ) {
        super();
        this.__mc = {};
        this.__mc.currentFrame = 0;
        this.__mc.currentAnimation = undefined;
        this.__mc.playing = false;
        this.__mc.targets = {};
        this.__mc.animations = {};
        this.__mc.options = Object.assign( defaultOptions, options );
        if ( timelineData ) this.addAnimations( timelineData );
        if ( this.__mc.options.autoPlay ) {
            this.play();
        }
    }

    /**
     * MovieClip에 animation을 추가한다.
     * 
     * @param {Timeline|TimelineGroup} timelineData - 하나의 타임라인 애니메이션을 Array로 넣거나 다수의 애니메이션을 Object로 넣을 수 있다
     * @memberof MovieClip
     */
    addAnimations( timelineData ) {
        if ( timelineData != null ) {
            if ( Array.isArray( timelineData ) ) {
                this.__mc.animations["default"] = parseTimeline.call( this, timelineData );
                this.__mc.currentAnimation = "default";
            } else {
                for ( const label in timelineData ) {
                    // 첫번째 애니메이션을 디폴트로
                    if ( this.__mc.currentAnimation == null ) this.__mc.currentAnimation = label;
                    this.__mc.animations[label] = parseTimeline.call( this, timelineData[label] );
                }
            }
        }
    }

    /**
     * 두 개의 MovieClip을 병합한다
     *
     * @param {MovieClip} mc
     * @param {boolean} replace
     * @memberof MovieClip
     */
    merge( mc,replace ) {
        for ( const label in mc.__mc.animations ) {
            const ani = mc.__mc.animations[label];

            if ( replace || this.__mc.animations[label] == null ) this.__mc.animations[label] = ani;
        }
    }


    setTarget( name, target ) {
        this.__mc.targets[name] = target;
    }


    /**
     *
     *
     * @param {string|number} f
     * @memberof MovieClip
     */
    gotoAndPlay( f ) {
        if ( typeof f == "string" ) {
            //@ts-ignore
            const [animationName, frame] = f.split( ":" );

            this.__mc.currentAnimation = animationName;
            this.__mc.currentFrame = frame != null ? parseInt( frame ) : 0;
        } else {
            console.assert( typeof f == "number" );
            //@ts-ignore
            this.__mc.currentFrame = parseInt( f );
        }

        this.play();
    }

    /**
     *
     *
     * @param {number} f
     * @memberof MovieClip
     */
    gotoAndStop( f ) {
        if ( typeof f == "string" ) {
            //@ts-ignore
            const [animationName, frame] = f.split( ":" );

            this.__mc.currentAnimation = animationName;
            this.__mc.currentFrame = frame != null ? parseInt( frame ) : 0;
        } else {
            console.assert( typeof f == "number" );
            //@ts-ignore
            this.__mc.currentFrame = parseInt( f );
        }

        this.stop();
    }

    play( aniName ) {
        if ( aniName != null ) {
            this.gotoAndPlay( aniName );
        }

        if ( !this.__mc.playing ) {
            this.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ENTER_FRAME,onEnterFrame,this );
            this.__mc.playing = true;
        }
    }

    stop() {
        if ( this.__mc.playing ) {
            this.removeEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ENTER_FRAME,onEnterFrame,this );
            this.__mc.playing = false;
        }
    }

    /**
     *
     *
     * @param {number} f
     * @param {string|number} destination
     * @memberof MovieClip
     */
    setGotoAction( f, destination ) {
        //@ts-ignore
        if ( parseInt( destination ) == destination ) destination = parseInt( destination );
        this.__mc.animations[this.__mc.currentAnimation].action[f] = destination;
    }

    /**
     *
     *
     * @param {number} f
     * @memberof MovieClip
     */
    setStopAction( f ) {
        this.__mc.animations[this.__mc.currentAnimation].action[f] = STOP_MARK; // stop
    }


    /**
     * target을 제외하고 모든 내용이 동일한 MovieClip을 만든다.
     *
     * @returns {MovieClip}
     * @memberof MovieClip
     */
    instance() {
        const newObj = new MovieClip( null );

        newObj.__mc.animations = this.__mc.animations;
        newObj.__mc.currentAnimation = Object.keys( this.__mc.animations )[0];
        Object.assign( newObj.__mc.targets, this.__mc.targets );
        newObj.play();

        return newObj;
    }
}

// let b = new Sprite();
// new MovieClip([
//     [0, 0, b, { x: [0,1,easing.outCubic],y: [1,1] }],
// ]);




/***/ }),

/***/ "./engine/src/MsdfFont.js":
/*!********************************!*\
  !*** ./engine/src/MsdfFont.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MsdfFont": () => (/* binding */ MsdfFont)
/* harmony export */ });
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _FontBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FontBase */ "./engine/src/FontBase.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");




class MsdfFont extends _FontBase__WEBPACK_IMPORTED_MODULE_1__.FontBase {
    constructor( MsdfFontName,referenceSize, styles ) {
        super( MsdfFontName, referenceSize, styles );
        // Bitmap
        this.asset = new _Asset__WEBPACK_IMPORTED_MODULE_0__.Asset( MsdfFontName,_Asset__WEBPACK_IMPORTED_MODULE_0__.Asset.AssetTypes.MsdfFont );
        // 페이지가 여러개 있는 폰트는 아직 처리 못함
        const page = this.asset.fontInfo.pages[0];
        const pngSize = _Utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getImageSize( page.file );

        this.asset.load( { 
            bitmap:        page.file, 
            width:         pngSize.width,
            height:        pngSize.height,
            referenceSize: this.referenceSize,
            styles:        this.styles,
            fontInfo:      this.asset.fontInfo 
        } );
        this.fontLoaded = false;
    }    

    measureTextWidth( str,size ) {
        super.measureTextWidth( str,size );

        const fontInfo = this.asset.fontInfo;
        const scale = size ? size / fontInfo.info.size : 1;

        let width = 0;

        for ( let i = 0; i < str.length; i++ ) {
            const char = str.charCodeAt( i );
            const charInfo = fontInfo.chars[char];

            width += charInfo.xadvance * scale;
        }
        return width;        
    }
}




/***/ }),

/***/ "./engine/src/Particles.js":
/*!*********************************!*\
  !*** ./engine/src/Particles.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Particles": () => (/* binding */ Particles)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");

 



class Particles extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor() {
        super();
    }

    addParticles( ...args ) {

    }

    setTexture( ...args ) {

    }
}



/***/ }),

/***/ "./engine/src/Pixel.js":
/*!*****************************!*\
  !*** ./engine/src/Pixel.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Pixel": () => (/* binding */ Pixel)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");





class Pixel extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor( color = 0xffffff, alpha = 1, width = 1, height = 1 ) {
        super();
        this._$$spriteType = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.SpriteTypes.PIXEL;
        this._$$updateCode = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.pixelColor = _Utils__WEBPACK_IMPORTED_MODULE_1__.Utils.hex2rgba( color,alpha );
        this.pixelWidth = width;
        this.pixelHeight = height;    
        this._$$localBounds.x = 0;
        this._$$localBounds.y = 0;
        this._$$localBounds.width = width;
        this._$$localBounds.height = height;
    }

    setColor( color = 0xffffff, alpha = 1 ) {
        this.pixelColor = _Utils__WEBPACK_IMPORTED_MODULE_1__.Utils.hex2rgba( color,alpha );
        this._$$updateCode = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
    }

    encodeExtraRenderingInfo() {
        let encodedBuffer = new Float32Array( 6 );

        encodedBuffer[0] = this.pixelWidth;
        encodedBuffer[1] = this.pixelHeight;
        encodedBuffer.set( this.pixelColor,2 );
        return [encodedBuffer];
    }
}



/***/ }),

/***/ "./engine/src/RenderTarget.js":
/*!************************************!*\
  !*** ./engine/src/RenderTarget.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderTarget": () => (/* binding */ RenderTarget)
/* harmony export */ });
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Application */ "./engine/src/Application.js");
/* harmony import */ var _TextureBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextureBase */ "./engine/src/TextureBase.js");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
//
// 렌더링과 로직 쓰레드가 분리되어 있기 때문에 RT가 가장 만들기 어렵다.
// RT를 요청하는 시점에서 메인쓰레드에 생성
// draw할 때 그릴 스프라이트 트리의 스냅샷을 전송
// main에서는 받은 스냅샷을 가지고 draw를 즉시 수행
// RT는 수동으로 파기 해주어야 함












class RenderTarget extends _TextureBase__WEBPACK_IMPORTED_MODULE_1__.TextureBase {
    /**
     *Creates an instance of RenderTarget.
     * @param {number} width
     * @param {number} height
     * @param {boolean} filter
     * @memberof RenderTarget
     */
    constructor( width, height, filter = false ) {
        super();
        this.asset = new _Asset__WEBPACK_IMPORTED_MODULE_6__.Asset( "<RT:*>",_Asset__WEBPACK_IMPORTED_MODULE_6__.Asset.AssetTypes.RenderTarget );
        this.width = width;
        this.height = height;
        this.uvRect = new _Types__WEBPACK_IMPORTED_MODULE_5__.Rect( 0,0,this.width,this.height );

        this.asset.load( { width: this.width,height: this.height,filter: filter } );
    }

    /**
     *
     *
     * @param {number} [color=0]
     * @param {number} [alpha=0]
     * @memberof RenderTarget
     */
    clear( color = 0 , alpha = 0 ) {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand", class: "RenderTarget", method: "clear",args: [this.asset.id, _Utils__WEBPACK_IMPORTED_MODULE_4__.Utils.hex2rgba( color,alpha )] } );
    }

    /**
     *
     *
     * @param {Sprite} spr
     * @memberof RenderTarget
     */
    draw( spr ) {
        let [buf,transferList] = spr.encodeRenderingInfoWithChildren();

        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand", class: "RenderTarget", method: "draw",args: [this.asset.id, buf] }, transferList );
    }
}


/***/ }),

/***/ "./engine/src/SceneManager.js":
/*!************************************!*\
  !*** ./engine/src/SceneManager.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SceneManager": () => (/* binding */ SceneManager)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");
/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Timer */ "./engine/src/Timer.js");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Mesh */ "./engine/src/Mesh.js");
/* harmony import */ var _RenderTarget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RenderTarget */ "./engine/src/RenderTarget.js");







// const Sprite = require("./sprite");
// const Mesh = require("./mesh");
// const RenderTarget = require("./renderTarget");
// const Utils = require("./utils");
// const Event = require("./event");

function rad( d ) {
    return d * Math.PI / 180;
}

let _needRT;

function defaultEase( ratio ) {
    return ratio;
}



class SceneManager extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor( application, x, y, w, h, lw, lh ) {
        super();
        this.application = application;
        this.stage = application.stage;
        this.x1 = x;
        this.y1 = y;
        this.x2 = x + w;
        this.y2 = y + h;
        this.lw = lw;
        this.lh = lh;
        this.tweening = false;
        this.transitionEventCatcher = new _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        /** @type {Mesh} */
        this._blackMesh = null;
        /** @type {RenderTarget} */
        this._RT = null;
    }

    //#region [Transitions]
	
    // scene2 == newScene;
    //---------------------------------------------------------------------------------------------------
    // 트랜지션들
    //---------------------------------------------------------------------------------------------------


    static accordionLeft( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        //let h = self.lh;
        const scale1 = ( 1 - t );
        const scale2 = t;

        scene1.setScaleX( scale1 );
        scene2.setX( w * scale1 );
        scene2.setScaleX( scale2 );
    }

    static accordionRight( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        //let h = self.lh;
        const scale1 = ( 1 - t );
        const scale2 = t;

        scene1.setX( w * scale2 );
        scene1.setScaleX( scale1 );
        scene2.setScaleX( scale2 );
    }


    static zoomOut( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        const scale1 = t + 1;
        const scale2 = t;
        const alpha = 1 - t * 1.2;

        scene1.setAlpha( alpha );
        if ( alpha <= 0 ) scene1.setVisible( false );

        scene1.setScale( scale1 );
        scene1.setPosition( -( w * scale1 - w ) / 2, -( h * scale1 - h ) / 2 );
        scene2.setAlpha( t );
        scene2.setScale( scale2 );
        scene2.setPosition( -( w * scale2 - w ) / 2, -( h * scale2 - h ) / 2 );
    }

    static zoomIn( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        const scale1 = t + 1;
        const scale2 = t;

        scene1.setAlpha( 1 - t );
        scene1.setScale( scale1 );
        scene1.setPosition( -( w * scale1 - w ) / 2, -( h * scale1 - h ) / 2 );
        scene2.setAlpha( t );
        scene2.setScale( scale2 );
        scene2.setPosition( -( w * scale2 - w ) / 2, -( h * scale2 - h ) / 2 );
    }

    static zoomOutCross( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        const scale1 = t + 1;
        const scale2 = ( 1 - t ) + 1;
        const alpha = 1 - t * 1.2;

        scene1.setAlpha( alpha );
        if ( alpha <= 0 ) scene1.setVisible( false );

        scene1.setScale( scale1 );
        scene1.setPosition( -( w * scale1 - w ) / 2, -( h * scale1 - h ) / 2 );
        scene2.setAlpha( t );
        scene2.setScale( scale2 );
        scene2.setPosition( -( w * scale2 - w ) / 2, -( h * scale2 - h ) / 2 );
    }

    static zoomInCross( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        const scale1 = ( 1 - t );
        const scale2 = t;

        scene1.setAlpha( 1 - t );
        scene1.setScale( scale1 );
        scene1.setPosition( -( w * scale1 - w ) / 2, -( h * scale1 - h ) / 2 );
        scene2.setAlpha( t );
        scene2.setScale( scale2 );
        scene2.setPosition( -( w * scale2 - w ) / 2, -( h * scale2 - h ) / 2 );
    }


    static spinCW( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        //	let a1 = (1-t) * 360;
        const a1 = t * 180;
        const a2 = 180 + t * 180;
        //let l = Math.sqrt((w / 2) ** 2, (h / 2) ** 2);
        const [x1, y1] = [Math.cos( rad( a1 ) ) * w / 2 - Math.sin( rad( a1 ) ) * h / 2 - w / 2,
                          Math.sin( rad( a1 ) ) * w / 2 + Math.cos( rad( a1 ) ) * h / 2 - h / 2];
        const [x2, y2] = [Math.cos( rad( a2 ) ) * w / 2 - Math.sin( rad( a2 ) ) * h / 2 - w / 2,
                          Math.sin( rad( a2 ) ) * w / 2 + Math.cos( rad( a2 ) ) * h / 2 - h / 2];

        scene1.setAlpha( 1 - t );
        scene2.setAlpha( t );
        scene1.setRotation( a1 );
        scene2.setRotation( a2 );
        scene1.setPosition( -x1, -y1 );
        scene2.setPosition( -x2, -y2 );
    }

    static spinCCW( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        //	let a1 = (1-t) * 360;
        const a1 = 180 + ( 1 - t ) * 180;
        const a2 = ( 1 - t ) * 180;
        //let l = Math.sqrt((w / 2) ** 2, (h / 2) ** 2);
        const [x1, y1] = [Math.cos( rad( a1 ) ) * w / 2 - Math.sin( rad( a1 ) ) * h / 2 - w / 2,
                          Math.sin( rad( a1 ) ) * w / 2 + Math.cos( rad( a1 ) ) * h / 2 - h / 2];
        const [x2, y2] = [Math.cos( rad( a2 ) ) * w / 2 - Math.sin( rad( a2 ) ) * h / 2 - w / 2,
                          Math.sin( rad( a2 ) ) * w / 2 + Math.cos( rad( a2 ) ) * h / 2 - h / 2];

        scene1.setAlpha( 1 - t );
        scene2.setAlpha( t );
        scene1.setRotation( a1 );
        scene2.setRotation( a2 );
        scene1.setPosition( -x1, -y1 );
        scene2.setPosition( -x2, -y2 );
    }

    static spinCrossCW( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        const a1 = -t * 180;
        const a2 = 180 + t * 180;
        //let l = Math.sqrt((w / 2) ** 2, (h / 2) ** 2);
        const [x1, y1] = [Math.cos( rad( a1 ) ) * w / 2 - Math.sin( rad( a1 ) ) * h / 2 - w / 2,
                          Math.sin( rad( a1 ) ) * w / 2 + Math.cos( rad( a1 ) ) * h / 2 - h / 2];
        const [x2, y2] = [Math.cos( rad( a2 ) ) * w / 2 - Math.sin( rad( a2 ) ) * h / 2 - w / 2,
                          Math.sin( rad( a2 ) ) * w / 2 + Math.cos( rad( a2 ) ) * h / 2 - h / 2];

        scene1.setAlpha( 1 - t );
        scene2.setAlpha( t );
        scene1.setRotation( a1 );
        scene2.setRotation( a2 );
        scene1.setPosition( -x1, -y1 );
        scene2.setPosition( -x2, -y2 );
    }

    static spinCrossCCW( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        const a1 = t * 180;
        const a2 = 180 + -t * 180;
        //let l = Math.sqrt((w / 2) ** 2, (h / 2) ** 2);
        const [x1, y1] = [Math.cos( rad( a1 ) ) * w / 2 - Math.sin( rad( a1 ) ) * h / 2 - w / 2,
                          Math.sin( rad( a1 ) ) * w / 2 + Math.cos( rad( a1 ) ) * h / 2 - h / 2];
        const [x2, y2] = [Math.cos( rad( a2 ) ) * w / 2 - Math.sin( rad( a2 ) ) * h / 2 - w / 2,
                          Math.sin( rad( a2 ) ) * w / 2 + Math.cos( rad( a2 ) ) * h / 2 - h / 2];

        scene1.setAlpha( 1 - t );
        scene2.setAlpha( t );
        scene1.setRotation( a1 );
        scene2.setRotation( a2 );
        scene1.setPosition( -x1, -y1 );
        scene2.setPosition( -x2, -y2 );
    }


    static balloon( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        const scale1x = t + 1;
        const scale2x = ( 1 - t ) + 1;
        const scale1y = ( 1 - t );
        const scale2y = t;

        scene1.setAlpha( 1 - t );
        scene1.setScale( scale1x, scale1y );
        scene1.setPosition( -( w * scale1x - w ) / 2, -( h * scale1y - h ) / 2 );
        scene2.setAlpha( t );
        scene2.setScale( scale2x, scale2y );
        scene2.setPosition( -( w * scale2x - w ) / 2, -( h * scale2y - h ) / 2 );
    }


    static tv( self, scene1, scene2, t, rawT ) {
        const w = self.lw;
        const h = self.lh;
        const scale1x = t * 3 + 1;
        const scale2x = t * 0.2 + 0.8;//1--(1-t)*3+1;
        const scale1y = ( 1 - t );
        const scale2y = t;

        scene1.setAlpha( 1 - t );
        //let color = Math.max(1-t*2,0);
        //scene1.setColorMultiplier(color,color,color);
        scene1.setScale( scale1x, scale1y );
        scene1.setPosition( -( w * scale1x - w ) / 2, -( h * scale1y - h ) / 2 );
        scene2.setAlpha( t );
        scene2.setScale( scale2x, scale2y );
        scene2.setPosition( -( w * scale2x - w ) / 2, -( h * scale2y - h ) / 2 );
    }

    static getWiperV2( self, w, h ) {
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        m.setVertexArray( [0, 0, w, 0, 0, h * 1.2, w, h, 0, h * 1.4, w, h * 1.2] );
        m.setColorArray( [0x000000, 1, 0x000000, 1, 0x000000, 1, 0x000000, 1, 0x000000, 0, 0x000000, 0] );
        m.setIndexArray( [0, 1, 2, 1, 3, 2, 2, 3, 4, 3, 4, 5] );
        m.setColorMultiplier( 0, 0, 0 );

        return m;
    }

    static getWiperV( self, w, h ) {
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        m.setVertexArray( [0, 0, w, 0, 0, h, w, h, 0, h * 1.2, w, h * 1.2] );
        m.setColorArray( [0x000000, 1, 0x000000, 1, 0x000000, 1, 0x000000, 1, 0x000000, 0, 0x000000, 0] );
        m.setIndexArray( [0, 1, 2, 1, 3, 2, 2, 3, 4, 3, 4, 5] );
        m.setColorMultiplier( 0, 0, 0 );

        return m;
    }

    static getWiperH( self, w, h ) {
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        m.setVertexArray( [0, 0, w, 0, 0, h, w, h, w * 1.2, 0, w * 1.2, h] );
        m.setColorArray( [0x000000, 1, 0x000000, 1, 0x000000, 1, 0x000000, 1, 0x000000, 0, 0x000000, 0] );
        m.setIndexArray( [0, 1, 2, 1, 3, 2, 1, 4, 3, 4, 5, 3] );
        m.setColorMultiplier( 0, 0, 0 );

        return m;
    }

    static wipeUp2( self, scene1, scene2, t, rawT ) {
        const physicalMarginX = -self.x1;
        const physicalMarginY = -self.y1;
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( t < 0.5 ) {
            //let t2 = t * 2;
            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getWiperV2( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setScaleY( -1 );
            m.setX( -physicalMarginX );
            m.setY( h * ( 1 + ( 1 - t * 2 ) * 1.4 ) - physicalMarginY );
        } else {
            const t2 = ( t - 0.5 ) * 2;

            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getWiperV2( self,w, h );

            self._blackMesh = m;
            m.setScaleX( -1 );
            self.addChild( m );
            m.setX( w - physicalMarginX );
            m.setY( h * ( -t2 * 1.4 ) - physicalMarginY );
        }
    }


    static wipeDown( self, scene1, scene2, t, rawT ) {
        const physicalMarginX = -self.x1;
        const physicalMarginY = -self.y1;
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( t < 0.5 ) {
            const t2 = t * 2;

            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getWiperV( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setX( -physicalMarginX );
            m.setY( -h * ( 1 - t2 ) * 1.2 - physicalMarginY );
        } else {
            const t2 = ( t - 0.5 ) * 2;

            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getWiperV( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setScaleY( -1 );
            m.setX( -physicalMarginX );
            m.setY( h * ( 1 + t2 * 1.2 ) - physicalMarginY );
        }
    }

    static wipeUp( self, scene1, scene2, t, rawT ) {
        const physicalMarginX = -self.x1;
        const physicalMarginY = -self.y1;
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( t < 0.5 ) {
            //let t2 = t * 2;
            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getWiperV( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setScaleY( -1 );
            m.setX( -physicalMarginX );
            m.setY( h * ( 1 + ( 1 - t * 2 ) * 1.2 ) - physicalMarginY );
        } else {
            const t2 = ( t - 0.5 ) * 2;

            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getWiperV( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setX( -physicalMarginX );
            m.setY( h * ( -t2 * 1.2 ) - physicalMarginY );
        }
    }

    static wipeRight( self, scene1, scene2, t, rawT ) {
        const physicalMarginX = -self.x1;
        const physicalMarginY = -self.y1;
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( t < 0.5 ) {
            const t2 = t * 2;

            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getWiperH( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setX( -w * ( 1 - t2 ) * 1.2 - physicalMarginX );
            m.setY( -physicalMarginY );
        } else {
            const t2 = ( t - 0.5 ) * 2;

            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getWiperH( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setScaleX( -1 );
            m.setX( w * ( 1 + t2 * 1.2 ) - physicalMarginX );
            m.setY( -physicalMarginY );
        }
    }

    static wipeLeft( self, scene1, scene2, t, rawT ) {
        const physicalMarginX = -self.x1;
        const physicalMarginY = -self.y1;
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( t < 0.5 ) {
            //let t2 = t * 2;
            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getWiperH( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setScaleX( -1 );
            m.setX( w * ( 1 + ( 1 - t * 2 ) * 1.2 ) - physicalMarginX );
            m.setY( -physicalMarginY );
        } else {
            const t2 = ( t - 0.5 ) * 2;

            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getWiperH( self,w, h );

            self._blackMesh = m;
            self.addChild( m );
            m.setX( w * ( -t2 * 1.2 ) - physicalMarginX );
            m.setY( -physicalMarginY );
        }
    }


    static getClockMesh( self, w, h, ratio ) {
        if ( ratio < 0 ) {
            ratio = 0;
        }

        if ( ratio > 1 ) {
            ratio = 1;
        }

        const angle = ratio * 360;
        const angleZone = Math.floor( ratio * 8 ) + 1;
        const angle2 = ( angle % 45 );
        const triWidth = Math.sin( rad( angle2 ) );
        let v = [];
        let idx = [];

        if ( ratio == 1 ) {
            v = [0 * w, 0 * h, 1 * w, 0 * h, 1 * w, 1 * h, 0 * w, 1 * h];
            idx = [0, 1, 2, 2, 3, 0];
        } else if ( angleZone == 1 ) {
            v = [0.5 * w, 0 * h, ( 0.5 + triWidth ) * w, 0 * h, 0.5 * w, 0.5 * h];
            idx = [0, 1, 2];
        } else if ( angleZone == 2 ) {
            v = [1 * w, 0 * h, 1 * w, triWidth * h, 0.5 * w, 0.5 * h, 0.5 * w, 0 * h];
            idx = [0, 1, 2, 3, 0, 2];
        } else if ( angleZone == 3 ) {
            v = [1 * w, 0.5 * h, 1 * w, ( 0.5 + triWidth ) * h, 0.5 * w, 0.5 * h, 0.5 * w, 0 * h, 1 * w, 0 * h];
            idx = [0, 1, 2, 3, 4, 2, 4, 0, 2];
        } else if ( angleZone == 4 ) {
            v = [1 * w, 1 * h, ( 1 - triWidth ) * w, 1 * h, 0.5 * w, 0.5 * h, 0.5 * w, 0 * h, 1 * w, 0 * h];
            idx = [0, 1, 2, 3, 4, 2, 4, 0, 2];
        } else if ( angleZone == 5 ) {
            v = [0.5 * w, 1 * h, ( 0.5 - triWidth ) * w, 1 * h, 0.5 * w, 0.5 * h, 0.5 * w, 0 * h, 1 * w, 0 * h, 1 * w, 1 * h];
            idx = [0, 1, 2, 3, 4, 0, 4, 5, 0];
        } else if ( angleZone == 6 ) {
            v = [0 * w, 1 * h, 0 * w, ( 1 - triWidth ) * h, 0.5 * w, 0.5 * h, 0.5 * w, 0 * h, 1 * w, 0 * h, 1 * w, 1 * h];
            idx = [0, 1, 2, 3, 4, 2, 4, 5, 0];
        } else if ( angleZone == 7 ) {
            v = [0 * w, 0.5 * h, 0 * w, ( 0.5 - triWidth ) * h, 0.5 * w, 0.5 * h, 0.5 * w, 0 * h, 1 * w, 0 * h, 1 * w, 1 * h, 0 * w, 1 * h];
            idx = [0, 1, 2, 3, 4, 2, 4, 5, 6, 0, 2, 6];
        } else {
            v = [0 * w, 0 * h, triWidth * w, 0 * h, 0.5 * w, 0.5 * h, 0.5 * w, 0 * h, 1 * w, 0 * h, 1 * w, 1 * h, 0 * w, 1 * h];
            idx = [0, 1, 2, 3, 4, 2, 4, 5, 6, 0, 2, 6];
        }

        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        //m.setTexture(tex);
        //m.setTextureCoordinateArray(v);
        m.setVertexArray( v );
        m.setIndexArray( idx );
        m.setColorMultiplier( 0, 0, 0 );

        return m;
    }



    static getCircleMesh( self, radius ) {
        const sides = 64;
        const v = [0, 0];
        const idx = [];
        const c = [0x000000, 1];

        for ( let i = 0; i < sides; i++ ) {
            const angle = ( i / sides ) * 2 * Math.PI;

            v[2 + i * 4] = Math.cos( angle ) * radius;
            v[2 + i * 4 + 1] = Math.sin( angle ) * radius;
            v[2 + i * 4 + 2] = Math.cos( angle ) * radius * 1.2;
            v[2 + i * 4 + 3] = Math.sin( angle ) * radius * 1.2;
            c[2 + i * 4] = 0x000000;
            c[2 + i * 4 + 1] = 1;
            c[2 + i * 4 + 2] = 0x000000;
            c[2 + i * 4 + 3] = 0;
            idx[ i * 9] = 0;	//origin;
            idx[ i * 9 + 1] = ( i * 2 ) + 1;
            idx[ i * 9 + 2] = ( i * 2 ) + 3;
            idx[ i * 9 + 3] = ( i * 2 ) + 1;
            idx[ i * 9 + 4] = ( i * 2 ) + 2;
            idx[ i * 9 + 5] = ( i * 2 ) + 4;
            idx[ i * 9 + 6] = ( i * 2 ) + 1;
            idx[ i * 9 + 7] = ( i * 2 ) + 4;
            idx[ i * 9 + 8] = ( i * 2 ) + 3;

            if ( i == sides - 1 ) {
                idx[ i * 9 + 2] = 1;
                idx[ i * 9 + 5] = 2;
                idx[ i * 9 + 7] = 2;
                idx[ i * 9 + 8] = 1;
            }
        }

        //log(Log.UI, table.concat(idx,","));
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        m.setVertexArray( v );
        m.setIndexArray( idx );
        m.setColorArray( c );

        return m;
    }

    static getCircleHoleMesh( self, radius1, radius2 ) {
        const sides = 32;
        const v = [];
        const idx = [];
        const c = [];

        for ( let i = 0; i < sides; i++ ) {
            const angle = ( i / sides ) * 2 * Math.PI;

            v[ i * 6] = Math.cos( angle ) * radius1 / 1.2;
            v[ i * 6 + 1] = Math.sin( angle ) * radius1 / 1.2;
            v[ i * 6 + 2] = Math.cos( angle ) * radius1;
            v[ i * 6 + 3] = Math.sin( angle ) * radius1;
            v[ i * 6 + 4] = Math.cos( angle ) * radius2;
            v[ i * 6 + 5] = Math.sin( angle ) * radius2;
            c[ i * 6] = 0x000000;
            c[ i * 6 + 1] = 0;
            c[ i * 6 + 2] = 0x000000;
            c[ i * 6 + 3] = 1;
            c[ i * 6 + 4] = 0x000000;
            c[ i * 6 + 5] = 1;
            idx[ i * 12] = ( i * 3 ) + 0;
            idx[ i * 12 + 1] = ( i * 3 ) + 4;
            idx[ i * 12 + 2] = ( i * 3 ) + 3;
            idx[ i * 12 + 3] = ( i * 3 ) + 0;
            idx[ i * 12 + 4] = ( i * 3 ) + 1;
            idx[ i * 12 + 5] = ( i * 3 ) + 4;
            idx[ i * 12 + 6] = ( i * 3 ) + 1;
            idx[ i * 12 + 7] = ( i * 3 ) + 2;
            idx[ i * 12 + 8] = ( i * 3 ) + 5;
            idx[ i * 12 + 9] = ( i * 3 ) + 1;
            idx[ i * 12 + 10] = ( i * 3 ) + 5;
            idx[ i * 12 + 11] = ( i * 3 ) + 4;

            if ( i == sides - 1 ) {
                idx[ i * 12 + 1] = 1;
                idx[ i * 12 + 2] = 0;
                idx[ i * 12 + 5] = 1;
                idx[ i * 12 + 8] = 2;
                idx[ i * 12 + 10] = 2;
                idx[ i * 12 + 11] = 1;
            }
        }

        //log(Log.UI, table.concat(idx,","));
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        m.setVertexArray( v );
        m.setIndexArray( idx );
        m.setColorArray( c );

        return m;
    }

    static circleInOut( self, scene1, scene2, t, rawT ) {
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;
        const radius = Math.sqrt( ( w / 2 ) ** 2 + ( h / 2 ) ** 2 );

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( ( t < 0.5 ) ) {
            const t2 = t * 2;

            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getCircleHoleMesh( self,radius * ( 1 - t2 ) * 1.2, radius * 1.2 );

            self._blackMesh = m;
            self.addChild( m );
            //m.setScale(t);
            m.setX( self.lw / 2 );
            m.setY( self.lh / 2 );
        } else {
            const t2 = ( t - 0.5 ) * 2;

            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getCircleHoleMesh( self,radius * t2 * 1.2, radius * 1.2 );

            self._blackMesh = m;
            self.addChild( m );
            //m.setScale(t);
            m.setX( self.lw / 2 );
            m.setY( self.lh / 2 );
        }
    }


    static circleOut( self, scene1, scene2, t, rawT ) {
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;
        const radius = Math.sqrt( ( w / 2 ) ** 2 + ( h / 2 ) ** 2 );

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( ( t < 0.5 ) ) {
            const t2 = t * 2;

            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getCircleMesh( self,radius * 1.2 );

            self._blackMesh = m;
            self.addChild( m );
            m.setScale( t2 );
            m.setX( self.lw / 2 );
            m.setY( self.lh / 2 );
        } else {
            const t2 = ( t - 0.5 ) * 2;

            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getCircleHoleMesh( self,radius * t2 * 1.2, radius * 1.2 );

            self._blackMesh = m;
            self.addChild( m );
            //m.setScale(t);
            m.setX( self.lw / 2 );
            m.setY( self.lh / 2 );
        }
    }

    static circleIn( self, scene1, scene2, t, rawT ) {
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;
        const radius = Math.sqrt( ( w / 2 ) ** 2 + ( h / 2 ) ** 2 );

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( ( t < 0.5 ) ) {
            const t2 = t * 2;

            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getCircleHoleMesh( self,radius * ( 1 - t2 ) * 1.2, radius * 1.2 );

            self._blackMesh = m;
            self.addChild( m );
            //m.setScale(t);
            m.setX( self.lw / 2 );
            m.setY( self.lh / 2 );
        } else {
            const t2 = ( t - 0.5 ) * 2;

            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getCircleMesh( self,radius * 1.2 );

            self._blackMesh = m;
            self.addChild( m );
            m.setScale( 1 - t2 );
            m.setX( self.lw / 2 );
            m.setY( self.lh / 2 );
        }
    }


    static clock( self, scene1, scene2, t, rawT ) {
        const physicalMarginX = -self.x1;
        const physicalMarginY = -self.y1;
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        if ( ( t < 0.5 ) ) {
            scene1.setVisible( true );
            scene2.setVisible( false );
            const m = SceneManager.getClockMesh( self,w, h, t * 2 );

            m.setX( -physicalMarginX );
            m.setY( -physicalMarginY );
            self._blackMesh = m;
            self.addChild( m );
        } else {
            scene1.setVisible( false );
            scene2.setVisible( true );
            const m = SceneManager.getClockMesh( self,w, h, 1 - ( t - 0.5 ) * 2 );

            m.setScaleX( -1 );
            m.setX( w - physicalMarginX );
            m.setY( -physicalMarginY );
            self._blackMesh = m;
            self.addChild( m );
        }
    }



    //-----------------------------------------------------
    // RT transition;
    //-----------------------------------------------------

    static getCircleMeshRT( self, radius ) {
        const sides = 64;
        const v = [0, 0];
        const t = [( self.x2 - self.x1 ) / 2, ( self.y2 - self.y1 ) / 2];
        const idx = [];
        const c = [0xffffff, 1];

        for ( let i = 0; i < sides; i++ ) {
            const angle = ( i / sides ) * 2 * Math.PI;

            v[2 + i * 4] = Math.cos( angle ) * radius;
            v[2 + i * 4 + 1] = Math.sin( angle ) * radius;
            v[2 + i * 4 + 2] = Math.cos( angle ) * radius * 1.2;
            v[2 + i * 4 + 3] = Math.sin( angle ) * radius * 1.2;
            t[2 + i * 4] = t[1] + v[2 + i * 4];
            t[2 + i * 4 + 1] = t[2] + v[2 + i * 4 + 1];
            t[2 + i * 4 + 2] = t[1] + v[2 + i * 4 + 2];
            t[2 + i * 4 + 3] = t[2] + v[2 + i * 4 + 3];
            c[2 + i * 4] = 0xffffff;
            c[2 + i * 4 + 1] = 1;
            c[2 + i * 4 + 2] = 0xffffff;
            c[2 + i * 4 + 3] = 0;
            idx[i * 9] = 0;	//origin;
            idx[i * 9 + 1] = ( i * 2 ) + 1;
            idx[i * 9 + 2] = ( i * 2 ) + 3;
            idx[i * 9 + 3] = ( i * 2 ) + 1;
            idx[i * 9 + 4] = ( i * 2 ) + 2;
            idx[i * 9 + 5] = ( i * 2 ) + 4;
            idx[i * 9 + 6] = ( i * 2 ) + 1;
            idx[i * 9 + 7] = ( i * 2 ) + 4;
            idx[i * 9 + 8] = ( i * 2 ) + 3;

            if ( i == sides - 1 ) {
                idx[i * 9 + 2] = 1;
                idx[i * 9 + 5] = 2;
                idx[i * 9 + 7] = 2;
                idx[i * 9 + 8] = 1;
            }
        }

        //log(Log.UI, table.concat(idx,","));
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        m.setVertexArray( v );
        m.setIndexArray( idx );
        m.setColorArray( c );
        m.setTextureCoordinateArray( t );
        m.setTexture( self._RT );

        return m;
    }

    static getCircleHoleMeshRT( self, radius1, radius2 ) {
        const sides = 32;
        const [cx, cy] = [( self.x2 - self.x1 ) / 2, ( self.y2 - self.y1 ) / 2];
        const v = [];
        const t = [];
        const idx = [];
        const c = [];

        for ( let i = 0; i < sides; i++ ) {
            const angle = ( i / sides ) * 2 * Math.PI;

            v.push(
                Math.cos( angle ) * radius1 / 1.2, Math.sin( angle ) * radius1 / 1.2,
                Math.cos( angle ) * radius1, Math.sin( angle ) * radius1,
                Math.cos( angle ) * radius2, Math.sin( angle ) * radius2
            );
            t.push(
                cx + v[i * 6], cy + v[i * 6 + 1],
                cx + v[i * 6 + 2], cy + v[i * 6 + 3],
                cx + v[i * 6 + 4], cy + v[i * 6 + 5]
            );
            c.push(
                0xffffff, 0,
                0xffffff, 1,
                0xffffff, 1
            );
            idx.push(
                ( i * 3 ) + 0, ( i * 3 ) + 4, ( i * 3 ) + 3,
                ( i * 3 ) + 0, ( i * 3 ) + 1, ( i * 3 ) + 4,
                ( i * 3 ) + 1, ( i * 3 ) + 2, ( i * 3 ) + 5,
                ( i * 3 ) + 1, ( i * 3 ) + 5, ( i * 3 ) + 4
            );

            if ( i == sides - 1 ) {
                idx[i * 12 + 1] = 1;
                idx[i * 12 + 2] = 0;
                idx[i * 12 + 5] = 1;
                idx[i * 12 + 8] = 2;
                idx[i * 12 + 10] = 2;
                idx[i * 12 + 11] = 1;
            }
        }

        //log(Log.UI, table.concat(idx,","));
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        m.setVertexArray( v );
        m.setIndexArray( idx );
        m.setColorArray( c );
        m.setTextureCoordinateArray( t );
        m.setTexture( self._RT );

        return m;
    }


    static circleOutRT( self, scene1, scene2, t, rawT ) {
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;

        if ( self._blackMesh != null ) {
            self._blackMesh.removeFromParent();
        }

        const radius = Math.sqrt( ( w / 2 ) ** 2 + ( h / 2 ) ** 2 );

        scene1.setVisible( false );
        scene2.setVisible( true );
        const m = SceneManager.getCircleHoleMeshRT( self,radius * t * 1.2, radius * 1.2 );

        self._blackMesh = m;
        self.addChild( m );
        //m.setScale(t);
        m.setX( self.lw / 2 );
        m.setY( self.lh / 2 );
    }

    static circleInRT( self, scene1, scene2, t, rawT ) {
        const w = self.x2 - self.x1;
        const h = self.y2 - self.y1;

        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        const radius = Math.sqrt( ( w / 2 ) ** 2 + ( h / 2 ) ** 2 );

        scene1.setVisible( false );
        scene2.setVisible( true );
        const m = SceneManager.getCircleMeshRT( self,radius * ( 1 - t ) * 1.2 );

        self._blackMesh = m;
        self.addChild( m );
        m.setX( self.lw / 2 );
        m.setY( self.lh / 2 );
    }

    static getPaperMeshRT( self, clip1, clip2 ) {
        //let sides = 32;
        const v = [
            self.x1, self.y1,
            self.x2 - clip1 - clip2, self.y1,
            self.x1, self.y2,
            self.x2 - clip1 - clip2, self.y2
        ];
        const t = [0 + clip1, 0, ( self.x2 - self.x1 ) - clip2, 0, 0 + clip1, ( self.y2 - self.y1 ), ( self.x2 - self.x1 ) - clip2, ( self.y2 - self.y1 )];
        const idx = [0, 1, 2, 1, 3, 2];
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh();

        m.setVertexArray( v );
        m.setIndexArray( idx );
        m.setTextureCoordinateArray( t );
        m.setTexture( self._RT );

        return m;
    }


    static paperDownRT( self, scene1, scene2, t, rawT ) {
        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        scene1.setVisible( false );
        scene2.setVisible( true );
        const clip1 = Math.sin( rad( t * 180 ) ) * ( self.x2 - self.x1 ) / 2;
        const clip2 = ( t < 0.5 ) ? 0 : ( 1 - Math.cos( rad( ( t - 0.5 ) * 180 ) ) ) * ( self.x2 - self.x1 );
        const m = SceneManager.getPaperMeshRT( self,clip1, clip2 );

        scene2.setX( Math.sin( rad( t * 180 ) ) * ( self.x2 - self.x1 ) / 2 );
        m.setX( 0 );
        const b1 = 1 - t * 0.5;
        const b2 = Math.max( 0, t * 2 - 1 );

        scene2.setColorMultiplier( b2, b2, b2 );
        m.setColorMultiplier( b1, b1, b1 );
        self._blackMesh = m;
        self.addChild( m );
    }

    static paperUpRT( self, scene1, scene2, t, rawT ) {
        if ( self._blackMesh ) {
            self._blackMesh.removeFromParent();
        }

        scene1.setVisible( false );
        scene2.setVisible( true );
        scene2.setX( -Math.sin( rad( t * 180 ) ) * ( self.x2 - self.x1 ) / 2 );
        const x2 = ( t < 0.5 ) ? Math.sin( rad( t * 180 ) ) * ( self.x2 - self.x1 ) / 2 : scene2.getX() + ( self.x2 - self.x1 );
        const clip1 = ( t < 0.5 ) ? 0 : x2 - ( self.x2 - self.x1 ) / 2 - Math.cos( rad( ( t - 90 ) * 180 ) ) * ( self.x2 - self.x1 ) / 2;
        const clip2 = x2 - clip1;
        const m = SceneManager.getPaperMeshRT( self,clip1, clip2 );

        m.setX( x2 );
        const b1 = 1 - t * 0.5;
        const b2 = Math.max( 0, t * 2 - 1 );

        scene2.setColorMultiplier( b2, b2, b2 );
        m.setColorMultiplier( b1, b1, b1 );
        self._blackMesh = m;
        self.addChild( m );
    }



    static moveFromRight( self, scene1, scene2, t, rawT ) {
        const width = self.lw + -self.x1 * 2;

        scene1.setX( -t * width );
        scene2.setX( ( 1 - t ) * width );
    }

    static moveFromLeft( self, scene1, scene2, t, rawT ) {
        const width = self.lw + -self.x1 * 2;

        scene1.setX( t * width );
        scene2.setX( ( t - 1 ) * width );
    }

    static overFromRight( self, scene1, scene2, t, rawT ) {
        const width = self.lw + -self.x1 * 2;

        scene2.setX( ( 1 - t ) * width );
    }

    static overFromLeft( self, scene1, scene2, t, rawT ) {
        const width = self.lw + -self.x1 * 2;

        scene2.setX( ( t - 1 ) * width );
    }

    static moveFromRightWithFade( self, scene1, scene2, t, rawT ) {
        const width = self.lw + -self.x1 * 2;

        scene1.setAlpha( 1 - t );
        scene1.setX( -t * width );
        scene2.setX( ( 1 - t ) * width );
    }

    static moveFromLeftWithFade( self, scene1, scene2, t, rawT ) {
        const width = self.lw + -self.x1 * 2;

        scene1.setAlpha( 1 - t );
        scene1.setX( t * width );
        scene2.setX( ( t - 1 ) * width );
    }

    static overFromRightWithFade( self, scene1, scene2, t, rawT ) {
        const width = self.lw + -self.x1 * 2;

        scene1.setAlpha( 1 - t );
        scene2.setX( ( 1 - t ) * width );
    }

    static overFromLeftWithFade( self, scene1, scene2, t, rawT ) {
        const width = self.lw + -self.x1 * 2;

        scene1.setAlpha( 1 - t );
        scene2.setX( ( t - 1 ) * width );
    }

    static moveFromBottom( self, scene1, scene2, t, rawT ) {
        const height = self.lh;

        scene1.setY( -t * height );
        scene2.setY( ( 1 - t ) * height );
    }

    static moveFromTop( self, scene1, scene2, t, rawT ) {
        const height = self.lh;

        scene1.setY( t * height );
        scene2.setY( ( t - 1 ) * height );
    }

    static overFromBottom( self, scene1, scene2, t, rawT ) {
        const height = self.lh;

        scene2.setY( ( 1 - t ) * height );
    }

    static overFromTop( self, scene1, scene2, t, rawT ) {
        const height = self.lh;

        scene2.setY( ( t - 1 ) * height );
    }

    static moveFromBottomWithFade( self, scene1, scene2, t, rawT ) {
        const height = self.lh;

        scene1.setAlpha( 1 - t );
        scene1.setY( -t * height );
        scene2.setY( ( 1 - t ) * height );
    }

    static moveFromTopWithFade( self, scene1, scene2, t, rawT ) {
        const height = self.lh;

        scene1.setAlpha( 1 - t );
        scene1.setY( t * height );
        scene2.setY( ( t - 1 ) * height );
    }


    static overFromBottomWithFade( self, scene1, scene2, t, rawT ) {
        const height = self.lh;

        scene1.setAlpha( 1 - t );
        scene2.setY( ( 1 - t ) * height );
    }

    static overFromTopWithFade( self, scene1, scene2, t, rawT ) {
        const height = self.lh;

        scene1.setAlpha( 1 - t );
        scene2.setY( ( t - 1 ) * height );
    }

    static fade( self, scene1, scene2, t, rawT ) {
        if ( t < 0.5 ) {
            scene1.setAlpha( ( 0.5 - t ) * 2 );
        } else {
            scene1.setAlpha( 0 );
        }

        if ( t < 0.5 ) {
            scene2.setAlpha( 0 );
        } else {
            scene2.setAlpha( ( t - 0.5 ) * 2 );
        }
    }

    static crossfade( self, scene1, scene2, t, rawT ) {
        scene1.setAlpha( 1 - t );
        scene2.setAlpha( t );
    }

    static flip( self, scene1, scene2, t, rawT ) {
        const width = self.lw;

        if ( t < 0.5 ) {
            const s = ( 0.5 - t ) * 2;

            scene1.setScaleX( s );
            scene1.setX( ( 1 - s ) * width * 0.5 );
        } else {
            scene1.setScaleX( 0 );
            scene1.setX( width * 0.5 );
        }

        if ( t < 0.5 ) {
            scene2.setScaleX( 0 );
            scene2.setX( width * 0.5 );
        } else {
            const s = ( t - 0.5 ) * 2;

            scene2.setScaleX( s );
            scene2.setX( ( 1 - s ) * width * 0.5 );
        }
    }

    static flipWithFade( self, scene1, scene2, t, rawT ) {
        const width = self.lw;

        if ( t < 0.5 ) {
            const s = ( 0.5 - t ) * 2;

            scene1.setScaleX( s );
            scene1.setX( ( 1 - s ) * width * 0.5 );
            scene1.setAlpha( s );
        } else {
            scene1.setScaleX( 0 );
            scene1.setX( width * 0.5 );
            scene1.setAlpha( 0 );
        }

        if ( t < 0.5 ) {
            scene2.setScaleX( 0 );
            scene2.setX( width * 0.5 );
            scene2.setAlpha( 0 );
        } else {
            const s = ( t - 0.5 ) * 2;

            scene2.setScaleX( s );
            scene2.setX( ( 1 - s ) * width * 0.5 );
            scene2.setAlpha( s );
        }
    }

    static flipWithShade( self, scene1, scene2, t, rawT ) {
        const width = self.lw;

        if ( t < 0.5 ) {
            const s = ( 0.5 - t ) * 2;

            scene1.setScaleX( s );
            scene1.setX( ( 1 - s ) * width * 0.5 );
            scene1.setColorMultiplier( 1 - t, 1 - t, 1 - t, 1 );
        } else {
            scene1.setScaleX( 0 );
            scene1.setX( width * 0.5 );
            scene1.setColorMultiplier( 0.5, 0.5, 0.5, 1 );
        }

        if ( t < 0.5 ) {
            scene2.setScaleX( 0 );
            scene2.setX( width * 0.5 );
            scene2.setColorMultiplier( 0.5, 0.5, 0.5, 1 );
        } else {
            const s = ( t - 0.5 ) * 2;

            scene2.setScaleX( s );
            scene2.setX( ( 1 - s ) * width * 0.5 );
            scene2.setColorMultiplier( t, t, t, 1 );
        }
    }


    //#endregion

    //---------------------------------------------------------------------------------------------------
    //
    // 메인 코드
    //
    //---------------------------------------------------------------------------------------------------


    getCurrentSceneName() {
        return this.currentScene;
    }

    getCurrentScene() {
        if ( this.scene2 ) {
            return this.scene2;
        }

        return this.scene1;
    }

    isChanging() {
        return this.changingScene;
    }

    changeScene( sprOrFunc, duration, transition, ease, options ) {
        let spr;

        if ( typeof sprOrFunc == "function" ) {
            spr = sprOrFunc();
        } else {
            spr = sprOrFunc;
        }

        //log(Log.SCENE, "changeScene: " .. (this.currentScene ~= null and this.currentScene or "null") .. " to " .. (scene ~= null and scene or "null"));
        if ( !this.active ) {
            //if (GLOBAL.layerShieldForSceneChange) { GLOBAL.layerShieldForSceneChange.show() }
            this.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ENTER_FRAME, this.onEnterFrame, this );
            this.active = true;
        }

        this.changingScene = true;	 // 신 전환시 입력을 막거나 할 때 쓰려고. tweening하고는 시점이 좀 다르다
        this.eventFilter = options != null ? options.eventFilter : null;
        this.currentScene = spr;

        // henjeon, 2014.12.01;
        // 한 프레임에 onEnterFrame() 전에 changeScene() 연속으로 호출되면 begin이벤트 없이 } 이벤트가 호출되는 문제가 있다.
        // changeScene()에서 transitionBegin 이벤트를 바로 호출할 경우 코드 흐름이 전과 달라져서 여러 가지 문제가 발생하여,
        // 호출 순서는 그대로 유지하도록 여기서 this.time이 0이 아닐때만 이벤트를 호출하도록 처리함
        //		
        if ( this.tweening ) {
            if ( this.time != 0 ) {
                //return;
                this.dispatchEvent( "transitionEnd" );
                this.scene1.dispatchEvent( "exitEnd" );
                this.scene2.dispatchEvent( "enterEnd" );
                this.onTransitionEnd();
                this.scene1.removeFromParent();
                this.scene1 = this.scene2;
                this.scene2 = null;
                this.tweening = false;
                this.changingScene = false;
            } else {
                if ( this.scene2 ) {
                    this.scene2.removeFromParent();
                    this.scene2 = null;
                }
            }
        }

        if ( this.scene1 == null ) {
            //이전 씬이 없는 경우이다.
            this.scene1 = new _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        }

        this.duration = duration;
        this.transition = transition;
        this.ease = ease || defaultEase;
        this.scene2 = spr; //this.scenes[scene].new(options and options.userData);
        this.scene2.setVisible( false );
        this.addChild( this.scene2 );
        this.time = 0;
        this.currentTimer = _Timer__WEBPACK_IMPORTED_MODULE_3__.Timer.now();
        this.tweening = true;

        if ( _needRT.get( transition ) ) {
            const ss = this.stage.getScale();
            const w = ( this.x2 - this.x1 ); //* ss;
            const h = ( this.y2 - this.y1 ); //* ss;
            const sx = this.stage.getX();

            this.stage.setScale( 1 );
            const rt = new _RenderTarget__WEBPACK_IMPORTED_MODULE_5__.RenderTarget( w, h, true );

            rt.clear( 0x000000, 1 );
            this.stage.setPosition( -this.x1, -this.y1 );
            rt.draw( this.stage );
            this.stage.setX( sx );
            this.stage.setScale( ss.x,ss.y );
            this._RT = rt;
        }

        return this.scene2;
    }

    resetCurrentScene( currentScene ) {
        this.scene1 = currentScene;
        this.addChild( this.scene1 );
    }

    filterTransitionEvents( event ) {
        event.stopPropagation();
    }

    onTransitionBegin() {
        if ( this.eventFilter ) {
            this.stage.addChild( this.transitionEventCatcher );

            for ( const i in this.eventFilter ) {
                const event = this.eventFilter[i];

                this.transitionEventCatcher.addEventListener( event, this.filterTransitionEvents, this );
            }
        }
    }

    onTransitionEnd() {
        if ( this.eventFilter ) {
            for ( const i in this.eventFilter ) {
                const event = this.eventFilter[i];

                this.transitionEventCatcher.removeEventListener( event, this.filterTransitionEvents, this );
            }

            this.transitionEventCatcher.removeFromParent();
        }
    }

    onEnterFrame( event ) {
        // 이벤트필터링개체를 always on top 시킨다
        this.stage.addChild( this.transitionEventCatcher );

        // 트랜지션 종료시 이곳에서 일괄 처리
        if ( !this.tweening ) {
            //if (GLOBAL.layerShieldForSceneChange) { GLOBAL.layerShieldForSceneChange.hide() }
            this.removeEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.ENTER_FRAME, this.onEnterFrame, this );
            this.scene1.removeFromParent();
            this.scene1 = this.scene2;
            this.scene2 = null;
            this.active = null;
            this.changingScene = false;

            //wiper remove;
            if ( this._blackMesh ) {
                this._blackMesh.removeFromParent();
                this._blackMesh = null;
            }
		
            if ( this._RT ) {
                this._RT = null;
            }

            return;
        }

        if ( this.time == 0 ) {
            this.onTransitionBegin();
            this.scene2.setVisible( true );
            this.dispatchEvent( "transitionBegin" );
            this.scene1.dispatchEvent( "exitBegin" );
            this.scene2.dispatchEvent( "enterBegin" );
        }

        const timer = _Timer__WEBPACK_IMPORTED_MODULE_3__.Timer.now();
        const deltaTime = 1000 / 60; // timer - this.currentTimer;

        this.currentTimer = timer;
        const t = ( this.duration == 0 ) ? 1 : ( this.time / this.duration );

        this.transition( this, this.scene1, this.scene2, this.ease( t ), t );

        if ( this.time == this.duration ) {
            this.dispatchEvent( "transitionEnd" );
            this.scene1.dispatchEvent( "exitEnd" );
            this.scene2.dispatchEvent( "enterEnd" );
            this.onTransitionEnd();
            this.tweening = false;
        }

        this.time = this.time + deltaTime;

        if ( this.duration < this.time ) {
            this.time = this.duration;
        }
    }
}

_needRT = new Map( [
    [SceneManager.circleInRT, true],
    [SceneManager.circleOutRT, true],
    [SceneManager.paperDownRT, true],
    [SceneManager.paperUpRT, true],
] );



/***/ }),

/***/ "./engine/src/Serializer.js":
/*!**********************************!*\
  !*** ./engine/src/Serializer.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Serializer": () => (/* binding */ Serializer)
/* harmony export */ });

//import EventDispatcher from "./eventDispatcher";


/** 
 * @typedef {object} ClassDefOptions
 * @param {function=} construct
 * @param {boolean=} fill
 * @param {string[]=} white
 * @param {string[]=} black
 * @param {string[]=} keep
 * @param {boolean=} dataOnly
 */

/**
 * @typedef {[object,ClassDefOptions]} _ClassDef
 * 
 */

/**
 * @typedef {object|_ClassDef} ClassDef
 * 
 */

const S = {
    undefined:     "$$UDF",
    function:      "$$FNC",
    unknown:       "$$UKN",
    NaN:           "$$NAN",
    Infinity:      "$$INF",
    MinusInfinity: "$$MIF",
    Date:          "$$DAT",
    RegExp:        "$$RGX",
    Reference:     "$$REF"
};

const defaultOptions = {
    ignorePrefix:     "__",
    ignoreList:       ["__pixi"],
    skipUndefined:    true,
    skipUnknownClass: true
};

/** 
 * @typedef {object} SerializerOptions
 * @property {string=} ignorePrefix
 * @property {string[]=} ignoreList
 * @property {boolean=} skipUndefined
 * @property {boolean=} skipUnknownClass
 * 
 */


function copyObject( dst, src, keep ) {
    if ( keep == null ) {
        Object.assign( dst, src );
    } else {
        for ( const k in src ) {
            if ( typeof src[k] == "object" && dst[k] && keep.includes( k ) ) {
                // 대상이 프록시일 경우 그냥 복사하면 프록시 핸들러를 잃어버리기 때문에 
                // keep 리스트의 것들은 주소를 보존시켜야한다.
                Object.assign( dst[k], src[k] );
            } else {
                dst[k] = src[k];
            }
        }
    }
}

/**
 * 게임 오브젝트를 직렬화하고 다시 게임오브젝트로 만들 수 있도록 한다.
 * 직렬화한 오브젝트는 네트웍으로 보내거나 파일에 저장할 수 있다.
 * 
 * 직렬화할 오브젝트가 생성자에서 Proxy를 만드는 경우 주의가 필요함
 * Proxy가 다층으로 구성될 경우 Proxy의 handler를 잃어버릴 수 있다.
 * 그런 것들은 keep 옵션을 사용해서 타겟 개체의 프로토타입을 유지하도록 할 것
 *
 * @class Serializer
 */
class Serializer {
    /**
     *Creates an instance of Serializer.
     * @param {ClassDef[]} classList
     * @param {SerializerOptions} [options={}]
     * @memberof Serializer
     */
    constructor( classList, options = defaultOptions ) {
        //super();

        /** @type {Object.<string,_ClassDef>} */
        this.classList = {};
        this.options = options;
        for ( const classDef of classList ) {
            if ( Array.isArray( classDef ) ) {
                this.classList[classDef[0].name] = [classDef,classDef[1]];
            } else {
                this.classList[classDef.name] = [classDef,null];
            }
        }
        this.__objectToId = undefined;
        this.__idToObject = undefined;
        this.__refCount = undefined;
        //console.log( this.classList );
    }

    /**
     *
     *
     * @param {*} obj
     * @returns {object}
     * @memberof Serializer
     */
    _getSerializableObject( obj ) {
        if ( this.__objectToId.has( obj ) ) {
            this.__refCount[this.__objectToId.get( obj )] = ( this.__refCount[this.__objectToId.get( obj )] || 0 ) + 1;

            return S.Reference + ":" + this.__objectToId.get( obj );
        }
        if ( typeof obj == "undefined" ) {
            return S.undefined;
        } else if ( obj === null ) {
            return null;
        } else if ( obj instanceof RegExp ) {
            return S.RegExp + ":" + obj.toString();
        } else if ( obj instanceof Date ) {
            return S.Date + ":" + obj.getTime();
        } else if ( typeof obj == "string" || typeof obj == "number" || typeof obj == "boolean" ) {
            //@ts-ignore
            if ( Number.isNaN( obj ) ) {
                return S.NaN;
            } else if ( obj === Number.POSITIVE_INFINITY ) {
                return S.Infinity;
            } else if ( obj === Number.NEGATIVE_INFINITY ) {
                return S.MinusInfinity;
            } else {
                return obj;
            }
        } else if ( typeof obj == "function" ) {
            return S.function;
        } else if ( typeof obj == "object" )  {
            if ( this.options.skipUnknownClass && obj.constructor !== Object && obj.constructor !== Array && this.classList[obj.constructor.name] == null ) {
                return S.unknown;
            }

            const id = this.__objectToId.size;

            this.__objectToId.set( obj, id );
            let result;

            if ( Array.isArray( obj ) ) {
                result = [];
                for ( let i = 0; i < obj.length; i++ ) {
                    const convertedObj = this._getSerializableObject( obj[i] );

                    if ( this.options.skipUndefined && convertedObj == S.undefined ) continue;
                    if ( convertedObj != S.function && convertedObj != S.unknown ) {
                        result[i] = convertedObj;
                    }
                }
            } else {
                /** @type {ClassDefOptions} */
                const classOptions = obj.constructor !== Object ? this.classList[obj.constructor.name][1] : null;

                result = !( classOptions && classOptions.dataOnly ) && obj.constructor !== Object ? { __class: obj.constructor.name } : {};
                
                const sortedKey = Object.keys( obj ).sort();

                for ( const k of sortedKey ) {
                    // console.assert( k != "entityManager" );
                    if ( !this.options.ignoreList.includes( k ) && !k.startsWith( this.options.ignorePrefix ) ) {
                        if ( classOptions && classOptions.black && classOptions.black.includes( k ) ) continue;
                        if ( classOptions && classOptions.white && !classOptions.white.includes( k ) ) {
                            continue;
                        }
                        const convertedObj = this._getSerializableObject( obj[k] );

                        if ( this.options.skipUndefined && convertedObj == S.undefined ) continue;
                        if ( convertedObj != S.function && convertedObj != S.unknown ) {
                            result[k] = convertedObj;
                        }
                    }
                }
            }
            this.__idToObject[id] = result;
            //@ts-ignore
            result.__refId = id;

            return result;
        }
        throw new Error( `알 수 없는 타입 발견 ${obj}` );
    }

    getSerializableObject( obj ) {
        this.__objectToId = new Map();
        this.__idToObject = {};
        this.__refCount = {};

        const r = this._getSerializableObject( obj );

        // 리퍼런스 정리

        for ( const id in this.__idToObject ) {
            if ( this.__refCount[id] == null ) {
                delete this.__idToObject[id].__refId;
            }
        }
        delete this.__objectToId;
        delete this.__idToObject;
        delete this.__refCount;
        
        return r;
    }

    /**
     *
     *
     * @param {object} obj
     * @returns {string}
     * @memberof Serializer
     */
    stringify( obj ) {
        return JSON.stringify( this.getSerializableObject( obj ) );
    }

    /**
     * 직렬화된 개체를 복구한다.
     * 
     *
     * @param {string|object} s - 문자열 혹은 직렬화 처리된 개체
     * @param {object=} parseOptions
     * @returns {object}
     * @memberof Serializer
     */
    parse( s , parseOptions ) {
        /** @type {Serializer} */
        const self = this;
        const receiver = function ( k, v ) {
            if ( v == null ) {
                return v;
            } else if ( typeof v == "object" ) {
                if ( Array.isArray( v ) || v._$$class == null ) {
                    return v;
                } else {
                    console.assert( !self.__objectToId.has( v ) );

                    let newObj;
                    
                    console.assert( self.classList[v._$$class] );
                    const [classObj, classDefOptions] = self.classList[v._$$class];

                    if ( classDefOptions == null ) {
                        console.assert( classObj.length == 0,`${v._$$class}의 생성자의 인수는 ${classObj.length}인데 인수 없이 생성을 시도하고 있다. construct 옵션이 필요함` );
                        newObj = new classObj();
                        Object.assign( newObj, v );
                    } else {
                        if ( classDefOptions.construct ) {
                            newObj = classDefOptions.construct.call( self, v, parseOptions );
                        
                            if ( classDefOptions.fill !== false ) {
                                copyObject( newObj, v,classDefOptions.keep );
                            }
                        } else {
                            copyObject( newObj, v, classDefOptions.keep );
                        }
                    }
                    const id = v.__refId;

                    if ( id != null ) {
                        self.__objectToId.set( v, id );
                        self.__idToObject[id] = newObj;
                    
                        delete newObj.__refId;
                    }

                    delete newObj._$$class;

                    return newObj;
                }
            } else if ( typeof v == "string" ) {
                if ( Object.values( S ).includes( v.substr( 0, 5 ) ) ) {
                    // 내부타입 발견
                    const type = v.substr( 0, 5 );

                    if ( type == S.NaN ) return Number.NaN;
                    else if ( type == S.Infinity ) return Number.POSITIVE_INFINITY;
                    else if ( type == S.MinusInfinity ) return Number.NEGATIVE_INFINITY;
                    else if ( type == S.RegExp ) return new RegExp( v.substr( 6 ) );
                    else if ( type == S.Date ) return new Date( v.substr( 6 ) );
                    else if ( type == S.Reference ) {
                        const id = v.substr( 6 );

                        if ( self.__idToObject[id] ) return self.__idToObject[id];

                        throw new Error( "리퍼런스 개체가 만들어지기 전에 리퍼런스를 연결하려고 함" );
                    } else {
                        throw new Error( `parse 할 수 없는 개체 ${v}` );
                    }
                } else {
                    return v;
                }
            } else {
                return v;
            }
        };

        this.__objectToId = new Map();
        this.__idToObject = {};
        console.log( s );
        
        let r;

        if ( typeof s == "object" ) {
            const parseObject = function ( o ) {
                if ( o == null ) {
                    return o;
                } else if ( typeof o == "object" ) {
                    const r = Array.isArray( o ) ? [] : {};

                    for ( const k in o ) {
                        r[k] = receiver.call( r, k, parseObject( o[k] ) );
                    }

                    return r;
                } else {
                    return o;
                }
            };

            r = parseObject( s );
        } else if ( typeof s == "string" ) {
            r = JSON.parse( s, receiver );
        }

        delete this.__idToObject;
        delete this.__objectToId;

        console.log( r );

        return r;
    }
}




/***/ }),

/***/ "./engine/src/Shader.js":
/*!******************************!*\
  !*** ./engine/src/Shader.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Shader": () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Application */ "./engine/src/Application.js");
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _TextureBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextureBase */ "./engine/src/TextureBase.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");






class Shader {
    /**
     *Creates an instance of Shader.
     * @param {string} vertexSrc
     * @param {string} fragmentSrc
     * @param {TextureBase[]=} textures
     * @param {object=} constants
     * @memberof Shader
     */
    constructor( vertexSrc, fragmentSrc, textures, constants ) {
        this.asset = new _Asset__WEBPACK_IMPORTED_MODULE_1__.Asset( "<Shader:*>",_Asset__WEBPACK_IMPORTED_MODULE_1__.Asset.AssetTypes.Shader );
        this.textures = textures != null ? textures : {};
        this.constants = constants != null ? constants : {};
        this.dirty = false;
        this.asset.load( { vertexSrc: vertexSrc,fragmentSrc: fragmentSrc,textures: this._getTextureIds(),constants: this.constants } );
    }

    _getTextureIds() {
        const textureIds = {};

        for ( let name in this.textures ) {
            textureIds[name] = this.textures[name].asset.id;
        }
        return textureIds;
    }

    _update() {
        this.dirty = true;
    }

    forceUpdate() {
        if ( this.dirty ) {
            this.asset.update( { textures: this._getTextureIds(),constants: this.constants } );
            this.dirty = false;
        }
    }

    release() {
        this.asset.release();
    }

    setConstant( name, value ) {
        this.constants[name] = value;
        this._update();

        return this;
    }

    setConstants( constants ) {
        Object.assign( this.constants,constants );
        this._update();

        return this;
    }

    /**
     * 셰이더에 텍스쳐를 바인딩한다
     * name을 지정하면 셰이더안에 nameSampler로 읽을 수 있다.
     * Sampler가 붙는 것에 주의할 것
     *
     * @param {string} name
     * @param {TextureBase} texture
     * @returns {Shader}
     * @memberof Shader
     */
    setTexture( name, texture ) {
        this.textures[name] = texture;
        this._update();

        return this;
    }

    /**
     *
     *
     * @returns {Shader} 
     * @memberof Shader
     */
    clone() {
        const newShader = { textures: {},constants: {} };

        newShader.asset = new _Asset__WEBPACK_IMPORTED_MODULE_1__.Asset( "<Shader:*>",_Asset__WEBPACK_IMPORTED_MODULE_1__.Asset.AssetTypes.Shader );
        Object.assign( newShader.textures,this.textures );
        Object.assign( newShader.constants,this.constants );
        Object.setPrototypeOf( newShader,Shader.prototype );
        newShader.asset.load( { copyFrom: this.asset.id, textures: newShader._getTextureIds(),constants: newShader.constants } );
        //@ts-ignore
        return newShader;
    }
}
Shader.lastId = 0;


/***/ }),

/***/ "./engine/src/Shape.js":
/*!*****************************!*\
  !*** ./engine/src/Shape.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Shape": () => (/* binding */ Shape)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");




// gideros와 완전히 호환은 안됨. 
// 대충 만든 다음에 API를 바꿀 것


class Shape extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor( texture ) {
        super();
        this._$$spriteType = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.SpriteTypes.SHAPE;
        this._$$updateCode = _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
        this.beginPath();
        this.setLineStyle( 0,0x000000,0 );
        this.setFillStyle( Shape.SOLID,0x000000,0 );
    }

    get currentSubPathPoints() {
        return this.subPaths[this.subPaths.length - 1];
    }

    setLineStyle( width, color, alpha ) {
        this.lineWidth = width;
        this.lineColor = _Utils__WEBPACK_IMPORTED_MODULE_1__.Utils.hex2rgba( color,alpha );
    }

    setFillStyle( type, ...args ) {
        if ( type == Shape.SOLID ) {
            const [color, alpha] = args;

            this.fillColor = _Utils__WEBPACK_IMPORTED_MODULE_1__.Utils.hex2rgba( color,alpha );
        }
    }

    beginPath( winding ) {
        this.startX = 0;
        this.startY = 0;
        this.lastX = 0;
        this.lastY = 0;
        this.subPaths = [[]];
    }

    clear() {
        this.subPaths = [];
    }

    moveTo( x,y ) {
        this.endPath();
        if ( this.currentSubPathPoints.length == 0 ) {
            this.startX = x;
            this.startY = y;
        }
        this.currentSubPathPoints.push( x,y );
        this.lastX = x;
        this.lastY = y;
        this._$$localBounds.extendPoint( x,y );
    }

    lineTo( x,y ) {
        if ( this.currentSubPathPoints.length == 0 ) return this.moveTo( x,y );
        this.currentSubPathPoints.push( x, y );
        this.lastX = x;
        this.lastY = y;
        this._$$localBounds.extendPoint( x,y );
    }

    endPath() {
    }

    closePath() {
        if ( this.currentSubPathPoints.length > 0 ) {
            this.currentSubPathPoints.push( this.startX,this.startY );
            this.subPaths.push( [] );
        }
        this._$$updateCode |= _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.UpdateCodes.UPDATE_EXTRA;
    }


    makeBox( x, y, w, h, c, a ) {
        this.beginPath();
        this.setFillStyle( Shape.SOLID, c, a );
        this.moveTo( x,y );
        this.lineTo( x + w,y );
        this.lineTo( x + w,y + h );
        this.lineTo( x,y + h );
        this.closePath();
    }

    static makeBox( x, y, w, h, c, a ) {
        const sh = new Shape();

        sh.makeBox( x, y, w, h, c, a );
        return sh;
    }

    encodeExtraRenderingInfo() {
        const getArray = ()=> {
            const arr = [];

            arr.push( this.subPaths.length - ( this.currentSubPathPoints.length == 0 ? 1 : 0 ) );
            this.subPaths.forEach( path => {
                arr.push( path.length );
                arr.push( ...path );
            } );
            return arr;
        };

        let arr2 = getArray();
        let encodedBuffer = new Float32Array( 9 + arr2.length );

        encodedBuffer[0] = this.lineWidth;
        encodedBuffer.set( this.lineColor,1 );
        encodedBuffer.set( this.fillColor,5 );
        encodedBuffer.set( arr2,9 );

        return [encodedBuffer];
    }
}

Shape.NONE = "none";
Shape.SOLID = "solid";
Shape.TEXTURE = "texture";
Shape.LINEAR_GRADIENT = "linearGradient";
Shape.RADIAL_GRADIENT = "radialGradient";
Shape.NON_ZERO = "noneZero";



/***/ }),

/***/ "./engine/src/Sound.js":
/*!*****************************!*\
  !*** ./engine/src/Sound.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sound": () => (/* binding */ Sound)
/* harmony export */ });
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Application */ "./engine/src/Application.js");
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");







class Sound extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_3__.EventDispatcher {
    constructor( name ) {
        super();
        this.asset = new _Asset__WEBPACK_IMPORTED_MODULE_1__.Asset( name,_Asset__WEBPACK_IMPORTED_MODULE_1__.Asset.AssetTypes.Sound );
        this.asset.load();
        this.playing = false;
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @param {boolean} [isOnce=false]
     * @returns {Sound}
     * @memberof Sound
     */
    addEventListener( eventName, func, context = null, isOnce = false ) {
        if ( eventName == _Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED ) {
            this.asset.addEventListener( eventName, this.dispatchEvent.bind( this,_Event__WEBPACK_IMPORTED_MODULE_2__.Event.LOADED ), null, isOnce );
        }
        //@ts-ignore
        return super.addEventListener( eventName, func, context, isOnce );
    }

    play( startTime,looping,paused ) {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand",class: "Sound", method: "play",args: [this.asset.id, startTime,looping,paused] } );
        this.playing = true;
    }

    setVolume( v ) {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand",class: "Sound",method: "setVolume",args: [this.asset.id, v] } );
    }

    setPitch( v ) {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand",class: "Sound",method: "setPitch",args: [this.asset.id, v] } );
    }

    isPlaying() {
        return this.playing;
    }

    setPaused( v ) {
        if ( v ) {
            _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand",class: "Sound",method: "setPaused",args: [this.asset.id, v] } );
        } else {
            this.play();
        }
        this.playing = !v;
    }

    setPosition( v ) {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand",class: "Sound",method: "setPosition",args: [this.asset.id, v] } );
    }

    stop() {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand",class: "Sound",method: "stop",args: [this.asset.id] } );
        this.playing = false;
    }

    getLength() {
        throw new Error( "Not implemented" );
    }

    static playSound( name ) {
        return ( new Sound( name ) ).play();
    }

    /**
     * 같은 key를 사용히면 항상 하나의 사운드만 나오게 한다.
     * 만약 같은 key인데 name이 다를 경우 이전 사운드는 중지시키고 새로 연주
     *
     * @static
     * @param {*} name
     * @param {*} vol
     * @param {*} loop
     * @param {*} [key=name]
     * @memberof Sound
     */
    static playSingleSound( name,vol,loop,key = name ) {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand",class: "Sound",method: "playSingleSound",args: [name,vol,loop,key] } );
    }

    static stopAllSingleSound() {
        _Application__WEBPACK_IMPORTED_MODULE_0__.application.postMessageToRender( { msg: "addCommand",class: "Sound",method: "stopAllSingleSound",args: [] } );
    }
}




/***/ }),

/***/ "./engine/src/Spine.js":
/*!*****************************!*\
  !*** ./engine/src/Spine.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spine": () => (/* binding */ Spine)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _TextField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextField */ "./engine/src/TextField.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _Storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Storage */ "./engine/src/Storage.js");

// import {SpinePixi from "./ext/spine-pixi";






//pixi-spine docs
//https://github.com/pixijs/pixi-spine/blob/next/examples/index.md

class Spine extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor( spineFilename ) {
        super();
 
        this.loader = new SpinePixi.AssetManager();
        this.loader.loadText( spineFilename + ".json" );
        // this.loader.loadText( spineFilename + ".atlas" );
        // this.loader.loadTexture( spineFilename + ".png" );
        // this.loader.loadTexture( spineFilename + "2.png" );
        // this.loader.loadTexture( spineFilename + "3.png" );
        // this.loader.loadTexture( spineFilename + "4.png" );
        this.loader.loadText( "Spines/Spine_Player_3.atlas" );
        this.loader.loadTexture( "Spines/Spine_Player_3.png" );

        // Storage.loadFile( spineFilename ).on( Event.COMPLETE,( e )=>{

        //     this.spine = new SpinePixi( e.data );
        //     this.on( Event.READY,()=>{

        //         this.onStage( Event.ENTER_FRAME,()=>{

        //             this.spine.update();
                
        //         } );
            
        //     } );
        
        // } );
        this.spineFilename = spineFilename;
        requestAnimationFrame( ()=>this.load() );
    }

    load() {
        if ( this.loader.isLoadingComplete() ) {
            console.log( "완료" );
            let data = this.loadSkeleton( this.spineFilename );

            this.skeleton = data.skeleton;
            this.state = data.state;
            this.bounds = data.bounds;
            this.skeletonData = data;
            // this.onStage( Event.ENTER_FRAME,()=>{

            //     s.update( 1000 / 60 );
            // } );
            this.renderer = new SpinePixi.SkeletonRenderer( this.__pixi );
            this.onStage( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.ENTER_FRAME,()=>{
                this.state.update( 1 / 60 );
                this.state.apply( this.skeleton );
                this.renderer.draw( this.skeleton );
            } );

            this.__pixi.emit( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.READY );
        } else {
            requestAnimationFrame( ()=>this.load() );
        }
    }

    loadSkeleton( name ) {
        let basePath = name.substr( 0,name.lastIndexOf( "/" ) );
        //        let atlas = new SpinePixi.core.TextureAtlas( this.loader.get( name.replace( "-pro", "" ).replace( "-ess", "" ) + ".atlas" ), ( path ) => {
        let atlas = new SpinePixi.core.TextureAtlas( this.loader.get( "Spines/Spine_Player_3.atlas" ), ( path ) => {
            return this.loader.get( basePath + "/" + path );
        } );

        // Create a AtlasAttachmentLoader, which is specific to the WebGL backend.
        let atlasLoader = new SpinePixi.core.AtlasAttachmentLoader( atlas );
        // Create a SkeletonJson instance for parsing the .json file.
        let skeletonJson = new SpinePixi.core.SkeletonJson( atlasLoader );

        let skeletonData = skeletonJson.readSkeletonData( this.loader.get( name + ".json" ) );
        let skeleton = new SpinePixi.core.Skeleton( skeletonData );

        skeleton.flipY = true;
        let bounds = this.calculateBounds( skeleton );

        skeleton.setSkinByName( "runner" );
        // Create an AnimationState, and set the initial animation in looping mode.
        var animationState = new SpinePixi.core.AnimationState( new SpinePixi.core.AnimationStateData( skeleton.data ) );

        animationState.setAnimation( 0, "standing", true );

        //@ts-ignore
        animationState.addListener( {
            event: function( trackIndex, event ) {
                // console.log("Event on track " + trackIndex + ": " + JSON.stringify(event));
            },
            complete: function( trackIndex, loopCount ) {
                // console.log("Animation on track " + trackIndex + " completed, loop count: " + loopCount);
            },
            start: function( trackIndex ) {
                // console.log("Animation on track " + trackIndex + " started");
            },
            end: function( trackIndex ) {
                // console.log("Animation on track " + trackIndex + " ended");
            }
        } );

        // Pack everything up and return to caller.
        return { skeleton: skeleton, state: animationState, bounds: bounds };
    }

    calculateBounds( skeleton ) {
        var data = skeleton.data;

        skeleton.setToSetupPose();
        skeleton.updateWorldTransform();
        var offset = new SpinePixi.core.Vector2();
        var size = new SpinePixi.core.Vector2();

        skeleton.getBounds( offset, size, [] );

        return { offset: offset, size: size };
    }
}

// Spine은 자체적으로 차일드를 생성하기 때문에 차일드 수가 꼬일 수 있음
// 같은 처리를 하고 있는 TextField의 것을 쓰자
Spine.prototype.getChildAt = _TextField__WEBPACK_IMPORTED_MODULE_1__.TextField.prototype.getChildAt;
Spine.prototype.getNumChildren = _TextField__WEBPACK_IMPORTED_MODULE_1__.TextField.prototype.getNumChildren;
Spine.prototype.sortChildren = _TextField__WEBPACK_IMPORTED_MODULE_1__.TextField.prototype.sortChildren;
Spine.prototype.refreshColor = _TextField__WEBPACK_IMPORTED_MODULE_1__.TextField.prototype.refreshColor;



/***/ }),

/***/ "./engine/src/Sprite.js":
/*!******************************!*\
  !*** ./engine/src/Sprite.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sprite": () => (/* binding */ Sprite)
/* harmony export */ });
/* harmony import */ var twgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _ComponentHolder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComponentHolder */ "./engine/src/ComponentHolder.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Application */ "./engine/src/Application.js");
/* harmony import */ var _easing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./easing */ "./engine/src/easing.js");
/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Transform */ "./engine/src/Transform.js");
/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Shader */ "./engine/src/Shader.js");













class Sprite extends _ComponentHolder__WEBPACK_IMPORTED_MODULE_3__.ComponentHolder {
    constructor() {
        super();
        this._$$id = Sprite.lastId++;
        Sprite.finalizationRegistry.register( this,{ thisObjId: this._$$id } );
        this._$$spriteType = Sprite.SpriteTypes.SPRITE;
        this._$$updateCode = Sprite.UpdateCodes.UPDATE_NOTHING;
        this.transform = new _Transform__WEBPACK_IMPORTED_MODULE_9__.Transform();
        this.transform.invalidateCallback = this.onInvalidateTransform.bind( this );
        this._$$localBounds = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( 0,0,0,0 );
        this._$$boundsDirty = true;
        this._$$bounds = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( 0,0,0,0 );
        /** @type {Rect} */
        this.customBounds = undefined;
        // this.boundsDirty
        this.useCustomLocalBounds = false;
        this.worldMatrix = undefined;
        this.colorOverride = [1,1,1,1];
        this.colorAdd = [0,0,0,0];
        this.clipRegion = null;
        /** @type {Sprite[]} */
        this.children = [];
        this.parent = null;
        this._$$visible = true;
        this.customPrev;

        /** @type {Asset} */
        this.asset;

        this.cacheBitmapMode = Sprite.CacheBitmapModes.NO_CACHE;
        this.cacheBitmapDstId = 0;
        /** @type {Asset} */
        this.cacheBitmapAsset;
        this.blendMode = Sprite.BlendModes.NORMAL;
        this.motionBlur = true;

        /** @type {Shader} */
        this.shader;
    }

    static finalizeHandler( obj ) {
        // GC에 의해 수거되었으면 릴리즈를 보낸다.
        _Application__WEBPACK_IMPORTED_MODULE_7__.application.postMessageToRender( { msg: "addCommand",class: "Sprite", method: "release",args: [obj.thisObjId] } );
    }


    release() {
        // 강제로 삭제
        if ( this.asset != null )  {
            this.asset.release();
        }
        // 스프라이트 지우라는 메시지 보내야함
        for ( let key in this ) {
            delete this[key];
        }
        _Application__WEBPACK_IMPORTED_MODULE_7__.application.postMessageToRender( { msg: "addCommand",executionTiming: 2,class: "Sprite",method: "release",args: [this._$$id] } );
    }

    /**
     * 스프라이트의 복사본을 만든다
     * 얕은 복사를 하기 때문에 스프라이트를 상속한 개체인 경우 값이 아니라 참조가 복사되는 것에 주의 할 것
     *
     * @returns {Sprite} 
     * @memberof Sprite
     */
    clone() {
        /** @type {Sprite} */
        const newObj = {};

        Object.assign( newObj,this );
        Object.setPrototypeOf( newObj,Object.getPrototypeOf( this ) );
        newObj._$$id = Sprite.lastId++;
        // 개체를 공유하게 되기 때문에 clone을 다시 해주어야 한다
        newObj.transform = newObj.transform.clone();
        newObj.transform.invalidateCallback = newObj.onInvalidateTransform.bind( newObj );
        newObj._$$localBounds = newObj._$$localBounds.clone();
        newObj._$$bounds = newObj._$$bounds.clone();
        newObj.worldMatrix = ( newObj.worldMatrix != null ) ? twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.copy( newObj.worldMatrix ) : null;
        newObj.colorOverride = [...newObj.colorOverride];
        newObj.colorAdd = [...newObj.colorAdd];
        newObj.clipRegion = ( newObj.clipRegion != null ) ? newObj.clipRegion.clone() : null;
        newObj.children = [...newObj.children];
        newObj.customPrev = ( newObj.customPrev != null ) ? ( Object.assign( {},newObj.customPrev ) ) : null;
        newObj._$$updateCode |= Sprite.UpdateCodes.UPDATE_EXTRA;
        return newObj;
    }

    onInvalidateTransform() {
        let spr = this;

        do {
            spr._$$boundsDirty = true;
            spr = spr.parent;
        } while ( spr != null );
        return spr;
    }

    getPath( detailInfo ) {
        const path = [];
        let spr = this;

        while ( spr.parent != null ) {
            if ( detailInfo ) {
                path.unshift( spr.parent.children.indexOf( spr ) + ":" + spr.constructor.name );
            } else {
                path.unshift( spr.parent.children.indexOf( spr ) );
            }
            spr = spr.parent;
        }
        //@ts-ignore
        if ( spr.isStage ) {
            return "//" + path.join( "/" );
        } else {
            return "?/" + path.join( "/" );
        }
    }


    /**
     * @returns {Point} 
     * @memberof Sprite
     */
    get position() {
        return new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( this.transform.x,this.transform.y );
    }

    /**
     * @param {Point} v
     * @memberof Sprite
     */
    set position( v ) {
        this.transform.x = v.x;
        this.transform.y = v.y;
    }

    setPosition( x,y ) {
        this.transform.x = x;
        this.transform.y = y;
    }

    getPosition() {
        return this.position;
    }


    get x() { return this.transform.x; }

    set x( v ) { this.transform.x = v; }

    getX() { return this.transform.x; }

    setX( v ) { this.transform.x = v; } 

    get y() { return this.transform.y; }

    set y( v ) { this.transform.y = v; }

    getY() { return this.transform.y; }

    setY( v ) { this.transform.y = v; } 

    /**
     * [x,y] 형태로 반환한다.
     *
     * @returns {[number,number]}
     * @memberof Sprite
     */
    get xy() { return [this.x, this.y]; }

    /**
     * [x,y] 형태로만 받는다.
     * 
     * @param {number[]|Point} v
     * @memberof Sprite
     */
    set xy( v ) {
        if ( Array.isArray( v ) ) {
            this.x = v[0];
            this.y = v[1];
        } else {
            //@ts-ignore
            this.x = v.x;
            //@ts-ignore
            this.y = v.y;
        }
    }

    /**
     * @returns {number}
     * @memberof Sprite
     */
    getRotation() { return this.transform.rotation; }

    /**
     * @param {number} v
     * @memberof Sprite
     */
    setRotation( v ) { this.transform.rotation = v; }

    get anchorX() { 
        return this.transform.anchorX / ( this.bounds.width || 1 ); 
    }

    /**
     * @returns {Point}
     * @memberof Sprite
     */
    get anchorPosition() {
        return new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( this.transform.anchorX,this.transform.anchorY );
    }

    /**
     * @param {Point} v
     * @memberof Sprite
     */
    set anchorPosition( v ) {
        this.transform.anchorX = v.x;
        this.transform.anchorY = v.y;
    }

    get anchorPositionX() {
        return this.transform.anchorX;
    }

    set anchorPositionX( v ) {
        this.transform.anchorX = v;
    }

    get anchorPositionY() {
        return this.transform.anchorY;
    }

    set anchorPositionY( v ) {
        this.transform.anchorY = v;
    }


    set anchorX( v ) { 
        this.transform.anchorX = v * this.bounds.width; 
    }

    get anchorY() { 
        return this.transform.anchorY / ( this.bounds.height || 1 ); 
    }

    set anchorY( v ) { 
        this.transform.anchorY = v * this.bounds.height; 
    }

    getAnchorPoint() {
        return new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( this.anchorX,this.anchorY );
    }

    setAnchorPoint( ax,ay ) {
        this.anchorX = ax;
        this.anchorY = ay;
    }

    get scaleX() { return this.transform.scaleX; }

    set scaleX( v ) { this.transform.scaleX = v; }

    getScaleX() { return this.transform.scaleX; }

    setScaleX( v ) { this.transform.scaleX = v; }
    

    get scaleY() { return this.transform.scaleY; }

    set scaleY( v ) { this.transform.scaleY = v; }

    getScaleY() { return this.transform.scaleY; }

    setScaleY( v ) { this.transform.scaleY = v; }



    /**
     * @returns {Point}
     * @memberof Sprite
     */
    get scale() { return new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( this.transform.scaleX,this.transform.scaleY ); }

    /**
     * @param {number|Point} v
     *
     * @memberof Sprite
     */

    /**
     * @param {[number,number]|Float32Array|number|Point} v
     * @memberof Sprite
     */
    set scale( v ) {
        if ( typeof v === "number" ) {
            // 스케일은 동시에 넣을 수 있으면 편리
            this.transform.scaleX = v;
            this.transform.scaleY = v;
        } else {
            const p = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( v );

            this.transform.scaleX = p.x;
            this.transform.scaleY = p.y;
        }
    } 

    getScale() {
        return this.scale;
    }

    setScale( x,y ) {
        this.scaleX = x;
        this.scaleY = y == null ? x : y;
    }

    get rotation() {
        return this.transform.rotation;
    }

    set rotation( v ) {
        this.transform.rotation = v;
    }

    /**
     * 자식 스프라이트를 제외하고 순수하게 자기 자신의 크기
     *
     * @readonly
     * @memberof Sprite
     */
    get localBounds() {
        const r = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( this._$$localBounds );

        r.x -= this.transform.anchorX;
        r.y -= this.transform.anchorY;
        return r;
    }

    /**
     * 자신과 자식 모두를 포함한 경계 사각형을 구한다.
     *
     * @readonly
     * @memberof Sprite
     */
    get bounds() {
        if ( this.customBounds ) {
            return this.customBounds;
        }
        if ( !this._$$boundsDirty ) {
            return this._$$bounds;
        }
        // 여기 느리다. 나중에 최적화 할 것
        // 하위 개체가 추가/삭제되거나 이동하면 다시 계산하도록 해야 한다.
        // 다시 계산이 필요한 경우 상위로 전파시켜줘야할 것 같음
        let matFrom = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.identity();
        let bounds = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect();
        let boundsPoints = [];

        const search = ( spr,mat )=>{
            if ( !spr._$$boundsDirty ) {
                // 자식 스프라이트가 바뀐게 없으면 보관된 점들을 사용한다.
                boundsPoints.push( ... spr._$$boundsPoints );
            } else {
                if ( spr.spriteType != 0 ) {
                    const [x1,y1,x2,y2,x3,y3,x4,y4] = spr.localBounds.getCornerPoints();
                    let x,y;

                    [x,y] = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.transformPoint( mat,[x1,y1,0] );
                    boundsPoints.push( x,y );
                    [x,y] = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.transformPoint( mat,[x2,y2,0] );
                    boundsPoints.push( x,y );
                    [x,y] = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.transformPoint( mat,[x3,y3,0] );
                    boundsPoints.push( x,y );
                    [x,y] = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.transformPoint( mat,[x4,y4,0] );
                    boundsPoints.push( x,y );
                }
                for ( let child of spr.children ) {
                    if ( child.visible ) {
                        search( child,twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.multiply( mat,child.transform.matrix ) );
                    }
                }
            }
        };

        search( this,matFrom );
        for ( let i = 0; i < boundsPoints.length; i += 2 ) {
            bounds.extendPoint( boundsPoints[i],boundsPoints[i + 1] );
        }

        this._$$bounds = bounds;
        this._$$boundsDirty = false;
        this._$$boundsPoints = boundsPoints;
        return bounds;      
    }

    getBounds() {
        return this.bounds;
    }

    updateLocalBounds() {

    }    

    get visible() {
        return this._$$visible;
    }

    set visible( v ) {
        if ( !this._$$visible && v ) {
            this._updateChildren( Sprite.UpdateCodes.UPDATE_CLEAR_PREV ); 
        }
        this._$$visible = v;
    }

    isVisible() {
        return this.visible;
    }

    setVisible( v ) {
        this.visible = v;
    }

    isVisibleDeeply() {
        let spr;

        for ( spr = this; spr != null && !spr.isStage; spr = spr.parent ) {
            if ( !spr.visible ) return false;
        }
        if ( spr == null ) return false;

        return true;
    }

    get redMultiplier() { return this.colorOverride[0]; }

    set redMultiplier( v ) { this.colorOverride[0] = v; }

    get greenMultiplier() { return this.colorOverride[1]; }

    set greenMultiplier( v ) { this.colorOverride[1] = v; }

    get blueMultiplier() { return this.colorOverride[2]; }

    set blueMultiplier( v ) { this.colorOverride[2] = v; }

    get alpha() {
        return this.colorOverride[3];
    }

    set alpha( v ) {
        this.colorOverride[3] = v;
    }

    setAlpha( v ) {
        this.colorOverride[3] = v;
    }

    getAlpha( v ) {
        return this.colorOverride[3];
    }

    setColorMultiplier( r,g,b,a ) {
        this.colorOverride[0] = r;
        this.colorOverride[1] = g;
        this.colorOverride[2] = b;
        if ( a != null ) this.colorOverride[3] = a; 
    }

    setOverrideColor( c,a ) {
        const arr = _Utils__WEBPACK_IMPORTED_MODULE_5__.Utils.hex2rgba( c,a );

        this.colorOverride[0] = arr[0];
        this.colorOverride[1] = arr[1];
        this.colorOverride[2] = arr[2];
        if ( a != null ) this.colorOverride[3] = arr[3];
    }

    get width() {
        return this.bounds.width;
    }

    set width( v ) {
        this.customBounds = this.customBounds || this.bounds;
        this.customBounds.width = v;
    }

    get height() {
        return this.bounds.height;
    }

    set height( v ) {
        this.customBounds = this.customBounds || this.bounds;
        this.customBounds.height = v;
    }

    setCustomBounds( x,y,w,h ) {
        this.customBounds.x = x;
        this.customBounds.y = y;
        this.customBounds.width = w;
        this.customBounds.height = h;
    }


    getWidth() {
        return this.width;
    }

    getHeight() {
        return this.height;
    }

    localToGlobal( x,y ) {
        let matArr = [];

        for ( let spr = this; ; spr = spr.parent ) {
            matArr.unshift( spr.transform.matrix );
            if ( spr.parent == null ) break;
        }
        let mat = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.identity();

        matArr.forEach( v=>{
            twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.multiply( mat,v,mat );
        } );
        let p = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.transformPoint( mat,[x,y,0] );

        return new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( p[0],p[1] );
    }

    globalToLocal( x,y ) {
        //@ts-ignore
        if ( this.parent == null || this.isStage ) {
            return new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( x,y );
        }
        // 지난 프레임에 구해놓은 worldMatrix를 사용하면 빠르게 할 수 있다.
        // 지금은 그냥 둔다
        let matArr = [];

        for ( let spr = this; ; spr = spr.parent ) {
            matArr.push( twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.inverse( spr.transform.matrix ) );
            if ( spr.parent == null ) break;
        }
        let mat = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.identity();

        matArr.forEach( v=>{
            twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.multiply( mat,v,mat );
        } );
        let p = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.transformPoint( mat,[x,y,0] );

        return new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( p[0],p[1] );
    }

    setBlendMode( v ) {
        this.blendMode = v;        
    }


    //#region addChild & removeChild

    _updateChildren( updateCodeToON ) {
        for ( const s of this.searchChildren() ) {
            s.updateCode |= updateCodeToON;
        }
    }

    /**
     *
     *
     * @param {Sprite} spr
     * @param {number=} i
     * @memberof Sprite
     */
    addChildAt( spr, i ) {
        if ( i == null ) {
            i = this.children.length;
        }
        const oldIndex = this.children.indexOf( spr );
            
        this.children.splice( i,0, spr );
        if ( oldIndex >= 0 ) {
            // 원래 있던 경우 위치 이동
            if ( oldIndex > i ) {
                this.children.splice( oldIndex + 1,1 );
            } else if ( oldIndex < i ) {
                this.children.splice( oldIndex,1 );
            }
        }
        spr.parent = this;
        if ( this.isOnStage() ) {
            spr._updateChildren( Sprite.UpdateCodes.UPDATE_CLEAR_PREV ); 
            spr.dispatchEventWithChildren( new _Event__WEBPACK_IMPORTED_MODULE_2__.Event( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.ADDED_TO_STAGE ) );
        }
        this.onInvalidateTransform();
    }


    /**
     *
     *
     * @param {...Sprite} sprs
     * @memberof Sprite
     */
    addChild( ...sprs ) {
        for ( const spr of sprs ) {
            this.addChildAt( spr );
        }
    }


    removeChildAt( i ) {
        const child = this.children[i];

        child.parent = null;
        this.children.splice( i,1 );
        if ( this.isOnStage() ) {
            child.dispatchEventWithChildren( new _Event__WEBPACK_IMPORTED_MODULE_2__.Event( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.REMOVED_FROM_STAGE ) );
        }
        this.onInvalidateTransform();
    }

    /**
     *
     *
     * @param {Sprite} spr
     * @memberof Sprite
     */
    removeChild( spr ) {
        let index = this.children.indexOf( spr );

        if ( index != -1 ) this.removeChildAt( index );
    }

    removeFromParent() {
        if ( this.parent ) {
            this.parent.removeChild( this );
        }
    }

    clearChildren() {
        for ( let i = this.children.length - 1; i >= 0; i-- ) {
            this.removeChildAt( i );
        }
    }

    getChildIndex( spr ) {
        return this.children.indexOf( spr );
    }

    getChildAt( i ) {
        return this.children[i];
    }

    //#endregion

    getStage() {
        let spr;

        for ( spr = this; spr != null && !spr.isStage; spr = spr.parent );
        return spr;
    }

    isOnStage() {
        return this.getStage() != null;
    }

    /**
     *
     *
     * @param {Event|string} eventOrName
     * @param {object=} extendedValues
     * @memberof Sprite
     */
    dispatchEventWithChildren( eventOrName,extendedValues ) {
        let event;

        if ( typeof eventOrName == "string" ) {
            event = new _Event__WEBPACK_IMPORTED_MODULE_2__.Event( eventOrName );
        } else {
            event = eventOrName;
        }
        Object.assign( event,extendedValues );
        // const inputOnly = Event.isInputEvent( event.name );

        for ( const spr of this.searchChildren( true ) ) {
            if ( event.stopped ) return;
            spr.dispatchEvent( event );
        }
    }

    /**
     * 
     * @param {boolean} [bottomUp=false]
     */
    *searchChildren( bottomUp ) {
        yield* Sprite.searchChildren( this, bottomUp );
    }

    /**
     *
     *
     * @static
     * @param {Sprite} startObj
     * @param {boolean} [bottomUp=false]
     * @memberof Sprite
     */
    static *searchChildren( startObj, bottomUp = false ) {
        const searchRecursive = function* ( cur ) {
            if ( bottomUp ) {
                if ( cur.children.length > 0 ) {
                    for ( let i = cur.children.length - 1; i >= 0; i-- ) {
                        const child = cur.children[i];

                        if ( child ) yield* searchRecursive( child );
                    }
                }
                yield cur;
            } else {
                yield cur;
                if ( cur.children.length > 0 ) {
                    for ( let i = 0; i < cur.children.length; i++ ) {
                        const child = cur.children[i];

                        if ( child ) yield* searchRecursive( child );
                    }
                }
            }
        };

        yield* searchRecursive( startObj );
    }

    findChildById( id ) {
        for ( let spr of this.searchChildren( ) ) {
            if ( spr.id == id ) return spr;
        }
    }


    getNumChildren() {
        return this.children.length;
    }

    /**
     *
     *
     * @returns {Sprite}
     * @memberof Sprite
     */
    getParent() {
        return this.parent;
    }

    /**
     *
     *
     * @param {Sprite} spr
     * @returns {boolean}
     * @memberof Sprite
     */
    contains( spr ) {
        return this.children.includes( spr );
    }

    hitTestPoint( x, y ) {
        const p = this.globalToLocal( x,y );
        const rect = this.bounds;

        return rect.contains( p.x,p.y );
    }

    setClip( x,y,width,height ) {
        this.clipRegion = new _Types__WEBPACK_IMPORTED_MODULE_4__.Rect( x,y,width,height );
    }

    setShader( shader ) {
        this.shader = shader;
    }

    getShader() {
        return this.shader;
    }


    //#region setInteractive() 
    
    /**
     * @callback AnimationHandler
     * @param {{x:number,y:number,button:*,target:Sprite}} event
     * @param {{downPointerPosition:Point,downThisPosition:Point,downOffset:Point,downButton:*,pushed:boolean,clickCancled:boolean,state:string,moveDeltaPosition:Point,moveThisPosition:Point}} info
     * @return {Tween}
     */
    /**
     * @callback InteractiveHandler
     * @param {{x:number,y:number,button:*,target:Sprite}} event
     * @param {{downPointerPosition:Point,downThisPosition:Point,downOffset:Point,downButton:*,pushed:boolean,clickCancled:boolean,state:string,moveDeltaPosition:Point,moveThisPosition:Point}} info
     */
    /**
     *
     * @param {object} options
     * @param {AnimationHandler=} options.pressAnimation - 눌러지는 애니메이션을 틀기. tween를 리턴해야한다.
     * @param {AnimationHandler=} options.releaseAnimation - 올라오는 애니메이션을 틀기. tween을 리턴해야한다.
     * @param {InteractiveHandler=} options.down - 영역안에서 down한 경우
     * @param {InteractiveHandler=} options.move - down 후 move할 경우
     * @param {InteractiveHandler=} options.up - down 후 up할 경우
     * @param {InteractiveHandler=} options.click - down에서 멀리 떨어지지 않은 위치에서 up
     * @param {InteractiveHandler=} options.press - down 후 up할 때 영역 안
     * @param {boolean=} options.preventRelease - click이나 press에서 releaseAnimation하지 않도록
     * @param {boolean=} options.disableBasicAnimation - 기본 애니메이션 끄기
     * @param {number=} options.pressOffsetY - 기본 pressAnimation에서 얼마나 아래로 내려가는가
     * @param {number=} options.clickRadius - click으로 판정하는 반지름
     * @param {boolean=} options.dragX - 가로축으로 드래그
     * @param {boolean=} options.dragY - 세로축으로 드래그
     * @param {number=} options.dragReleaseDistance - 이 거리를 벗어나면 drag가 취소된다.
     * @param {boolean=} options.allowDragOutside - 화면 밖으로 못 끌고 나가도록 한다
     * @memberof Sprite
     */
    setInteractive( options = null ) {
        this.__interactive = this.__interactive || {};
        const _i = this.__interactive;
        const clickCancelDistance = ( options && options.clickRadius != null ) ? options.clickRadius : 10;
        const defaultPressOffsetY = 3;// 실제 픽셀기준으로 해야함
        const pointerDown = ( e ) => {
            if ( this.hitTestPoint( e.x, e.y ) ) {
                _i.downPointerPosition = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( e.x, e.y );
                _i.downThisPosition = this.getPosition().clone();
                _i.downOffset = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( e.x - this.x, e.y - this.y );
                _i.downButton = e.button;
                _i.pushed = true;
                _i.clickCanceled = false;
                _i.state = "down";
                if ( !options.disableBasicAnimation ) {
                    if ( _i.tween ) _i.tween.stop();
                    _i.tween = this.move(
                        _i.downThisPosition.x,
                        _i.downThisPosition.y + ( options.pressOffsetY != null ? options.pressOffsetY : defaultPressOffsetY ),
                        300,
                        _easing__WEBPACK_IMPORTED_MODULE_8__.easing.outBack );
                    e.stopPropagation();
                } else if ( options.pressAnimation ) {
                    if ( _i.tween ) _i.tween.stop();
                    _i.tween = options.pressAnimation.call( this, e, _i );
                    e.stopPropagation();
                }
                if ( options.down != null ) {
                    options.down.call( this, e, _i );
                }
            }
        };
        const pointerMove = ( e ) => {
            if ( _i.state == "down" || _i.state == "move" ) {
                _i.state = "move";
                _i.moveDeltaPosition = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( e.x - _i.downPointerPosition.x , e.y - _i.downPointerPosition.y );
                _i.moveThisPosition = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point(
                    options.dragX ? _i.downThisPosition.x + _i.moveDeltaPosition.x : _i.downThisPosition.x,
                    options.dragY ? _i.downThisPosition.y + _i.moveDeltaPosition.y : _i.downThisPosition.y,
                );
                if ( !options.allowDragOutside ) {
                    _i.moveThisPosition.x = _Utils__WEBPACK_IMPORTED_MODULE_5__.Utils.clamp( _i.moveThisPosition.x, _Application__WEBPACK_IMPORTED_MODULE_7__.application.logicalRenderBounds.left - _i.downOffset.x, _Application__WEBPACK_IMPORTED_MODULE_7__.application.logicalRenderBounds.right - _i.downOffset.x );
                    _i.moveThisPosition.y = _Utils__WEBPACK_IMPORTED_MODULE_5__.Utils.clamp( _i.moveThisPosition.y, _Application__WEBPACK_IMPORTED_MODULE_7__.application.logicalRenderBounds.top - _i.downOffset.y, _Application__WEBPACK_IMPORTED_MODULE_7__.application.logicalRenderBounds.bottom - _i.downOffset.y );
                }
                if ( options.dragX || options.dragY ) {
                    if ( _i.tween ) _i.tween.cancel();
                }
                if ( options.dragX ) this.x = _i.moveThisPosition.x;
                if ( options.dragY ) this.y = _i.moveThisPosition.y;
                if ( _i.clickCanceled == false ) {
                    if ( Math.sqrt( _i.moveDeltaPosition.x ** 2 + _i.moveDeltaPosition.y ** 2 ) > clickCancelDistance ) {
                        _i.clickCanceled = true;
                    }
                }
                e.stopPropagation();
                if ( options.move != null ) {
                    options.move.call( this,e, _i );
                }
                if ( _i.pushed && !this.hitTestPoint( e.x, e.y ) ) {
                    _i.pushed = false;
                    if ( !options.disableBasicAnimation ) {
                        if ( _i.tween ) _i.tween.stop();
                        _i.tween = this.move(
                            _i.moveThisPosition.x,
                            _i.moveThisPosition.y,
                            200,
                            _easing__WEBPACK_IMPORTED_MODULE_8__.easing.outCubic );
                        e.stopPropagation();
                    } else if ( options.releaseAnimation ) {
                        if ( _i.tween ) _i.tween.stop();
                        _i.tween = options.releaseAnimation.call( this, e, _i );
                        e.stopPropagation();
                    }
                } else if ( !_i.pushed && this.hitTestPoint( e.x, e.y ) ) {
                    _i.pushed = true;
                    if ( !options.disableBasicAnimation ) {
                        if ( _i.tween ) _i.tween.stop();
                        _i.tween = this.move(
                            _i.moveThisPosition.x,
                            _i.moveThisPosition.y + ( options.pressOffsetY != null ? options.pressOffsetY : defaultPressOffsetY ),
                            100,
                            _easing__WEBPACK_IMPORTED_MODULE_8__.easing.outCubic );
                        e.stopPropagation();
                    } else if ( options.pressAnimation ) {
                        if ( _i.tween ) _i.tween.stop();
                        _i.tween = options.pressAnimation.call( this, e, _i );
                        e.stopPropagation();
                    }
                }
            }
        };
        const pointerUp = ( e ) => {
            if ( _i.state == "down" || _i.state == "move" ) {
                _i.state = "up";
                _i.moveDeltaPosition = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point( e.x - _i.downPointerPosition.x , e.y - _i.downPointerPosition.y );
                _i.moveThisPosition = new _Types__WEBPACK_IMPORTED_MODULE_4__.Point(
                    options.dragX ? _i.downThisPosition.x + _i.moveDeltaPosition.x : _i.downThisPosition.x,
                    options.dragY ? _i.downThisPosition.y + _i.moveDeltaPosition.y : _i.downThisPosition.y,
                );
                if ( options.dragX ) this.x = _i.moveThisPosition.x;
                if ( options.dragY ) this.y = _i.moveThisPosition.y;
                if ( !options.allowDragOutside ) {
                    _i.moveThisPosition.x = _Utils__WEBPACK_IMPORTED_MODULE_5__.Utils.clamp( _i.moveThisPosition.x, _Application__WEBPACK_IMPORTED_MODULE_7__.application.logicalRenderBounds.left - _i.downOffset.x, _Application__WEBPACK_IMPORTED_MODULE_7__.application.logicalRenderBounds.right - _i.downOffset.x );
                    _i.moveThisPosition.y = _Utils__WEBPACK_IMPORTED_MODULE_5__.Utils.clamp( _i.moveThisPosition.y, _Application__WEBPACK_IMPORTED_MODULE_7__.application.logicalRenderBounds.top - _i.downOffset.y, _Application__WEBPACK_IMPORTED_MODULE_7__.application.logicalRenderBounds.bottom - _i.downOffset.y );
                }
                if ( _i.clickCanceled == false ) {
                    if ( Math.sqrt( _i.moveDeltaPosition.x ** 2 + _i.moveDeltaPosition.y ** 2 ) < clickCancelDistance ) {
                        if ( options.click != null ) options.click.call( this, e, _i );
                    }
                }
                if ( this.hitTestPoint( e.x, e.y ) ) {
                    _i.pushed = true;
                    if ( options.press != null ) options.press.call( this,e, _i );
                }
                if ( !options.preventRelease ) {
                    if ( !options.disableBasicAnimation ) {
                        if ( _i.tween ) _i.tween.stop();
                        _i.tween = this.move(
                            _i.moveThisPosition.x,
                            _i.moveThisPosition.y,
                            300,
                            _easing__WEBPACK_IMPORTED_MODULE_8__.easing.outBounce );
                        e.stopPropagation();
                    } else if ( options.releaseAnimation ) {
                        if ( _i.tween ) _i.tween.stop();
                        _i.tween = options.releaseAnimation.call( this, e, _i );
                        e.stopPropagation();
                    }
                }
                if ( options.up != null ) {
                    options.up.call( this, e, _i );
                }
            }
        };

        if ( options != null ) {
            this.on( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.POINTER_DOWN, pointerDown );
            this.on( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.POINTER_MOVE, pointerMove );
            this.on( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.POINTER_UP, pointerUp );
        } else {
            this.removeEventListener( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.POINTER_DOWN, pointerDown );
            this.removeEventListener( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.POINTER_MOVE, pointerMove );
            this.removeEventListener( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.POINTER_UP, pointerUp );
            delete this.__interactive;
        }
    }

    //#endregion    


    encodeRenderingInfo() {
        // id(1),type(1),updateCode(1),colorOverride(4),colorAdd(4),anchor(2),shaderId(1),matrix(16),clipRegion(4)
        const encodedBuffer = new Float32Array( 38 );

        // encodedBuffer[0] = this.id;
        // encodedBuffer[1] = this.spriteType;
        // encodedBuffer[2] = this.updateCode; 
        // // encodedBuffer.set( this.colorOverride,3 );
        // encodedBuffer[3] = this.colorOverride[0];
        // encodedBuffer[4] = this.colorOverride[1];
        // encodedBuffer[5] = this.colorOverride[2];
        // encodedBuffer[6] = this.colorOverride[3];
        // // encodedBuffer.set( this.colorAdd,7 );
        // encodedBuffer[7] = this.colorAdd[0];
        // encodedBuffer[8] = this.colorAdd[1];
        // encodedBuffer[9] = this.colorAdd[2];
        // encodedBuffer[10] = this.colorAdd[3];
        // encodedBuffer[11] = this.transform.anchorX;
        // encodedBuffer[12] = this.transform.anchorY;

        encodedBuffer.set( [this._$$id,
                            this._$$spriteType,
                            this._$$updateCode,
                            this.colorOverride[0],
                            this.colorOverride[1],
                            this.colorOverride[2],
                            this.colorOverride[3],
                            this.colorAdd[0],
                            this.colorAdd[1],
                            this.colorAdd[2],
                            this.colorAdd[3],
                            this.transform.anchorX,
                            this.transform.anchorY] );

        if ( this.shader != null ) {
            this.shader.forceUpdate();
            encodedBuffer[13] = this.shader.asset.id;
        } else {
            encodedBuffer[13] = 0;
        }
        // for ( let i = 0; i < 16; i++ ) {
        //     encodedBuffer[14 + i] = this.transform.matrix[i]; 
        // }
        // encodedBuffer.set( this.transform.matrix,14 );
        _Types__WEBPACK_IMPORTED_MODULE_4__.TypedArrayHelper.memcpy( encodedBuffer,14,this.transform.matrix,0,16 );

        encodedBuffer.set( ( this.clipRegion != null ) ? this.clipRegion.xywh : [NaN,NaN,NaN,NaN],30 );
        encodedBuffer[34] = this.cacheBitmapAsset != null ? this.cacheBitmapAsset.id : 0;
        encodedBuffer[35] = this.cacheBitmapDstId;
        encodedBuffer[36] = this.blendMode;
        encodedBuffer[37] = +this.motionBlur;

        return encodedBuffer;
    }

    encodeCustomPrev() {
        const encodedBuffer = new Float32Array( 22 );

        encodedBuffer.set( [
            this.customPrev.colorOverride[0],
            this.customPrev.colorOverride[1],
            this.customPrev.colorOverride[2],
            this.customPrev.colorOverride[3],
            this.customPrev.anchorPositionX,
            this.customPrev.anchorPositionY] );
        // encodedBuffer.set( this.customPrev.worldMatrix,6 );
        _Types__WEBPACK_IMPORTED_MODULE_4__.TypedArrayHelper.memcpy( encodedBuffer,6,this.customPrev.worldMatrix,0,16 );
        return encodedBuffer;
    }

    sortChildren( prop = "y" ) {
        this.children.sort( ( a, b ) => a[prop] - b[prop] );
    }


    setCustomPrev( worldMatrix,colorOverride,anchorPositionX,anchorPositionY ) {
        this.customPrev = {
            worldMatrix,
            colorOverride,
            anchorPositionX,
            anchorPositionY,
        };
        this._$$updateCode |= Sprite.UpdateCodes.UPDATE_CUSTOM_PREV;
    }

    setCacheMode( mode ) {
        if ( this.cacheBitmapMode == Sprite.CacheBitmapModes.SNAPSHOT ) {
            this._updateChildren( Sprite.UpdateCodes.UPDATE_CLEAR_PREV );   
        }
        if ( this.cacheBitmapAsset ) {            
            this.cacheBitmapAsset.release();

            /**
             *
             *
             * @param {Sprite} spr
             */
            const clearDstId = ( spr )=>{
                if ( spr.cacheBitmapMode == Sprite.CacheBitmapModes.NO_CACHE ) {
                    this.cacheBitmapAsset = null;
                    spr.cacheBitmapDstId = 0;
                    for ( let spr2 of spr.children ) {
                        clearDstId( spr2 );
                    }
                }   
            };

            this.cacheBitmapMode = Sprite.CacheBitmapModes.NO_CACHE;
            clearDstId( this );
        }
        this.cacheBitmapMode = mode;
    }


    encodeRenderingInfoWithChildren() {
        const encodedBuffers = [];
        const transferList = [];

        /**
         *
         *
         * @param {Sprite} spr
         * @param {m4.Mat4} worldMatrix
         * @param {[number,number,number,number]|Float32Array} colorOverride
         * @param {[number,number,number,number]|Float32Array|null} clipRect
         * @param {number} cacheBitmapDstId
         */
        function encodeChildren( spr,worldMatrix,colorOverride, clipRect, cacheBitmapDstId ) {
            const buf = spr.encodeRenderingInfo();
            const bufMatrix = buf.subarray( 14,14 + 16 );
            const curColorOverride = buf.subarray( 3,3 + 4 );
            const curClipRect = buf.subarray( 30,30 + 4 );
            let assetId = 0;
            let extra;
            let strs;
            let genericData;
            let customPrev;
            let needMakeRT = false;

            // clipRegion 트랜스폼
            if ( !Number.isNaN( curClipRect[0] ) ) {
                let clipPos = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.transformPoint( worldMatrix,[curClipRect[0],curClipRect[1],0] );

                curClipRect[0] = clipPos[0] + spr.x;
                curClipRect[1] = clipPos[1] + spr.y;
            }

            // 매트릭스는 트리 하단으로 갈 수록 곱한다.
            twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.multiply( worldMatrix,bufMatrix,bufMatrix );
            // 월드 매트릭스로 보관. 한 프레임 늦은 값이다.
            // copy하는 이유는 postMessage로 원본이 보내져서 사라지기 때문
            spr.worldMatrix = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.copy( bufMatrix );


            if ( spr.cacheBitmapMode != Sprite.CacheBitmapModes.NO_CACHE ) {
                if ( spr.cacheBitmapAsset == null ) {
                    needMakeRT = true;
                } else if ( spr.cacheBitmapMode == Sprite.CacheBitmapModes.FILTER ) {
                    // 필터링 모드
                    spr.cacheBitmapAsset.release();
                    needMakeRT = true;
                }
            } 
            
            if ( needMakeRT ) {
                const rect = spr.bounds;
                const asset = new _Asset__WEBPACK_IMPORTED_MODULE_6__.Asset( "<RT:*>",_Asset__WEBPACK_IMPORTED_MODULE_6__.Asset.AssetTypes.RenderTarget );

                asset.load( { 
                    x:           rect.x,
                    y:           rect.y,
                    width:       Math.min( 2048, rect.width ),
                    height:      Math.min( 2048,rect.height ), 
                    worldMatrix: spr.worldMatrix  } );
                spr.cacheBitmapAsset = asset;
                assetId = asset.id;
                spr.cacheBitmapDstId = assetId;
                cacheBitmapDstId = assetId;
                // console.log( `Cache ${assetId} src=${spr.cacheBitmapSrcId}` );
            } else {
                spr.cacheBitmapDstId = cacheBitmapDstId || spr.cacheBitmapDstId;
            }
            buf[35] = spr.cacheBitmapDstId;

            // 컬러는 RGBA각각을 곱해나간다. 0~1 값
            curColorOverride[0] = curColorOverride[0] * colorOverride[0];
            curColorOverride[1] = curColorOverride[1] * colorOverride[1];
            curColorOverride[2] = curColorOverride[2] * colorOverride[2];
            curColorOverride[3] = curColorOverride[3] * colorOverride[3];
            // clipRect는 NaN이면 부모 것을 가져온다
            if ( Number.isNaN( curClipRect[0] ) && !Number.isNaN( clipRect[0] ) ) {
                curClipRect.set( clipRect );
            }
            if ( spr._$$spriteType != 0 ) {
                //@ts-ignore
                if ( ( spr._$$updateCode & Sprite.UpdateCodes.UPDATE_EXTRA ) && spr.encodeExtraRenderingInfo != null ) {
                    let transfer;

                    //@ts-ignore
                    [extra,strs,genericData,transfer] = spr.encodeExtraRenderingInfo();
                    if ( transfer ) transferList.push( ...transfer );
                }
                if ( ( spr._$$updateCode & Sprite.UpdateCodes.UPDATE_CUSTOM_PREV ) ) {
                    customPrev = spr.encodeCustomPrev();
                }
                // RT에 그릴 것이라서 srcId=0
                buf[34] = 0;
                encodedBuffers.push( [buf,extra,strs,customPrev,genericData] );
            } 
            
            if ( spr.cacheBitmapMode == Sprite.CacheBitmapModes.SNAPSHOT && spr.cacheBitmapDstId == 0 ) {
                // 캐시된 경우
            } else {
                // 비트맵에 캐시한 경우가 아니면 차일드를 그린다.
                spr.children.forEach( child => {
                    if ( child.visible ) {
                        encodeChildren( child, bufMatrix,curColorOverride, curClipRect, cacheBitmapDstId );
                        if ( spr.cacheBitmapMode == Sprite.CacheBitmapModes.SNAPSHOT ) {
                            child.cacheBitmapDstId = 0;
                        }
                    }
                } );
                if ( spr.cacheBitmapMode == Sprite.CacheBitmapModes.SNAPSHOT ) {
                    spr.cacheBitmapDstId = 0;
                }
            }

            if ( spr.cacheBitmapAsset ) {
                // 텍스쳐를 그려야 함
                const buf2 = new Float32Array( buf );

                buf2[34] = assetId;
                buf2[35] = 0;
                encodedBuffers.push( [buf2,null,null,customPrev,null] );
            }
            spr._$$updateCode = Sprite.UpdateCodes.UPDATE_NOTHING;
        }

        if ( this.visible ) {
            encodeChildren( this,twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.identity(), [1,1,1,1], [NaN,NaN,NaN,NaN], 0 );

            for ( let i = 0; i < encodedBuffers.length; i++ ) {
                transferList.push( encodedBuffers[i][0].buffer );
                if ( encodedBuffers[i][1] ) {
                    transferList.push( encodedBuffers[i][1].buffer );
                }
                if ( encodedBuffers[i][3] ) {
                    transferList.push( encodedBuffers[i][3].buffer );
                }
            }
            return [encodedBuffers,transferList];
        } else {
            return [null,null];
        }
    }
}

Sprite.lastId = 1;
Sprite.finalizationRegistry = new FinalizationRegistry( Sprite.finalizeHandler );
Sprite.loadedEventDispatcher = new _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher();


Sprite.SpriteTypes = {
    SPRITE:    0,
    BITMAP:    1,
    MESH:      2,
    TEXTFIELD: 3,
    PIXEL:     4,
    SHAPE:     5,
};
Sprite.UpdateCodes = {
    UPDATE_NOTHING:     0,
    UPDATE_EXTRA:       1,
    UPDATE_CLEAR_PREV:  2,
    UPDATE_CUSTOM_PREV: 4,
};
Sprite.CacheBitmapModes = {
    NO_CACHE: 0,
    SNAPSHOT: 1,
    FILTER:   2,
};


/** 
 * @enum {number}
*/
Sprite.BlendModes = {
    NORMAL:     0, //[gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    MULTIPLY:   1, //[gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
    ADD:        2, //[gl.ONE, gl.DST_ALPHA];
    SCREEN:     3, //[gl.ONE, gl.ONE_MINUS_SRC_COLOR];
    NORMAL_NPM: 4, //[gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    ADD_NPM:    5, //[gl.SRC_ALPHA, gl.DST_ALPHA, gl.ONE, gl.DST_ALPHA];
    SCREEN_NPM: 6, //[gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_COLOR];
};


/***/ }),

/***/ "./engine/src/Stage.js":
/*!*****************************!*\
  !*** ./engine/src/Stage.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stage": () => (/* binding */ Stage)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var twgl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");






class Stage extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor() {
        super();
        this.isStage = true;
    }
}

/***/ }),

/***/ "./engine/src/Storage.js":
/*!*******************************!*\
  !*** ./engine/src/Storage.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Storage": () => (/* binding */ Storage)
/* harmony export */ });
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Timer */ "./engine/src/Timer.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");






// 각 스토리지 설명
//https://blog.sessionstack.com/how-javascript-works-storage-engines-how-to-choose-the-proper-storage-api-da50879ef576
// 캐시 데이터는 Cache API
// 유저 데이터는 IndexedDB 쓰라고 권고 하고 있다

class Storage extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {
    constructor( dbName ) {
        super();
        console.assert( self.indexedDB, "indexedDB가 지원되지 않는 브라우저" );

        const version = 1;
        const request = self.indexedDB.open( dbName,version );

        request.onerror = ( event ) => {
            throw new Error( "indexedDB 열기 실패" );
        };
        request.onupgradeneeded = ( event ) => {
            const thisDb = event.target.result;

            // console.log( "upgrade" );
            thisDb.createObjectStore( "files", { keyPath: "path" } );
        };
        request.onsuccess = ( event ) => {
            const db = request.result;

            this.db = db;

            // console.log( event );
            this.dispatchEvent( "ready" );
        };
    }

    read( key ) {
        return new Promise( ( resolve, reject ) => {
            const func = () => {
                const request = this.db.transaction( "files", "readonly" ).objectStore( "files" ).get( key );

                request.onsuccess = ( event ) => {
                    this.dispatchEvent( new _Event__WEBPACK_IMPORTED_MODULE_2__.Event( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.COMPLETE, { content: event.target.result.content } ) );
                    resolve( event.target.result.content );
                };
            };

            if ( this.db ) {
                func();
            } else {
                this.once( "ready", func );
            }
        } );
    }

    write( key, value ) {
        return new Promise( ( resolve, reject ) => {
            const func = () => {
                const request = this.db.transaction( "files", "readwrite" ).objectStore( "files" ).put( { path: key, content: value } );

                request.onsuccess = ( event ) => {
                    this.dispatchEvent( new _Event__WEBPACK_IMPORTED_MODULE_2__.Event( _Event__WEBPACK_IMPORTED_MODULE_2__.Event.COMPLETE ) );
                    resolve();
                };
            };

            if ( this.db ) {
                func();
            } else {
                this.once( "ready", func );
            }
        } );
    }


    static loadFile( filename ) {
        // /** @type {PIXI.Loader} */
        // //@ts-ignore
        // const loader = PIXI.Loader.shared;
        // const r = new EventDispatcher();

        // if ( loader.resources[filename] ) {
        //     if ( loader.resources[filename].isComplete ) {
        //         Timer.delayedCall( 0, ()=> r.dispatchEvent( Event.COMPLETE,{ data: loader.resources[filename].data } ) );
        //     } else {
        //         loader.load( ( loader,resources )=> r.dispatchEvent( Event.COMPLETE,{ data: resources[filename].data } ) );
        //     }
        // } else {
        //     loader.add( filename,filename );
        //     loader.load( ( loader,resources )=> {
        //         if ( resources[filename].error ) throw new Error( resources[filename].error );
        //         r.dispatchEvent( Event.COMPLETE,{ data: resources[filename].data } );
        //     }
        //     );
        // }

        // return r;
    }
}



/***/ }),

/***/ "./engine/src/TextField.js":
/*!*********************************!*\
  !*** ./engine/src/TextField.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextField": () => (/* binding */ TextField)
/* harmony export */ });
/* harmony import */ var _FontBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FontBase */ "./engine/src/FontBase.js");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _TrueTypeFont__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TrueTypeFont */ "./engine/src/TrueTypeFont.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");







class TextField extends _Sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite {
    /**
     * Creates an instance of TextField.
     * @param {Font} font
     * @param {string} text
     * @param {*} styles
     * @memberof TextField
     */
    constructor( font, text, styles ) {
        super();
        this.font = font;
        this.styles = styles;
        this.useBaseline = false;
        this._$$spriteType = _Sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite.SpriteTypes.TEXTFIELD;
        this._$$updateCode = _Sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite.UpdateCodes.UPDATE_EXTRA;
        // 트루타입폰트를 캔버스에 그렸다가 텍스쳐로 바꾸는데 이 때 알파에 검정이 섞이는 것을 빼려면 다음과 같이 해야한다.
        this.colorAdd = ( font instanceof _TrueTypeFont__WEBPACK_IMPORTED_MODULE_2__.TrueTypeFont ) ? [1,1,1,0] : [0,0,0,0];
        this.customBounds = new _Types__WEBPACK_IMPORTED_MODULE_3__.Rect();
        this.text = text;
    }

    get text() {
        return this._text;
    }

    set text( text ) {
        if ( text != this._text ) {
            this.customBounds.width = this.font.measureTextWidth( text,this.fontSize );
            this.customBounds.height = this.fontSize;
        }
        this._text = text;
    }

    get fontSize() {
        return this.font.referenceSize;
    }

    getTextWidth() {
        return this.width;
    }

    setTextColor( c,a ) {
        // this.colorAdd = Utils.hex2rgba( c,a );
        this.setOverrideColor( c,a );
    }

    static fromTextWrap( text, areaWidth, areaHeight, lineSpacing, font, align, ignoreWordWrap ) {
        const wordWrapStyle = {
            align:         align != null ? align : "left",
            lineHeight:    lineSpacing,
            wordWrap:      areaWidth != null && !ignoreWordWrap,
            whiteSpate:    "normal",
            trim:          true,
            breakWord:     areaWidth != null && !ignoreWordWrap,
            wordWrapWidth: areaWidth
        };

        const tf = new TextField( font, text, wordWrapStyle );

        //spr.addChild( tf );
        //TODO: 틀렸음
        tf.anchorX = ( align == "center" ) ? 0.5 : ( align == "right" ? 1.0 : 0.0 );

        //tf.__pixi.x = (align == "center") ? areaWidth * 0.5 : (align == "right" ? areaWidth : 0.0);
        if ( areaWidth != null ) {
            tf.x += areaWidth * tf.anchorPosition.x;
        }

        return tf;
    }



    encodeExtraRenderingInfo() {
        let encodedBuffer = new Float32Array( 2 );

        encodedBuffer[0] = this.font.asset.id;
        encodedBuffer[1] = +this.useBaseline;

        return [encodedBuffer,[this.text]];
    }
}


/***/ }),

/***/ "./engine/src/Texture.js":
/*!*******************************!*\
  !*** ./engine/src/Texture.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Texture": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _TextureBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextureBase */ "./engine/src/TextureBase.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");





class Texture extends _TextureBase__WEBPACK_IMPORTED_MODULE_1__.TextureBase {
    /**
     * Creates an instance of Texture.
     * @param {string} filename
     * @param {boolean} filter
     * @param {*} option
     * @memberof Texture
     */
    constructor( filename, filter = false, option = {} ) {
        super();
        this.asset = new _Asset__WEBPACK_IMPORTED_MODULE_0__.Asset( filename,_Asset__WEBPACK_IMPORTED_MODULE_0__.Asset.AssetTypes.Texture );
        const size = _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.getImageSize( filename );

        this.uvRect = option.rect || new _Types__WEBPACK_IMPORTED_MODULE_2__.Rect( 0,0,size.width,size.height );
        this.width = this.uvRect.width;
        this.height = this.uvRect.height;
        this.asset.load( { width: size.width,height: size.height,uvRect: this.uvRect, filter: filter } );
    }

    /**
     *
     *
     * @param {string} eventName
     * @param {function} func
     * @param {any=} context
     * @param {boolean} [isOnce=false]
     * @returns {Texture}
     * @memberof Texture
     */
    addEventListener( eventName, func, context = null, isOnce = false ) {
        if ( eventName == _Event__WEBPACK_IMPORTED_MODULE_4__.Event.LOADED ) {
            this.asset.addEventListener( eventName, this.dispatchEvent.bind( this,_Event__WEBPACK_IMPORTED_MODULE_4__.Event.LOADED ), null, isOnce );
        } 
        //@ts-ignore
        return super.addEventListener( eventName, func, context, isOnce );
    }
}



/***/ }),

/***/ "./engine/src/TextureBase.js":
/*!***********************************!*\
  !*** ./engine/src/TextureBase.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureBase": () => (/* binding */ TextureBase)
/* harmony export */ });
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");




class TextureBase extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {
    constructor() {
        super();
        this.width = 0;
        this.height = 0;
        /** @type {Asset} */
        this.asset = undefined;
        /** @type {Rect} */
        this.uvRect = undefined;
    }

    get size() {
        return [this.width,this.height];
    }
}



/***/ }),

/***/ "./engine/src/TexturePack.js":
/*!***********************************!*\
  !*** ./engine/src/TexturePack.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TexturePack": () => (/* binding */ TexturePack)
/* harmony export */ });
/* harmony import */ var _TextureBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureBase */ "./engine/src/TextureBase.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Types */ "./engine/src/Types.js");
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Texture */ "./engine/src/Texture.js");







class TexturePack extends _TextureBase__WEBPACK_IMPORTED_MODULE_0__.TextureBase {
    /**
     *Creates an instance of TexturePack.
     * @param {string|object} txtfile
     * @param {string} imagefile
     * @param {TextureBase.Filters} filter
     * @param {object=} options
     * @memberof TexturePack
     */
    constructor( txtfile,imagefile,filter,options ) {
        super();
        this.filename =  imagefile;
        this.regions = {};

        if ( typeof( txtfile ) == "string" ) {
            const s = _Utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getEmbeddedFile( txtfile );


            if ( s != null ) {
                const lines = s.split( "\n" );

                for ( const line of lines ) {
                //console.log(line);
                    const result = /([^,]+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)/.exec( line );

                    if ( result != null ) {
                        const [, name, x, y, width, height] = result;
                        //console.log(`${name} ${x} ${y} ${width} ${height}`);
                        const rect = new _Types__WEBPACK_IMPORTED_MODULE_3__.Rect( parseFloat( x ), parseFloat( y ), parseFloat( width ), parseFloat( height ) );

                        this.regions[name] = new _Texture__WEBPACK_IMPORTED_MODULE_4__.Texture( this.filename,false,{ rect } );
                    }
                }
            }
        } else {
            // txtfile 부분에 개체를 넣은 경우
            for ( let name in txtfile ) {
                let rectArr = txtfile[name];
                let rect = new _Types__WEBPACK_IMPORTED_MODULE_3__.Rect( ...rectArr );

                this.regions[name] = new _Texture__WEBPACK_IMPORTED_MODULE_4__.Texture( this.filename,filter,{ rect } );
            }
        }
    }

    getTextureRegion( name ) {
        return this.regions[name];
    }
}



/***/ }),

/***/ "./engine/src/TileMap.js":
/*!*******************************!*\
  !*** ./engine/src/TileMap.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TileMap": () => (/* binding */ TileMap)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Mesh */ "./engine/src/Mesh.js");
/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Shader */ "./engine/src/Shader.js");
/* harmony import */ var _TextureBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextureBase */ "./engine/src/TextureBase.js");





/*

2019-10-05
resize가 너무 느려서 처음에 메시를 만들어 두는 쪽으로 했다

2021-11-21

mesh를 child로 가지고 있는 것을 그냥 mesh를 extend하게 수정하거나
숨겨줘야함

*/



/**
 * @this {TileMap}
 *
 * @param {number} tx
 * @param {number} ty
 * @returns {number[]}
 */
function tileToRect( tx, ty ) {
    const x1 = tx * ( this.__tileWidth + this.__spacingX ) + this.__marginX;
    const y1 = ty * ( this.__tileHeight + this.__spacingY ) + this.__marginY;

    // 기데로스의 uv좌표 변환시 생기는 문제 때문에 0.99999를 곱함
    //return [x1,y1,x1 + this.__tileWidth * 0.99999,y1 + this.__tileHeight * 0.99999];
    //return [x1, y1, x1 + this.__tileWidth ,y1 + this.__tileHeight];
    // return [x1 >>> 0, y1 >>> 0, x1 + this.__tileWidth >>> 0, y1 + this.__tileHeight >>> 0];
    return [x1, y1, x1 + this.__tileWidth, y1 + this.__tileHeight];
    // let [a, b, c, d] = [0.03,0.125,-0.03,-0.125];
    // return [x1 + a, y1 + b, x1 + this.__tileWidth + c, y1 + this.__tileHeight + d];
}

function replaceMeshData( m, i, x1, y1, x2, y2, tx1, ty1, tx2, ty2, c1, a1, c2, a2, c3, a3, c4, a4 ) {
    const [nVtx, nUv, nVc, nIdx] = [i * 4,i * 4, i * 4, i * 6];

    m.setVertices(
        nVtx + 0, x1, y1,
        nVtx + 1, x2, y1,
        nVtx + 2, x1, y2,
        nVtx + 3, x2, y2
    );
    m.setTextureCoordinates(
        nUv + 0, tx1, ty1,
        nUv + 1, tx2, ty1,
        nUv + 2, tx1, ty2,
        nUv + 3, tx2, ty2
    );
    m.setColors(
        nVc + 0, c1, a1,
        nVc + 1, c2, a2,
        nVc + 2, c3, a3,
        nVc + 3, c4, a4
    );
    m.setIndices(
        nIdx + 0, nVtx + 0,
        nIdx + 1, nVtx + 1,
        nIdx + 2, nVtx + 2,
        nIdx + 3, nVtx + 1,
        nIdx + 4, nVtx + 3,
        nIdx + 5, nVtx + 2
    );
}



class TileMap extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    /**
     *Creates an instance of TileMap.
     * @param {number} width
     * @param {number} height
     * @param {TextureBase} texture
     * @param {number} tileWidth
     * @param {number} tileHeight
     * @param {number} [spacingX=0]
     * @param {number} [spacingY=0]
     * @param {number} [marginX=0]
     * @param {number} [marginY=0]
     * @param {number} [displayWidth=tileWidth]
     * @param {number} [displayHeight=tileHeight]
     * @memberof TileMap
     */
    constructor( width, height, texture, tileWidth, tileHeight, spacingX = 0, spacingY = 0, marginX = 0, marginY = 0, displayWidth = tileWidth, displayHeight = tileHeight ) {
        super();
        this.__mapWidth = width;
        this.__mapHeight = height;
        this.__texture = texture;
        this.__tileWidth = tileWidth;
        this.__tileHeight = tileHeight;
        this.__spacingX = spacingX;
        this.__spacingY = spacingY;
        this.__marginX = marginX;
        this.__marginY = marginY;
        this.__displayWidth = displayWidth || tileWidth;
        this.__displayHeight = displayHeight || tileHeight;
        const m = new _Mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh();

        m.setTexture( texture );
        this.__mesh = m;
        this.useCustomLocalBounds = true;
        this._$$localBounds.width = width * tileWidth;
        this._$$localBounds.height = height * tileHeight;
        this.clearAllTiles();
        this.addChild( m );
    }

    clearAllTiles() {
        const [vtx, idx, uv, vc] = [[], [], [], []];

        for ( let y = 0; y < this.__mapHeight; y++ ) {
            for ( let x = 0; x < this.__mapWidth; x++ ) {
                const [x1,y1,x2,y2] = [x * this.__displayWidth,y * this.__displayHeight,( x + 1 ) * this.__displayWidth,( y + 1 ) * this.__displayHeight];

                vtx.push( x1,y1,x2,y1,x1,y2,x2,y2 );
                uv.push( 0,0,0,0,0,0,0,0 );
                vc.push( 0,0,0,0,0,0,0,0 );
                idx.push( 0,0,0, 0,0,0 );
            }
        }
        let m = this.__mesh;

        m.setVertexArray( vtx );
        m.setIndexArray( idx );
        m.setTextureCoordinateArray( uv );
        m.setColorArray( vc );
        this.__map = [];
    }
	
    /**
     *
     *
     * @param {number} x
     * @param {number} y
     * @param {number} tx
     * @param {number} ty
     * @param {boolean} [flip=false]
     * @param {number} [c1=0xffffff]
     * @param {number} [a1=1.0]
     * @param {number} [c2=c1]
     * @param {number} [a2=a1]
     * @param {number} [c3=c1]
     * @param {number} [a3=a1]
     * @param {number} [c4=c1]
     * @param {number} [a4=a1]
     * @memberof TileMap
     */
    setTile( x,y,tx,ty,flip = false,c1 = 0xffffff,a1 = 1.0,c2 = c1,a2 = a1,c3 = c1,a3 = a1,c4 = c1,a4 = a1 ) {
        if ( tx == null || ty == null ) {
            this.clearTile( x,y );
        }

        const w = this.__mapWidth;
        const [x1,y1,x2,y2] = [x * this.__displayWidth,y * this.__displayHeight,( x + 1 ) * this.__displayWidth,( y + 1 ) * this.__displayHeight];
        const m = this.__mesh;
        const [tx1,ty1,tx2,ty2] = tileToRect.call( this,tx,ty );
        let t = this.__map[y * this.__mapWidth + x];

        // if ( t == null ) {

        //     const nVtx = m.getVertexArraySize();

        //     m.resizeVertexArray( nVtx + 4 );
        //     m.resizeTextureCoordinateArray( nVtx + 4 );
        //     m.resizeColorArray( nVtx + 4 );
        //     m.resizeIndexArray( nVtx / 4 * 6 + 6 );
        //     replaceMeshData( m, nVtx / 4 ,
        //                      x1, y1, x2, y2,
        //                      tx1, ty1, tx2, ty2,
        //                      c1, a1, c2, a2, c3, a3, c4, a4 );
        //     t = [tx, ty, flip, c1, a1, c2, a2, c3, a3, c4, a4, nVtx / 4 ];
        
        // } else {

        replaceMeshData( m, x + y * this.__mapWidth,// t[11],
                         x1,y1,x2,y2,
                         tx1,ty1,tx2,ty2,
                         c1,a2,c2,a2,c3,a3,c4,a4 );
        t = [tx, ty, flip, c1, a1, c2, a2, c3, a3, c4, a4, x + y * this.__mapWidth];//t[11]];
        
        // }

        this.__map[y * this.__mapWidth + x] = t;
    }
	
    getTile( x,y ) {
        const t = this.__map[y * this.__mapWidth + x];

        if ( t != null ) {
            return t;
        }
    }
	
    getArray( x,y ) {
        const t = this.__map[y * this.__mapWidth + x];

        if ( t == null ) {
            return;
        }

        const pos = t[11];
        const [nVtx,nIdx] = [pos * 4,pos * 6];
        const m = this.__mesh;
        const vtx = [];
        const uv = [];
        const vc = [];
        const idx = [];

        for ( let i = 0; i < 4; i++ ) {
            const { x, y } = m.getVertex( nVtx + i );

            vtx.push( x,y );
            const { x: u, y: v } = m.getTextureCoordinate( nVtx + i );

            uv.push( u,v );
            const { color, alpha } = m.getColor( nVtx + i );

            vc.push( color,alpha );
        }

        for ( let i = 0; i < 6; i++ ) {
            const v = m.getIndex( nIdx + i );

            idx.push( v );
        }

        return [vtx,uv,vc,idx];
    }
	
    clearTile( x,y ) {
        const t = this.__map[y * this.__mapWidth + x];

        if ( t != null ) {
            const nIdx = t[11] * 6;

            this.__mesh.setIndices(
                nIdx + 0, 0,
                nIdx + 1, 0,
                nIdx + 2, 0,
                nIdx + 3, 0,
                nIdx + 4, 0,
                nIdx + 5, 0
            );
        }

        this.__map[y * this.__mapWidth + x] = null;
    }
    /*
	shift(offsetX,offsetY) {
	
	}
	*/


    setTexture( texture ) {
        this.__mesh.setTexture( texture );//, matrix);
    }


    /**
     *
     *
     * @param {Shader} shader
     * @memberof TileMap
     */
    setShader( shader ) {
        this.__mesh.setShader( shader );
    }

    setTileColor( x, y, color, alpha, isCorner ) {
        const w = this.__mapWidth;

        if ( !isCorner ) {
            const t = this.__map[y * this.__mapWidth + x];

            if ( t ) {
                const nVc = t[11] * 4;

                this.__mesh.setColors(
                    nVc + 0, color, alpha,
                    nVc + 1, color, alpha,
                    nVc + 2, color, alpha,
                    nVc + 3, color, alpha
                );
            }
        } else {
            // 코너의 컬러
            // 12
            // 30
            const t0 = this.__map[y * this.__mapWidth + x];
            const t1 = ( y > 0 && x > 0 ) ? this.__map[( y - 1 ) * this.__mapWidth + x - 1] : null;
            const t2 = ( y > 0 ) ? this.__map[( y - 1 ) * this.__mapWidth + x] : null;
            const t3 = ( x > 0 ) ? this.__map[y * this.__mapWidth + x - 1] : null;

            if ( t0 ) {
                this.__mesh.setColor( t0[11] * 4 + 0, color, alpha );
            }

            if ( t1 ) {
                this.__mesh.setColor( t1[11] * 4 + 3, color, alpha );
            }

            if ( t2 ) {
                this.__mesh.setColor( t2[11] * 4 + 2, color, alpha );
            }

            if ( t3 ) {
                this.__mesh.setColor( t3[11] * 4 + 1, color, alpha );
            }
        }
    }
}
TileMap.FLIP_DIAGONAL = "flipDiagonal";
TileMap.FLIP_HORIZONTAL = "flipHorizontal";
TileMap.FLIP_VERTICAL = "flipVertical";




/***/ }),

/***/ "./engine/src/Timer.js":
/*!*****************************!*\
  !*** ./engine/src/Timer.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Timer": () => (/* binding */ Timer)
/* harmony export */ });
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");





class Timer extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {
    /**
     * 타이머 개체를 만든다.
     * 타이머는 바로 시작하지 않으며 start를 불러야 시작한다.
     * 
     * @param {number} delay - ms 단위
     * @param {number} [repeatCount=0] - 몇 번을 반복하는 타이머인가? 0이면 무한 반복
     * @memberof Timer
     */
    constructor( delay, repeatCount = 0 ) {
        super();
        this.delay = delay;
        this.repeatCount = repeatCount;
        this.count = 0;
    }

    start() {
        this.stop();
        this.__timer = setInterval( () => {
            this.count++;
            const e = new _Event__WEBPACK_IMPORTED_MODULE_1__.Event( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.TIMER );

            // @ts-ignore
            e.timer = this;
            this.dispatchEvent( e );

            if ( this.repeatCount != 0 && this.count >= this.repeatCount ) {
                this.stop();
            }
        }, this.delay );
    }

    stop() {
        if ( this.__timer ) {
            clearInterval( this.__timer );
            this.__timer = null;
        }
    }

    getCurrentCount() {
        return this.count;
    }

    getDelay() {
        return this.delay;
    }

    /**
     * delay 만큼의 지연시간 후에 함수를 실행한다
     *
     * @static
     * @param {number} delay - ms 단위. 0을 줘도 동기적으로 실행되지 않는다.
     * @param {function} func
     * @param {object=} context
     * @returns {Timer}
     * @memberof Timer
     */
    static delayedCall( delay, func, context ) {
        console.assert( func != null );
        const t = new Timer( delay, 1 );

        t.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_1__.Event.TIMER, func, context );
        t.start();

        return t;
    }

    /**
     * 현재 시간을 밀리세컨드 단위로 돌려준다
     *
     * @static
     * @returns {number}
     * @memberof Timer
     */
    static now() {
        return ( +new Date );
    }

    /**
     * 퍼포먼스 타이머는 Timer.now()보다 더 정확한 시간 간격을 측정할 수 있지만
     * 이것이 현재 시간을 표시하고 있는 것은 아님에 주의. Timer.now()와 다른 값이다.
     * 간격은 매우 정확하며 1ms 이상의 해상도를 돌려준다. 그러나 이 호출 자체가 비싸다.
     *
     * @static
     * @returns {number}
     * @memberof Timer
     */
    static getPerformaceTimer() {
        return performance.now();
    }

    /**
     * 파일이름이나 로그에 출력할 때 사용하기 편한 ISO포멧의 시간 표시를 돌려준다
     *
     * @static
     * @param {Date} [date=new Date()]
     * @returns {string}
     * @memberof Timer
     */
    static getShortDate( date = new Date() ) {
        return date.toISOString();
    }

    static wait( ms ) {
        return new Promise( ( resolve,reject )=>{
            this.delayedCall( ms,resolve );
        } );
    }

    static waitFrame( frame ) {
        return new Promise( ( resolve,reject )=>{
            this.delayedCall( 1000 / 60 * frame,resolve );
        } );
    }
}



/***/ }),

/***/ "./engine/src/Transform.js":
/*!*********************************!*\
  !*** ./engine/src/Transform.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Transform": () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var twgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");



class Transform {
    constructor() {
        this._x = 0;
        this._y = 0;
        this._anchorX = 0;
        this._anchorY = 0;
        this._scaleX = 1;
        this._scaleY = 1;
        this._rotation = 0;
        this._matrixDirty = false;
        this._matrix = twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.identity();
        this.invalidateCallback = null;
    }

    get x() {
        return this._x;
    }

    get y() {
        return this._y;
    }

    get anchorX() {
        return this._anchorX;
    }

    get anchorY() {
        return this._anchorY;
    }


    get scaleX() {
        return this._scaleX;
    }

    get scaleY() {
        return this._scaleY;
    }

    get rotation() {
        return this._rotation;       
    }

    set x( v ) {
        this.setDirty( this._x != v );
        this._x = v;
    }

    set y( v ) {
        this.setDirty( this._y != v );
        this._y = v;
    }

    set anchorX( v ) {
        this.setDirty( this._anchorX != v );
        this._anchorX = v;
    }

    set anchorY( v ) {
        this.setDirty( this._anchorY != v );
        this._anchorY = v;
    }

    set scaleX( v ) {
        this.setDirty( this._scaleX != v );
        this._scaleX = v;
    }

    set scaleY( v ) {
        this.setDirty( this._scaleY != v );
        this._scaleY = v;
    }

    set rotation( v ) {
        this.setDirty( this._rotation != v );
        this._rotation = v;
    }

    get matrix() {
        if ( this._matrixDirty ) {
            const mat =  twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.translation( [this._x,this._y,0] );

            // 앵커만큼 역으로 이동한 다음
            // 여기가 구버전과 다른 점
            // m4.translate( mat, [this.anchorPosition.x,this.anchorPosition.y,0],mat );
            twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.scale( mat, [this._scaleX,this._scaleY,1] ,mat );
            twgl_js__WEBPACK_IMPORTED_MODULE_0__.m4.rotateZ( mat,this._rotation * Math.PI / 180 ,mat );        
            // 여기서 다시 앵커만큼 이동해야 하는데
            // 이 처리는 vs에서 한다
            this._matrix = mat;
            this._matrixDirty = false;
        } 
        return this._matrix;
    }

    setDirty( v ) {
        if ( this.invalidateCallback && v ) {
            // _matrixDirty가 이번에 false에서 true가 될 때만 호출하는게 아니고
            // true에서 true가 될 때도 호출 한다.
            // 그래야 _boundsDirty가 제대로 처리 되기 때문
            this.invalidateCallback();
        }
        this._matrixDirty = this._matrixDirty || v;
    }

    /**
     *
     *
     * @returns {Transform} 
     * @memberof Transform
     */
    clone() {
        const newTransform = {};

        Object.assign( newTransform,this );
        Object.setPrototypeOf( newTransform,this.constructor.prototype );
        //@ts-ignore
        return newTransform;
    }
}




/***/ }),

/***/ "./engine/src/TrueTypeFont.js":
/*!************************************!*\
  !*** ./engine/src/TrueTypeFont.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrueTypeFont": () => (/* binding */ TrueTypeFont)
/* harmony export */ });
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset */ "./engine/src/Asset.js");
/* harmony import */ var _FontBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FontBase */ "./engine/src/FontBase.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./engine/src/Utils.js");





class TrueTypeFont extends _FontBase__WEBPACK_IMPORTED_MODULE_1__.FontBase {
    constructor( trueTypeFontName,referenceSize, styles ) {
        super( trueTypeFontName, referenceSize, styles );
        // TTF
        this.asset = new _Asset__WEBPACK_IMPORTED_MODULE_0__.Asset( trueTypeFontName,_Asset__WEBPACK_IMPORTED_MODULE_0__.Asset.AssetTypes.TrueTypeFont );
        this.asset.load( { 
            referenceSize: this.referenceSize, 
            styles:        this.styles 
        } );
        this.fontLoaded = false;
    }    

    measureTextWidth( str,size ) {
        super.measureTextWidth( str,size );

        const fontInfo = this.asset.fontInfo;

        let width = 0;

        for ( let i = 0; i < str.length; i++ ) {
            const char = str.charCodeAt( i );
            const charInfo = fontInfo.chars[char];

            if ( Array.isArray( charInfo ) ) {
                width += charInfo[0];
                if ( false ) {}   
            } else if ( charInfo != null ) {
                width += charInfo;
            }
            if ( i < str.length - 1 && fontInfo.kerningPairs ) {
            //마지막 글자가 아닌경우 kerning
                const charNext = str.charCodeAt( i + 1 );

                const kerning = fontInfo.kerningPairs[char + "," + charNext];

                if ( kerning ) {
                    width += kerning;
                }
            }
        }
        return width / fontInfo.unitsPerEm * ( size || this.referenceSize );
    }
}




/***/ }),

/***/ "./engine/src/Tween.js":
/*!*****************************!*\
  !*** ./engine/src/Tween.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tween": () => (/* binding */ Tween)
/* harmony export */ });
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Event */ "./engine/src/Event.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sprite */ "./engine/src/Sprite.js");
/* harmony import */ var _easing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./easing */ "./engine/src/easing.js");
/* harmony import */ var _Stage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Stage */ "./engine/src/Stage.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Application */ "./engine/src/Application.js");







/**
 * @typedef Prop
 * @property {function|string=} ease
 * @property {boolean=} autoPlay
 * @property {boolean=} swapValues
 * @property {boolean=} reflect
 * @property {number=} delay
 * @property {number=} repeatCount
 * @property {boolean=} dispatchEvents
 * @property {number=} timeScale
 * @property {Tween=} nextTween
 */



/*
base on GTween for Gideros;
This code is MIT licensed, see http://www.opensource.org/licenses/mit-license.php;
Copyright (c) 2010 - 2011 Gideros Mobile;
Based on Tween 2.01 for ActionScript 3;
http://gskinner.com/libraries/GTween/
GTween 2.01 for ActionScript 3 is MIT licensed, see http://www.opensource.org/licenses/mit-license.php;
Copyright (c) 2009 Grant Skinner;
Notes:
* Documentation is derived from GTween 2.01's original documentation.
*/

/*
	* Tween is a light-weight instance oriented tween engine. This means that you instantiate tweens for specific purposes, && then reuse, update || discard them.
	* This is different than centralized tween engines where you "register" tweens with a global object. This provides a more familiar && useful interface;
	* for object oriented programmers.

	* Tween boasts a number of advanced features:
	* - frame && time based durations/positions which can be set per tween;
	* - simple sequenced tweens using .nextTween;
	* - pause && resume individual tweens || all tweens;
	* - jump directly to the } || beginning of a tween with :toEnd() || :toBeginning();
	* - jump to any arbitrary point in the tween with :setPosition();
	* - complete, init, && change callbacks;
	* - smart garbage collector interactions (prevents collection while active, allows collection if target is collected);
	* - easy to set up in a single line of code;
	* - can repeat || reflect a tween a specified number of times;
	* - deterministic, so setting a position on a tween will (almost) always result in predictable results;
*/

function hexToRgb( c ) {
    return [( c >> 16 ) / 255, ( ( c >> 8 ) & 0xff ) / 255, ( c & 0xff ) / 255];
}


const copyTickList = [];

class Tween extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {
    /**
     *Creates an instance of Tween.
     * @param {object} target
     * @param {number} duration
     * @param {object=} values
     * @param {string|function|Prop=} props
     * @memberof Tween
     */
    constructor( target, duration, values, props ) {
        super();
        this._delay = 0;
        this._paused = true;
        this._position = Number.NaN;
        this._isEnd = false;
        this.autoPlay = true;
        this.repeatCount = 1;
        this.timeScale = 1;
        this.ease = Tween.defaultEase;
        this.dispatchEvents = Tween.defaultDispatchEvents;
        this.target = target;
        this.duration = duration;
        this.reflect = undefined;
        this.nextTween = undefined;
        let swap = null;

        if ( typeof props == "function" || typeof props == "string" ) {
            //@ts-ignore
            props = { ease: props };
        }

        if ( props != null ) {
            //@ts-ignore
            swap = props.swapValues;
            //@ts-ignore
            props.swapValues = null;
            Object.assign( this, props );
        }

        if ( typeof this.ease == "string" ) {
            this.ease = _easing__WEBPACK_IMPORTED_MODULE_3__.easing[this.ease];
        }

        console.assert( this.ease != null );
        this.resetValues( values );

        if ( swap ) {
            this.swapValues();
        }

        if ( this.duration == 0 && this.getDelay() == 0 && this.autoPlay ) {
            this.calculatedPosition = null;
            this.setPosition( 0 );
        }

        if ( !Tween.active ) {
            _Application__WEBPACK_IMPORTED_MODULE_5__.application.stage.addEventListener( _Event__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME, Tween.onTick );
            Tween.active = true;
        }
    }

    /*
		* Plays or pauses a tween. You can still change the position value externally on a paused;
		* tween, but it will !be updated automatically. While paused is false, the tween is also prevented;
		* from being garbage collected while it is active.
		* This is achieved in one of two ways:
		* 1. If the target object derives from EventDispatcher, then the tween will subscribe to a dummy event using a hard reference. This allows;
		* the tween to be garbage collected if its target is also collected, && there are no other external references to it.
		* 2. If the target object is !an EventDispatcher, then the tween is placed in a global list, to prevent collection until it is paused || completes.
		* Note that pausing all tweens via the Tween.pauseAll static property will !free the tweens for collection.
	*/
    /**
     *
     *
     * @returns {boolean}
     * @memberof Tween
     */
    isPaused() {
        return this._paused;
    }


    isEnd() {
        return this._isEnd;
    }

    stop() {
        this.setPaused( true );
    }

    /**
     *
     *
     * @param {boolean} value
     * @memberof Tween
     */
    setPaused( value ) {
        if ( value == this._paused ) {
            return;
        }

        this._paused = value;

        if ( this._paused ) {
            Tween.activeTweenList.delete( this );
        } else {
            if ( Number.isNaN( this._position ) || ( this.repeatCount != 0 && this._position >= this.repeatCount * this.duration ) ) {
                // reached the end, reset.
                this._inited = false;
                this.calculatedPosition = 0;
                this.calculatedPositionOld = 0;
                this.ratio = 0;
                this.ratioOld = 0;
                this.positionOld = 0;
                this._position = -this.getDelay();
            }

            Tween.activeTweenList.set( this,true );
        }
    }

    stopAll() {
        for ( const [tween] of Tween.activeTweenList ) {
            tween.stop();
        }
    }


    /*
		* Gets && sets the position of the tween in frames || seconds (depending on .useFrames). This value will;
		* be constrained between -delay && repeatCount*duration. It will be resolved to a .calculatedPosition before;
		* being applied.
		*
		* Negative values:
		* Values below 0 will always resolve to a calculatedPosition of 0. Negative values can be used to set up a delay on the tween, as the tween will have to count up to 0 before initing.
		*
		* Positive values:
		* Positive values are resolved based on the duration, repeatCount, && reflect properties.
	*/
    getPosition() {
        return this._position;
    }

    /**
     *
     *
     * @param {number} pos
     * @returns {Tween}
     * @memberof Tween
     */
    setPosition( pos ) {
        this.positionOld = this._position;
        this.ratioOld = this.ratio;
        this.calculatedPositionOld = this.calculatedPosition;
        const maxPosition = this.repeatCount * this.duration;
        const isEnd = pos >= maxPosition && this.repeatCount > 0;

        if ( isEnd ) {
            if ( this.calculatedPositionOld == maxPosition ) {
                return;
            }

            this._position = maxPosition;
            this.calculatedPosition = ( this.reflect && ( this.repeatCount % 2 == 0 ) ) && 0 || this.duration;
        } else {
            this._position = pos;
            this.calculatedPosition = ( this._position < 0 ) ? 0 : ( this._position % this.duration );

            if ( this.reflect && Math.floor( this.getPosition() / this.duration ) % 2 != 0 ) {
                this.calculatedPosition = this.duration - this.calculatedPosition;
            }
        }

        this.ratio = ( this.duration == 0 && this._position >= 0 ) ? 1 : this.ease( this.calculatedPosition / this.duration, 0, 1, 1 );

        if ( this.target && ( this._position >= 0 || this.positionOld >= 0 ) && this.calculatedPosition != this.calculatedPositionOld ) {
            if ( !this._inited ) {
                this.init();
            }

            for ( const n in this._endValues ) {
                let initVal, rangeVal, val;

                if ( n == "color" ) {
                    // 컬러는 쪼개서 트윈해야한다
                    initVal = this._initValues[n];
                    rangeVal = this._rangeValues[n];
                    const val1  = initVal[0] + rangeVal[0] * this.ratio;
                    const val2  = initVal[1] + rangeVal[1] * this.ratio;
                    const val3  = initVal[2] + rangeVal[2] * this.ratio;

                    this.target.setColorMultiplier( val1, val2, val3 );
                } else {
                    initVal = this._initValues[n];
                    rangeVal = this._rangeValues[n];
                    val = initVal + rangeVal * this.ratio;
                    console.assert( this.target[n] != null );
                    this.target[n] = val;
                }
            }
        }

        if ( this.dispatchEvents ) {
            this.dispatchEvent( "change" );
        }

        if ( isEnd ) {
            this._isEnd = true;
            this.setPaused( true );

            if ( this.nextTween ) {
                this.nextTween.setPaused( false );
            }

            if ( this.dispatchEvents ) {
                this.dispatchEvent( "complete" );
            }
        }

        return this;
    }


    /*
		* The length of the delay in frames || seconds (depending on .useFrames).
		* The delay occurs before a tween reads initial values || starts playing.
	*/
    /**
     *
     *
     * @returns {number}
     * @memberof Tween
     */
    getDelay() {
        return this._delay;
    }

    /**
     *
     *
     * @param {number} value
     * @returns {Tween}
     * @memberof Tween
     */
    setDelay( value ) {
        if ( this._position <= 0 ) {
            this._position = -value;
        }

        this._delay = value;

        return this;
    }


    /*
		* Sets the numeric end value for a property on the target object that you would like to tween.
		* For example, if you wanted to tween to a new x position, you could use: myTween.setValue("x",400).
		*
		* name: The name of the property to tween.
		* value: The numeric end value (the value to tween to).
	*/
    /**
     *
     *
     * @param {string} name
     * @param {*} value
     * @returns {Tween}
     * @memberof Tween
     */
    setValue( name, value ) {
        this._endValues[name] = value;
        this.invalidate();

        return this;
    }

    /*
		* Returns the end value for the specified property if one exists.
		*
		* name: The name of the property to return a } value for.
	*/
    getValue( name ) {
        return this._endValues[name];
    }

    /*
		* Removes a end value from the tween. This prevents the Tween instance from tweening the property.
		*
		* name: The name of the end property to delete.
	*/
    deleteValue( name ) {
        this._rangeValues[name] = null;
        this._initValues[name] = null;
        const result = this._endValues[name] != null;

        this._endValues[name] = null;

        return result;
    }


    /*
		* Shorthand method for making multiple setProperty calls quickly.
		* This adds the specified properties to the values list.
		* 
		* Example: set x and y end values:
		* myTween.setEndValues({x:200, y:400});
		*
		* properties: An object containing end property values.
	*/
    /**
     *
     *
     * @param {object} values
     * @returns {Tween}
     * @memberof Tween
     */
    setValues( values ) {
        Object.assign( this._endValues, values );
        this.invalidate();

        return this;
    }

    /*
		* Similar to .setEndValues(), but clears all previous end values;
		* before setting the new ones.
		*
		* properties: An object containing end property values.
	*/
    /**
     *
     *
     * @param {*} values
     * @returns {Tween}
     * @memberof Tween
     */
    resetValues( values ) {
        this._endValues = {};
        this.setValues( values );

        return this;
    }

    /*
		* Returns the table of all end properties && their values. This is a copy of values, so modifying;
		* the returned object will not affect the tween.
	*/
    /**
     *
     *
     * @returns {object}
     * @memberof Tween
     */
    getValues() {
        return Object.assign( {}, this._endValues );
    }

    /*
		* Returns the initial value for the specified property.
		* Note that the value will not be available until the tween inits.
	*/
    /**
     *
     *
     * @param {string} name
     * @returns {*}
     * @memberof Tween
     */
    getInitValue( name ) {
        return this._initValues[name];
    }

    /*
		* Swaps the init && } values for the tween, effectively reversing it.
		* This should generally only be called before the tween starts playing.
		* This will force the tween to init if it hasn't already done so, which;
		* may result in an onInit call.
		* It will also force a render (so the target immediately jumps to the new values;
		* immediately) which will result in the onChange callback being called.
		* 
		* You can also use the special "swapValues" property on the props parameter of;
		* the Tween constructor to call :swapValues() after the values are set.
		* 
		* The following example would tween the target from 100,100 to its current position:
		* new Tween(ball, 2, {x=100, y=100}, {swapValues=true});
	*/
    swapValues() {
        if ( !this._inited ) {
            this.init();
        }

        const o = this._endValues;

        this._endValues = this._initValues;
        this._initValues = o;

        for ( const n in this._rangeValues ) {
            const v = this._rangeValues[n];

            this._rangeValues[n] = -v;
        }

        this.calculatedPosition = null;

        if ( this._position < 0 ) {
            const pos = this.positionOld;

            this.setPosition( 0 );
            this._position = this.positionOld;
            this.positionOld = pos;
        } else {
            this.setPosition( this._position );
        }
    }

    /*
		* Reads all of the initial values from target && calls the onInit callback.
		* This is called automatically when a tween becomes active (finishes delaying);
		* && when :swapValues() is called. It would rarely be used directly;
		* but is exposed for possible use by power users.
	*/
    init() {
        this._inited = true;
        this._initValues = {};
        this._rangeValues = {};

        for ( const key in this._endValues ) {
            if ( key == "color" ) {
                // hex로 들어온 값을 r, g, b 값으로 나눠서 저장한다
                this._initValues[key] = hexToRgb( this.target.colorMultiplier );
                let value;

                value = hexToRgb( this._endValues[key] );
                this._rangeValues[key] = [
                    value[0] - parseFloat( this._initValues[key][0] ),
                    value[1] - parseFloat( this._initValues[key][1] ),
                    value[2] - parseFloat( this._initValues[key][2] )
                ];
            } else {
                //나머지 원본으로
                console.assert( this.target[key] != null, `트윈으로 조작하려는 값이 null이다.` );
                this._initValues[key] = this.target[key];
                this._rangeValues[key] = this._endValues[key] - this._initValues[key];
            }
        }

        if ( this.dispatchEvents ) {
            this.dispatchEvent( "init" );
        }
    }

    /*
		* Jumps the tween to its beginning && pauses it. This is the same as calling .setPosition(0) and .setPaused(true).
	*/
    toStart() {
        this.setPosition( 0 );
        //this.setPaused(true);
    }

    cancel() {
        this.setPosition( 0 );
        this.stop();
    }

    /*
		* Jumps the tween to its end and pauses it. This is roughly the same as calling .setPosition(repeatCount*duration).
	*/
    toEnd() {
        this.setPosition( ( this.repeatCount > 0 ) && this.repeatCount * this.duration || this.duration );
    }

    invalidate() {
        this._inited = false;

        if ( this._position > 0 ) {
            this._position = 0;
        }

        if ( this.autoPlay ) {
            this.setPaused( false );
        }
    }


    /**
     *
     *
     * @returns {Tween}
     * @memberof Tween
     */
    onCompleteRemoveFromParent() {
        this.addEventListener( "complete",
                               () => {
                                   this.target.removeFromParent();
                                   this.target = null;
                               },this );

        return this;
    }

    /**
     *
     *
     * @param {function} func
     * @param {any=} data
     * @returns {Tween}
     * @memberof Tween
     */
    onComplete( func,data ) {
        this.addEventListener( "complete",func,data );

        return this;
    }

    /**
     *
     *
     * @param {function} func
     * @param {any=} data
     * @returns {Tween}
     * @memberof Tween
     */
    onChange( func,data ) {
        this.addEventListener( "change",func,data );

        return this;
    }

    /**
     *
     *
     * @param {Tween} tween
     * @returns {Tween}
     * @memberof Tween
     */
    setNextTween( tween ) {
        this.nextTween = tween;

        return this;
    }

    /**
     *
     *
     * @param {number} duration
     * @param {object} values
     * @param {string|function|Prop=} props
     * @returns {Tween}
     * @memberof Tween
     */
    tween( duration, values, props ) {
        const newTween = new Tween( this.target, duration, values, props );

        if ( !this.isEnd() ) {
            newTween.setPaused( true );
            this.setNextTween( newTween );
        }

        return newTween;
    }

    /**
     *
     *
     * @param {number} x
     * @param {number} y
     * @param {number} [duration = 0]
     * @param {string|function|Prop=} props
     * @returns {Tween}
     * @memberof Tween
     */
    move( x, y, duration = 0, props ) {
        const newTween = new Tween( this.target, duration, { x: x, y: y }, props );

        if ( !this.isEnd() ) {
            newTween.setPaused( true );
            this.setNextTween( newTween );
        }

        return newTween;
    }

    /**
     *
     *
     * @param {number} [duration=0]
     * @param {function=} func
     * @param {object=} context
     * @returns {Tween}
     * @memberof Tween
     */
    wait( duration = 0, func, context ) {
        const newTween = new Tween( this.target, duration );

        if ( func ) {
            this.onComplete( func, context );
        }

        if ( !this.isEnd() ) {
            newTween.setPaused( true );
            this.setNextTween( newTween );
        }

        return newTween;
    }

    stopTweenChain() {
        Tween.stopTarget( this.target );
    }


    static linearEase( a, b, c, d ) {
        return a;
    }

    static onTick() {
        if ( Tween.pauseAll ) {
            return;
        }

        const dt = 1 / 60 * Tween.timeScaleAll * 1000;

        for ( const [tween] of Tween.activeTweenList ) {
            copyTickList.push( tween );
        }

        for ( let i = 0; i < copyTickList.length; i++ ) {
            const tween = copyTickList[i];

            tween.setPosition( tween._position + ( tween.useFrames && Tween.timeScaleAll || dt ) * tween.timeScale );
        }

        if ( copyTickList.length == 0 ) {
            _Application__WEBPACK_IMPORTED_MODULE_5__.application.stage.removeEventListener( _Event__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME, Tween.onTick );
            Tween.active = null;
        }

        copyTickList.length = 0;
    }

    // 타겟에 걸린 트윈 모두 정지
    static stopTarget( target ) {
        for ( const [tween] of Tween.activeTweenList ) {
            if ( tween.target == target ) {
                tween.stop();
            }
        }
    }

    /*
	* Constructs a new Tween instance.
	*
	* target: The object whose properties will be tweened.
	* duration: The length of the tween in frames || seconds depending on the timingMode.
	* values: An object containing } property values. For example, to tween to x=100, y=100, you could pass {x=100, y=100} as the values object.
	* props: An object containing properties to set on this tween. For example, you could pass {ease=myEase} to set the ease property of the new instance. It also supports a single special property "swapValues" that will cause :swapValues() to be called after the values specified in the values parameter are set.
    */
}

/*

트윈을 연결해서 애니메이션을 만들 수 있도록 하기 위해서 작성
Sprite 파일에 함수를 정의하면 상호참조 때문에 안됨
spr.move(10,10,100).move(100,50,200)...

*/

_EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.prototype.tween = function ( duration, values, props ) {
    return new Tween( this, duration, values, props );
};

_EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.prototype.move = function ( x, y, duration = 0, props ) {
    return new Tween( this, duration, { x: x, y: y }, props );
};

_EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.prototype.wait = function ( duration = 0, func, context ) {
    return new Tween( this, duration ).onComplete( func,context );
};

_EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.prototype.getTweens = function ( playingOnly ) {
    const tweens = [];

    for ( const [tween] of Tween.activeTweenList ) {
        if ( tween.target == this ) {
            if ( !playingOnly || tween.paused ) {
                tweens.push( tween );
            }
        }
    }

    return tweens.length > 0 ? tweens : null;
};

_EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher.prototype.stopAllTweens = function () {
    Tween.stopTarget( this );
};

Tween.active = false;
Tween.defaultDispatchEvents = true;
Tween.defaultEase = Tween.linearEase;
Tween.pauseAll = false;
Tween.timeScaleAll = 1;
Tween.activeTweenList = new Map();




/***/ }),

/***/ "./engine/src/Types.js":
/*!*****************************!*\
  !*** ./engine/src/Types.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rect": () => (/* binding */ Rect),
/* harmony export */   "Point": () => (/* binding */ Point),
/* harmony export */   "TypedArrayHelper": () => (/* binding */ TypedArrayHelper)
/* harmony export */ });

function getRectLike( r ) {
    if ( Array.isArray( r ) || r instanceof Float32Array ) {
        return { x: r[0],y: r[1], width: r[2],height: r[3] };
    } else {
        return r;
    }
}

function getPointLike( p ) {
    if ( Array.isArray( p ) || p instanceof Float32Array ) {
        return { x: p[0],y: p[1] };
    } else {
        return p;
    }
}


class Rect {
    /**
     * Creates an instance of Rect.
     * @param {[number,number,number,number]|Float32Array|number|Rect=} x
     * @param {number=} y
     * @param {number=} width
     * @param {number=} height
     * @memberof Rect
     */
    constructor( x,y,width,height ) {
        if ( Array.isArray( x ) || x instanceof Float32Array ) {
            this.x  = x[0];
            this.y = x[1];
            this.width = x[2];
            this.height = x[3];
        } else if ( typeof x === "object" ) {
            this.x = x.x;
            this.y = x.y;
            this.width = x.width;
            this.height = x.height;
        } else {
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
        }
    }

    /**
     *
     *
     * @returns {Rect}
     * @memberof Rect
     */
    clone() {
        return new Rect( this );    
    }


    getCornerPoints() {
        const { x,y,width,height } = this;

        return [x,y,x + width,y,x,y + height,x + width,y + height];
    }

    getArray() {
        return [this.x,this.y,this.width,this.height];
    }

    extendPoint( x,y ) {
        if ( this.x == null ) {
            this.x = x;
            this.y = y;
            this.width = 0;
            this.height = 0;
        } else {
            if ( x < this.x ) {
                this.width += this.x - x;
                this.x = x;
            }
            if ( y < this.y ) {
                this.height += this.y - y;
                this.y = y;
            }
            this.width = Math.max( this.right,x ) - this.x;
            this.height = Math.max( this.bottom,y ) - this.y;
        }
    }

    extendRect( r ) {
        this.extendPoint( r.x,r.y );
        this.extendPoint( r.right,r.y );
        this.extendPoint( r.x,r.bottom );
        this.extendPoint( r.right,r.bottom );
    }

    get xywh() {
        return [this.x,this.y,this.width,this.height];
    }

    set xywh( r ) {
        const r2 = getRectLike( r );

        this.x = r2.x;
        this.y = r2.y;
        this.width = r2.width;
        this.height = r2.height;
    }

    get left() { return this.x; }

    get right() { return this.x + this.width; }

    get top() { return this.y; }

    get bottom() { return this.y + this.height; }

    contains( x,y ) {
        return ( x >= this.left && x < this.right && y >= this.top && y < this.bottom );
    }
}


class Point {
    /**
     * Creates an instance of Point.
     * @param {[number,number]|Float32Array|number|Point=} x
     * @param {number=} y
     * @memberof Point
     */
    constructor( x,y ) {
        if ( Array.isArray( x ) || x instanceof Float32Array ) {
            this.x = x[0];
            this.y = x[1];
        } else if ( typeof x === "object" ) {
            this.x = x.x;
            this.y = x.y;
        } else {
            this.x = x || 0;
            this.y = y || 0;
        }
    }

    /**
     *
     *
     * @returns {Point}
     * @memberof Point
     */
    clone() {
        return new Point( this );    
    }

    getArray() {
        return [this.x,this.y];
    }

    get xy() {
        return [this.x,this.y];
    }

    set xy( p ) {
        const p2 = getPointLike( p );

        this.x = p2.x;
        this.y = p2.y;
    }

    /**
     * Point를 더한다.
     *
     * @param {Point|number} p
     * @returns {Point}
     * @memberof Point
     */
    add( p ) {
        const p2 = getPointLike( p );

        this.x += p2.x;
        this.y += p2.y;
        return new Point( this );
    }

    /**
     * Point를 뺀다.
     *
     * @param {Point|number} p
     * @returns {Point}
     * @memberof Point
     */
    subtract( p ) {
        const p2 = getPointLike( p );

        this.x -= p2.x;
        this.y -= p2.y;
        return new Point( this );
    }

    /**
     *
     *
     * @param {Point|number} p
     * @returns {Point}
     * @memberof Point
     */
    mul( p ) {
        const p2 = getPointLike( p );

        this.x *= p2.x;
        this.y *= p2.y;
        return new Point( this );
    }
}


class TypedArrayHelper {
    /**
     *
     *
     * @static
     * @param {Uint8Array} uint8Arr
     * @param {number} begin
     * @param {number=} length
     * @returns {Float32Array} 
     * @memberof TypedArrayHelper
     */
    static Uint8ToFloat32( uint8Arr,begin = 0,length = null ) {
        return new Float32Array( uint8Arr.buffer,uint8Arr.byteOffset + begin,( length != null ) ? Math.ceil( length / 4 ) : null );
    }

    /**
     *
     *
     * @static
     * @param {Uint16Array} uint16Arr
     * @param {number} begin
     * @param {number=} length
     * @returns {Float32Array} 
     * @memberof TypedArrayHelper
     */
    static Uint16ToFloat32( uint16Arr,begin = 0,length = null ) {
        return new Float32Array( uint16Arr.buffer,uint16Arr.byteOffset + begin * 2,length != null ? Math.ceil( length / 2 ) : null );
    }

    /**
     *
     *
     * @static
     * @param {Float32Array} float32Arr
     * @param {number} begin
     * @param {number=} length
     * @returns {Uint8Array} 
     * @memberof TypedArrayHelper
     */
    static Float32ToUint8( float32Arr,begin = 0,length = null ) {
        return new Uint8Array( float32Arr.buffer,float32Arr.byteOffset + begin * 4,length != null ? length * 4 : null );
    }

    /**
     *
     *
     * @static
     * @param {Float32Array} float32Arr
     * @param {number} begin
     * @param {number=} length
     * @returns {Uint16Array} 
     * @memberof TypedArrayHelper
     */
    static Float32ToUint16( float32Arr,begin = 0,length = null ) {
        return new Uint16Array( float32Arr.buffer,float32Arr.byteOffset + begin * 4,length != null ? length * 2 : null );
    }

    /**
     *
     *
     * @static
     * @param {Float32Array|Uint16Array|Uint8Array} typedArr
     * @param {number} begin
     * @param {number=} length
     * @returns {*} 
     * @memberof TypedArrayHelper
     */
    static subarray( typedArr,begin = 0,length = null ) {        
        return typedArr.subarray( begin, length != null ? begin + length : null );
    }

    /**
     *
     *
     * @static
     * @param {Float32Array|Uint16Array|Uint8Array} typedArr
     * @param {number} newSize
     * @returns {Float32Array|Uint16Array|Uint8Array}
     * @memberof TypedArrayHelper
     */
    static resize( typedArr, newSize ) {
        //@ts-ignore
        const newArr = new ( typedArr.constructor )( newSize );

        newArr.set( typedArr,0,Math.min( newSize,typedArr.length ) );
        return newArr;
    }

    static memcpy( dst,dstOffset,src,srcOffset,srcLength ) {
        // webpack polyfill 을 사용하는 코드
        // const elementSize = dst.constructor.BYTES_PER_ELEMENT;

        // dstOffset = dst.byteOffset + dstOffset * elementSize;
        // srcOffset = src.byteOffset + srcOffset * elementSize;
        // srcLength *= elementSize;

        // Buffer.from( src.buffer, srcOffset,srcLength ).copy( Buffer.from( dst.buffer, dstOffset, srcLength ) );

        if ( srcLength < 100 ) {
            const dst2 = dst.subarray( dstOffset );
            const src2 = src.subarray( srcOffset );

            for ( let i = 0; i < srcLength; i++ ) {
                dst2[i] = src2[i];
            }
        } else {
            const byteLength = srcLength * src.BYTES_PER_ELEMENT;
            const u8dst = new Uint8Array( dst.buffer,dst.byteOffset + dstOffset * dst.BYTES_PER_ELEMENT );
            const u8src = new Uint8Array( src.buffer,src.byteOffset + srcOffset * src.BYTES_PER_ELEMENT,byteLength );

            u8dst.set( u8src );
        }
    }    
}


/***/ }),

/***/ "./engine/src/Utils.js":
/*!*****************************!*\
  !*** ./engine/src/Utils.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Utils": () => (/* binding */ Utils)
/* harmony export */ });



class AsyncValue {
    constructor() {
        this.value = undefined;
        this.promise = new Promise( ( resolve,reject ) => {
            this._resolve = resolve;
            this._reject = reject;
        } );
    }

    resolve( v ) {
        this.value = v;
        this._resolve( v );
        delete this.promise;
        delete this._resolve;
        delete this._reject;
    }

    reject( e ) {
        this._reject( e );
        delete this.promise;
        delete this._resolve;
        delete this._reject;
    }
}

const Utils = {

    AsyncValue,
    /**
     * Ctrl-shift-H
     * Alt-R 상태로 다음 조건 변환하여 일괄 삭제할 수 있다
     * Utils\.nullReplace\(([^,]+)\s*,\s*([^)]+)\)
     * $1 != null ? $1 : $2
     * 
     * @param {*} target
     * @param {*} value
     * @returns {*}
     * @memberof Utils
     */
    nullReplace( target, value ) {
        return target != null ? target : value;
    },

    /**
     *
     *
     * @param {number=} a
     * @param {number=} b
     * @returns {number}
     * @memberof Utils
     */
    random( a, b ) {
        console.assert( ( a == null && b == null ) || ( a != null && b != null ), `random(${a},${b}) 구문은 허용되지 않음. random(1,a) 혹은 random(0,a)를 명확히 쓸 것` );

        if ( b == null ) {
            // [1,i]
            return Math.floor( Math.random() * a + 1 );
        } else if ( a == null ) {
            return Math.random();
        } else {
            // [i,j]
            return Math.floor( Math.random() * ( b - a + 1 ) + a );
        }
    },

    /**
     *
     *
     * @param {number|string} a
     * @param {number} b
     * @returns {number}
     * @memberof Utils
     */
    precision( a, b ) {
        //@ts-ignore
        return parseFloat( a ).toPrecision( b );
    },

    /**
     *
     *
     * @param {number} a
     * @param {number} b
     * @returns {number}
     * @memberof Utils
     */
    idiv( a, b ) {
        // 음수에 대해서 바르게 처리함
        return a / b >> 0;
    },

    /**
     *
     *
     * @param {number} v0
     * @param {number} v1
     * @param {number} a
     * @returns {number}
     * @memberof Utils
     */
    lerp( v0, v1, a ) {
        return v0 + ( v1 - v0 ) * a;
    },

    /**
     *
     *
     * @param {number} v
     * @param {number} min
     * @param {number} max
     * @returns {number}
     * @memberof Utils
     */
    clamp( v, min, max ) {
        return Math.min( Math.max( v, min ), max );
    },

    /**
     *
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @returns {number}
     * @memberof Utils
     */
    distance( x1, y1, x2, y2 ) {
        return Math.sqrt( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) );
    },

    /**
     *
     *
     * @param {number} a
     * @returns {number}
     * @memberof Utils
     */
    frac( a ) {
        return a % 1;
    },

    legacy( msg = "" ) {
        // console.log( `♨ Legacy API ${msg}` );
    },

    notImplements( msg = "" ) {
        // console.log( `♨ Not Implemented. ${msg}` );
    },

    /**
     *
     *
     * @param {string} filename
     * @returns {string}
     * @memberof Utils
     */
    getEmbeddedFile( filename ) {
        console.assert( self._embeddedFiles[filename.toLowerCase()] != null );

        return self._embeddedFiles[filename];
    },

    /**
     *
     *
     * @param {string} filename
     * @returns {Uint8Array}
     * @memberof Utils
     */
    getEmbeddedBinaryFile( filename ) {
        console.assert( self._embeddedFiles[filename.toLowerCase()] != null );
        const base64Data = self._embeddedFiles[filename.toLowerCase()];
        const lookupTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        const arr = [];

        for ( let i = 0; i < base64Data.length; ) {
            const d = lookupTable.indexOf( base64Data.charAt( i++ ) );
            const e = lookupTable.indexOf( base64Data.charAt( i++ ) );
            const f = lookupTable.indexOf( base64Data.charAt( i++ ) );
            const g = lookupTable.indexOf( base64Data.charAt( i++ ) );
            const a = ( d << 2 ) | ( e >> 4 );
            const b = ( ( e & 15 ) << 4 ) | ( f >> 2 );
            const c = ( ( f & 3 ) << 6 ) | g;

            arr.push( a );
            if ( f != 64 ) arr.push( b );
            if ( g != 64 ) arr.push( c );
        }
        return new Uint8Array( arr );
    },

    embeddedFileExist( filename ) {
        return self._embeddedFiles[filename] != null;
    },

    /**
     *
     *
     * @param {string} filename
     * @returns {XMLDocument}
     * @memberof Utils
     */
    getEmbeddedXmlFile( filename ) {
        // @ts-ignore
        const xml = ( new window.DOMParser() ).parseFromString( Utils.getEmbeddedFile( filename ), "text/xml" );

        return xml;
    },

    /**
     * @typedef {object} Size
     * @property {number} width
     * @property {number} height
     *
     * @param {string} filename
     * @returns {Size}
     * @memberof Utils
     */
    getImageSize( filename ) {
        const imageInfo = self._imageSizes[filename.toLowerCase()];

        if ( imageInfo ) {
            return imageInfo;
        } else {
            return { width: 0,height: 0 };
        }
    },

    /**
     * 문자열에서 <tag> </tag> 형태를 추출한다
     *
     * @static
     * @param {string} str
     * @returns {*}
     * @memberof TextField
     */
    splitStringWithTag( str ) {
        const tagRegExp = /<([^>]+)>/g;
        const tagStack = ["default"];
        const resultArr = [];

        let lastIndex = 0;

        while ( true ) {
            const result = tagRegExp.exec( str );
            const lastTag = tagStack[tagStack.length - 1]; 

            if ( result == null ) {
                // 태그 못찾음
                if ( lastIndex < str.length ) {
                    resultArr.push( [lastTag,str.substring( lastIndex )] );
                }
                return resultArr;
            } else {
                const tagName = result[1];
                const tagIndex = result.index;

                if ( tagName[0] != '/' ) {
                    tagStack.push( tagName );
                } else if ( lastTag == tagName.substring( 1 ) ) {
                    tagStack.length--;
                } 
                if ( lastIndex != tagIndex ) {
                    resultArr.push( [lastTag,str.substring( lastIndex,tagIndex )] );
                }
                lastIndex = tagRegExp.lastIndex;
            }
        }
    },



    /**
     * [r,g,b,a] 가 담긴 어레이를 반환한다. r,g,b는 0~1.0의 값이다.
     *
     * @param {number} c
     * @param {number=} a
     * @returns {[number,number,number,number]}
     * @memberof Utils
     */
    hex2rgba( c,a ) {
        const result = [];

        // b,g,r,a 순서
        result[0] = ( ( c & 0xff0000 ) >> 16 ) / 255;
        result[1] = ( ( c & 0xff00 ) >> 8 ) / 255;
        result[2] = ( c & 0xff ) / 255;
        if ( a != null ) {
            result[3] = a;
        } else {
            result[3] = ( ( c & 0xff000000 ) >> 24 ) / 255;
        }
        //@ts-ignore
        return result;
    },

    rgba2hex( arr, i ) {
        const idx = i || 0;

        return ( ( arr[idx] * 255 ) << 16 ) | ( ( arr[idx + 1] * 255 ) << 8 ) | ( arr[idx + 2] * 255 ) | ( ( arr[idx + 3] * 255 ) << 24 );
    },


    /**
     *
     *
     * @param {number} angle
     * @returns {number}
     * @memberof Utils
     */
    angleToDir( angle ) {
        let dir;

        if ( -135 < angle && angle <= -45 ) {
            dir = 1;
        } else if ( -45 < angle && angle <= 45 ) {
            dir = 2;
        } else if ( 45 < angle && angle <= 135 ) {
            dir = 3;
        } else {
            dir = 4;
        }

        return dir;
    },

    /**
     *
     *
     * @param {number} dir
     * @returns {[number,number]}
     * @memberof Utils
     */
    dirToOffset( dir ) {
        let ax, ay;

        if ( dir == 1 ) {
            [ax, ay] = [0, -1];
        } else if ( dir == 2 ) {
            [ax, ay] = [1, 0];
        } else if ( dir == 3 ) {
            [ax, ay] = [0, 1];
        } else if ( dir == 4 ) {
            [ax, ay] = [-1, 0];
        }

        return [ax, ay];
    },



    filterAttrib( attrib, whiteList, blackList ) {
        // 성공하면 true
        const whiteListStr = whiteList != null ? ( Array.isArray( whiteList ) ? "," + whiteList.join( "," ) + "," : "," + whiteList + "," ) : ",*,";
        const blackListStr = blackList != null ? ( Array.isArray( blackList ) ? "," + blackList.join( "," ) + "," : "," + blackList + "," ) : "";
        const attribs = attrib != null ? ( Array.isArray( attrib ) ? attrib : attrib.split( "," ) ) : [];


        let whitePass;

        if ( blackListStr.indexOf( ",*," ) >= 0 ) {
            // black이 * 면 그냥 실패
            return false;
        } else if ( whiteListStr.indexOf( ",*," ) >= 0 ) {
            //white가 * 면 그냥 통과
            whitePass = true;
        } else if ( attribs.length > 0 ) {
            for ( const v of attribs ) {
                if ( whiteListStr.indexOf( "," + v + "," ) >= 0 ) {
                    //화이트에서 하나라도 있으면 통과
                    whitePass = true;
                    break;
                }
            }
        } else {
            //어트리뷰트가 하나도 주어지지 않았을 경우 실패
            return false;
        }

        if ( whitePass ) {
            for ( const v of attribs ) {
                if ( blackListStr.indexOf( "," + v + "," ) >= 0 ) {
                    //블랙에서 하나라도 있으면 최종 실패
                    return false;
                }
            }

            return true;
        }

        return false;
    },


    format( text, ...args ) {
        let s;

        if ( args.length > 0 ) {
            // %s %d
            // %0 %1 %2 %3 %4...
            let count = 0;

            s = text.replace( /%[s|d]/g, function ( s ) {
                return `%${count++}`;
            } );

            for ( let i = 0; i < args.length; i++ ) {
                s = s.replace( `%${i}`, args[i] );
            }
        } else s = text;

        return s;
    },

    isNode() {
        return ( typeof {"env": {}} == "object" && typeof {"env": {}}.versions == "object" && typeof {"env": {}}.versions.node != "undefined" );
    },

    isWebWorker() {
        //@ts-ignore
        return !this.isNode() 
            && ( typeof WorkerGlobalScope !== "undefined" ) 
            && ( typeof importScripts === "function" ) 
            // eslint-disable-next-line no-undef
            && ( navigator instanceof WorkerNavigator );
    },

    clearObject( obj ) {
        const props = Object.keys( obj );

        for ( let i = 0,n = props.length; i < n; i++ ) {
            delete obj[props[i]];
        }
    }

};


/***/ }),

/***/ "./engine/src/easing.js":
/*!******************************!*\
  !*** ./engine/src/easing.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "easing": () => (/* binding */ easing)
/* harmony export */ });
/*
Easing functions adapted from Robert Penner's AS3 tweening equations.
*/

const easing = {};

const backS = 1.70158;

easing.inBack = function ( t ) {
    return t * t * ( ( backS + 1 ) * t - backS );
};

easing.outBack = function ( t ) {
    t = t - 1;

    return t * t * ( ( backS + 1 ) * t + backS ) + 1;
};

easing.inOutBack = function ( t ) {
    t = t * 2;

    if ( t < 1 ) return 0.5 * ( t * t * ( ( backS * 1.525 + 1 ) * t - backS * 1.525 ) );
    else {
        t = t - 2;

        return 0.5 * ( t * t * ( ( backS * 1.525 + 1 ) * t + backS * 1.525 ) + 2 );
    }
};

easing.inBounce = function ( t ) {
    return 1 - easing.outBounce( 1 - t );
};

easing.outBounce = function ( t ) {
    if ( t < 1 / 2.75 ) {
        return 7.5625 * t * t;
    } else if ( t < 2 / 2.75 ) {
        t = t - 1.5 / 2.75;

        return 7.5625 * t * t + 0.75;
    } else if ( t < 2.5 / 2.75 ) {
        t = t - 2.25 / 2.75;

        return 7.5625 * t * t + 0.9375;
    } else {
        t = t - 2.625 / 2.75;

        return 7.5625 * t * t + 0.984375;
    }
};

easing.inOutBounce = function ( t ) {
    t = t * 2;
    if ( t < 1 ) return 0.5 * easing.inBounce( t );
    else return 0.5 * easing.outBounce( t - 1 ) + 0.5;
};

easing.inCircular = function ( t ) {
    return -( Math.sqrt( 1 - t * t ) - 1 );
};

easing.outCircular = function ( t ) {
    return Math.sqrt( 1 - ( t - 1 ) * ( t - 1 ) );
};

easing.inOutCircular = function ( t ) {
    t = t * 2;

    if ( t < 1 ) return -0.5 * ( Math.sqrt( 1 - t * t ) - 1 );
    else {
        t = t - 2;

        return 0.5 * ( Math.sqrt( 1 - t * t ) + 1 );
    }
};

easing.inCubic = function ( t ) {
    return t * t * t;
};

easing.outCubic = function ( t ) {
    t = t - 1;

    return t * t * t + 1;
};

easing.inOutCubic = function ( t ) {
    if ( t < 0.5 ) return 4 * t * t * t;
    else {
        t = t - 1;

        return 4 * t * t * t + 1;
    }
};

var elasticA = 1;
var elasticP = 0.3;
var elasticS = elasticP / 4;

easing.inElastic = function ( t ) {
    if ( t == 0 || t == 1 ) return t;
    t = t - 1;

    return -( elasticA * Math.pow( 2, 10 * t ) * Math.sin( ( t - elasticS ) * ( 2 * Math.PI ) / elasticP ) );
};

easing.outElastic = function ( t ) {
    if ( t == 0 || t == 1 ) return t;

    return elasticA * Math.pow( 2, -10 * t ) * Math.sin( ( t - elasticS ) * ( 2 * Math.PI ) / elasticP ) + 1;
};

easing.inOutElastic = function ( t ) {
    if ( t == 0 || t == 1 ) return t;
    t = t * 2 - 1;
    if ( t < 0 ) return -0.5 * ( elasticA * Math.pow( 2, 10 * t ) * Math.sin( ( t - elasticS * 1.5 ) * ( 2 * Math.PI ) / ( elasticP * 1.5 ) ) );

    return 0.5 * elasticA * Math.pow( 2, -10 * t ) * Math.sin( ( t - elasticS * 1.5 ) * ( 2 * Math.PI ) / ( elasticP * 1.5 ) ) + 1;
};

easing.inExponential = function ( t ) {
    if ( t == 0 ) return 0;

    return Math.pow( 2, 10 * ( t - 1 ) );
};

easing.outExponential = function ( t ) {
    if ( t == 1 ) return 1;

    return 1 - Math.pow( 2, -10 * t );
};

easing.inOutExponential = function ( t ) {
    if ( t == 0 || t == 1 ) return t;
    t = t * 2 - 1;
    if ( t < 0 ) return 0.5 * Math.pow( 2, 10 * t );

    return 1 - 0.5 * Math.pow( 2, -10 * t );
};

easing.linear = function ( t ) {
    return t;
};

easing.inQuadratic = function ( t ) {
    return t * t;
};

easing.outQuadratic = function ( t ) {
    return -t * ( t - 2 );
};

easing.inOutQuadratic = function ( t ) {
    if ( t < 0.5 ) return 2 * t * t;

    return -2 * t * ( t - 2 ) - 1;
};

easing.inQuartic = function ( t ) {
    return t * t * t * t;
};

easing.outQuartic = function ( t ) {
    t = t - 1;

    return 1 - t * t * t * t;
};

easing.inOutQuartic = function ( t ) {
    if ( t < 0.5 ) return 8 * t * t * t * t;
    t = t - 1;

    return -8 * t * t * t * t + 1;
};

easing.inQuintic = function ( t ) {
    return t * t * t * t * t;
};

easing.outQuintic = function ( t ) {
    t = t - 1;

    return 1 + t * t * t * t * t;
};

easing.inOutQuintic = function ( t ) {
    if ( t < 0.5 ) return 16 * t * t * t * t * t;
    t = t - 1;

    return 16 * t * t * t * t * t + 1;
};

easing.inSine = function ( t ) {
    return 1 - Math.cos( t * ( Math.PI / 2 ) );
};

easing.outSine = function ( t ) {
    return Math.sin( t * ( Math.PI / 2 ) );
};

easing.inOutSine = function ( t ) {
    return -0.5 * ( Math.cos( t * Math.PI ) - 1 );
};

easing.outElasticSmooth = function ( t ) {
    if ( t == 0 || t == 1 ) return t;
    var elasticA = 1, elasticP = 0.38;
    var elasticS = elasticP / 4;

    return elasticA * Math.pow( 2.5, -10 * t ) * Math.sin( ( t - elasticS ) * ( 2 * Math.PI ) / elasticP ) + 1;
};

easing.inElasticSmooth2 = function ( t ) {
    if ( t == 0 || t == 1 ) return t;
    t = t - 1;
    var elasticA = 1, elasticP = 0.57;
    var elasticS = elasticP / 4;

    return -( elasticA * Math.pow( 2.6, 10 * t ) * Math.sin( ( t - elasticS ) * ( 2 * Math.PI ) / elasticP ) );
};

easing.outElasticSmooth2 = function ( t ) {
    if ( t == 0 || t == 1 ) return t;
    var elasticA = 1, elasticP = 0.57;
    var elasticS = elasticP / 4;

    return elasticA * Math.pow( 2.6, -10 * t ) * Math.sin( ( t - elasticS ) * ( 2 * Math.PI ) / elasticP ) + 1;
};

easing.outElasticWave = function ( t ) {
    if ( t == 0 || t == 1 ) return t;
    var elasticP = 0.19;
    var elasticS = elasticP / 4;
    var tPow = Math.pow( t, 4 );
    var v = Math.pow( 220, -0.7 * Math.pow( t, 0.4 ) ) * Math.sin( ( Math.pow( t, 0.95 ) - elasticS ) * ( 2 * Math.PI ) / elasticP ) + 1;

    return v * ( 1 - tPow ) + tPow;
};




/***/ }),

/***/ "./engine/src/flatfast.js":
/*!********************************!*\
  !*** ./engine/src/flatfast.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Application": () => (/* reexport safe */ _Application_js__WEBPACK_IMPORTED_MODULE_0__.Application),
/* harmony export */   "application": () => (/* reexport safe */ _Application_js__WEBPACK_IMPORTED_MODULE_0__.application),
/* harmony export */   "stage": () => (/* reexport safe */ _Application_js__WEBPACK_IMPORTED_MODULE_0__.stage),
/* harmony export */   "Bitmap": () => (/* reexport safe */ _Bitmap_js__WEBPACK_IMPORTED_MODULE_1__.Bitmap),
/* harmony export */   "Component": () => (/* reexport safe */ _Component_js__WEBPACK_IMPORTED_MODULE_2__.Component),
/* harmony export */   "ComponentHolder": () => (/* reexport safe */ _ComponentHolder_js__WEBPACK_IMPORTED_MODULE_3__.ComponentHolder),
/* harmony export */   "Event": () => (/* reexport safe */ _Event_js__WEBPACK_IMPORTED_MODULE_4__.Event),
/* harmony export */   "EventDispatcher": () => (/* reexport safe */ _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_5__.EventDispatcher),
/* harmony export */   "TrueTypeFont": () => (/* reexport safe */ _TrueTypeFont_js__WEBPACK_IMPORTED_MODULE_6__.TrueTypeFont),
/* harmony export */   "BitmapFont": () => (/* reexport safe */ _BitmapFont_js__WEBPACK_IMPORTED_MODULE_7__.BitmapFont),
/* harmony export */   "MsdfFont": () => (/* reexport safe */ _MsdfFont_js__WEBPACK_IMPORTED_MODULE_8__.MsdfFont),
/* harmony export */   "KeyCode": () => (/* reexport safe */ _KeyCode_js__WEBPACK_IMPORTED_MODULE_9__.KeyCode),
/* harmony export */   "Layout": () => (/* reexport safe */ _Layout_js__WEBPACK_IMPORTED_MODULE_10__.Layout),
/* harmony export */   "Matrix": () => (/* reexport safe */ _Matrix_js__WEBPACK_IMPORTED_MODULE_11__.Matrix),
/* harmony export */   "Mesh": () => (/* reexport safe */ _Mesh_js__WEBPACK_IMPORTED_MODULE_12__.Mesh),
/* harmony export */   "MovieClip": () => (/* reexport safe */ _MovieClip_js__WEBPACK_IMPORTED_MODULE_13__.MovieClip),
/* harmony export */   "Particles": () => (/* reexport safe */ _Particles_js__WEBPACK_IMPORTED_MODULE_14__.Particles),
/* harmony export */   "Pixel": () => (/* reexport safe */ _Pixel_js__WEBPACK_IMPORTED_MODULE_15__.Pixel),
/* harmony export */   "RenderTarget": () => (/* reexport safe */ _RenderTarget_js__WEBPACK_IMPORTED_MODULE_16__.RenderTarget),
/* harmony export */   "SceneManager": () => (/* reexport safe */ _SceneManager_js__WEBPACK_IMPORTED_MODULE_17__.SceneManager),
/* harmony export */   "Shader": () => (/* reexport safe */ _Shader_js__WEBPACK_IMPORTED_MODULE_18__.Shader),
/* harmony export */   "Shape": () => (/* reexport safe */ _Shape_js__WEBPACK_IMPORTED_MODULE_19__.Shape),
/* harmony export */   "Sound": () => (/* reexport safe */ _Sound_js__WEBPACK_IMPORTED_MODULE_20__.Sound),
/* harmony export */   "Spine": () => (/* reexport safe */ _Spine_js__WEBPACK_IMPORTED_MODULE_21__.Spine),
/* harmony export */   "Sprite": () => (/* reexport safe */ _Sprite_js__WEBPACK_IMPORTED_MODULE_22__.Sprite),
/* harmony export */   "Stage": () => (/* reexport safe */ _Stage_js__WEBPACK_IMPORTED_MODULE_23__.Stage),
/* harmony export */   "Storage": () => (/* reexport safe */ _Storage_js__WEBPACK_IMPORTED_MODULE_24__.Storage),
/* harmony export */   "TextField": () => (/* reexport safe */ _TextField_js__WEBPACK_IMPORTED_MODULE_25__.TextField),
/* harmony export */   "Texture": () => (/* reexport safe */ _Texture_js__WEBPACK_IMPORTED_MODULE_26__.Texture),
/* harmony export */   "TextureBase": () => (/* reexport safe */ _TextureBase_js__WEBPACK_IMPORTED_MODULE_27__.TextureBase),
/* harmony export */   "TexturePack": () => (/* reexport safe */ _TexturePack_js__WEBPACK_IMPORTED_MODULE_28__.TexturePack),
/* harmony export */   "TileMap": () => (/* reexport safe */ _TileMap_js__WEBPACK_IMPORTED_MODULE_29__.TileMap),
/* harmony export */   "Timer": () => (/* reexport safe */ _Timer_js__WEBPACK_IMPORTED_MODULE_30__.Timer),
/* harmony export */   "Tween": () => (/* reexport safe */ _Tween_js__WEBPACK_IMPORTED_MODULE_31__.Tween),
/* harmony export */   "Utils": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_32__.Utils),
/* harmony export */   "easing": () => (/* reexport safe */ _easing_js__WEBPACK_IMPORTED_MODULE_33__.easing),
/* harmony export */   "hangul": () => (/* reexport safe */ _hangul_js__WEBPACK_IMPORTED_MODULE_34__.hangul),
/* harmony export */   "Point": () => (/* reexport safe */ _Types_js__WEBPACK_IMPORTED_MODULE_35__.Point),
/* harmony export */   "Rect": () => (/* reexport safe */ _Types_js__WEBPACK_IMPORTED_MODULE_35__.Rect),
/* harmony export */   "Serializer": () => (/* reexport safe */ _Serializer_js__WEBPACK_IMPORTED_MODULE_36__.Serializer)
/* harmony export */ });
/* harmony import */ var _Application_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Application.js */ "./engine/src/Application.js");
/* harmony import */ var _Bitmap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bitmap.js */ "./engine/src/Bitmap.js");
/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Component.js */ "./engine/src/Component.js");
/* harmony import */ var _ComponentHolder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComponentHolder.js */ "./engine/src/ComponentHolder.js");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Event.js */ "./engine/src/Event.js");
/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EventDispatcher.js */ "./engine/src/EventDispatcher.js");
/* harmony import */ var _TrueTypeFont_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TrueTypeFont.js */ "./engine/src/TrueTypeFont.js");
/* harmony import */ var _BitmapFont_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BitmapFont.js */ "./engine/src/BitmapFont.js");
/* harmony import */ var _MsdfFont_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MsdfFont.js */ "./engine/src/MsdfFont.js");
/* harmony import */ var _KeyCode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./KeyCode.js */ "./engine/src/KeyCode.js");
/* harmony import */ var _Layout_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Layout.js */ "./engine/src/Layout.js");
/* harmony import */ var _Matrix_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Matrix.js */ "./engine/src/Matrix.js");
/* harmony import */ var _Mesh_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Mesh.js */ "./engine/src/Mesh.js");
/* harmony import */ var _MovieClip_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./MovieClip.js */ "./engine/src/MovieClip.js");
/* harmony import */ var _Particles_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Particles.js */ "./engine/src/Particles.js");
/* harmony import */ var _Pixel_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Pixel.js */ "./engine/src/Pixel.js");
/* harmony import */ var _RenderTarget_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./RenderTarget.js */ "./engine/src/RenderTarget.js");
/* harmony import */ var _SceneManager_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./SceneManager.js */ "./engine/src/SceneManager.js");
/* harmony import */ var _Shader_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Shader.js */ "./engine/src/Shader.js");
/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Shape.js */ "./engine/src/Shape.js");
/* harmony import */ var _Sound_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Sound.js */ "./engine/src/Sound.js");
/* harmony import */ var _Spine_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Spine.js */ "./engine/src/Spine.js");
/* harmony import */ var _Sprite_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./Sprite.js */ "./engine/src/Sprite.js");
/* harmony import */ var _Stage_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./Stage.js */ "./engine/src/Stage.js");
/* harmony import */ var _Storage_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./Storage.js */ "./engine/src/Storage.js");
/* harmony import */ var _TextField_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./TextField.js */ "./engine/src/TextField.js");
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./Texture.js */ "./engine/src/Texture.js");
/* harmony import */ var _TextureBase_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./TextureBase.js */ "./engine/src/TextureBase.js");
/* harmony import */ var _TexturePack_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./TexturePack.js */ "./engine/src/TexturePack.js");
/* harmony import */ var _TileMap_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./TileMap.js */ "./engine/src/TileMap.js");
/* harmony import */ var _Timer_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./Timer.js */ "./engine/src/Timer.js");
/* harmony import */ var _Tween_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./Tween.js */ "./engine/src/Tween.js");
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./Utils.js */ "./engine/src/Utils.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./easing.js */ "./engine/src/easing.js");
/* harmony import */ var _hangul_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./hangul.js */ "./engine/src/hangul.js");
/* harmony import */ var _Types_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./Types.js */ "./engine/src/Types.js");
/* harmony import */ var _Serializer_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./Serializer.js */ "./engine/src/Serializer.js");







































/***/ }),

/***/ "./engine/src/hangul.js":
/*!******************************!*\
  !*** ./engine/src/hangul.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hangul": () => (/* binding */ hangul)
/* harmony export */ });

const choSungTable = ["ㄱ", "ㄲ", "ㄴ", "ㄷ", "ㄸ", "ㄹ", "ㅁ", "ㅂ", "ㅃ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅉ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"];
const jungSungTable = [
    "ㅏ", "ㅐ", "ㅑ", "ㅒ", "ㅓ", // 0~4;
    "ㅔ", "ㅕ", "ㅖ", "ㅗ", "ㅘ", // 5~9;
    "ㅙ", "ㅚ", "ㅛ", "ㅜ", "ㅝ", // 10~14;
    "ㅞ", "ㅟ", "ㅠ", "ㅡ", "ㅢ", // 15~19;
    "ㅣ"];
const jongSungTable = [" ", "ㄱ", "ㄲ", "ㄳ", "ㄴ", "ㄵ", "ㄶ", "ㄷ", "ㄹ", "ㄺ", "ㄻ", "ㄼ", "ㄽ", "ㄾ", "ㄿ", "ㅀ", "ㅁ", "ㅂ", "ㅄ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"];

const choSungToCode = {};
const jungSungToCode = {
    ["ㅏㅣ"]:  1,
    ["ㅣㅏ"]:  2,
    ["ㅑㅣ"]:  3,
    ["ㅓㅣ"]:  5,
    ["ㅣㅓ"]:  6,
    ["ㅕㅣ"]:  7,
    ["ㅗㅏ"]:  9,
    ["ㅗㅐ"]:  10,
    ["ㅗㅏㅣ"]: 10,
    ["ㅗㅣ"]:  11,
    ["ㅣㅗ"]:  12,
    ["ㅜㅓ"]:  14,
    ["ㅜㅔ"]:  15,
    ["ㅜㅓㅣ"]: 15,
    ["ㅜㅣ"]:  16,
    ["ㅡㅜ"]:  17,
    ["ㅡㅣ"]:  19,
};
const jongSungToCode = {};

for ( let i = 0; i < choSungTable.length; i++ ) {
    const v = choSungTable[i];

    choSungToCode[v] = i;
}

for ( let i = 0; i < jungSungTable.length; i++ ) {
    const v = jungSungTable[i];

    jungSungToCode[v] = i;
}

for ( let i = 0; i < jongSungTable.length; i++ ) {
    const v = jongSungTable[i];

    jongSungToCode[v] = i;
}

const uniCodeHangulBase = 0xac00;
const uniCodeHangulLast = 0xd79f;

const hangul = {};

function ucharToNumber( uchar ) {
    return uchar.charCodeAt( 0 );
}

const rangeHangul = [ucharToNumber( "가" ), ucharToNumber( "힣" )];

hangul.isValidUnicode = function ( uchar ) {
    //[가-힣] 검사, 
    const num = ucharToNumber( uchar );

    return num >= rangeHangul[0] && num <= rangeHangul[1];
};

const rangeHangulJa = [ucharToNumber( "ㄱ" ), ucharToNumber( "ㅎ" )];
const rangeHangulMo = [ucharToNumber( "ㅏ" ), ucharToNumber( "ㅣ" )];

hangul.isJamo = function ( uchar ) {
    //자모 여부 검사 검사
    const num = ucharToNumber( uchar );

    return ( num >= rangeHangulJa[0] && num <= rangeHangulJa[1] ) ||
		( num >= rangeHangulMo[0] && num <= rangeHangulMo[1] );
};

// 마지막이 종성이 검사
hangul.isJongSung = function ( str ) {
    const char = str.substr( str.length - 1 );
    const code = char.charCodeAt( 0 );

    if ( code < uniCodeHangulBase || code > uniCodeHangulLast ) {
        const choSung = choSungToCode[char];

        if ( choSung ) {
            // 자음은 모두 받침이 있게 발음된다
            return true;
        }

        if ( "bcdfghjklmnpqrstvwxz136780".indexOf( char ) >= 0 ) {
            return true;
        }

        return false;
    }

    // 분해해서 받침이 있는지 본다
    let uc = code - uniCodeHangulBase;

    //const choSung = Math.floor(uc / (21 * 28));
    uc = uc % ( 21 * 28 );
    //const jungSung = Math.floor(uc / 28);
    uc = uc % 28;
    const jongSung = uc;

    return jongSung > 0;
};




// 대한민국{를} 가려면 [비행기]{을} 타라

hangul.replaceJoSa = function ( inputText ) {
    if ( inputText == null || inputText == "" ) return inputText;

    //let words = inputText.match(/\s*([\S]+){([^/}]+)}/g);
    const re = /}?([^}]*){([^/}]*)}/g;
    let result = re.exec( inputText );
    //const words = [];
    let lastIndex = 0;
    let s = "";

    while ( result != null ) {
        lastIndex = re.lastIndex;
        const [pre, joSa, lastChar] = [
            //RegExp.lastMatch,
            RegExp.$1,
            RegExp.$2,
            RegExp.$1.match( /.['"`^()[\]]?$/ )[0].substr( 0, 1 ), // 마지막 글자
        ];
        const isJongSung = hangul.isJongSung( lastChar );
        const jongSung = isJongSung ? hangul.divideJaSo( lastChar )[2] : null;
        let newJoSa;

        if ( joSa == "을" || joSa == "를" ) {
            newJoSa = isJongSung ? "을" : "를";
        } else if ( joSa == "이" || joSa == "가" ) {
            newJoSa = isJongSung ? "이" : "가";
        } else if ( joSa == "과" || joSa == "와" ) {
            newJoSa = isJongSung ? "과" : "와";
        } else if ( joSa == "은" || joSa == "는" ) {
            newJoSa = isJongSung ? "은" : "는";
        } else if ( joSa == "이는" ) {
            newJoSa = isJongSung ? "이는" : "는";
        } else if ( joSa == "이와" ) {
            newJoSa = isJongSung ? "이와" : "와";
        } else if ( joSa == "여" || joSa == "이여" ) {
            newJoSa = isJongSung ? "이여" : "여";
        } else if ( joSa == "으로" || joSa == "로" ) {
            newJoSa = ( isJongSung && jongSung != "ㄹ" ) ? "으로" : "로";
        } else if ( joSa == "이네" || joSa == "네" ) {
            newJoSa = isJongSung ? "이네" : "네";
        } else if ( joSa == "이랑" || joSa == "랑" ) {
            newJoSa = isJongSung ? "이랑" : "랑";
        } else if ( joSa == "라" ) {
            newJoSa = isJongSung ? "이라" : "라";
        }

        s = s + pre + newJoSa;

        result = re.exec( inputText );
    }

    return s + inputText.substr( lastIndex );
};

hangul.format = function ( text, ...args ) {
    let s;

    if ( args.length > 0 ) {
        // %s %d
        // %0 %1 %2 %3 %4...
        let count = 0;

        s = text.replace( /%[s|d]/g, function ( s ) {
            return `%${count++}`;
        } );

        for ( let i = 0; i < args.length; i++ ) {
            s = s.replace( `%${i}`, args[i] );
        }
    } else s = text;

    return hangul.replaceJoSa( s );
};

// 자소를 합친다
hangul.mergeJaSo = function ( choSung, jungSung, jongSung ) {
    //log(choSung,jungSung,jongSung);
    const choSungPos = choSungToCode[choSung];
    const jungSungPos = jungSungToCode[jungSung];
    const jongSungPos = jongSung ? jongSungToCode[jongSung] : 0;
    const code = uniCodeHangulBase + ( choSungPos * 21 + jungSungPos ) * 28 + jongSungPos;

    return String.fromCharCode( code );
};

// 글자하나를 자소로 분리한다
hangul.divideJaSo = function ( char ) {
    const code = char.charCodeAt( 0 );

    if ( code < uniCodeHangulBase || code > uniCodeHangulLast ) {
        const choSung = choSungToCode[char];

        if ( choSung ) {
            return [choSungTable[choSung]];
        }

        const jungSung = jungSungToCode[char];

        if ( jungSung ) {
            return [null, jungSungTable[jungSung]];
        }

        return [];
    }

    let uc = code - uniCodeHangulBase;
    const choSung = Math.floor( uc / ( 21 * 28 ) );

    uc = uc % ( 21 * 28 );
    const jungSung = Math.floor( uc / 28 );

    uc = uc % 28;
    const jongSung = uc;

    return [
        choSungTable[choSung],
        jungSungTable[jungSung],
        ( jongSung > 0 && jongSungTable[jongSung] || null )
    ];
};

// 이 캐릭터가 자소중에 하나인지 검사
hangul.getTypeOfJaSo = function ( char ) {
    let [f1, f2, f3] = [false, false, false];
    const choSung = choSungToCode[char];

    if ( choSung ) {
        f1 = true;
    }

    const jungSung = jungSungToCode[char];

    if ( jungSung ) {
        f2 = true;
    }

    const jongSung = jongSungToCode[char];

    if ( jongSung ) {
        f3 = true;
    }

    return [f1, f2, f3];
};

// console.log(hangul.divideJaSo("한"));
// console.log(hangul.mergeJaSo(...hangul.divideJaSo("글")));
// console.log(hangul.isJamo("한"));
// console.log(hangul.isJamo("ㅏ"));
// console.log(hangul.isJongSung("간"));
// console.log(hangul.isJongSung("가"));
// console.log(hangul.isJongSung("bob"));
// console.log(hangul.replaceJoSa("대한민국{를} 가려면 '비행기'{을} 타라 323{로}"));


/***/ }),

/***/ "./games/PALO2/src/dialog.js":
/*!***********************************!*\
  !*** ./games/PALO2/src/dialog.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsWrapper/vs */ "./games/PALO2/src/vsWrapper/vs.js");




const dialogData = {
    "1p": [
        { face: "A", time: 0, dialog: "에구에구..\n또다시 출격이라니.." },
    ],
    "2p": [
        { face: "B", time: 0, dialog: "산소, 출격합니다~!" },
    ],
    "1p2p": [
        { face: "B", time: 3, dialog: "아이템은 공평하게\n나눠먹기에요!" },
        { face: "A", time: 0, dialog: "그거야 능력껏 먹는거지\n헐헐~" },
    ],
    "exit": [
        { face: "C", time: 2, dialog: "갈려고? 그럼 지구는 내 차지닷!\n크푸하타타타타!" },
        { face: "C", time: 2, dialog: "그래 맨날 공부만 해라!\n치사한 녀석 같으니~" },
        { face: "D", time: 4, dialog: "어! 진짜 갈려고? 가지마잉~\n좀 더 해봐잉~" },
        { face: "E", time: 3, dialog: "EXIT TO DOS?" },
        { face: "E", time: 4, dialog: "DOS는 이제 없어\n못나가" },
        { event: "mode:title" },
    ],
    "9": [
        { face: "E", time: 4, dialog: "나는 제작자A다.\n부디 1등상을 타오기 바란다." },
        { face: "E", time: 4, dialog: "인삼을 먹으면 아래 게이지에\n하나씩 불이 켜진다." },
        { face: "E", time: 4, dialog: "원하는 파워업에 불이 켜질때\n파워업 버튼을 누르면 된다." },
        { face: "E", time: 4, dialog: "할박사는 커서키와\nN, M으로 조종하고" },
        { face: "E", time: 4, dialog: "산소는 WASD키와\nZ, X로 조종하면 된다." },
        { face: "A", time: 0, dialog: "다 아는 거니까 그만해\n시끄럽다.. 쯧." },
    ],
    "16": [
        { face: "B", time: 3, dialog: "앗, 눈이 부셔!" },
        { face: "A", time: 4, dialog: "100k게임에 이 정도의 특수\n효과라니.. 대단하군." },
        { face: "E", time: 0, dialog: "후후후 이 정도를 가지고\n쑥스럽게." },
    ],
    "20": [
        { face: "B", time: 4, dialog: "계속 똑같은 배경만 나오잖아." },
        { face: "F", time: 4, dialog: "뭣이! 자세히 보면\n조금씩 다르단 말이다!" },
        { face: "A", time: 3, dialog: "앗, 자넨 누군가?" },
        { face: "F", time: 4, dialog: "음.. 소개가 늦었군.\n나는 제작자B요." },
        { face: "F", time: 4, dialog: "용량을 아끼느라 그런거니\n배경이 썰렁해도 이해하슈." },
        { face: "B", time: 0, dialog: "지루해.. -_-;" },
    ],
    "27": [
        { face: "C", time: 4, dialog: "훗훗훗.. 드디어 보스군.\n내 이름은 살모사!" },
        { face: "C", time: 4, dialog: "전편에서는 데모에만 나온\n비운의 악역이지!" },
        { face: "A", time: 3, dialog: "살모사 박사라구!\n산소야, 조심해라!" },
        { face: "B", time: 0, dialog: "네, 할아버지!" },
    ],
    "31": [
        { face: "D", time: 4, dialog: "우씨.. 두고보자!" },
        { face: "B", time: 0, dialog: "메에롱~" },
    ],
    "34": [
        { face: "B", time: 4, dialog: "여긴 우리학교잖아!\n근데 왜 이리 이상해?" },
        { face: "E", time: 4, dialog: "용량때문에\n다 삭제해서 그래." },
        { face: "A", time: 3, dialog: "전편에선 좀 나았는데.." },
        { face: "F", time: 0, dialog: "지금 배경은 전편의\n1/10분량의 타일이야!" },
    ],
    "39": [
        { face: "A", time: 3, dialog: "앗.. 도서관이..\n살모사의 짓인가.." },
        { face: "B", time: 3, dialog: "나쁜 녀석..\n아름다운 학교를.." },
        { face: "F", time: 0, dialog: "미안하다.\n용량때문에 내가 그런거야~" },
    ],
    "43": [
        { face: "B", time: 0, dialog: "이게 뭐야 -_-;" },
    ],
    "45": [
        { face: "E", time: 4, dialog: "이봐이봐, 정신차려!\n보스 등장이다!" },
        { face: "E", time: 6, dialog: "이번 보스는..\n전편에 이어 초대형 오리!" },
        { face: "E", time: 4, dialog: "..로 할려고 했는데\n삭제됐다. 험험." },
        { face: "C", time: 4, dialog: "좀 근사한 걸로\n주지 그랬어!" },
        { face: "A", time: 0, dialog: "자, 어쨌든 대결이다!" },
    ],
    "51": [
        { face: "D", time: 4, dialog: "부..분하다!\n보스만 컸어도..!" },
        { face: "A", time: 4, dialog: "자고로 정의는 승리하는 법!" },
        { face: "B", time: 0, dialog: "멋있어요 할아버지~" },
    ],
    "55": [
        { face: "E", time: 4, dialog: "어때,\n1등상은 탈 수 있을것 같나?" },
        { face: "A", time: 4, dialog: "쯧쯔.. 자고로 물욕에\n눈이 어두워선 망하는법." },
        { face: "E", time: 3, dialog: "당신도 라면만 먹으며\n게임 만들어 봐!" },
        { face: "E", time: 3, dialog: "게임제작자가 얼마나\n배고픈지 알아?" },
        { face: "F", time: 3, dialog: "흑흑.. 이 게임 만드느라\n나흘동안 초코파이밖에 못먹었다." },
        { face: "E", time: 3, dialog: "그래 이걸로 한 몫\n잡는거야 제작자B!" },
        { face: "F", time: 0, dialog: "따뜻한 밥이 먹고싶다\n제작자A!" },
    ],
    "63": [
        { face: "A", time: 4, dialog: "왜 계속 우주만 나오는거지." },
        { face: "F", time: 4, dialog: "용량땜에 삭제했어.." },
        { face: "B", time: 4, dialog: "에이 썰렁해!" },
        { face: "E", time: 4, dialog: "너 계속 떠들면\n머리카락 흔들리는 거" },
        { face: "E", time: 4, dialog: "정지시켜버린다!\n6프레임이나 된단말야." },
        { face: "F", time: 3, dialog: "그래 그러자~\n용량이 아깝다." },
        { face: "B", time: 0, dialog: "칫.. 치사해.." },
    ],
    "71": [
        { face: "E", time: 2, dialog: "보스등장!" },
        { face: "C", time: 2, dialog: "제작자 양반,\n이번엔 좀 큰 걸루.." },
        { face: "E", time: 6, dialog: "이번엔 믿어봐!" },
        { face: "A", time: 2, dialog: "아.. 아니 이건..!" },
        { face: "B", time: 4, dialog: "용량 아낀대더니..\n이게 뭐야!" },
        { face: "A", time: 4, dialog: "음.. 자고로.." },
        { face: "A", time: 4, dialog: "좋은게 좋은거지\n^_^;" },
        { face: "C", time: 4, dialog: "맞아 맞아~" },
        { face: "B", time: 0, dialog: "으이구 남자들이란;" },
    ],
    "81": [
        { face: "D", time: 4, dialog: "미인계도 실패야.." },
        { face: "A", time: 4, dialog: "쩝.. 아쉽군." },
        { face: "B", time: 4, dialog: "할아버지!" },
        { face: "C", time: 0, dialog: "두고보자 흑흑.." },
    ],
    "86": [
        { face: "E", time: 4, dialog: "거의 다 왔다.\n이번 판은 좀 어려워." },
        { face: "A", time: 4, dialog: "여기까지 와서\n물러날 순 없지!" },
        { face: "B", time: 4, dialog: "힘내자, 화이팅!" },
        { face: "F", time: 4, dialog: "레이저로는 이 스테이지를\n통과하지 못해." },
        { face: "F", time: 0, dialog: "스테이지 초반에\n'꽝'을 먹어두도록." },
    ],
    "92": [
        { face: "B", time: 4, dialog: "헉헉..\n정말 힘든 스테이지군." },
        { face: "A", time: 4, dialog: "산소야\n여기서 포기하면 안돼." },
        { face: "F", time: 0, dialog: "길을 잘 선택하도록." },
    ],
    "96": [
        { face: "F", time: 3, dialog: "드디어 보스까지 왔군." },
        { face: "E", time: 4, dialog: "이번 보스도 대형이다." },
        { face: "A", time: 3, dialog: "거짓말 마\n이젠 남은 용량이 없을걸." },
        { face: "B", time: 3, dialog: "맞아\n100k 다 썼겠다." },
        { face: "E", time: 6, dialog: "그럼 이건 어때?" },
        { face: "A", time: 3, dialog: "으헉 이게 뭐야 -_-;" },
        { face: "B", time: 3, dialog: "발악을 하는군." },
        { face: "C", time: 0, dialog: "훗훗훗, 이제 너흰 끝장이다!" },
    ],
    "105": [
        { face: "D", time: 2, dialog: "..." },
        { face: "D", time: 2, dialog: "..." },
        { face: "D", time: 2, dialog: "..." },
        { face: "B", time: 4, dialog: "뭐야, 뭐 말할라구." },
        { face: "D", time: 0, dialog: "... T_T" },
    ],
    "111": [
        { face: "F", time: 4, dialog: "드디어 끝판이다.\n훌륭해." },
        { face: "A", time: 4, dialog: "컨티뉴가 몇 개나 남았지." },
        { face: "B", time: 0, dialog: "과연 엔딩을 볼 수 있을까." },
    ],
    "115": [
        { face: "E", time: 4, dialog: "최종보스다, 조심해!" },
        { face: "C", time: 3, dialog: "후후.. 이번에는\n최강의 우주병기," },
        { face: "C", time: 4, dialog: "최신예 아스카\n불기둥이다!" },
        { face: "F", time: 0, dialog: "저 녀석 언제\n저걸 훔쳤지.." },
    ],
    "monitor": [
        { face: "C", time: 6, dialog: "에잇 그렇다면\n비장의 수단이닷!" },
        { face: "E", time: 3, dialog: "앗 안 돼!!!\n1등상인 모니터다!!" },
        { face: "F", time: 3, dialog: "모니터는 건드리지마!\n게임오버시킬거야!" },
        { face: "E", time: 3, dialog: "비싼건데 T_T" },
        { face: "C", time: 3, dialog: "후후.. 싸우기가\n한결 편해졌는걸." },
        { face: "A", time: 3, dialog: "어떻게 싸우란 말이냐!" },
        { face: "B", time: 3, dialog: "할아버지 조심해요!" },
        { face: "E", time: 0, dialog: "살모사 이 나쁜 놈!\n힘내라 할박사,산소!" },
    ],
    "monitorBroken": [
        { face: "F", time: 3, dialog: "1등상을 터트렸어!" },
        { face: "E", time: 0, dialog: "끝났어! 다 끝났다고!" },
    ],
    "ending": [
        { face: "C", time: 4, dialog: "이, 이런..!\n으으으아악!!" },
        { face: "D", time: 4, dialog: "잘 있어라 동무들아..\n나는 황천에 간다.." },
        { face: "B", time: 4, dialog: "와! 이겼어요\n할아버지!" },
        { face: "A", time: 4, dialog: "휴.. 간신히 이겼군." },
        { face: "E", time: 4, dialog: "잘 했다.\n칭찬해주고 싶군." },
        { face: "F", time: 4, dialog: "핫핫.\n수고 많이했다." },
        { face: "B", time: 4, dialog: "흠..이제 엔딩인가?" },
        { face: "F", time: 4, dialog: "으..엔딩?\n좀 썰렁할텐데." },
        { face: "B", time: 4, dialog: "괜찮으니까 보여줘." },
        { face: "E", time: 4, dialog: "좋아. 이제 게임 끝이다." },
        { event: "mode:intro", data: { endingFlag: true } },
    ]
};


const dialogSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.VsSprite( "effect" );
const textSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.VsHangul();

dialogSpr.attrib.enableHideMesh = true;
dialogSpr.attrib.disableGravity = true;

const textRT = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.RenderTarget( 200,40 );
const textBitmap = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Bitmap( textRT );

textBitmap.xy = [45,5];
dialogSpr.addChild( textBitmap );

let dialogTimer;

function showDialog( msg, index = 0 ) {
    if ( dialogTimer ) dialogTimer.stop();
    console.assert( msg,`잘못된 메시지 요청` );
    let d = dialogData[msg][index];

    if ( d == null ) {
        return;
    } else if ( d.event ) {
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( d.event,d.data ) );
        return;
    }
    dialogSpr.setAction( 3,0 );
    dialogSpr.xy = [15,180];
    dialogSpr.autoRemoveTimer = 120;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.addChildAt( dialogSpr, _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.getNumChildren() );
    textRT.clear();
    textSpr.setPalette( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.palette );
    textSpr.setColor( 0 );
    textSpr.setText( d.dialog );  
    textSpr.xy = [1,0];
    textRT.draw( textSpr );
    textSpr.xy = [1,2];
    textRT.draw( textSpr );
    textSpr.xy = [0,1];
    textRT.draw( textSpr );
    textSpr.xy = [2,1];
    textRT.draw( textSpr );
    textSpr.setColor( 15 );
    textSpr.xy = [1,1];
    textRT.draw( textSpr );
    dialogSpr.addChild( dialogSpr.getMesh( d.face.charCodeAt( 0 ) - 48 ) );
    // console.log( d.dialog );
    dialogTimer = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Timer.delayedCall( 1000 / 60 * d.time * 30,()=>{
        showDialog( msg,index + 1 );
    } );
}


_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "dialog",( e )=>{
    showDialog( e.msg,e.index );
} );


/***/ }),

/***/ "./games/PALO2/src/gameEvent.js":
/*!**************************************!*\
  !*** ./games/PALO2/src/gameEvent.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ "./games/PALO2/src/global.js");
/* harmony import */ var _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsWrapper/vs */ "./games/PALO2/src/vsWrapper/vs.js");





function ending() {
    // console.log( `엔딩` );
    // endFlag=1;
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "mode:intro",{ endingFlag: true } )  );
}


function message1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "dialog",{ msg: e.var2 } );
}

function music( e ) {
    // console.log( `음악 ${e.var2}` );
    switch ( e.var2 ) {
    case 0:
        // playXem(0,"space.xem");
        break;
    case 1:
        // playXem(0,"stage.xem");
        break;
    case 2:
        // playXem(0,"demo.xem");
        break;
    case 3:
        // sFadeOut();
        break;
    case 4:
        // sFadeOut();
        break;
    case 5:
        // sSetVolume(127);
        break;
    case 6:
        // sSetVolume(e.var3);
        break;
    }
}

function quake( ) {
    // console.log( `진동` );
    // setQuake(e.var3,e.var2);
}

function voice() {
    // 안씀
}

function scrollStop( ) {
    // console.log( `스크롤 스탑` );
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x = 0;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventTarget.velocity.x = 0;
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "bgm",{ filename: `boss` } );
}

function loadStage( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "stage",{ stageNumber: e.var2 } );
    return true;
}

function space( e ) {
    // console.log( `우주 설정 ${e.var2}` );
    switch ( e.var2 ) {
    case 0:
        // playXem(0,"stage.xem");
        // spaceFlag=-128;
        // spaceMove=1;
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "bgm",{ filename: `stage${_global__WEBPACK_IMPORTED_MODULE_1__["default"].currentStage}` } );
        // console.log( `우주에서 스테이지 진입` );
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.fade( {
            start:    -1,
            end:      0,
            duration: 300,
            range:    [128,255 ],
        } );
        break;
    case 1:
        // playXem(0,"space.xem");
        // spaceFlag=0;
        // spaceMove=-1;
        // console.log( `스테이지에서 우주로 진입` );
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.fade( {
            start:    0,
            end:      -1,
            duration: 50,
            range:    [128,255 ],
        } );
        break;
    }
}

function chain( ) {
    //
}

function init( e ) {
    if ( e.var2 < 0 ) {
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[-e.var2].flag = 1;
    } else {
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[e.var2].flag = 0;
    }
    if ( e.var3 < 0 ) {
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[-e.var3].flag = 1;
    } else {
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[e.var3].flag = 0;
    }
    if ( e.var4 < 0 ) {
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[-e.var4].flag = 1;
    } else {
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[e.var4].flag = 0;
    }
}

function palette( ) {
    // console.log( `팔레트 설정` );
    // fadePaletteWhenFlip(e.var2,mainPalette,e.var3,eventVar4[currentEvent]);
}

function paletteFade( e ) {
    // console.log( `팔레트 페이드` );
    let e2 = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[e.var4];

    // e2.var3 : dir
    // e2.var4 : speed
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.fade( {
        range:    [e2.var5,e.var2],
        start:    e2.var1 / 64,
        end:      e2.var2 / 64,
        duration: e2.var4,
    } );
}

// int setLens(int x,int y,int,int);
function lensFlare( e ) {
    // console.log( `렌즈 플레어` );
    let pos = [0.1,-0.35,-0.9,-1.1,-1.18];

    let espr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( null,{ x: e.x,y: e.y } );

    // espr.attrib.enableAutoRemoveStageOut = true;
    espr.attrib.disableGravity = true;
    espr.setUpdatePhaseCallback( ()=>{
        if ( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageX( espr.x ) < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.width + 10 ) {
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.fade( {
                start:    0.7,
                end:      0,
                duration: 300,
                range:    [0,255]
            } );
            for ( let i = 0; i < 5; i++ ) {
                let spr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( "effect",{
                    x:      0,
                    y:      0,
                    action: _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 7,8 ),
                } );

                spr.attrib.disableGravity = true;
                spr._currentMesh.setBlendMode( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite.BlendModes.ADD );
                spr._currentMesh.alpha = 0.5;
                spr.setUpdatePhaseCallback( ()=>{
                    let originPos = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageCoordinate( e.x,e.y );
                    let dx = originPos.x - 128;
                    let dy = originPos.y - 100;
        
                    dx = dx * pos[i];
                    dy = dy * pos[i];
                    let flarePos = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldCoordinate( 128 + dx,100 + dy );

                    spr.x = flarePos.x;
                    spr.y = flarePos.y;
                    if ( originPos.x < -10 ) {
                        spr.remove();
                    }
                } );
                _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.addChild( spr );
            }
            espr.remove();                    
        }
    } );
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer4.addChildAt( espr );
}


// int setZako1(int x,int y,int hp,int type,int level);
function zako1_1( e ) {
    let i;

    for ( i = 0; i < 6; i++ ) {
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
            type:    "zako1",
            x:       _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.width + i * 20 ),
            y:       e.y,
            hp:      e.var2,
            subType: 0,
            level:   e.var3,
            options: {
                spriteEvent: e,
                status4:     i * 10,
                status3:     e.var3,
            }
        } );
    }
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako1",
        x:       _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.width + i * 20 ),
        y:       e.y,
        hp:      e.var2,
        subType: 1,
        level:   e.var3,
        options: {
            spriteEvent: e,
            status4:     i * 10,
        }
    } );
    //		newSpr.status3=e.var3;
}

// int setZako2(int x,int y,int hp,int timer);
function zako2_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako2",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        timer:   e.var3,
        options: {
            spriteEvent: e,
        }
    } );
}

// int setZako3(int x,int y,int hp,int type);
function zako3_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako3",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        subType: e.var3,
        options: {
            spriteEvent: e,
        }
    } );
}

// int setZako4(int x,int y,int hp,int level);
function zako4_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako4",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        level:   e.var3,
        options: {
            spriteEvent: e,
        }
    } );
}


// int setZako5(int x,int y,int hp);
function zako5_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako5",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        options: {
            spriteEvent: e,
        }
    } );
}

// int setZako6(int x,int y,int hp);
function zako6_1( e ) {
    for ( let i = 0; i < 5; i++ ) {
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
            type:    "zako6",
            x:       _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.width + i * 15 ),
            y:       _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0, 189 ) + 5 ),
            hp:      e.var2,
            options: {
                spriteEvent: e,
            }
        } );
    }
}

// int setZako7(int x,int y,int hp,int level);
function zako7_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako7",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        level:   e.var3,
        options: {
            spriteEvent: e,
        }
    } );
}


// int setZako8(int x,int y,int hp,int level);
function zako8_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako8",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        level:   e.var3,
        options: {
            spriteEvent: e,
        }
    } );
}

// int setZako9(int x,int y,int hp);
function zako9_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako9",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        options: {
            spriteEvent: e,
        }
    } );
}


// int setZako10(int x,int y,int type);
function zako10_1( e ) {
    function setZako10( t ) {
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
            type:    "zako10",
            x:       _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,119 ) + 100 ),
            y:       _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 210 ),
            subType: t,
            options: {
                spriteEvent: e,
            }
        } );    
    }
    for ( let i = 0; i < e.var2; i++ ) {
        setZako10( 1 );
    }
    for ( let i = 0; i < e.var3; i++ ) {
        setZako10( 0 );
    }
    for ( let i = 0; i < e.var4; i++ ) {
        setZako10( 2 );
    }
    for ( let i = 0; i < e.var5; i++ ) {
        setZako10( 3 );
    }
    
    return true;
}

// int setZako11(int x,int y,int hp);
function zako11_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "spawn:zako",{
        type:    "zako11",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        options: {
            spriteEvent: e,
        }
    } ) );
}

// int setZako12(int x,int y,int hp);
function zako12_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako12",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        options: {
            spriteEvent: e,
        }
    } );
}

// int setZako13(int x,int y,int hp);
function zako13_1( e ) {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:zako",{
        type:    "zako13",
        x:       e.x,
        y:       e.y,
        hp:      e.var2,
        options: {
            spriteEvent: e,
        }
    } );
}


function moveGhost( e ) {
    // console.log( `스크롤타겟 이동 ${e.x},${e.y}` );
    // 월드 아래의 모든 스프라이트를 같이 옮겨준다.
    // 이것은 구 VS엔진이 좌표계를 다루는 문제와의 호환성 때문에 하는 것이다.
    // 스테이지 초반에 우주에서 진입할 때 한 번 일어난다.
    // let adjustX = vsStage.world.scrollTarget.x - e.x;
    // let adjustY = vsStage.world.scrollTarget.y - e.y;
    // let sprs = vsStage.world.searchChildren();
    // for ( let spr of sprs ) {
    //     if (spr instanceof VsSprite) {
    //         spr.x -= adjustX;
    //         spr.y -= adjustY;
    //     }
    // }
    // vsStage.world.scrollTarget.x = e.x;
    // vsStage.world.scrollTarget.y = e.y;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventTarget.x = e.x;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventTarget.y = e.y;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x = _global__WEBPACK_IMPORTED_MODULE_1__["default"].scrollSpeed;
    // console.log( vsStage.world.scrollTarget.x );
}

const eventTable = [
    null,                   //0
    message1,
    music,
    chain,
    quake,
    voice,
    scrollStop,
    moveGhost,
    loadStage,
    space,
    //10
    init,
    palette,
    paletteFade,
    lensFlare,
    ending,
    null,
    null,
    null,
    null,
    null,
    //20
    zako1_1,
    zako2_1,
    zako3_1,
    zako4_1,
    zako5_1,
    zako6_1,
    zako7_1,
    zako8_1,
    zako9_1,
    zako10_1,
    //30
    zako11_1,
    zako12_1,
    zako13_1,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    //40
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    //50
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    //60
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    //70
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    //80
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    //90
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    //100
    null,
    null,
    null,
    
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    //110
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
];



function processGameEvent( e ) {
    if ( e.eventNumber == 0 ) return;
    // console.log( `게임이벤트:${e.eventNumber},${e.eventTypeNumber}` );

    const world = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world;

    let eventNum = e.eventNumber;

    if ( eventNum != null ) {
        do {
            // var1이 type
            let eventTypeNum = world.eventData.eventVars[eventNum].var1;

            console.assert( eventTypeNum != 0 && eventTable[eventTypeNum], `존재하지 않는 이벤트를 호출 ${eventTypeNum}` );
            let evars = world.eventData.eventVars[eventNum];

            if ( evars.flag == 0 ) {
                // 플래그가 0 이었을 경우 실행
                // console.log( `이벤트실행:${eventNum}->${eventTypeNum},${JSON.stringify( evars )}` );
                let result = eventTable[ eventTypeNum ]( evars );

                if ( evars.flag < 255 ) {
                    evars.flag++;
                }
                //@ts-ignore
                if ( result != true && evars.var5 > 0 ) {
                    eventNum = evars.var5;
                } else {
                    eventNum = -1;
                }
            } else {
                eventNum = -1;
            }
        } while ( eventNum > 0 );
    } else {
        eventTable[ e.eventTypeNum ]( e.eventVars );
    }
}

_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "gameEvent", processGameEvent );


/***/ }),

/***/ "./games/PALO2/src/gameLoop.js":
/*!*************************************!*\
  !*** ./games/PALO2/src/gameLoop.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ "./games/PALO2/src/global.js");
/* harmony import */ var _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsWrapper/vs */ "./games/PALO2/src/vsWrapper/vs.js");




const START_STAGE = 1;

let starSpeed;
let originalStarSpeed;

let continueScrollVelocity;
let continueEventVelocity;
let continueSpr;

let scrollTargetSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite();

let eventTargetSpr =  new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite();

eventTargetSpr.onStage( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME,function() {
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "gameEvent",{ eventNumber: _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getMapEventNumber( this.x,this.y ) } ) );
} );

let statusSpr = [];

const MAX_STAR = 40;

function changeBGM( e ) {
    // console.log( `사운드 플레이 ${e.filename}` );
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSingleSound( `${e.filename}.m4a`,0.5,true,"bgm" );
}

function setStars() {
    // init stars

    const starColorArray = [7,8,15];

    for ( let i = 0; i < MAX_STAR; i++ ) {
        let x = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,259 );
        let y = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,199 );
        let vx = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 1,3 );
        let c = starColorArray[_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,2 )];
        let px = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Pixel( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsPalette.indexToColor( c ),1 );

        px.setShader( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.createShader() );
        px.xy = [x,y];
        px.onStage( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME, function() {
            px.x -= starSpeed / vx;
            if ( px.x < 0 ) {
                px.x = 260 + _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,260 );
            }
        } );
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.addChild( px );
    }
}

function setStatus( player ) {
    let playerSpr = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[player];
    let spr = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();
    let text;

    if ( playerSpr == null || playerSpr.gameOver ) {
        if  ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[3 - player] == null || _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[3 - player].gameOver ) {
        // 게임 오버
            showContinue();
        } 
        if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].restCoin > 0 ) {
            text = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSystemText( `CONTINUE ${_global__WEBPACK_IMPORTED_MODULE_1__["default"].restCoin}` );
        } else {
            text = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSystemText( `GAME OVER` );
        }
        text.xy = [( player - 1 ) * 128 + 40,192];
        spr.addChild( text );
    } else {
        text = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSystemText( `${playerSpr.name} ${playerSpr.rest} ${playerSpr.score.toString().padStart( 8,"0" )}` );
        text.xy = [( player - 1 ) * 128 + 20,192];
        spr.addChild( text );

        let effectSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( "effect" );

        for ( let i = 0; i < 7; i++ ) {
            if ( playerSpr.power == i ) {
                let barText = effectSpr.getMesh( i );

                barText.xy = [( player - 1 ) * 128 + 20 + i * 12,185];
                let bar = effectSpr.getMesh( playerSpr.isBarEmpty[i] ? 10 : 9 );

                bar.xy = [( player - 1 ) * 128 + 20 + i * 12,185];
                spr.addChild( bar );
                spr.addChild( barText );
            } else {
                let bar = effectSpr.getMesh( playerSpr.isBarEmpty[i] ? 8 : 7 );

                bar.xy = [( player - 1 ) * 128 + 20 + i * 12,185];
                spr.addChild( bar );
            }
        }
    }
    if ( statusSpr[player] ) statusSpr[player].removeFromParent();
    statusSpr[player] = spr;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.addChild( spr );
}

function doContinue() {
    if ( continueSpr ) {
        continueSpr.removeFromParent();
        continueSpr = null;
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x = continueScrollVelocity;
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventTarget.velocity.x = continueEventVelocity;
    }

    setStatus( 1 );
    setStatus( 2 );
}

function showContinue() {
    if ( continueSpr ) return;
    let spr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSystemText();
    let continueTimer = 600;

    continueSpr = spr;
    spr.xy = [100,93];
    continueScrollVelocity = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x;
    continueEventVelocity = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventTarget.velocity.x;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x = 0;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventTarget.velocity.x = 0;

    spr.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME,()=>{
        if ( continueSpr == null ) {
            spr.removeFromParent();
            return;
        }
        if ( ( continueTimer % 60 ) == 0 ) {
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].restCoin > 0 ) {
                spr.setText( `CONTINUE? ${continueTimer / 60}` );
            } else {
                spr.setText( `GAME OVER` );
            }
        }
        continueTimer--;
        if ( continueTimer <= -60 ) {
            // 완전히 끝
            spr.removeFromParent();
            continueSpr = null;
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "mode:title" );
        }
    } );
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.addChild( spr );
}

async function gameLoop( gameSetting ) {
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.clearChildren();
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.backgroundColor = 128;
    _global__WEBPACK_IMPORTED_MODULE_1__["default"].players = [];

    setStars();

    // 여기를 수정하면 시작 스테이지가 바뀐다
    changeStage( { stageNumber: START_STAGE } );

    if ( gameSetting.player1 ) {
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:player",{ player: 1 } );
    }
    if ( gameSetting.player2 ) {
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "spawn:player",{ player: 2 } );
    }

    setStatus( 1 );
    setStatus( 2 );
}

async function changeStage( e ) {
    let scrollSpeed;
    let legacyCoordinateMode = 0;
    let canBreakBlock = false;

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.setPalette( new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsPalette( `stage${e.stageNumber}` ) );

    switch ( e.stageNumber ) {
    case 1:
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.rotate();
        scrollSpeed = 0.5;
        originalStarSpeed = starSpeed = 0.5;
        break;
    case 2:
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.rotate( {
            range: [256 - 8,254],
            speed: 4
        } );
        scrollSpeed = 0.5;
        originalStarSpeed = starSpeed = 0.5;
        break;
    case 3:
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.rotate( {
            range: [256 - 20,252],
            speed: 4
        } );
        scrollSpeed = 0.25;
        originalStarSpeed = starSpeed = 1;
        legacyCoordinateMode = 1;
        break;
    case 4:
        canBreakBlock = true;
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.rotate();
        scrollSpeed = 10 / 16;
        originalStarSpeed = starSpeed = 10 / 16;
        break;
    case 5:
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.rotate();
        scrollSpeed = 0.25;
        originalStarSpeed = starSpeed = 0.25;
        legacyCoordinateMode = 2;
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.colorArray[128] = 0;    // 스테이지 5 팔레트 배경이 회색으로 되어있어서 수정
        break;
    }

    // 배경만 숨김
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.add( -1,128,255 );
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "bgm",{ filename: `space` } );

    let oldWorldPos;

    if ( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world ) oldWorldPos = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.position;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.setWorld( new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsWorld( `stage${e.stageNumber}` ),true );

    if ( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget ) {
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.removeFromParent();
    }
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.gravity.y = 0.1388;
    // console.log( `맵사이즈 ${vsStage.world.mapWidth},${vsStage.world.mapHeight}` );
    if ( legacyCoordinateMode == 1 ) {
        scrollTargetSpr.xy = [-390,180];
    } else if ( legacyCoordinateMode == 2 ) {
        scrollTargetSpr.xy = [-390 + 82,180];
    } else {
        scrollTargetSpr.xy = [-84,180];
    }
    scrollTargetSpr.attrib.enableDebug = true;
    scrollTargetSpr.attrib.disableGravity = true;
    // console.log( `스크롤 시작 지점 ${scrollTargetSpr.x},${scrollTargetSpr.y}` );
    scrollTargetSpr.velocity.x = 0.5;//scrollSpeed;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.setScrollTarget( scrollTargetSpr );
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventTarget = eventTargetSpr;
    eventTargetSpr.velocity.x = scrollSpeed;
    eventTargetSpr.xy = [_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[0].x,_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventData.eventVars[0].y];
    eventTargetSpr.attrib.enableDebug = true;
    eventTargetSpr.attrib.disableGravity = true;
    // vsStage.world.safeBorder = 5 * 16;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer0.addChild( scrollTargetSpr );
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer0.addChild( eventTargetSpr );

    _global__WEBPACK_IMPORTED_MODULE_1__["default"].scrollSpeed = scrollSpeed;
    _global__WEBPACK_IMPORTED_MODULE_1__["default"].canBreakBlock = canBreakBlock;
    _global__WEBPACK_IMPORTED_MODULE_1__["default"].currentStage = e.stageNumber;

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.processScroll();

    if ( oldWorldPos ) {
        let sprs = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.searchChildren();
        let adjustX = oldWorldPos.x - _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.x;
        let adjustY = oldWorldPos.y - _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.y;

        for ( let spr of sprs ) {
            if ( spr instanceof _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite && spr != scrollTargetSpr && spr != eventTargetSpr ) {
                spr.x += adjustX;
                spr.y += adjustY;
            }
        }
    }
}

_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "bgm", changeBGM );
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "stage", changeStage );
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "mode:gameLoop", gameLoop );
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "refreshUI", ( e )=>{
    setStatus( e.player );
} );
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "continue", doContinue );


/***/ }),

/***/ "./games/PALO2/src/global.js":
/*!***********************************!*\
  !*** ./games/PALO2/src/global.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./player */ "./games/PALO2/src/player.js");



class AppData {
    constructor() {
        this.currentStage = 0;
        this.scrollSpeed = 0;
        /** @type {Player[]} */
        this.players = [];
        this.restCoin = 0;
        this.canBreakBlock = false;
    }
}

const GLOBAL = new AppData();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GLOBAL);


/***/ }),

/***/ "./games/PALO2/src/intro.js":
/*!**********************************!*\
  !*** ./games/PALO2/src/intro.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsWrapper/vs */ "./games/PALO2/src/vsWrapper/vs.js");



async function intro( e ) {
    const demoPal = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.VsPalette( "demo" );

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.setPalette( demoPal );
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.backgroundColor = 0;
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.clearChildren();
    const demoSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.VsSprite( "demo" );
    let timer;

    const eventSpr = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.addChild( eventSpr );

    function hputs( s,x,y ) {
        // console.log( `데모메시지:${s}` );
        let t = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.VsHangul();

        t.setColor( 128 - 32 + 15,128 - 32 );
        t.setText( s );
        t.xy = [x,y];
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.addChild( t );
    }

    function demoFade( slideNum ) {
        return new Promise( ( resolve )=>{
            demoPal.fade( { start: -1,end: 1, duration: 400, range: [128 - 32,128 - 32 + 15] } );
            if ( slideNum > 0 ) {
                let s = demoSpr.getMesh( slideNum + 7 );

                s.xy = [15,10];
                _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.addChild( s );
            }
            timer = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Timer.delayedCall( 1000 / 60 * 705, ()=>{
                _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.clearChildren();
                _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.addChild( eventSpr );
                resolve();
            } );
        } );
    }

    // console.log( `인트로 화면` );
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "bgm",{ filename: "intro" } );
    eventSpr.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.REMOVED_FROM_STAGE, () => {
        // console.log( "인트로 이벤트 스프라이트 삭제" );
        timer.stop();
    } );
    eventSpr.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_DOWN, e => {
        e.stopPropagation();
        // console.log( `키입력 ${e.keyCode}` );
        if ( e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.SPACE || e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.ESC || e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.ENTER ) {
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.clearChildren();
            timer.stop();
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "mode:title" );
        }
    } );
    if ( e.endingFlag == true ) {
        hputs(  "할박사 일행은 우주 대악마 살모사 박사를\n" +
                "무찌르고 지구로 귀환하였다.\n" +
                "다시 우주에는 평화가 찾아왔다...",10,120 );
        await demoFade( 4 );
        hputs(  "지금까지 본 게임을 플레이해주신\n" +
                "여러분께 깊은 감사를 드립니다.\n" +
                "오브젝트 스퀘어의 다음 게임인\n" +
                "학원 호러 어드벤쳐 (8.15해저드)를\n" +
                "기대해 주십시오! 언제 나올진 몰라요.",10,40 );
        await demoFade( 0 );
    } else {
        hputs( "우리는 역사와 민족 앞에 진심으로\n참회하며 이 기록을 남긴다",10,70 );
        hputs( "         1997년 2월\n    표류 850일째, DR.할",80,130 );
        await demoFade( 0 );

        hputs( "단기 1997+2333년",10,10 );
        hputs( "오브젝트 스퀘어 앞으로 의문의\n초대장이 도착하였다.",30,30 );
        hputs(  "(100K 게임 공모전을 개최한다.\n" +
                "    - 길어서 삭제 -\n" +
                " 부디 왕림하여 자리를 빛내주기 바란다)\n" +
                "        from 하이텔 게임제작동호회",30,70 );
        let cardSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.VsSprite( "demo",{ x: 128,y: 170 } );

        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.vsStage.addChild( cardSpr );
        await demoFade( 0 );

        hputs( "오브젝트 스퀘어 팀은 3년전 우주 대악마\n" +
            "살모사 박사에게 대항하기 위해 할박사와\n" +
            "산소를 보냈다.",10,120 );
        await demoFade( 1 );

        hputs( "그러나 공짜로 얻은 캡춰보드를 끼우다\n" +
            "하드를 날려먹는 오브젝트 스퀘어 팀...\n" +
            "덕분에 할박사와 산소는 1 스테이지를\n" +
            "클리어 후 우주미아가 되고만다.",10,120 );
        await demoFade( 2 );

        hputs( "지구로 돌아가고 싶은 산소와 할박사,\n" +
            "그러나 그들은 오브젝트 스퀘어를 원망하지\n" +
            "않았다!",10,120 );
        await demoFade( 3 );

        hputs( "고생 끝에 낙이 오는 법. 공짜를 밝히는\n" +
            "오브젝트 스퀘어 팀의 야욕과 함께 할박사\n" +
            "일행은 지구로 돌아온다. 그들에게 내려진\n" +
            "임무는 공모전에서 상을 타오는 것.",10,120 );
        await demoFade( 4 );

        hputs( "100K에 끼워 맞추기 위해 내용을 마구\n" +
            "삭제한 85되었수다 스페셜과 함께 두명은\n" +
            "다시 출격하지만, 역시 이번 대회에도\n" +
            "뭔가 악의 기운이...",10,120 );
        await demoFade( 5 );
    }
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "mode:title" );
}

_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "mode:intro",intro );



/***/ }),

/***/ "./games/PALO2/src/player.js":
/*!***********************************!*\
  !*** ./games/PALO2/src/player.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Player": () => (/* binding */ Player)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ "./games/PALO2/src/global.js");
/* harmony import */ var _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsWrapper/vs */ "./games/PALO2/src/vsWrapper/vs.js");




const controlKeys = {
    "1": {
        "up":      [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.UP,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.I],
        "down":    [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.DOWN,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.K],
        "left":    [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.LEFT,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.J],
        "right":   [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.RIGHT,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.L],
        "shoot":   [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.SPACE,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.N],
        "powerUp": [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.CTRL,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.M],    
    },
    "2": {
        "up":      [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.W],
        "down":    [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.S],
        "left":    [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.A],
        "right":   [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.D],
        "shoot":   [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.Z],
        "powerUp": [_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.X],    
    }
};

const OptionInterval = 16;

/**
 * 플레이어 스프라이트 클래스
 * 
 *
 * @class Player
 * @extends {VsSprite}
 */
class Player extends _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite {
    constructor( e ) {
        super( e.player == 1 ? "p_hal" : "p_crys" );
        let x = 60;
        let y = e.player == 1 ? 50 : 110;
 
        this.position = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldCoordinate( x,y );
        this.attrib.disableGravity = true;
        this.attrib.enableMapCollisionBottom = true;
        this.attrib.enableMapCollisionTop = true;
        this.attrib.enableMapCollisionLeft = true;
        this.attrib.enableMapCollisionRight = true;
        // this.attrib.enableDebug = true;
        this.player = e.player;
        this.name = e.player == 1 ? "HAL" : "O2 ";
        this.rest = 3;
        this.gameOver = false;
        this.score = 0;
        this.maxOption = 3;
        this.readyTimer = 0;

        this.setUpdatePhaseCallback( this.update );
        this.setMapCollisionPhaseCallback( ( flag )=>{
            if ( flag != 0 ) {
                this.onHit();
            }
        } );
        this.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_DOWN,this.keyHandler.bind( this,true ) );
        this.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_UP,this.keyHandler.bind( this,false ) );
        this.inputs = {};
        this.newInputs = {};

        this.optionIndex = 0;
        this.optionBuffer = [];
        this.resetPowerUp();
        this.on( "hit",this.onHit );
    }

    revive() {
        this.x = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( -10 );
        this.setAction( 12 );
        this.readyTimer = 200;
        this.attrib.enableFlicker = true;
        this.attrib.enableMapCollisionLeft = false;
        this.attrib.enableMapCollisionRight = false;
        this.attrib.enableMapCollisionTop = false;
        this.attrib.enableMapCollisionBottom = false;
        this.setMapCollisionPhaseCallback( null );

        this.gameOver = false;
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "continue" );
    }

    onHit( e ) {
        if ( this.gameOver ) return;
        if ( e != null && e.forceHit != true && this.readyTimer > 0 ) return;
        
        this.maxOption = 3;
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `bang.wav` );
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "explosion", { x: this.x,y: this.y,count: 10,power: 1 } );
        this.resetPowerUp();
        if ( this.rest == 0 ) {
            this.inputs.shoot = false;
            this.rest = 3;
            this.gameOver = true;
            this.setAction( 0 );
            this.x = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( -50 );
            // this.y = vsStage.world.getWorldY( -100 );
            this.velocity.x = 0;
            this.velocity.y = 0;
            this.attrib.enableMapCollisionLeft = false;
            this.attrib.enableMapCollisionRight = false;
            this.attrib.enableMapCollisionTop = false;
            this.attrib.enableMapCollisionBottom = false;
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "refreshUI",{ player: this.player } );
        } else {
            this.rest--;
            this.revive();
        }
    }

    resetPowerUp() {
        this.power = -1;
        this.isBarEmpty = [false,false,false,false,false,false,false];
        this.missile = false;
        this.moveSpeed = 0.55;
        this.weapon = "normal";
        if ( Array.isArray( this.options ) ) this.options.forEach( spr => {
            spr.remove( "reset" );
        } );
        this.options = [];
        this.shield = null;
        
        this.autoShootCoolDown = 10;
        this.autoShootReset = 11;
        this.autoShootCount = this.autoShootReset;

        this.missileDelay = 60;
        this.missileCount = 0;
    }

    keyHandler( isDown,e ) {
        // console.log( e );
        if ( isDown == false && e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.O ) _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "stage",{ stageNumber: 2 } );
        let controlMap = controlKeys[this.player];

        for ( let input in controlMap ) {
            if ( controlMap[input].indexOf( e.keyCode ) >= 0 ) {
                if ( isDown && !this.inputs[input] ) {
                    this.newInputs[input] = true;
                }
                this.inputs[input] = isDown;
            }
        }
    }

    update() {
        if ( this.gameOver ) {
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].restCoin > 0 && this.inputs.shoot ) {
                // continue 
                _global__WEBPACK_IMPORTED_MODULE_1__["default"].restCoin--;
                this.revive();
                this.inputs.shoot = false;
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `power.wav` );
            }
            return;
        }

        if ( this.readyTimer ) {
            this.readyTimer--;
            if ( this.readyTimer == 0 ) {
                this.setMapCollisionPhaseCallback( ( flag )=>{
                    if ( flag != 0 ) {
                        this.onHit();
                    }
                } );
                this.attrib.enableFlicker = false;
                this.attrib.enableMapCollisionLeft = true;
                this.attrib.enableMapCollisionRight = true;
                this.attrib.enableMapCollisionTop = true;
                this.attrib.enableMapCollisionBottom = true;
            }
        }
        // 스크롤 속도에 맞춘다
        let scrollSpeed = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x;
        let isMoved = false;


        // 방향키 처리
        if ( this.readyTimer < 140 ) {
            if ( this.inputs.up ) {
                this.setAction( 1 );
                this.velocity.y = -this.moveSpeed;
                isMoved = true;
            } else if ( this.inputs.down ) {
                this.setAction( 3 );
                this.velocity.y = this.moveSpeed;
                isMoved = true;
            } else {
            // 상하 움직임이 없을 경우
                if ( this.action == 1 ) this.setAction( 2 );
                if ( this.action == 3 ) this.setAction( 4 );
                this.velocity.y = 0;
            }
            if ( this.inputs.left ) {
                this.velocity.x = -this.moveSpeed;
                isMoved = true;
            } else if ( this.inputs.right ) {
                this.velocity.x = this.moveSpeed;
                isMoved = true;
            } else {
                this.velocity.x = 0;
            }
        } else {
            this.velocity.x = 0;
            this.velocity.y = 0;    
        }
        // 화면 밖으로 넘어가지 못하게 처리
        if ( this.x < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 5 ) || this.x > _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 250 ) ) {
            this.velocity.x = 0;
            this.x = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( this.x,_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 5 ),_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 250 ) );
        }
        if ( this.y < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 5 ) || this.y > _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 195 ) ) {
            this.velocity.y = 0;
            this.y = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( this.y,_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 5 ),_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 195 ) );
        }
        // 스크롤 속도에 맞춰서 비행
        this.velocity.x += scrollSpeed;

        if ( this.inputs.shoot ) {
            this.shoot();
        } else {
            this.autoShootCount = this.autoShootReset;
        }
        if ( this.newInputs.powerUp ) {
            this.newInputs.powerUp = false;
            this.powerUp();
        }

        if ( this.missileCount > 0 ) this.missileCount--;

        if ( isMoved && this.options.length > 0 ) {
            this.optionBuffer.push( [_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageX( this.x ),_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageY( this.y )] );
            if ( this.optionBuffer.length > OptionInterval * this.optionBuffer.length ) {
                this.optionBuffer = this.optionBuffer.splice( 0,this.optionBuffer.length - ( OptionInterval * this.optionBuffer.length ) );
            }
        }
    }

    optionUpdate() {
        /** @type {Player} */
        //@ts-ignore
        let owner = this.owner;

        if ( owner.optionBuffer.length > 0 ) {
            let readPos = Math.max( 0,owner.optionBuffer.length - this.optionIndex * OptionInterval );
            let x = owner.optionBuffer[readPos][0];
            let y = owner.optionBuffer[readPos][1];

            this.position = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldCoordinate( x,y );
        } else {
            this.position = owner.position;
        }
    }

    shoot() {
        const createBullet = ( damage )=> {
            let spr = this.createVsSprite( {
                x:      this.x,
                y:      this.y,
                action: 5,
            } );

            spr.attrib.disableGravity = true;
            spr.attrib.enableAutoRemoveStageOut = true;
            spr.attrib.enableMapCollisionRight = true;
            spr.velocity.x = 10;
            spr.setMapCollisionPhaseCallback( ( flag, info )=>{
                if ( flag ) {
                    if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].canBreakBlock ) {
                        info.collideList.forEach( v=>{
                        // collideList는 충돌 정보를 담은 어레이
                        // [x,y,mapNum] 순으로 담겨 있다
                            if ( damage >= 10 && ( v[2] == 1 || v[2] == 2 ) ) {
                            // 레이저는 damage가 5니까 일반 탄만 블록을 부술 수 있도록
                                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "explosion", { x: ( v[0] << 4 ) + 8,y: ( v[1] << 4 ) + 8,count: 1,power: 0 } );
                                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `zako.wav` );
                                _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.setMap( v[0],v[1],v[2] - 1 );
                            } 
                        } );
                    }
                    spr.remove( "block" );
                }
            } );
            spr.setCollisionPhaseCallback( ( sprs )=>{
                for ( let target of sprs ) {
                    if ( target.isEnemy && spr.checkRange( target,0,0 ) ) {
                        target.dispatchEvent( "hit",{ type: "bullet", damage: damage, owner: this } );
                        spr.remove( "enemyHit" );
                    }
                }
            } );
            return spr;
        };

        if ( this.optionIndex == 0 ) this.options.forEach( ( option )=>{
            option.missile = this.missile;
            option.missileCount = this.missileCount;
            option.weapon = this.weapon;
            option.autoShootCount = this.autoShootCount;
            option.autoShootCoolDown = this.autoShootCoolDown;
            option.shoot(); 
        } );

        if ( this.missile && this.missileCount == 0 ) {
            let spr = createBullet( 40 );

            spr.action = 7;
            spr.velocity.x = 1.75;
            spr.attrib.enableMapCollisionTop = true;
            spr.attrib.enableMapCollisionBottom = true;
            spr.attrib.enableMapCollisionLeft = true;
            spr.attrib.disableGravity = false;
            spr.setMapCollisionPhaseCallback( ( flag )=>{
                if ( flag & _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsWorld.TILEATTRIB_RWALL ) {
                    spr.remove( "block" );
                }
            } );
            // spr.setMapCollisionPhaseCallback();
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer2.addChild( spr );
            this.missileCount = this.missileDelay;
        }

        this.autoShootCount--;
        if ( this.autoShootCount < this.autoShootCoolDown ) {
            if ( this.autoShootCount == 0 ) {
                this.autoShootCount = this.autoShootReset;
            }
            return;
        }

        if ( this.weapon == "normal" || this.weapon == "double" ) {
            if ( this.optionIndex == 0 ) _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `shoot.wav` );
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer2.addChild( createBullet( 10 ) );
        }
        if ( this.weapon == "double" ) {
            let spr = createBullet( 10 );

            spr.velocity.y = -6;
            spr.attrib.enableMapCollisionTop = true;
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer2.addChild( spr );
        }
        if ( this.weapon == "laser" ) {
            if ( this.optionIndex == 0 && this.autoShootCount == this.autoShootReset - 1 ) {
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `laser.wav` );
            }
            let spr = createBullet( 5 );

            spr.action = 6;
            spr.velocity.x = 30;
            spr.attrib.enableMapCollisionTop = true;
            spr.attrib.enableMapCollisionBottom = true;
            spr.setUpdatePhaseCallback( ()=>{
                spr.y = this.y;
            } );
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer2.addChild( spr );
        }
    }

    powerUp() {
        if ( this.power < 0 || this.isBarEmpty[this.power] ) return;
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `power.wav` );
        switch ( this.power ) {
        case 0: // 스피드업
            this.moveSpeed += 0.5;
            if ( this.moveSpeed >= 3 ) this.isBarEmpty[this.power] = true;
            break;
        case 1: // 미사일
            this.missile = true;
            this.isBarEmpty[this.power] = true;
            break;
        case 2: // 더블
            this.weapon = "double";
            this.isBarEmpty[this.power] = true;
            this.isBarEmpty[3] = false;
            this.autoShootCoolDown = 10;
            this.autoShootReset = 11;
            break;
        case 3: // 레이저
            this.weapon = "laser";
            this.isBarEmpty[this.power] = true;
            this.isBarEmpty[2] = false;
            this.autoShootCoolDown = 20;
            this.autoShootReset = 50;
            break;
        case 4: // 옵션
            {
                /** @type {Player} */
                //@ts-ignore
                let optionSpr = this.createVsSprite( { x: this.x,y: this.y,action: 8 } );

                Object.setPrototypeOf( optionSpr,Player.prototype );
                optionSpr.attrib.disableGravity = true;
                //@ts-ignore
                optionSpr.owner = this;
                optionSpr.player = this.player;
                optionSpr.setUpdatePhaseCallback( this.optionUpdate );
                this.options.push( optionSpr );
                optionSpr.optionIndex = this.options.length;
                if ( this.options.length == this.maxOption ) this.isBarEmpty[this.power] = true;
                _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer2.addChild( optionSpr );
            }
            break;
        case 5: // 보호막
            {
                let shield = this.createVsSprite( { action: 13 } );

                //@ts-ignore
                shield.life = 100;
                //@ts-ignore
                shield.playerNumber = this.player;
                shield.attrib.disableGravity = true;
                shield.on( "hit",( e )=>{
                    //@ts-ignore
                    shield.life -= e.damage;
                    //@ts-ignore
                    if ( shield.life <= 0 ) {
                        // 실드 파괴
                        shield.remove();
                        this.isBarEmpty[5] = false;
                        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "refreshUI",{ player: this.player } );
                    }
                } );
                shield.setUpdatePhaseCallback( ()=>{
                    shield.white = 0;
                } );
                this.isBarEmpty[this.power] = true;
                this.addChild( shield );

                this.shield = shield;
            }
            break;
        case 6: // 꽝
            this.resetPowerUp();
            break;
        }
        this.power = -1;
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "refreshUI",{ player: this.player } );
    }
}

function gameOver() {
    _global__WEBPACK_IMPORTED_MODULE_1__["default"].restCoin = 0;
    for ( let i = 1; i <= 2; i++ ) {
        if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[i] ) {
            _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[i].rest = 0;
            _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[i].dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "hit",{ forceHit: true } ) );
        }
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "refreshUI",{ player: i } );
    }
}

function spawnPlayer( e ) {
    let spr = new Player( e );

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
    _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[e.player] = spr;
}

_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "gameOver", gameOver );
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "spawn:player", spawnPlayer );


/***/ }),

/***/ "./games/PALO2/src/title.js":
/*!**********************************!*\
  !*** ./games/PALO2/src/title.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ "./games/PALO2/src/global.js");
/* harmony import */ var _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsWrapper/vs */ "./games/PALO2/src/vsWrapper/vs.js");




const MAX_STAR = 40; 


async function title() {
    const titlePal = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsPalette( "stage1" );

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.setPalette( titlePal );
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.setWorld( null ); // world 날리고
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.clearChildren();
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.backgroundColor = 0; // 배경 메시 생김

    {
        // init stars

        const starColorArray = [7,8,15];
    
        for ( let i = 0; i < MAX_STAR; i++ ) {
            let x = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,259 );
            let y = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,199 );
            let vx = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 1,3 );
            let c = starColorArray[_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,2 )];
            let px = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Pixel( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsPalette.indexToColor( c ),1 );

            px.setShader( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.createShader() );
            px.xy = [x,y];
            px.onStage( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME, function() {
                px.x -= vx;
                if ( px.x < 0 ) {
                    px.x = 260 + _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,259 );
                }
            } );
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.addChild( px );
        }
    }

    const titleSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( "effect",{ x: 128,y: 40,action: 2 } );

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.addChild( titleSpr );
    const titleSpr2 = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( "effect",{ x: 128,y: 40,action: 5 } );

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.addChild( titleSpr2 );

    let coin = _global__WEBPACK_IMPORTED_MODULE_1__["default"].restCoin = 4;
    let textSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSystemText();

    // t.setColor( 15 );
    textSpr.setText( `1P START\n\n2P START\n\n1P and 2P START\n\nREPLAY INTRO\n\nEXIT TO DOS\n\n\nCONTINUE ${coin}` );
    textSpr.xy = [ 90,105 ];
    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.addChild( textSpr );

    // 쾅하고 번쩍거리는 효과
    titlePal.fade( { start: 1,end: 0, duration: 60, range: [0,254] } );
    // Sound.playSound( `bang.wav` );
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "bgm",{ filename: "title" } );

    const playerSprFiles = ["p_hal","p_crys"];
    const selectorSpr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( playerSprFiles[_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 )],{ x: 75,y: 108,action: 0 } );

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.addChild( selectorSpr );
    let selector = 0;
    let demoTimer = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Timer.delayedCall( 15 * 1000,()=>{
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "mode:intro" );
    } );

    selectorSpr.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.REMOVED_FROM_STAGE, () => {
        demoTimer.stop();
    } );

    selectorSpr.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_DOWN, async ( e )=>{
        if ( e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.UP && selector > 0 ) {
            selector--;
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `zako.wav` );
            selectorSpr.y = 108 + 16 * selector;
            demoTimer.stop();
            demoTimer.start();            
        }
        if ( e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.DOWN && selector < 4 ) {
            selector++;
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `zako.wav` );
            selectorSpr.y = 108 + 16 * selector;
            demoTimer.stop();
            demoTimer.start();            
        }
        if ( e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.ENTER || e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.SPACE || e.keyCode == _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.N ) {
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `item.wav` );
            demoTimer.stop();
            textSpr.removeFromParent();
            selectorSpr.removeFromParent();
            if ( selector == 3 ) {
                e.stopPropagation();
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "mode:intro",{ endingFlag: false } )  );
            } else if ( selector == 4 ) {
                e.stopPropagation();
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "dialog",{ msg: "exit" } ) );
            } else {
                let gameSetting = { coin: coin };

                if ( selector == 0 ) {
                    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "dialog",{ msg: "1p" } ) );
                    gameSetting.player1 = true;
                } else if ( selector == 1 ) {
                    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "dialog",{ msg: "2p" } ) );
                    gameSetting.player2 = true;
                } else if ( selector == 2 ) {
                    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "dialog",{ msg: "1p2p" } ) );
                    gameSetting.player1 = true;
                    gameSetting.player2 = true;
                }
                await _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Timer.waitFrame( 200 );
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "mode:gameLoop",gameSetting );
            }
        }
    } );
}

_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "mode:title",title );


/***/ }),

/***/ "./games/PALO2/src/vsWrapper/vs.js":
/*!*****************************************!*\
  !*** ./games/PALO2/src/vsWrapper/vs.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VsPad": () => (/* reexport safe */ _vsPad__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "VsPalette": () => (/* reexport safe */ _vsPalette__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "VsWorld": () => (/* reexport safe */ _vsWorld__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "VsSprite": () => (/* reexport safe */ _vsSprite__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "VsSystemText": () => (/* reexport safe */ _vsSystemText__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "VsHangul": () => (/* reexport safe */ _vsHangul__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "VsStage": () => (/* reexport safe */ _vsStage__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "vsStage": () => (/* binding */ vsStage),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsPalette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsPalette */ "./games/PALO2/src/vsWrapper/vsPalette.js");
/* harmony import */ var _vsWorld__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsWorld */ "./games/PALO2/src/vsWrapper/vsWorld.js");
/* harmony import */ var _vsSprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vsSprite */ "./games/PALO2/src/vsWrapper/vsSprite.js");
/* harmony import */ var _vsSystemText__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vsSystemText */ "./games/PALO2/src/vsWrapper/vsSystemText.js");
/* harmony import */ var _vsHangul__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vsHangul */ "./games/PALO2/src/vsWrapper/vsHangul.js");
/* harmony import */ var _vsStage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vsStage */ "./games/PALO2/src/vsWrapper/vsStage.js");
/* harmony import */ var _vsPad__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vsPad */ "./games/PALO2/src/vsWrapper/vsPad.js");
/* harmony import */ var _vs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vs */ "./games/PALO2/src/vsWrapper/vs.js");




















const vsStage = _vsStage__WEBPACK_IMPORTED_MODULE_6__["default"].instance;




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vs__WEBPACK_IMPORTED_MODULE_8__);



/***/ }),

/***/ "./games/PALO2/src/vsWrapper/vsHangul.js":
/*!***********************************************!*\
  !*** ./games/PALO2/src/vsWrapper/vsHangul.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VsHangul)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsStage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsStage */ "./games/PALO2/src/vsWrapper/vsStage.js");
/* harmony import */ var _vsPalette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsPalette */ "./games/PALO2/src/vsWrapper/vsPalette.js");





// TODO: 외곽선 처리 해야함

const widthTable = {
    "I": 5,
    "J": 6,
    "i": 5,
    "j": 6,
    "l": 5,
    "|": 4,
    "{": 6,
    "}": 5,
};

// 6 바이트씩 인코딩 x,y,w,h,sx,sy
// 한글은 회전이 없어서 6개면 됨
// 영어 95자
const hangulFontFrames = new Uint8Array( [
    40,43,2,12,2,1,208,65,4,4,2,0,20,15,8,12,0,0,0,30,8,14,0,0,240,0,8,10,0,2,31,0,8,12,0,0,196,72,2,4,3,0,18,30,4,14,2,0,23,58,4,14,2,0,22,73,8,8,0,2,41,13,8,10,0,1,199,72,2,4,3,10,116,51,8,2,0,5,72,70,2,2,2,12,249,0,6,10,1,2,18,45,6,12,1,0,29,15,6,12,1,0,95,13,6,12,1,0,102,13,6,12,1,0,0,60,8,12,0,0,109,13,6,12,1,0,116,13,6,12,1,0,123,13,6,12,1,0,130,13,6,12,1,0,137,13,6,12,1,0,228,13,2,10,2,1,228,24,2,10,2,2,144,13,6,12,1,0,125,51,8,4,0,4,151,13,6,12,1,0,158,13,6,12,1,1,40,0,8,12,0,0,165,13,6,12,1,0,9,45,8,12,0,0,172,13,6,12,1,0,49,0,8,12,0,0,58,0,8,12,0,0,67,0,8,12,0,0,179,13,6,12,1,0,76,0,8,12,0,0,43,37,4,12,0,0,9,58,6,14,0,0,85,0,8,12,0,0,94,0,8,12,0,0,103,0,8,12,0,0,112,0,8,12,0,0,121,0,8,12,0,0,130,0,8,12,0,0,139,0,8,12,0,1,148,0,8,12,0,0,186,13,6,12,1,0,157,0,8,12,0,0,166,0,8,12,0,0,193,13,6,12,1,0,175,0,8,12,0,0,184,0,8,12,0,0,193,0,8,12,0,0,202,0,8,12,0,0,50,24,4,12,2,0,200,13,6,12,1,0,48,37,4,12,2,0,54,50,6,4,1,0,151,58,8,2,0,12,196,77,2,4,3,0,221,26,6,8,1,4,207,13,6,12,0,0,161,35,6,8,1,4,214,13,6,12,1,0,168,35,6,8,1,4,221,13,6,12,1,0,43,24,6,12,1,2,211,0,8,12,0,0,55,24,4,12,0,0,23,28,4,14,0,0,220,0,8,12,0,0,53,37,4,12,0,0,31,73,8,8,0,4,40,73,8,8,0,4,175,35,6,8,1,4,60,24,6,10,0,4,67,24,6,10,1,4,182,35,6,8,0,4,189,35,6,8,1,4,74,24,6,10,0,2,81,24,8,8,0,4,196,35,6,8,1,4,95,26,8,8,0,4,104,26,8,8,0,4,50,13,8,10,0,4,203,35,6,8,1,4,25,43,4,14,0,0,58,37,2,12,0,0,28,58,4,14,0,0,134,51,8,4,0,5,59,13,8,10,0,1,61,35,6,10,0,0,68,35,6,10,0,0,75,35,6,10,0,0,82,33,6,10,0,0,210,35,6,10,0,0,217,35,6,10,0,0,224,35,6,10,0,0,231,11,6,10,0,0,231,22,6,10,0,0,238,11,6,10,0,0,231,33,6,10,0,0,238,22,6,10,0,0,245,11,6,10,0,0,238,33,6,10,0,0,245,22,6,10,0,0,245,33,6,10,0,0,249,44,6,10,0,0,242,51,6,10,0,0,41,62,6,10,0,0,23,43,1,1,0,0,113,26,8,8,0,0,122,26,8,8,0,0,131,26,8,8,0,0,140,26,8,8,0,0,149,26,8,8,0,0,158,26,8,8,0,0,167,26,8,8,0,0,176,26,8,8,0,0,185,26,8,8,0,0,194,26,8,8,0,0,203,26,8,8,0,0,212,26,8,8,0,0,89,35,8,8,0,0,98,35,8,8,0,0,107,35,8,8,0,0,116,35,8,8,0,0,125,35,8,8,0,0,134,35,8,8,0,0,143,35,8,8,0,0,23,43,1,1,0,0,113,26,8,8,0,0,122,26,8,8,0,0,131,26,8,8,0,0,140,26,8,8,0,0,149,26,8,8,0,0,158,26,8,8,0,0,167,26,8,8,0,0,176,26,8,8,0,0,185,26,8,8,0,0,194,26,8,8,0,0,203,26,8,8,0,0,212,26,8,8,0,0,89,35,8,8,0,0,98,35,8,8,0,0,107,35,8,8,0,0,116,35,8,8,0,0,125,35,8,8,0,0,134,35,8,8,0,0,143,35,8,8,0,0,23,43,1,1,0,0,49,73,6,8,0,0,56,73,6,8,0,0,63,73,6,8,0,0,72,61,6,8,0,0,79,61,6,8,0,0,86,61,6,8,0,0,93,61,6,8,0,0,100,61,6,8,0,0,107,61,6,8,0,0,114,61,6,8,0,0,249,55,6,8,0,0,124,63,6,8,0,0,131,63,6,8,0,0,138,63,6,8,0,0,145,63,6,8,0,0,152,61,6,8,0,0,214,58,6,8,0,0,221,58,6,8,0,0,228,58,6,8,0,0,23,43,1,1,0,0,49,73,6,8,0,0,56,73,6,8,0,0,63,73,6,8,0,0,72,61,6,8,0,0,79,61,6,8,0,0,86,61,6,8,0,0,93,61,6,8,0,0,100,61,6,8,0,0,107,61,6,8,0,0,114,61,6,8,0,0,249,55,6,8,0,0,124,63,6,8,0,0,131,63,6,8,0,0,138,63,6,8,0,0,145,63,6,8,0,0,152,61,6,8,0,0,214,58,6,8,0,0,221,58,6,8,0,0,228,58,6,8,0,0,23,43,1,1,0,0,235,58,6,8,0,0,242,62,6,8,0,0,249,64,6,8,0,0,70,73,6,8,0,0,77,73,6,8,0,0,86,61,6,8,0,0,84,73,6,8,0,0,91,73,6,8,0,0,98,73,6,8,0,0,105,73,6,8,0,0,249,55,6,8,0,0,112,73,6,8,0,0,119,73,6,8,0,0,126,73,6,8,0,0,133,73,6,8,0,0,140,73,6,8,0,0,214,58,6,8,0,0,147,73,6,8,0,0,228,58,6,8,0,0,23,43,1,1,0,0,83,44,8,6,0,0,92,44,8,6,0,0,101,44,8,6,0,0,110,44,8,6,0,0,119,44,8,6,0,0,128,44,8,6,0,0,137,44,8,6,0,0,146,44,8,6,0,0,155,44,8,6,0,0,164,44,8,6,0,0,173,44,8,6,0,0,182,44,8,6,0,0,191,44,8,6,0,0,200,44,8,6,0,0,231,44,8,6,0,0,240,44,8,6,0,0,143,51,8,6,0,0,152,51,8,6,0,0,161,51,8,6,0,0,23,43,1,1,0,0,159,65,6,6,0,0,166,65,6,6,0,0,173,65,6,6,0,0,180,65,6,6,0,0,187,65,6,6,0,0,194,65,6,6,0,0,201,65,6,6,0,0,213,67,6,6,0,0,220,67,6,6,0,0,227,67,6,6,0,0,234,67,6,6,0,0,241,71,6,6,0,0,248,73,6,6,0,0,154,72,6,6,0,0,161,72,6,6,0,0,168,72,6,6,0,0,175,72,6,6,0,0,182,72,6,6,0,0,189,72,6,6,0,0,23,43,1,1,0,0,28,28,4,14,6,0,30,43,4,14,5,0,33,58,4,14,6,0,33,28,4,14,5,0,35,43,4,14,4,0,36,13,4,14,5,0,38,28,4,14,4,0,16,58,6,14,3,0,43,50,10,4,0,10,0,0,10,14,0,0,0,15,10,14,0,0,11,15,8,14,0,0,61,46,10,4,0,10,72,46,10,4,0,10,22,0,8,14,0,0,11,0,10,14,0,0,0,45,8,14,0,0,209,46,10,4,0,10,61,51,10,2,0,12,9,30,8,14,0,0,38,58,2,14,6,0,23,43,1,1,0,0,28,28,4,14,6,0,30,43,4,14,5,0,33,58,4,14,6,0,33,28,4,14,5,0,35,43,4,14,4,0,36,13,4,14,5,0,38,28,4,14,4,0,16,58,6,14,3,0,43,50,10,4,0,10,0,0,10,14,0,0,0,15,10,14,0,0,11,15,8,14,0,0,61,46,10,4,0,10,72,46,10,4,0,10,22,0,8,14,0,0,11,0,10,14,0,0,0,45,8,14,0,0,209,46,10,4,0,10,61,51,10,2,0,12,9,30,8,14,0,0,38,58,2,14,6,0,23,43,1,1,0,0,90,24,4,10,6,0,252,11,4,10,5,0,252,22,4,10,6,0,252,33,4,10,5,0,48,62,4,10,4,0,53,62,6,10,3,0,60,62,4,10,4,0,65,61,6,10,3,0,72,51,10,2,0,6,0,73,10,8,0,0,11,73,10,8,0,0,152,35,8,8,0,0,83,51,10,2,0,6,94,51,10,2,0,7,68,13,8,10,0,0,229,0,10,10,0,0,77,13,8,10,0,0,105,51,10,2,0,7,61,51,10,2,0,6,86,13,8,10,0,0,121,61,2,10,6,0,23,43,1,1,0,0,90,24,4,10,6,0,252,11,4,10,5,0,252,22,4,10,6,0,252,33,4,10,5,0,48,62,4,10,4,0,53,62,6,10,3,0,60,62,4,10,4,0,65,61,6,10,3,0,72,51,10,2,0,6,0,73,10,8,0,0,11,73,10,8,0,0,152,35,8,8,0,0,83,51,10,2,0,6,94,51,10,2,0,7,68,13,8,10,0,0,229,0,10,10,0,0,77,13,8,10,0,0,105,51,10,2,0,7,61,51,10,2,0,6,86,13,8,10,0,0,121,61,2,10,6,0,23,43,1,1,0,0,170,51,8,6,0,8,179,51,8,6,0,8,188,51,8,6,0,8,197,51,8,6,0,8,206,51,8,6,0,8,215,51,8,6,0,8,224,51,8,6,0,8,233,51,8,6,0,8,43,55,8,6,0,8,52,55,8,6,0,8,61,54,8,6,0,8,70,54,8,6,0,8,79,54,8,6,0,8,88,54,8,6,0,8,97,54,8,6,0,8,106,54,8,6,0,8,115,54,8,6,0,8,124,56,8,6,0,8,142,58,8,4,0,10,220,46,10,4,0,10,133,56,8,6,0,8,160,58,8,6,0,8,169,58,8,6,0,8,178,58,8,6,0,8,187,58,8,6,0,8,196,58,8,6,0,8,205,58,8,6,0,8,23,43,1,1,0,0,170,51,8,6,0,8,179,51,8,6,0,8,188,51,8,6,0,8,197,51,8,6,0,8,206,51,8,6,0,8,215,51,8,6,0,8,224,51,8,6,0,8,233,51,8,6,0,8,43,55,8,6,0,8,52,55,8,6,0,8,61,54,8,6,0,8,70,54,8,6,0,8,79,54,8,6,0,8,88,54,8,6,0,8,97,54,8,6,0,8,106,54,8,6,0,8,115,54,8,6,0,8,124,56,8,6,0,8,142,58,8,4,0,10,220,46,10,4,0,10,133,56,8,6,0,8,160,58,8,6,0,8,169,58,8,6,0,8,178,58,8,6,0,8,187,58,8,6,0,8,196,58,8,6,0,8,205,58,8,6,0,8,23,43,1,1,0,0,170,51,8,6,1,8,179,51,8,6,1,8,188,51,8,6,1,8,197,51,8,6,1,8,206,51,8,6,1,8,215,51,8,6,1,8,224,51,8,6,1,8,233,51,8,6,1,8,43,55,8,6,1,8,52,55,8,6,1,8,61,54,8,6,1,8,70,54,8,6,1,8,79,54,8,6,1,8,88,54,8,6,1,8,97,54,8,6,1,8,106,54,8,6,1,8,115,54,8,6,1,8,124,56,8,6,1,8,142,58,8,4,1,10,220,46,10,4,0,10,133,56,8,6,1,8,160,58,8,6,1,8,169,58,8,6,1,8,178,58,8,6,1,8,187,58,8,6,1,8,196,58,8,6,1,8,205,58,8,6,1,8,23,43,1,1,0,0,170,51,8,6,0,8,179,51,8,6,0,8,188,51,8,6,0,8,197,51,8,6,0,8,206,51,8,6,0,8,215,51,8,6,0,8,224,51,8,6,0,8,233,51,8,6,0,8,43,55,8,6,0,8,52,55,8,6,0,8,61,54,8,6,0,8,70,54,8,6,0,8,79,54,8,6,0,8,88,54,8,6,0,8,97,54,8,6,0,8,106,54,8,6,0,8,115,54,8,6,0,8,124,56,8,6,0,8,142,58,8,4,0,10,220,46,10,4,0,10,133,56,8,6,0,8,160,58,8,6,0,8,169,58,8,6,0,8,178,58,8,6,0,8,187,58,8,6,0,8,196,58,8,6,0,8,205,58,8,6,0,8
] );

const hangulFontImage = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Texture( `hangulfont.png` );


// 한글 데이터 만들기
const chosungTable = new Uint8Array( [
    // 종성이 없을 때 중성 변환 테이블
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,
    // 종성이 있을 때 중성 변환 테이블
    2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3
] );

const joongsungTable = new Uint8Array( [
    // 종성 변환 테이블
    0, 2, 0, 2, 1, 2, 1, 2, 3, 0, 2, 1, 3, 3, 1, 2, 1, 3, 3, 1, 1,
    // 종성이 없을 때 초성 변환 테이블
    0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 3, 3, 1, 2, 4, 4, 4, 2, 1, 3, 0,
    // 종성이 있을 때 초성 변환 테이블
    5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 6, 6, 7, 7, 7, 6, 6, 7, 5
] );

const convChosung = new Uint8Array( [
    //ㄱ,ㄲ,ㄳ,ㄴ,ㄵ,ㄶ,ㄷ,ㄸ,ㄹ,ㄺ,ㄻ,ㄼ,ㄽ,ㄾ,ㄿ,ㅀ,ㅁ,ㅂ,ㅃ,ㅄ,ㅅ,ㅆ,ㅇ,ㅈ,ㅉ,ㅊ,ㅋ,ㅌ,ㅍ,ㅎ
    0, 1, 0, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 8, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
] );

const INDEX_CHOSUNG = 95;
const INDEX_JOONGSUNG = ( INDEX_CHOSUNG + 160 );
const INDEX_JONGSUNG = ( INDEX_JOONGSUNG + 87 );


class VsHangul extends _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Mesh {
    /**
     *Creates an instance of VsHangulFont.
     * @param {string=} s
     * @memberof VsHangulFont
     */
    constructor( s ) {
        super();
        this._color1 = 0x00f000;
        this._color2 = 0x00f000;
        this.setTexture( hangulFontImage );
        if ( s ) this.setText( s );
        this.once( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ADDED_TO_STAGE,()=>{
            this.setPalette( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.palette );
        } );
    }

    setPalette( pal ) {
        let sh = pal.createShader( hangulFontImage );

        this.setShader( sh );
    }

    /**
     *
     *
     * @param {number} index1
     * @param {number=} index2
     * @memberof VsHangul
     */
    setColor( index1, index2 ) {
        this._color1 = _vsPalette__WEBPACK_IMPORTED_MODULE_2__["default"].indexToColor( index1 );
        if ( index2 ) {
            this._color2 = _vsPalette__WEBPACK_IMPORTED_MODULE_2__["default"].indexToColor( index2 );
        } else {
            this._color2 = this._color1;
        }

        if ( this.text != null ) {
            let count = this.getColorArraySize();
            let colors = [];

            for ( let i = 0; i < count / 4; i++ ) {
                colors.push( this._color1,1,this._color1,1,this._color2,1,this._color2,1 );
            }
            this.setColorArray( colors );
        }
    }

   
    /**
     *
     *
     * @param {string} s
     * @memberof VsSmallFont
     */
    setText( s ) {
        let idx = [];
        let vtx = [];
        let uv = [];
        let colors = [];
        let x = 0;
        let y = 0;

        this.text = s;

        let addChar = ( code ) => {
            let dataPos = code * 6;
            let data = hangulFontFrames.slice( dataPos,dataPos + 6 );
            let ipos = vtx.length / 2;
            let [u,v,w,h,sx,sy] = data;
            
            idx.push( ipos,ipos + 1,ipos + 2,ipos + 1,ipos + 3,ipos + 2 );
            vtx.push( x + sx,y + sy,x + sx + w,y + sy,x + sx,y + sy + h,x + sx + w,y + sy + h );
            uv.push( u,v,u + w,v,u,v + h,u + w,v + h );
            colors.push( this._color1,1,this._color1,1,this._color2,1,this._color2,1 );
        };

        for ( let i = 0; i < s.length; i++ ) {
            let ch = s.charCodeAt( i );

            if ( ch == 0x20 ) {
                // 공백
                x += 7;
            } else if ( ch == 10 ) {
                // 엔터
                x = 0;
                y += 16;
            } else if ( ch > 0x20 && ch <= 0x20 + 95 ) {
                // 영어
                addChar( ch - 33 );
                if ( widthTable[s[i]] ) {
                    x += widthTable[s[i]];
                } else {
                    x += 8;
                }
            } else {
                let chosung;
                let joongsung;
                let jongsung;
                let b1,b2,b3;

                if ( ch >= 0x3131 && ch <= 0x314e ) {
                    // 자소만 출력
                    addChar( INDEX_CHOSUNG + convChosung[( ch - 0x3131 )] );
                } else {
                    ch -= 0xac00;
                    chosung = Math.floor( ch / ( 28 * 21 ) );
                    joongsung = Math.floor( ( ch % ( 28 * 21 ) ) / 28 );
                    jongsung = ch % 28;

                    b3 = joongsungTable[ joongsung ];
                    if ( jongsung == 0 ) {
                        b2 = chosungTable[ chosung ];
                        b1 = joongsungTable[ 21 + joongsung ];
                    } else {
                        b2 = chosungTable[ 19 + chosung ];
                        b1 = joongsungTable[ 2 * 21 + joongsung ];
                    }
                    addChar( INDEX_CHOSUNG + chosung + b1 * 20 );
                    addChar( INDEX_JOONGSUNG + joongsung + b2 * 22 );
                    if ( jongsung != 0 ) {
                        addChar( INDEX_JONGSUNG + jongsung + b3 * 28 );
                    }
                }
                x += 11;
            }
        }
        this.setVertexArray( vtx );
        this.setIndexArray( idx );
        this.setColorArray( colors );
        this.setTextureCoordinateArray( uv );
    }
}

//module.exports = VsHangul;


/***/ }),

/***/ "./games/PALO2/src/vsWrapper/vsPad.js":
/*!********************************************!*\
  !*** ./games/PALO2/src/vsWrapper/vsPad.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VsPad)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsStage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsStage */ "./games/PALO2/src/vsWrapper/vsStage.js");
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global */ "./games/PALO2/src/global.js");






function addButton( x,y,key,color ) {
    let t = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Texture( `vpad30.png` );
    let s = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Bitmap( t );

    s.setColorMultiplier( ..._engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.hex2rgba( color ) );
    s.alpha = 0.3;
    s.setAnchorPoint( 0.5,0.5 );
    s.xy = [x,y];
    s.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.POINTER_DOWN,( e )=>{
        if ( s.hitTestPoint( e.x,e.y ) ) {
            e.stopPropagation();
            let e2 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_DOWN );

            s.alpha = 0.5;
            e2.keyCode = key;
            s.downId = e.id;
            _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.dispatchEventWithChildren( e2 );
            // console.log( `DOWN ${key}` );
        }
    } );
    s.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.POINTER_UP,( e )=>{
        if ( e.id == s.downId ) {
            e.stopPropagation();
            let e2 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_UP );

            s.alpha = 0.3;
            e2.keyCode = key;
            s.downId = null;
            _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.dispatchEventWithChildren( e2 );
            // console.log( `UP ${key}` );
        }
    } );
    return s;
}


class VsPad extends _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor( alwaysShow ) {
        super();
        
        if ( alwaysShow || _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.touchEnabled ) {
            this.init();
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.RESIZE,this.init,this );
        }        
        // this.init();
    }

    init() {
        this.clearChildren();
        this.setDPad( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalRenderBounds.left + 50,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalRenderBounds.bottom - 50,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.UP,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.DOWN,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.LEFT,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.RIGHT );
        this.setButton( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalRenderBounds.right - 70,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalRenderBounds.bottom - 40,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.SPACE,0xff4040 );
        this.setButton( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalRenderBounds.right - 40,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalRenderBounds.bottom - 60,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.KeyCode.M,0x4000ff );
    }

    setDPad( x,y,keyUp,keyDown,keyLeft,keyRight ) {
        let originX = x;
        let originY = y;
        let hx = x;
        let hy = y;
        let border = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Bitmap( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Texture( `vpad50.png` ) );

        border.xy = [x,y];
        border.setAnchorPoint( 0.5,0.5 );
        border.alpha = 0.2;
        this.addChild( border );

        let dot = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Bitmap( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Texture( `vpad5.png` ) );

        dot.alpha = 0.5;
        dot.setAnchorPoint( 0.5,0.5 );
        dot.setVisible( false );
        dot.onStage( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME,()=>{
            if ( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.world && _global__WEBPACK_IMPORTED_MODULE_2__["default"].players && _global__WEBPACK_IMPORTED_MODULE_2__["default"].players[1] ) {
                let px = _global__WEBPACK_IMPORTED_MODULE_2__["default"].players[1].x;
                let py = _global__WEBPACK_IMPORTED_MODULE_2__["default"].players[1].y;

                dot.position = _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.world.getStageCoordinate( px,py );
                dot.x += ( hx - x ) * 0.6;
                dot.y += ( hy - y ) * 0.6;
            }
        } );
        this.addChild( dot );

        let head = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Bitmap( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Texture( `vpad30.png` ) );

        head.xy = [x,y];
        head.setAnchorPoint( 0.5,0.5 );
        head.alpha = 0.3;
        this.addChild( head );

        const keyStates = {};
        const dirToKey = [
            [keyUp],
            [keyUp,keyRight],
            [keyRight],
            [keyDown,keyRight],
            [keyDown],
            [keyDown,keyLeft],
            [keyLeft],
            [keyUp,keyLeft],
            [],
        ];
        const getDir = ( ex,ey )=>{
            if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.distance( x,y, ex,ey ) < 10 ) return 8;
            let angle = Math.atan2( ex - x,-( ey - y ) )  * 180 / Math.PI + 22.5;
            let dir = Math.floor( ( angle < 0 ? angle + 360 : angle ) / 45 );
            
            // console.log( dir );
            return dir;
        };

        head.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.POINTER_DOWN,( e )=>{
            if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.distance( originX,originY, e.x,e.y ) <= 100 ) {
                x = e.x;
                y = e.y;
                border.xy = [x,y];
                e.stopPropagation();
                head.downId = e.id;
                head.alpha = 0.5;
                head.xy = [e.x,e.y];
                head.lastDir = getDir( e.x,e.y );
                hx = e.x;
                hy = e.y;
                dot.setVisible( true );
                
                if ( dirToKey[head.lastDir].length > 0 ) {
                    let e1 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_DOWN );

                    e1.keyCode = dirToKey[head.lastDir][0];
                    keyStates[e1.keyCode] = true;
                    _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.dispatchEventWithChildren( e1 );
                    // console.log( `DOWN ${e1.keyCode}` );
                }
                if ( dirToKey[head.lastDir].length > 1 ) {
                    let e2 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_DOWN );

                    e2.keyCode = dirToKey[head.lastDir][1];
                    keyStates[e2.keyCode] = true;
                    _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.dispatchEventWithChildren( e2 );
                    // console.log( `DOWN ${e2.keyCode}` );
                }
            }
        } );
        head.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.POINTER_MOVE, ( e )=>{
            if ( head.downId != null ) {
                if ( e.id == head.downId ) {
                    e.stopPropagation();
                    head.xy = [e.x,e.y];
                    hx = e.x;
                    hy = e.y;
                    let dir = getDir( e.x,e.y );

                    // console.log( dir,head.lastDir,keyStates );
                    if ( head.lastDir != dir ) {
                        head.lastDir = dir;
                        for ( let key in keyStates ) {
                            let e1 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_UP );

                            if ( dirToKey[head.lastDir].indexOf( key ) < 0 ) {
                                e1.keyCode = key;
                                _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.dispatchEventWithChildren( e1 );
                                // console.log( `UP ${key}` );
                                delete keyStates[key];
                            }
                        }
                        if ( dirToKey[head.lastDir].length > 0 && !keyStates[dirToKey[head.lastDir][0]] ) {
                            let e1 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_DOWN );

                            e1.keyCode = dirToKey[head.lastDir][0];
                            keyStates[e1.keyCode] = true;
                            _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.dispatchEventWithChildren( e1 );
                            // console.log( `DOWN ${e1.keyCode}` );
                        }
                        if ( dirToKey[head.lastDir].length > 1 && !keyStates[dirToKey[head.lastDir][1]] ) {
                            let e2 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_DOWN );

                            e2.keyCode = dirToKey[head.lastDir][1];
                            keyStates[e2.keyCode] = true;
                            _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.dispatchEventWithChildren( e2 );
                            // console.log( `DOWN ${e2.keyCode}` );
                        }
                    }
                }
            }
        } );
        head.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.POINTER_UP,( e )=>{
            if ( e.id == head.downId ) {
                e.stopPropagation();
                x = originX;
                y = originY;
                border.xy = [x,y];

                head.alpha = 0.3;
                head.xy = [x,y];
                dot.setVisible( false );
                for ( let key in keyStates ) {
                    let e1 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.KEY_UP );

                    e1.keyCode = key;
                    _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.dispatchEventWithChildren( e1 );
                    delete keyStates[key];
                    // console.log( `UP ${key}` );
                }
                head.downId = null;
            }
        } );
    }

    setButton( x,y,key,color ) {
        this.addChild( addButton( x,y,key,color ) );
    }
}



// module.exports = VsPad;

/***/ }),

/***/ "./games/PALO2/src/vsWrapper/vsPalette.js":
/*!************************************************!*\
  !*** ./games/PALO2/src/vsWrapper/vsPalette.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VsPalette)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsStage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsStage */ "./games/PALO2/src/vsWrapper/vsStage.js");



const vertexSrc = `
precision mediump float;

#define PI 3.1415926535897932384626433832795
#define MOTION_BLUR_THRESHOLD 2.0

const bool useDiscard = true;

#ifndef NO_TEXTURE
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
#endif


    uniform mat4 u_viewMatrix;
    uniform mat4 u_worldMatrixPrev;
    uniform mat4 u_worldMatrix;
    uniform vec2 u_anchorPrev;
    uniform vec2 u_anchor;
    uniform vec4 u_colorOverridePrev;
    uniform vec4 u_colorOverride;
    uniform float u_alphaMod;
    uniform float u_alphaMod2;
    uniform float u_logicPerRenderFrame;
    uniform float u_subRenderFrame;

    attribute vec2 a_position;
    attribute vec4 a_color;
    attribute float a_blendFactor;

    varying float v_discardAll;
    varying vec4 v_colorOverride;

    varying float v_alphaCorrection;



//decomposing code from
//https://github.com/deoxxa/transformation-matrix-js/blob/master/src/matrix.js

struct Transform {
    vec2 position;
    vec2 scale;
    vec2 skew;
    float rotation;
};

Transform decompose(mat4 mat) {
    Transform result;
	float a = mat[0].x;
    float b = mat[0].y;
    float c = mat[1].x;
    float d = mat[1].y;

    float rotation = 0.0;
    vec2 scale = vec2(1.0, 1.0);
    vec2 skew = vec2(0.0, 0.0);

    float determ = a * d - b * c;	// determinant(), skip DRY here...

    if(a != 0.0 || b != 0.0) {
        float r = sqrt(a * a + b * b);
        rotation = b > 0.0 ? acos(a / r) : -acos(a / r);
        scale = vec2(r, determ / r);
        skew.x = atan((a * c + b * d), (r * r));
    } else if(c != 0.0 || d != 0.0) {
        float s = sqrt(c * c + d * d);
        rotation = PI * 0.5 - (d > 0.0 ? acos(-c / s) : -acos(c / s));
        scale = vec2(determ / s, s);
        skew.y = atan((a * c + b * d), (s * s));
    } else { // a = b = c = d = 0
        scale = vec2(0.0, 0.0);		// = invalid matrix
    } 
    result.scale = scale;
    result.rotation = rotation;
    result.skew = skew;
    result.position = mat[3].xy;
    return result;
}


void main() {

    vec4 pos = vec4(a_position.xy,1,1);
    float abf = a_blendFactor;
    float bf = (a_blendFactor+u_subRenderFrame) / max(1.0,u_logicPerRenderFrame);
    mat4 matrix1 = u_worldMatrixPrev;
    mat4 matrix2 = u_worldMatrix;

#ifndef NO_TEXTURE
    v_texCoord = a_texCoord;
#endif

    Transform t1 = decompose(matrix1);
    Transform t2 = decompose(matrix2);
    Transform t;

    float dist = length(matrix1[3].xy - matrix2[3].xy);
    bool isNotMoved = bf>=1.0 || (dist<=MOTION_BLUR_THRESHOLD && t1.scale == t2.scale && t1.rotation == t2.rotation);


    if(isNotMoved) {
        if (useDiscard && abf!=0.5) {
            v_discardAll = 1.0;
            gl_Position = vec4(0);
            return;
        } else {
            v_colorOverride = u_colorOverride;
            t.position = t2.position;
            t.rotation = t2.rotation;
            t.scale = t2.scale;
            t.skew = t2.skew;
            v_colorOverride *= a_color;
            v_alphaCorrection = 0.0;
        }
    } else {
        v_alphaCorrection = 1.0;
        float alpha = 1.0 - abs(abf - 0.5) * 2.0;
        v_colorOverride = mix(u_colorOverridePrev, u_colorOverride, bf);
        v_colorOverride *= a_color;
        v_colorOverride.a *= a_color.a;// * alpha;
        t.position = mix(t1.position, t2.position, bf);
        t.rotation = mix(t1.rotation, t2.rotation, bf);
        t.scale = mix(t1.scale, t2.scale, bf);
        t.skew = mix(t1.skew, t2.skew, bf);
    }
    v_discardAll = 0.0;

    mat4 posMat = mat4(1);
    mat4 scaleMat = mat4(1);
    mat4 rotMat = mat4(1);
    mat4 shearMat = mat4(1);
    mat4 anchorMat = mat4(1);

    anchorMat[3].xy = -mix(u_anchorPrev,u_anchor,bf);

    posMat[3].xy = t.position;
    shearMat[0].y = -t.skew.x;
    shearMat[1].x = t.skew.y;
    scaleMat[0].x = t.scale.x;
    scaleMat[1].y = t.scale.y;    
    rotMat[0].x = cos(t.rotation);
    rotMat[0].y = sin(t.rotation);
    rotMat[1].x = -sin(t.rotation);
    rotMat[1].y = cos(t.rotation);

    gl_Position = u_viewMatrix * posMat * shearMat * scaleMat * rotMat * anchorMat * pos;

}
            `;
const fragmentSrc = `
precision mediump float;

#define PI 3.1415926535897932384626433832795

#ifndef NO_TEXTURE

    uniform sampler2D u_texture;
    uniform vec2 u_textureSize;
    varying vec2 v_texCoord;

#endif

    uniform vec4 u_colorAdd;

    varying float v_discardAll;
    varying vec4 v_colorOverride;
    varying float v_alphaCorrection;

    uniform float u_alphaMod;
    uniform float u_alphaMod2;

    uniform sampler2D palette;
    uniform float white;

void main() {
    if(v_discardAll != 0.0) discard;

#ifndef NO_TEXTURE
    vec4 c = texture2D(u_texture,v_texCoord / u_textureSize);
#else
    vec4 c = vec4(1.0,1.0,1.0,1.0);
#endif
    c += u_colorAdd;
    c *= v_colorOverride;
    vec4 ic = c;
    float index = (ic.g * 16.0 + ic.r*16.0 * 16.0)/256.0;
    c = vec4( 
           mix ( texture2D(palette,vec2(index,0)).xyz, vec3(1,1,1),white) 
        , ic.a );
    
    // 모션블러된 값을 보정하는 식
    // 정확한 값을 구하는 것은 어렵고 근사치를 사용한다.
    // 모션블러 9개 그리는 것을 기준으로 구한 값
    // c.a *= 1.0 + (0.23/(1.18 - c.a) - 1.0)*v_alphaCorrection;
    // 모션블러 15개 기준
    c.a *= 1.0 + (0.09 / (1.5 - c.a) - 1.0) * v_alphaCorrection;
    c.rgb *= c.a;
    gl_FragColor = c;
}
            `;


const noTexShader = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Shader( "#define NO_TEXTURE\n" + vertexSrc,"#define NO_TEXTURE\n" + fragmentSrc,null );

// 팔레트를 한번에 변경할 수 있도록 메시를 미리 만들어둔다.
// 컬러어레이만 준비해서 그리면 된다.
const drawMesh = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Mesh();

{
    let vtx = [];
    let idx = [];

    for ( let i = 0; i <= 255; i++ ) {
        let v = vtx.length / 2;

        vtx.push( i,0, i + 1,0, i,1, i + 1,1 );
        idx.push( v,v + 1,v + 2, v + 1,v + 3,v + 2 );
    }
    drawMesh.setVertexArray( vtx );
    drawMesh.setIndexArray( idx );
}

class VsPalette {
    constructor( palName ) {
        let arr = JSON.parse( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.getEmbeddedFile( `pal_${palName}.json` ) );

        this._rt = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.RenderTarget( 256,1,false );
        this.colorArray = arr;
        this._currentColorArray = arr.slice();
        this._setArray();
        this.fadeInfo = null;
        this.rotateInfo = null;
        this.baseShader = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Shader( vertexSrc, fragmentSrc, null );
        // setTimeout( ()=>{
        //     let b = new Bitmap( this._rt );

        //     b.scale = 1;
        //     stage.addChild( b );
        // },1 );
    }

    get texture() {
        console.log( `aaaaaaaaaaaaaaaaa palette ${this._rt.asset.id}` );
        return this._rt;
    }

    /**
     *
     *
     * @param {TextureBase=} baseTexture
     * @returns {Shader}
     * @memberof VsPalette
     */
    createShader( baseTexture ) {
        let sh;

        if ( baseTexture ) {
            sh =  this.baseShader.clone();
            sh.setTexture( "palette",this._rt );
            sh.setTexture( "base",baseTexture );
            sh.setConstant( "texSize", baseTexture.size );
            sh.setConstant( "white", 0 );
        } else {
            sh = noTexShader;
            sh.setTexture( "palette",this._rt );
            sh.setConstant( "white", 0 );
        }
        return sh;
    }

    add( value, startRange = 0, endRange = 255 ) {
        for ( let i = startRange; i <= endRange; i++ ) {
            let arr = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.hex2rgba( this.colorArray[i] );
            let rarr = [];

            rarr[0] = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( arr[0] + value, 0,1 );
            rarr[1] = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( arr[1] + value, 0,1 );
            rarr[2] = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( arr[2] + value, 0,1 );
            this._currentColorArray[i] = ( ( rarr[0] * 255 << 16 ) | ( rarr[1] * 255 << 8 ) | ( rarr[2] * 255 ) );
        }
        this._setArray();
    }

    fade( options ) {
        this.fadeInfo = options;
    }

    rotate( options ) {
        this.rotateInfo = options;
    }

    _setArray() {
        let arr = this._currentColorArray;
        let colors = [];

        for ( let i = 0; i <= 255; i++  ) {
            colors.push( arr[i],1, arr[i],1, arr[i],1, arr[i],1 );
        }
        drawMesh.setColorArray( colors );
        this._rt.draw( drawMesh );
    }

    process() {
        if ( this.fadeInfo ) {
            let startRange = this.fadeInfo.range ? this.fadeInfo.range[0] : 0;
            let endRange = this.fadeInfo.range ? this.fadeInfo.range[1] : 255;
            let startValue = this.fadeInfo.start || 0;
            let endValue = this.fadeInfo.end || 0;
            let duration = this.fadeInfo.duration || 0;

            this.fadeInfo.count = this.fadeInfo.count++ || 0;
            let ratio = Math.min( 1, duration != 0 ? this.fadeInfo.count / duration : 0 );
            let value = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.lerp( startValue,endValue,ratio );

            for ( let i = startRange; i <= endRange; i++ ) {
                let arr = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.hex2rgba( this.colorArray[i] );
                let rarr = [];

                rarr[0] = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( arr[0] + value, 0,1 );
                rarr[1] = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( arr[1] + value, 0,1 );
                rarr[2] = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( arr[2] + value, 0,1 );
                this._currentColorArray[i] = ( ( rarr[0] * 255 << 16 ) | ( rarr[1] * 255 << 8 ) | ( rarr[2] * 255 ) );
            }
            this._setArray();
            this.fadeInfo.count++;
            if ( this.fadeInfo.count > this.fadeInfo.duration ) {
                this.fadeInfo = null;
            }
        }
        if ( this.rotateInfo ) {

        }
    }

    static indexToColor( index ) {
        return ( ( Math.floor( index / 16 ) * 16 ) << 16 ) | ( ( index % 16 ) * 16 << 8 );
    }
}



/***/ }),

/***/ "./games/PALO2/src/vsWrapper/vsSprite.js":
/*!***********************************************!*\
  !*** ./games/PALO2/src/vsWrapper/vsSprite.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VsSprite)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsStage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsStage */ "./games/PALO2/src/vsWrapper/vsStage.js");
/* harmony import */ var _vsPalette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsPalette */ "./games/PALO2/src/vsWrapper/vsPalette.js");
/* harmony import */ var _vsWorld__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vsWorld */ "./games/PALO2/src/vsWrapper/vsWorld.js");







class VsSprite extends _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor( sprName, options ) {
        super();

        if ( sprName != null ) {
            const imageName = `spr_${sprName}.png`;
            const sprData = JSON.parse( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.getEmbeddedFile( `spr_${sprName}.json` ) );

            this._meshes = [];
                                    
            

            this.texture = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Texture( imageName );
            for ( let i = 0; i < sprData.images.length; i++ ) {
                let img = sprData.images[i];
                let src = img.source;
                let x = img.x;
                let y = img.y;

                this._meshes[i] = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Mesh();
                this._meshes[i].setVertexArray( [x,y, x + src.width,y, x,y + src.height, x + src.width,y + src.height] );
                if ( img.inflip ) {
                // inflip을 쓰는 케이스가 거의 없는데
                // x에 img.flipX를 미리 더해줘야할 수도 있다.
                    this._meshes[i].setTextureCoordinateArray( [src.x + src.width,src.y, src.x,src.y, src.x + src.width,src.y + src.height, src.x,src.y + src.height] );
                    this._meshes[i].visibleRect = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Rect( x,y,src.width,src.height );
                } else {
                    this._meshes[i].setTextureCoordinateArray( [src.x,src.y, src.x + src.width,src.y, src.x,src.y + src.height, src.x + src.width,src.y + src.height] );
                    this._meshes[i].visibleRect = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Rect( x,y,src.width,src.height );
                }
                this._meshes[i].setColorArray( [0xffffff,1,0xffffff,1,0xffffff,1,0xffffff,1] );
                this._meshes[i].setIndexArray( [0,1,2,1,3,2] );
                this._meshes[i].setTexture( this.texture );
                this._meshes[i].flipX = img.flipX;
                this._meshes[i].flipY = img.flipY;
                this._meshes[i].ranges = img.ranges;
            // 3개
            // x1,y1,x2,y2,fx,fy
            }
            const actions = {};

            for ( let actionNum = 0; actionNum < sprData.actions.length; actionNum++ ) {
                let timeline = [];
                let frames = sprData.actions[actionNum];

                for ( let frameNum = 0; frameNum < frames.length; frameNum++ ) {
                    let imageNum = frames[frameNum].image;

                    if ( imageNum == -1 ) {
                    // chain
                        timeline.push( [-1 ,frames[frameNum].x == -1 ? actionNum : frames[frameNum].x,frames[frameNum].y] );
                        break;
                    } else {
                        timeline.push( [imageNum, frames[frameNum].x, frames[frameNum].y ] );
                    }
                }
                actions[actionNum] = timeline;
            }
            this._actions = actions;
        } else {
            this._meshes = null;
            this._action = null;
            this.texture = null;
        }
        this._init( options );

        // 첫 프레임 표시할 메시를 셋업
        this.updateVisual();

        if ( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.palette ) {
            this.setPalette( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.palette );
        } else {
            this.once( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ADDED_TO_STAGE,()=>{
                this.setPalette( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.palette );
            } );
        }
    }

    _init( options ) {
        this._white = 0;
        this._flicker = 0;
        this._currentAction = 0;
        this._currentFrame = 0;
        this.autoRemoveTimer = 0;
        this.animationStopCounter = 0;
        this.animationSpeed = 1;

        this.attrib = Object.assign( {},VsSprite.defaultAttrib );
        this.updateCallback = null;
        this.mapCollisionCallback = null;
        this.collisionCallback = null;
        this.removeCallback = null;

        this.flipX = false;
        this.flipY = false;

        this.velocity = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );
        this.acceleration = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );

        Object.assign( this,options );
    }

    /**
     * 같은 데이터를 사용하는 스프라이트를 생성한다
     *
     * @param {*} options
     * @returns {VsSprite}
     * @memberof VsSprite
     */
    createVsSprite( options ) {
        const spr = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();

        Object.setPrototypeOf( spr,VsSprite.prototype );
        Object.assign( spr, {
            _meshes: this._meshes.map( e=>{
                let m = e.clone();

                m.visibleRect = e.visibleRect;
                m.flipX = e.flipX;
                m.flipY = e.flipY;
                m.ranges = e.ranges;
                return m;
            } ),
            _actions: this._actions,
            texture:  this.texture
        } );
        
        //@ts-ignore
        spr.setPalette( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.palette );
        //@ts-ignore
        spr._init( options );
        //@ts-ignore
        spr.updateVisual();
        //@ts-ignore
        return spr;
    }

    /**
     *
     *
     * @param {number} num
     * @returns {flatfast.instanceOf.Mesh}
     * @memberof VsSprite
     */
    getMesh( num ) {
        let sh = this._meshes[num].getShader();
        let m = this._meshes[num].clone();

        m.setShader( sh );
        return m;
    }

    get action() {
        return this._currentAction;
    }

    set action( a ) {
        this._currentAction = a;
        this._currentFrame = 0;
        this.updateVisual();
    }

    get frame() {
        return this._currentFrame;
    }

    set frame( f ) {
        this._currentFrame = f;
        this.updateVisual();
    }

    setPalette( pal ) {
        console.assert( pal instanceof _vsPalette__WEBPACK_IMPORTED_MODULE_2__["default"], `팔레트가 제대로 세팅되어있지 않습니다` );
        let sh = pal.createShader( this.texture );

        if ( this._meshes == null ) return;
        for ( let b of Object.values( this._meshes ) ) {
            b.setShader( sh );
        }
    }

    get white() {
        return this._white;
    }

    set white( v ) {
        this._white = v;
        this._currentMesh.getShader().setConstant( "white",v );
    }

    /**
     *
     *
     * @param {number=} action
     * @param {number=} frame
     * @memberof VsSprite
     */
    setAction( action, frame ) {
        if ( action == null ) {
            this._currentFrame = frame == null ? this._currentFrame : frame;
        } else {
            if ( this._currentAction == action ) {
                this._currentFrame = frame == null ? this._currentFrame : frame;    
            } else {
                this._currentAction = action;
                this._currentFrame = frame == null ? 0 : frame;    
            }
        }
        this.updateVisual();
    }

    updateVisual() {
        if ( this._actions == null ) return new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );
        let frameData = this._actions[this._currentAction][this._currentFrame];

        const oldImageFrame = this._oldImageFrame;

        if ( frameData[0] == -1 ) {
            if ( frameData[1] == -2 ) {
                // 끝나는 프레임
                this.remove( "endOfAnimation" );
                return new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );
            } else {
                if ( frameData[1] != -1 ) this._currentAction = frameData[1];
                this._currentFrame = frameData[2];
                frameData = this._actions[this._currentAction][this._currentFrame];
            }
        } 
        if ( oldImageFrame != frameData[0] ) {
            this._oldImageFrame = frameData[0];
            let oldWorldMatrix = null;

            if ( this._currentMesh ) {
                oldWorldMatrix = this._currentMesh.worldMatrix;
                this._currentMesh.removeFromParent();
            }

            this._currentMesh = this._meshes[frameData[0]];
            this._currentMesh.scaleX = this.flipX ? -1 : 1;
            this._currentMesh.x = this.flipX ? this._currentMesh.flipX : 0;
            this._currentMesh.scaleY = this.flipY ? -1 : 1;
            this._currentMesh.y = this.flipY ? this._currentMesh.flipY : 0;
            if ( oldWorldMatrix ) {
                this._currentMesh.setCustomPrev( oldWorldMatrix,this._currentMesh.colorOverride,this._currentMesh.anchorX,this._currentMesh.anchorY );
            }
            if ( this.attrib.enableHideMesh == false ) {
                this.addChildAt( this._currentMesh,0 );
            }
        }
        // this._currentMesh.updateCode != Sprite.UpdateCodes.UPDATE_CLEAR_PREV;
        return new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( frameData[1],frameData[2] );
    }

    /**
     * VsSprite끼리 충돌검사. range끼리 검사한다 range는 0~2사이
     * this와 target이 일치하면 항상 false이다.
     *
     * @param {VsSprite} target
     * @param {number} srcRange
     * @param {number} dstRange
     * @returns {boolean}
     * @memberof VsSprite
     */
    checkRange( target,srcRange,dstRange ) {
        if ( this == target ) return false;
        let r1 = this._currentMesh.ranges[srcRange];
        let r2 = target._currentMesh.ranges[dstRange];
        let sx1 = r1.x1 + ( this.flipX ? r1.fx : 0 );
        let sy1 = r1.y1 + ( this.flipY ? r1.fy : 0 );
        let sx2 = r1.x2 + ( this.flipX ? r1.fx : 0 );
        let sy2 = r1.y2 + ( this.flipY ? r1.fy : 0 );
        let dx1 = r2.x1 + ( target.flipX ? r2.fx : 0 );
        let dy1 = r2.y1 + ( target.flipY ? r2.fy : 0 );
        let dx2 = r2.x2 + ( target.flipX ? r2.fx : 0 );
        let dy2 = r2.y2 + ( target.flipY ? r2.fy : 0 );
        
        let ps1 = this.localToGlobal( sx1,sy1 );
        let ps2 = this.localToGlobal( sx2,sy2 );
        let pd1 = target.localToGlobal( dx1,dy1 );
        let pd2 = target.localToGlobal( dx2,dy2 );

        if ( ps2.x < pd1.x || ps1.x > pd2.x || ps2.y < pd1.y || ps1.y > pd2.y ) return false;
        return true;
    }

    updateVelocityAndAcceleration() {
        this.velocity = this.velocity.add( this.acceleration );

        if ( this.attrib.disableGravity == false && _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.world ) {
            this.velocity = this.velocity.add( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.world.gravity );
        }
    }

    setMapCollisionPhaseCallback( func ) {
        this.mapCollisionCallback = func;
    }

    setUpdatePhaseCallback( func ) {
        this.updateCallback = func;
    }

    setCollisionPhaseCallback( func ) {
        this.collisionCallback = func;
    }

    setRemoveCallback( func ) {
        this.removeCallback = func;
    }

    /**
     *
     *
     * @param {string=} reason
     * @memberof VsSprite
     */
    remove( reason ) {
        // console.log( reason );
        // 처리 도중 다른 이벤트로 튀는 경우를 막기 위해서 끊어준다
        this.removeAllEventListeners();
        this.removeFromParent();
    }

    /**
     *
     *
     * @param {VsSprite[]} otherSprites
     * @memberof VsSprite
     */
    process( otherSprites ) {
        // autoRemoveTimer 처리. 최초에 0이면 작동안함
        if ( this.autoRemoveTimer > 0 ) {
            this.autoRemoveTimer--;
            if ( this.autoRemoveTimer == 0 ) {
                this.remove( "autoRemoveTimer" );
                return;
            }
        }

        this.updateVelocityAndAcceleration(); // 속도, 가속도, 중력
        let delta = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );

        if ( this.attrib.disableVelocity == false ) {
            delta = delta.add( this.velocity );
        }

        if ( this.attrib.disableGlobalVelocity == false && _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.world ) {
            delta = delta.add( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.world.constantVelocity );
        }

        if ( this.animationStopCounter == 0 ) {
            this._currentFrame++;
            delta = delta.add( this.updateVisual() );
        }

        let r0 = this._currentMesh && this._currentMesh.ranges[0];

        if ( this.attrib.enableDebug && r0 ) {
            if ( this.debugShape ) {
                this.debugShape.removeFromParent();
            }
            let s = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Shape();

            s.makeBox( r0.x1,r0.y1,r0.x2 - r0.x1 + 1,r0.y2 - r0.y1 + 1,0xff0000,0.7 );
            this.debugShape = s;
            this.addChild( s );
        }

        // TODO: push 처리
        // 다른 스프라이트를 미는 처리

        if ( this.attrib.enablePush == false ) {
            // push 속성이 없을 경우에 내 스프라이트를 밀려나게 하기 위한 처리
            for ( let spr of otherSprites ) {
                if ( spr.attrib.enableBlock ) {
                    // block 속성이 켜진 경우
                }
            }
        }

        if ( ( this.attrib.enableMapCollisionLeft || this.attrib.enableMapCollisionRight || this.attrib.enableMapCollisionTop || this.attrib.enableMapCollisionBottom ) && this.animationStopCounter == 0 ) {
            // 맵충돌 순서는 바닥, 천장, 우측, 좌측
            /** @type {VsWorld} */
            const world = _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.world;

            let adjust = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );
            let adjustVelocity = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );
            let touchedMapAttrib = 0;
            let opos = this.position;

            // TODO: 스프라이트가 계증 구조가 되는 경우를 커버해야함
            // 좌표계 바꾸는 처리가 필요하다

            let lpos = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( this.x + delta.x,this.y + delta.y );
            let collideList = [];

            if ( this.attrib.enableMapCollisionBottom && delta.y > 0 ) {
                for ( let x = ( ( lpos.x + r0.x1 ) >> 4 ); x <= ( ( lpos.x + r0.x2 ) >> 4 ); x++ ) {
                    const y = ( lpos.y + r0.y2 + 1 ) >> 4;
                    const mapAttrib = world.getMapAttrib( x,y );

                    if ( mapAttrib & _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_FLOOR ) {
                        collideList.push( [x,y,world.getMap( x,y )] );
                        if ( ( touchedMapAttrib & _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_FLOOR ) == 0 ) {
                            adjust.y = -( ( lpos.y + r0.y2 + 1 ) % 16 );
                            adjustVelocity.y = -this.velocity.y;
                            touchedMapAttrib |= _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_FLOOR;
                            break;
                        }
                    }
                }
            } else if ( this.attrib.enableMapCollisionTop && delta.y < 0 ) {
                for ( let x = ( ( lpos.x + r0.x1 ) >> 4 ); x <= ( ( lpos.x + r0.x2 ) >> 4 ); x++ ) {
                    const y = ( lpos.y + r0.y1 ) >> 4;
                    const mapAttrib = world.getMapAttrib( x,y );

                    if ( mapAttrib & _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_CEIL ) {
                        collideList.push( [x,y,world.getMap( x,y )] );
                        if ( ( touchedMapAttrib & _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_CEIL ) == 0 ) {
                            adjust.y = -( 16 - ( lpos.y + r0.y1 ) % 16 );
                            adjustVelocity.y = -this.velocity.y;
                            touchedMapAttrib |= _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_CEIL;
                            break;
                        }
                    }
                }
            }

            // 중력에 의해서 바닥에 충돌했을 때 바닥면과 좌우 충돌하지 않도록 하기 위해서 여기서 보정 처리 한다            
            lpos.y += adjust.y;
            if ( this.attrib.enableMapCollisionRight && delta.x > 0 ) {
                for ( let y = ( ( lpos.y + r0.y1 ) >> 4 ); y <= ( ( lpos.y + r0.y2 ) >> 4 ); y++ ) {
                    const x = ( lpos.x + r0.x2 + 1 ) >> 4;
                    const mapAttrib = world.getMapAttrib( x, y );

                    if ( mapAttrib & _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_RWALL ) {
                        collideList.push( [x,y,world.getMap( x,y )] );
                        if ( ( touchedMapAttrib & _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_RWALL ) == 0 ) {
                            adjust.x = -( ( lpos.x + r0.x2 + 1 ) % 16 );
                            adjustVelocity.x = -this.velocity.x;
                            touchedMapAttrib |= _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_RWALL;
                            break;
                        }
                    }
                }
            } else if ( this.attrib.enableMapCollisionLeft && delta.x < 0 ) {
                for ( let y = ( ( lpos.y + r0.y1 ) >> 4 ); y <= ( ( lpos.y + r0.y2 ) >> 4 ); y++ ) {
                    const x = ( lpos.x + r0.x1 ) >> 4;
                    const mapAttrib = world.getMapAttrib( x, y );

                    if ( mapAttrib & _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_LWALL ) {
                        collideList.push( [x,y,world.getMap( x,y )] );
                        if ( ( touchedMapAttrib & _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_LWALL ) == 0 ) {
                            adjust.x = -( 16 - ( lpos.x + r0.x1 ) % 16 );
                            adjustVelocity.x = -this.velocity.x;
                            touchedMapAttrib |= _vsWorld__WEBPACK_IMPORTED_MODULE_3__["default"].TILEATTRIB_LWALL;
                            break;
                        }
                    }
                }
            }
            
            // TODO: 빗면 블록처리가 들어갈 자리. palo2에는 용량 때문에 빗면 블록처리를 뺐다.

            if ( this.mapCollisionCallback ) {
                this.mapCollisionCallback.call( this, touchedMapAttrib, {
                    adjust, adjustVelocity,collideList
                } );
            }

            delta = delta.add( adjust );

            if ( this.attrib.disableVelocity == false ) {
                this.velocity = this.velocity.add( adjustVelocity );
            }
        } else {
            if ( this.animationStopCounter > 0 ) this.animationStopCounter--;
        }
        
        this.position = this.position.add( delta );
        // console.log( this.y,this._currentFrame,delta.y );
    }

    prepareDraw() {
        if ( this.attrib.enableFlicker ) {
            this._flicker = 1 - this._flicker;
            if ( this._flicker ) {
                this._currentMesh.setVisible( false );
            } else {
                this._currentMesh.setVisible( true );
            }
        } else {
            if ( this._currentMesh ) this._currentMesh.setVisible( true );
        }
        // 화면 밖으로 나가면 자동으로 사라지도록 한다
        if ( this.attrib.enableAutoRemoveStageOut ) {
            /** @type {VsWorld} */
            const world = _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.world;
            const screenRect = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Rect( -world.x,-world.y,_vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.width,_vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.height );

            if ( this._meshes ) {
                const meshRect = this._currentMesh.visibleRect;
            
                if ( this.x + meshRect.right < screenRect.left || this.x + meshRect.left > screenRect.right || 
                this.y + meshRect.top > screenRect.bottom || this.y + meshRect.bottom < screenRect.top ) {
                    this.remove( "autoRemoveStageOut" );
                }
            } else {
                if ( this.x < screenRect.left || this.x > screenRect.right || 
                this.y > screenRect.bottom || this.y < screenRect.top ) {
                    this.remove( "autoRemoveStageOut" );
                }            
            }
        }
    }

    static processAllSprites() {
        /** @type {Sprite[]} */
        let sprs = _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.searchChildren( true );

        let vsSprs = [];

        for ( let spr of sprs ) {
            if ( !spr.parent ) {
                console.log( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.children );
                console.assert( spr.parent );
            }
            if ( spr instanceof VsSprite ) {
                if ( spr.updateCallback ) spr.updateCallback.call( spr );
                vsSprs.push( spr );
            }
        }

        for ( let spr of vsSprs ) {
            spr.process( vsSprs );
        }

        for ( let spr of vsSprs ) {
            if ( spr.collisionCallback ) spr.collisionCallback.call( spr,vsSprs );
        }

        for ( let spr of vsSprs ) {
            spr.prepareDraw();
        }
        // console.log( vsSprs.length );
    }

    static removeAllSprites() {
        let sprs = stage.searchChildren( true );

        for ( let spr of sprs ) {
            if ( spr.isVsSprite ) {
                spr.remove( "removeAll" );
            }
        }
    }
}
VsSprite.DIR_LEFT = 0x10;
VsSprite.DIR_RIGHT = 0x20;
VsSprite.DIR_TOP = 0x40;
VsSprite.DIR_BOTOOM = 0x80;

VsSprite.defaultAttrib = {
    disableGravity:           false,
    disableGlobalVelocity:    false,
    disableVelocity:          false,
    disableChainAnimation:    false,
    enableAutoRemoveStageOut: false,
    enablePush:               false,        // push 속성을 켜면 block속성을 가진 스프라이트를 밀 수 있다
    enableBlock:              false,
    enableMapCollisionTop:    false,
    enableMapCollisionBottom: false,
    enableMapCollisionLeft:   false,
    enableMapCollisionRight:  false,
    enableHideMesh:           false,
    enableFlicker:            false,
    isScreenCoordinate:       false,
    dskip:                    false,        // ??
    enableDebug:              false,
};

// requestAnimationFrame(
//     ()=>{
//         console.assert( vsStage,`vsStage가 초기화되지 않았습니다.` );
//         VsStage.instance.addEventListener( Event.ENTER_FRAME,VsSprite.processAllSprites );
//         // console.log( `vsSprite: processAll을 등록했습니다.` );
//     }
// );



// GLOBAL.VsSprite = VsSprite;
// module.exports = VsSprite;


/***/ }),

/***/ "./games/PALO2/src/vsWrapper/vsStage.js":
/*!**********************************************!*\
  !*** ./games/PALO2/src/vsWrapper/vsStage.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VsStage)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsPalette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsPalette */ "./games/PALO2/src/vsWrapper/vsPalette.js");
/* harmony import */ var _vsSprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsSprite */ "./games/PALO2/src/vsWrapper/vsSprite.js");
/* harmony import */ var _vsWorld__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vsWorld */ "./games/PALO2/src/vsWrapper/vsWorld.js");








class VsStage extends _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    static get instance() {
        //@ts-ignore
        this.instances["PALO2"] = this.instances["PALO2"] || new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        return Object.setPrototypeOf( this.instances["PALO2"], this.prototype );
    }

    static init( width, height ) {
        return new VsStage( width,height );
    }

    constructor( width,height ) {
        super();
        const _this = VsStage.instance;

        this._width = width | _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalViewport.width;
        this._height = height || _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalViewport.height;
        
        this._backgroundColor = 255;
        this._background = null;

        //TODO: 디버그 팔레트를 기본으로 넣어줘야함
        /** @type {VsPalette|null} */
        this.palette = null;
        /** @type {VsWorld|null} */
        this.world = null;

        this.setClip( 0,0,this._width,this._height );
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.stage.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.RESIZE,function( e ) {
            _this.setClip( 0,0,_this._width,_this._height );
        } );


        _this.onStage( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME,function() {
            if ( VsStage.instance.palette ) VsStage.instance.palette.process();
            _vsSprite__WEBPACK_IMPORTED_MODULE_2__["default"].processAllSprites();
        } );

        // 앱이 기동하기 전에 application에 걸린 이벤트를 보존한다
        //@ts-ignore
        Object.assign( this.eventEmitter._events,_this.eventEmitter._events );
        Object.assign( _this,this );
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.stage.addChild( _this );
        return _this;
    }

    get width() {
        return this._width;
    }

    get height() {
        return this._height;
    }

    get size() {
        return new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( this.width,this.height );
    }

    get rect() {
        return new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Rect( 0,0,this.width,this.height );
    }

    setPalette( pal ) {
        this.palette = pal;
        if ( this._background ) this._background.setShader( pal.createShader() );
    }

    get backgroundColor() {
        return this._backgroundColor;
    }
    
    set backgroundColor( index ) {
        this._backgroundColor = index;
        if ( this._background ) {
            this._background.removeFromParent();
            this._background = null;
        }
        if ( index < 255 ) {
            this._background = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Pixel( _vsPalette__WEBPACK_IMPORTED_MODULE_1__["default"].indexToColor( index ),1, this.width,this.height );
            this._background.setShader( this.palette.createShader() );
            this.addChildAt( this._background,0 );
        }
    }

    setWorld( world, keepSprites ) {
        let oldWorld = this.world;
        let worldIndex;

        if ( oldWorld ) {
            if ( oldWorld.getParent() == this ) {
                worldIndex = this.getChildIndex( oldWorld );
            } else {
                worldIndex = 0;                
            }
            oldWorld.removeFromParent();
        }
        this.world = world;
        if ( this.world ) {
            if ( oldWorld && keepSprites ) {
                let tileMap = this.world.tileMap;

                this.world.clearChildren();
                oldWorld.layer0.removeFromParent();
                this.world.addChild( oldWorld.layer0 );
                this.world.addChild( tileMap );
                this.world.addChild( oldWorld.layer1 );
                this.world.addChild( oldWorld.layer2 );
                this.world.addChild( oldWorld.layer3 );
                this.world.addChild( oldWorld.layer4 );
                this.world.addChild( oldWorld.layer5 );
                this.world.layer0 = oldWorld.layer0;
                this.world.layer1 = oldWorld.layer1;
                this.world.layer2 = oldWorld.layer2;
                this.world.layer3 = oldWorld.layer3;
                this.world.layer4 = oldWorld.layer4;
                this.world.layer5 = oldWorld.layer5;
                this.world.scrollTarget = oldWorld.scrollTarget;
                this.world.eventTarget = oldWorld.eventTarget;
            }
            this.addChildAt( this.world,worldIndex );
            // this.addChild( this.world );
        }
    }
}

/** @type {Object.<string,VsStage>}} */
VsStage.instances = {};


/***/ }),

/***/ "./games/PALO2/src/vsWrapper/vsSystemText.js":
/*!***************************************************!*\
  !*** ./games/PALO2/src/vsWrapper/vsSystemText.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VsSystemText)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsStage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsStage */ "./games/PALO2/src/vsWrapper/vsStage.js");
/* harmony import */ var _vsPalette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsPalette */ "./games/PALO2/src/vsWrapper/vsPalette.js");






const systemFontWidths = [

    // 5 * 5 font length table
    6,2,4,6,6,6,6,3,3,3,5,6,3,6,2,6,6,6,6,6,6,6,6,6,6,6,2,3,4,5,4,4,
    6,6,6,6,6,6,6,6,6,4,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3,6,3,4,4,
    4,5,5,5,5,5,5,5,5,2,3,5,2,6,5,5,5,5,5,5,5,5,5,5,5,5,5,3,2,3,5,5,

    // 3 * 5 font length table
    4,2,4,4,4,4,4,3,3,3,4,4,3,4,2,4,4,4,4,4,4,4,4,4,4,4,2,3,4,4,4,4,
    6,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,4,3,4,4,
    3,4,4,4,4,4,4,4,4,2,3,4,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,2,3,4,4,

    // symbol font length table
    6,2,4,6,6,6,6,3,3,3,5,6,3,6,2,6,6,6,6,6,6,6,6,6,6,6,2,3,4,5,4,4,
    6,6,6,6,6,5,5,5,4,4,6,6,6,6,6,6,6,6,6,4,4,3,6,6,6,6,6,3,6,3,4,4,
    4,5,5,5,5,5,5,5,5,2,3,5,2,6,5,5,5,5,5,5,5,5,5,5,5,5,5,3,2,3,5,5

        
];


// 7 바이트씩 인코딩 x,y,w,h,sx,sy,rot
// 폰트마다 96개
const systemFontFrames = new Uint8Array( [
    99,54,6,8,0,0,0,46,11,1,5,0,0,0,21,1,3,2,0,0,0,61,12,5,5,0,0,0,68,12,5,5,0,0,0,75,12,5,5,0,0,0,82,12,5,5,0,0,0,26,1,2,2,0,0,0,89,12,2,5,0,0,0,93,12,2,5,0,0,0,97,12,4,5,0,0,0,103,12,5,5,0,0,0,30,1,2,2,0,3,0,1,1,5,1,0,2,0,8,1,1,1,0,4,0,110,12,5,5,0,0,0,117,12,5,5,0,0,0,124,12,3,5,1,0,0,6,16,5,5,0,0,0,13,16,5,5,0,0,0,20,17,5,5,0,0,0,27,17,5,5,0,0,0,34,17,5,5,0,0,0,46,18,5,5,0,0,0,53,18,5,5,0,0,0,60,19,5,5,0,0,0,50,1,1,3,0,1,0,6,4,2,4,0,1,0,1,15,3,5,0,0,0,53,1,4,3,0,1,0,41,17,3,5,0,0,0,67,19,3,5,0,0,0,72,19,5,5,0,0,0,79,19,5,5,0,0,0,86,19,5,5,0,0,0,93,19,5,5,0,0,0,100,19,5,5,0,0,0,107,19,5,5,0,0,0,114,19,5,5,0,0,0,121,19,5,5,0,0,0,6,23,5,5,0,0,0,1,22,3,5,0,0,0,13,23,4,5,0,0,0,19,24,5,5,0,0,0,26,24,5,5,0,0,0,33,24,5,5,0,0,0,44,25,5,5,0,0,0,117,12,5,5,0,0,0,51,25,5,5,0,0,0,58,26,5,5,0,0,0,65,26,5,5,0,0,0,72,26,5,5,0,0,0,79,26,5,5,0,0,0,86,26,5,5,0,0,0,93,26,5,5,0,0,0,100,26,5,5,0,0,0,107,26,5,5,0,0,0,114,26,5,5,0,0,0,121,26,5,5,0,0,0,40,24,2,5,0,0,0,5,30,5,5,0,0,0,1,29,2,5,0,0,0,34,1,3,2,0,0,0,11,1,3,1,0,4,0,10,4,3,4,0,1,0,15,4,4,4,0,1,0,12,30,4,5,0,0,0,21,5,4,4,0,1,0,18,31,4,5,0,0,0,27,5,4,4,0,1,0,24,31,4,5,0,0,0,30,31,4,5,0,1,0,36,31,4,5,0,0,0,42,32,1,5,0,0,0,1,36,2,6,0,0,0,45,32,4,5,0,0,0,51,32,1,5,0,0,0,33,5,5,4,0,1,0,40,5,4,4,0,1,0,50,6,4,4,0,1,0,58,33,4,5,0,1,0,64,33,4,5,0,1,0,56,6,4,4,0,1,0,62,6,4,4,0,1,0,70,33,4,5,0,0,0,68,6,4,4,0,1,0,74,6,4,4,0,1,0,80,6,4,4,0,1,0,86,6,4,4,0,1,0,76,33,4,5,0,1,0,92,6,4,4,0,1,0,54,32,2,5,0,0,0,82,33,1,5,0,0,0,85,33,2,5,0,0,0,39,1,4,2,0,0,0,98,6,4,4,0,1,0,123,47,4,8,0,0,0,46,11,1,5,0,0,0,21,1,3,2,0,0,0,89,33,3,5,0,0,0,94,33,3,5,0,0,0,99,33,3,5,0,0,0,104,6,3,4,0,1,0,26,1,2,2,0,0,0,89,12,2,5,0,0,0,93,12,2,5,0,0,0,59,1,3,3,0,1,0,64,1,3,3,0,1,0,30,1,2,2,0,3,0,16,1,3,1,0,2,0,8,1,1,1,0,4,0,69,1,3,3,0,1,0,104,33,3,5,0,0,0,109,33,1,5,1,0,0,112,33,3,5,0,0,0,117,33,3,5,0,0,0,122,33,3,5,0,0,0,5,37,3,5,0,0,0,10,37,3,5,0,0,0,15,38,3,5,0,0,0,20,38,3,5,0,0,0,25,38,3,5,0,0,0,50,1,1,3,0,1,0,6,4,2,4,0,1,0,1,15,3,5,0,0,0,74,1,3,3,0,1,0,41,17,3,5,0,0,0,67,19,3,5,0,0,0,72,19,5,5,0,0,0,30,38,3,5,0,0,0,35,38,3,5,0,0,0,40,39,3,5,0,0,0,45,39,3,5,0,0,0,50,39,3,5,0,0,0,55,40,3,5,0,0,0,60,40,3,5,0,0,0,65,40,3,5,0,0,0,1,22,3,5,0,0,0,70,40,3,5,0,0,0,75,40,3,5,0,0,0,80,40,3,5,0,0,0,85,40,3,5,0,0,0,90,40,3,5,0,0,0,95,40,3,5,0,0,0,100,40,3,5,0,0,0,105,40,3,5,0,0,0,110,40,3,5,0,0,0,115,40,3,5,0,0,0,120,40,3,5,0,0,0,1,44,3,5,0,0,0,6,44,3,5,0,0,0,11,45,3,5,0,0,0,16,45,3,5,0,0,0,21,45,3,5,0,0,0,26,45,3,5,0,0,0,40,24,2,5,0,0,0,79,1,3,3,0,1,0,1,29,2,5,0,0,0,34,1,3,2,0,0,0,11,1,3,1,0,4,0,46,5,2,4,0,1,0,109,6,3,4,0,1,0,31,45,3,5,0,0,0,114,6,3,4,0,1,0,36,46,3,5,0,0,0,119,6,3,4,0,1,0,41,46,3,5,0,0,0,46,46,3,5,0,1,0,51,47,3,5,0,0,0,42,32,1,5,0,0,0,1,36,2,6,0,0,0,56,47,3,5,0,0,0,51,32,1,5,0,0,0,124,6,3,4,0,1,0,1,9,3,4,0,1,0,6,10,3,4,0,1,0,61,47,3,5,0,1,0,66,47,3,5,0,1,0,11,10,3,4,0,1,0,16,10,3,4,0,1,0,71,47,3,5,0,0,0,21,11,3,4,0,1,0,26,11,3,4,0,1,0,31,11,3,4,0,1,0,36,11,3,4,0,1,0,76,47,3,5,0,1,0,41,11,3,4,0,1,0,54,32,2,5,0,0,0,82,33,1,5,0,0,0,85,33,2,5,0,0,0,45,1,3,2,0,0,0,84,1,3,3,0,2,0,99,54,6,8,0,0,0,46,11,1,5,0,0,0,21,1,3,2,0,0,0,61,12,5,5,0,0,0,68,12,5,5,0,0,0,75,12,5,5,0,0,0,82,12,5,5,0,0,0,26,1,2,2,0,0,0,89,12,2,5,0,0,0,93,12,2,5,0,0,0,97,12,4,5,0,0,0,103,12,5,5,0,0,0,30,1,2,2,0,3,0,1,1,5,1,0,2,0,8,1,1,1,0,4,0,110,12,5,5,0,0,0,81,47,5,5,0,0,0,88,47,5,5,0,0,0,95,47,5,5,0,0,0,102,47,5,5,0,0,0,109,47,5,5,0,0,0,89,1,5,3,0,2,0,116,47,5,5,0,0,0,1,51,5,5,0,0,0,8,52,5,5,0,0,0,15,52,5,5,0,0,0,50,1,1,3,0,1,0,6,4,2,4,0,1,0,1,15,3,5,0,0,0,53,1,4,3,0,1,0,41,17,3,5,0,0,0,67,19,3,5,0,0,0,72,19,5,5,0,0,0,22,52,5,5,0,0,0,29,52,5,5,0,0,0,117,12,5,5,0,0,0,36,53,5,5,0,0,0,96,1,3,3,1,1,0,49,12,4,4,0,0,0,55,12,4,4,0,1,0,101,1,3,3,0,0,0,106,1,3,3,0,2,0,43,53,5,5,0,0,0,50,54,5,5,0,0,0,57,54,5,5,0,0,0,64,54,5,5,0,0,0,71,54,5,5,0,0,0,78,54,5,5,0,0,0,85,54,5,5,0,0,0,111,1,5,3,0,1,0,118,1,5,3,0,1,0,1,4,3,3,0,1,0,64,1,3,3,0,1,0,125,1,2,3,0,1,0,92,54,5,5,0,0,0,100,26,5,5,0,0,0,107,26,5,5,0,0,0,114,26,5,5,0,0,0,121,26,5,5,0,0,0,40,24,2,5,0,0,0,5,30,5,5,0,0,0,1,29,2,5,0,0,0,34,1,3,2,0,0,0,11,1,3,1,0,4,0,10,4,3,4,0,1,0,15,4,4,4,0,1,0,12,30,4,5,0,0,0,21,5,4,4,0,1,0,18,31,4,5,0,0,0,27,5,4,4,0,1,0,24,31,4,5,0,0,0,30,31,4,5,0,1,0,36,31,4,5,0,0,0,42,32,1,5,0,0,0,1,36,2,6,0,0,0,45,32,4,5,0,0,0,51,32,1,5,0,0,0,33,5,5,4,0,1,0,40,5,4,4,0,1,0,50,6,4,4,0,1,0,58,33,4,5,0,1,0,64,33,4,5,0,1,0,56,6,4,4,0,1,0,62,6,4,4,0,1,0,70,33,4,5,0,0,0,68,6,4,4,0,1,0,74,6,4,4,0,1,0,80,6,4,4,0,1,0,86,6,4,4,0,1,0,76,33,4,5,0,1,0,92,6,4,4,0,1,0,54,32,2,5,0,0,0,82,33,1,5,0,0,0,85,33,2,5,0,0,0,39,1,4,2,0,0,0,98,6,4,4,0,1,0
] );

const systemFontImage = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Texture( `systemfont.png` );


class VsSystemText extends _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Mesh {
    /**
     *Creates an instance of VsSystemFont.
     * @param {string=} s
     * @param {number=} fontSet
     * @memberof VsSystemText
     */
    constructor( s,fontSet = VsSystemText.FONT_5X5 ) {
        super();
        this._color1 = 0x00f000;
        this._color2 = 0x00f000;
        this.setPalette( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.palette );
        // console.log( VsStage.instance.palette );
        this.fontSet = fontSet;
        this.setTexture( systemFontImage );
        if ( s ) this.setText( s );
    }

    setPalette( pal ) {
        let sh = pal.createShader( systemFontImage );

        this.setShader( sh );
    }

    /**
     *
     *
     * @param {number} index1
     * @param {number=} index2
     * @memberof VsSystemText
     */
    setColor( index1, index2 ) {
        this._color1 = _vsPalette__WEBPACK_IMPORTED_MODULE_2__["default"].indexToColor( index1 );
        if ( index2 ) {
            this._color2 = _vsPalette__WEBPACK_IMPORTED_MODULE_2__["default"].indexToColor( index2 );
        } else {
            this._color2 = this._color1;
        }
    }

    /**
     *
     *
     * @param {string} s
     * @memberof VsSystemText
     */
    setText( s ) {
        let idx = [];
        let vtx = [];
        let uv = [];
        let colors = [];
        let x = 0;
        let y = 0;

        for ( let i = 0; i < s.length; i++ ) {
            let ch = s.charCodeAt( i );

            if ( ch == 0x20 ) {
                // 공백
                x += systemFontWidths[this.fontSet * 96];
            } else if ( ch == 10 ) {
                // 엔터
                x = 0;
                y += 8;
            } else if ( ch == 1 ) {
                this.fontSet = VsSystemText.FONT_5X5;
            } else if ( ch == 2 ) {
                this.fontSet = VsSystemText.FONT_3X5;
            } else if ( ch == 3 ) {
                this.fontSet = VsSystemText.FONT_SYMBOL;
            } else if ( ch == 4 ) {
                // TODO: 폰트컬러
            } else if ( ch > 0x20 && ch <= 0x7f ) {
                let dataPos = this.fontSet * ( 96 * 7 ) + ( ch - 0x20 ) * 7;
                let data = systemFontFrames.slice( dataPos,dataPos + 7 );
                let ipos = vtx.length / 2;
                let [u,v,w,h,sx,sy,rot] = data;
                
                idx.push( ipos,ipos + 1,ipos + 2,ipos + 1,ipos + 3,ipos + 2 );
                vtx.push( x + sx,y + sy,x + sx + w,y + sy,x + sx,y + sy + h,x + sx + w,y + sy + h );
                if ( rot == 0 ) {
                    uv.push( u,v,u + w,v,u,v + h,u + w,v + h );
                } else {
                    uv.push( u + h,v,u + h,v + w,u,v,u,v + w );
                }
                colors.push( this._color1,1,this._color1,1,this._color2,1,this._color2,1 );
                x += systemFontWidths[this.fontSet * 96 + ch - 0x20];
            }
        }
        this.setVertexArray( vtx );
        this.setIndexArray( idx );
        this.setColorArray( colors );
        this.setTextureCoordinateArray( uv );
    }
}

VsSystemText.FONT_5X5 = 0;
VsSystemText.FONT_3X5 = 1;
VsSystemText.FONT_SYMBOL = 2;

//module.exports = VsSystemText;


/***/ }),

/***/ "./games/PALO2/src/vsWrapper/vsWorld.js":
/*!**********************************************!*\
  !*** ./games/PALO2/src/vsWrapper/vsWorld.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VsWorld)
/* harmony export */ });
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsStage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsStage */ "./games/PALO2/src/vsWrapper/vsStage.js");
/* harmony import */ var _vsPalette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsPalette */ "./games/PALO2/src/vsWrapper/vsPalette.js");
/* harmony import */ var _vsSprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vsSprite */ "./games/PALO2/src/vsWrapper/vsSprite.js");





        

class VsWorld extends _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor( mapName ) {
        super();
        const mapData = JSON.parse( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.getEmbeddedFile( `map_${mapName}.json` ) );
        const tileImageName = `pat_${mapName}.png`;

        this.mapWidth = mapData[0].length;
        this.mapHeight = mapData.length;

        this.tileMap = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.TileMap( this.mapWidth,this.mapHeight,new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Texture( tileImageName ),16,16,2,2,1,1 );
        this.setPalette( _vsStage__WEBPACK_IMPORTED_MODULE_1__["default"].instance.palette );

        let evnData = JSON.parse( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.getEmbeddedFile( `evn_${mapName}.json` ) );

        this.mapBase = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( evnData.mapBaseX,evnData.mapBaseY );
        this.eventData = evnData;
        for ( let i = 0; i < 256; i++ ) {
            this.eventData.eventVars[i].flag = 0;
        }
        
        let tileAttribs = JSON.parse( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.getEmbeddedFile( `pat_${mapName}.json` ) );

        this.tileAttribs = new Uint8Array( tileAttribs );
        
        this.mapData = [];
        // console.log( `맵설정` );
        for ( let y = 0; y < this.mapHeight; y++ ) {
            this.mapData[y] = new Uint16Array( this.mapWidth );
            for ( let x = 0; x < this.mapWidth; x++ ) {
                let t = mapData[y][x];

                this.tileMap.setTile( x,y,t % 14,Math.floor( t / 14 ) );
                this.mapData[y][x] = t;
            }
        }

        // console.log( `맵설정끝` );
        
        this.layer0 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        this.layer1 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        this.layer2 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        this.layer3 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        this.layer4 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        this.layer5 = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sprite();
        this.addChild( this.layer0 );
        this.addChild( this.tileMap );
        this.addChild( this.layer1 );
        this.addChild( this.layer2 );
        this.addChild( this.layer3 );
        this.addChild( this.layer4 );
        this.addChild( this.layer5 );

        this.scrollTargetPosition = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );
        this.currentScrollPosition = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0, 0 );
        this.scrollRect = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Rect( -1,-1,2,2 );
        this.scrollTarget = null;
        this.eventTarget = null;
        this.safeBorder = 0;
        this.gravity = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );
        this.constantVelocity = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( 0,0 );
        
        this.onStage( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.ENTER_FRAME,this.processScroll );
        
        // this.processScroll();
    }

    setPalette( pal ) {
        let sh = pal.createShader( this.tileMap.__texture );

        this.tileMap.setShader( sh );
    }

    setSafeBorder( pxWidth ) {
        //setExtraMap
        this.safeBorder = pxWidth;
    }

    setScrollTarget( spr ) {
        this.scrollTarget = spr;
    }

    processScroll() {
        // TODO: 스크롤 안하는 영역 처리 필요 
        // (127,99)-(255-127,199-99)

        if ( this.scrollTarget ) {
            this.scrollTargetPosition = this.scrollTarget.position;
        }
        // let x = Utils.clamp( this.scrollTargetPosition.x, this.safeBorder, this.mapWidth * 16 - VsStage.instance.width - this.safeBorder * 2 );
        // let y = Utils.clamp( this.scrollTargetPosition.y, this.safeBorder, this.mapHeight * 16 - VsStage.instance.height - this.safeBorder * 2 );
        let x = this.currentScrollPosition.x;
        let y = this.currentScrollPosition.y;
        let nx = this.scrollTargetPosition.x;
        let ny = this.scrollTargetPosition.y;
        let pos1 = this.getWorldCoordinate( this.scrollRect.left,this.scrollRect.top );
        let pos2 = this.getWorldCoordinate( this.scrollRect.right,this.scrollRect.bottom );

        if ( nx < pos1.x || nx >= pos2.x ) {
            x = nx;   
        }
        if ( ny < pos1.y || ny >= pos2.y ) {
            y = ny;
        }
        // y=160;
        // 원작과 같게 하려면 정수화가 필요함
        this.setScroll( x,y );
        this.currentScrollPosition.x = x;
        this.currentScrollPosition.y = y;
    }

    getMap( tileX,tileY ) {
        if ( tileX < 0 || tileX >= this.mapWidth || tileY < 0 || tileY >= this.mapHeight ) return 0;
        return this.mapData[tileY][tileX];
    }

    setMap( tileX,tileY,tileNum ) {
        if ( tileX < 0 || tileX >= this.mapWidth || tileY < 0 || tileY >= this.mapHeight ) return;
        this.tileMap.setTile( tileX,tileY,tileNum % 14,Math.floor( tileNum / 14 ) );
        this.mapData[tileY][tileX] = tileNum;
    }

    getMapAttrib( tileX,tileY ) {
        if ( tileX < 0 || tileX >= this.mapWidth || tileY < 0 || tileY >= this.mapHeight ) return 0;
        const tileNum = this.mapData[tileY][tileX];

        return this.tileAttribs[tileNum];
    }

    setScroll( x,y ) {
        // this.x = 128-Utils.clamp(x,this.safeBorder + 128, this.mapWidth * 16 - VsStage.instance.width - this.safeBorder * 2 +128);
        // this.y = 100-Utils.clamp(y, this.safeBorder + 100, this.mapHeight * 16 - VsStage.instance.height - this.safeBorder * 2 +100);
        this.x = 128 - x;
        this.y = 100 - y;
    }

    getMapEventNumber( x, y ) {
        let tx = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( Math.floor( x / 16 ),0,this.mapWidth - 1 );
        let ty = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.clamp( Math.floor( y / 16 ),0,this.mapHeight - 1 );

        return this.eventData.eventMap[ty][tx];
    }

    getWorldCoordinate( x,y ) {
        let p = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( x - this.x,y - this.y );

        return p;
    }

    getStageCoordinate( x,y ) {
        let p = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point(  x + this.x,y + this.y );

        return p;
    }

    getWorldX( x ) {
        return x - this.x;
    }

    getWorldY( y ) {
        return y - this.y;
    }

    getStageX( x ) {
        return x + this.x;
    }

    getStageY( y ) {
        return y + this.y;
    }
}

VsWorld.TILEATTRIB_FLOOR = 0x80;
VsWorld.TILEATTRIB_CEIL = 0x40;
VsWorld.TILEATTRIB_LWALL = 0x20;
VsWorld.TILEATTRIB_RWALL = 0x10;
VsWorld.TILEATTRIB_LSLOPE = 0x08;
VsWorld.TILEATTRIB_RSLOPE = 0x04;

// GLOBAL.VsWorld = VsWorld;
// module.exports = VsWorld;


/***/ }),

/***/ "./games/PALO2/src/zako.js":
/*!*********************************!*\
  !*** ./games/PALO2/src/zako.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ "./games/PALO2/src/global.js");
/* harmony import */ var _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vsWrapper/vs */ "./games/PALO2/src/vsWrapper/vs.js");





// TODO: life,level 등으로 정의된 부분을 명시적으로 바꿔주어야 한다. 




function angleToXY( angle,speed ) {
    let rad = angle * Math.PI / 180;

    return [Math.cos( rad ) * speed,-Math.sin( rad ) * speed];
}
/**
 *
 *
 * @class Zako
 * @extends {VsSprite}
 */
class Zako extends _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite {
    constructor( e ) {
        const { type, x,y,hp,level,subType,timer } = e;

        switch ( type ) {
        case "zako1": //디스켓과 CD
            super( "zako",{ x:                      x, y:                      y,
                            action:                 subType,
                            life:                   hp * 10,
                            level:                  level,
                            exprosionPower:         0,
                            exprosionParticleCount: 1,
                            isDropPowerUp:          subType,
                            scoreBonus:             200 + subType * 300
            } );
            this.velocity.x = -1;
            this.attrib.disableGravity = true;
            this.attrib.enableMapCollisionLeft = true;
            this.attrib.enableMapCollisionRight = true;
            this.AI = this.AI_zako1;
            break;
        case "zako2": // 주먹
            super( "zako",{ x:                      x, y:                      y,
                            action:                 2,
                            life:                   hp * 5,
                            targetPlayerNumber:     _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ),
                            timer:                  timer * 10,
                            exprosionPower:         1,
                            exprosionParticleCount: 5,
                            isDropPowerUp:          ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,6 ) == 0 ) ? 20 : 0,
                            scoreBonus:             1000,
            } );
            this.velocity.x = 0.25;
            this.attrib.disableGravity = true;
            // this.attrib.enableMapCollisionTop = true;
            // this.attrib.enableMapCollisionBottom = true;
            // this.attrib.enableMapCollisionLeft = true;
            // this.attrib.enableMapCollisionRight = true;
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null || _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].gameOver ) this.targetPlayerNumber = 1 - this.targetPlayerNumber;
            this.AI = this.AI_zako2;
            break;
        case "zako3": // 총알막는 신발
            super( "zako",{ x:                      x, y:                      y,
                            action:                 3 + subType,
                            life:                   hp * 5,
                            targetPlayerNumber:     _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ),
                            speed:                  subType + 1,
                            exprosionPower:         1,
                            exprosionParticleCount: 5,
                            isDropPowerUp:          20,
                            scoreBonus:             1500,
            } );
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null || _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].gameOver ) this.targetPlayerNumber = 1 - this.targetPlayerNumber;
            this.attrib.disableGravity = true;
            this.AI = this.AI_zako3;
            break;
        case "zako4": // 탄쏘는 반구
            super( "zako",{ x:                      x, y:                      y,
                            action:                 5,
                            life:                   hp * 10,
                            level:                  level,
                            targetPlayerNumber:     _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ),
                            timer:                  timer * 10,
                            exprosionPower:         0,
                            exprosionParticleCount: 1,
                            isDropPowerUp:          ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,9 ) == 0 ) ? 20 : 0,
                            scoreBonus:             600,
            } );
            this.status1 = 1;
            this.attrib.disableGravity = false;
            this.attrib.enableMapCollisionLeft = true;
            this.attrib.enableMapCollisionRight = true;
            this.attrib.enableMapCollisionBottom = true;
            this.AI = this.AI_zako4;
            break;
        case "zako5": // 원자탄
            super( "zako",{ x:                      x, y:                      y,
                            action:                 6,
                            life:                   hp * 10,
                            isShootWhenDie:         1,
                            exprosionPower:         0,
                            exprosionParticleCount: 1,
                            isDropPowerUp:          5,
                            scoreBonus:             500,
            } );
            this.velocity.x = 0.4;
            this.attrib.disableGravity = true;
            this.attrib.enableMapCollisionTop = true;
            this.attrib.enableMapCollisionBottom = true;
            this.attrib.enableMapCollisionLeft = true;
            this.attrib.enableMapCollisionRight = true;
            break;
        case "zako6": // 가위
            super( "zako",{ x:                      x, y:                      y,
                            action:                 7,
                            life:                   hp * 10,
                            exprosionPower:         2,
                            exprosionParticleCount: 2,
                            isDropPowerUp:          ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,9 ) == 0 ) ? 20 : 0,
                            scoreBonus:             500,
            } );
            this.velocity.x = -3;
            this.attrib.disableGravity = true;
            break;
        case "zako7": // 하루방
            super( "zako",{ x:                      x, y:                      y,
                            action:                 8,
                            life:                   hp * 10,
                            level:                  level,
                            timer:                  0,
                            targetPlayerNumber:     0,
                            exprosionPower:         1,
                            exprosionParticleCount: 5,
                            isDropPowerUp:          _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ) * 10,
                            scoreBonus:             5000,
            } );
            if ( level < 4 ) e.status1 = 1;
            this.flipX = true;
            this.attrib.enableMapCollisionBottom = true;
            this.status2 = 0;
            this.setMapCollisionPhaseCallback( ( flag )=>{
                if ( flag ) { 
                    if ( this.status2 == 0 ) {
                        if ( this.action == 8 ) {
                        // setQuake( 5,3 );
                        // sayVoice( 3 );
                        }
                        this.status2 = 1; // 바닥에 닿음
                    }
                }
            } );
            this.AI = this.AI_zako7;
            this.breakFlag = true;
            break;
        case "zako8": // 화투장
            super( "zako",{ x:                      x, y:                      y,
                            action:                 9,
                            life:                   hp * 5,
                            level:                  level,
                            targetPlayerNumber:     _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ),
                            exprosionPower:         0,
                            exprosionParticleCount: 1,
                            isDropPowerUp:          _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ) * 10,
                            scoreBonus:             700,
            } );
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null || _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].gameOver ) this.targetPlayerNumber = 1 - this.targetPlayerNumber;
            this.attrib.disableGravity = true;
            this.attrib.enableFlicker = true;
            this.AI = this.AI_zako8;
            break;
        case "miniDuck": // 작은 오리
            super( "zako",{ x:                      x, y:                      y,
                            action:                 21,
                            life:                   50,
                            level:                  1,
                            targetPlayerNumber:     _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ),
                            exprosionPower:         0,
                            exprosionParticleCount: 1,
                            isDropPowerUp:          _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ) * 5,
                            scoreBonus:             200,
            } );
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null || _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].gameOver ) this.targetPlayerNumber = 1 - this.targetPlayerNumber;
            this.attrib.disableGravity = true;
            this.attrib.enableFlicker = true;
            this.AI = this.AI_zako8;
            break;
        case "zako9": // 오리 보스
            super( "zako",{ x:                      x, y:                      y,
                            action:                 10,
                            life:                   hp * 10,
                            exprosionPower:         4,
                            exprosionParticleCount: 15,
                            scoreBonus:             5000,
            } );
            this.velocity.y = 1;
            this.attrib.disableGravity = true;
            this.AI = this.AI_zako9;
            break;
        case "zako10": //풍선
            super( "zako",{ x:                      x, y:                      y,
                            action:                 11 + subType,
                            life:                   0,
                            isShootWhenDie:         subType == 2 ? 1 : 0,
                            exprosionPower:         4,
                            exprosionParticleCount: 1,
                            isDropPowerUp:          subType == 0 ? 10 : 0,
                            scoreBonus:             100 + subType * 100,
            } );

            this.velocity.x = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( -2,5 ) * 0.05;
            this.velocity.y = -_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 1,12 ) * 0.05;
            // if (gameOver[sprite[newSpr].var[2]]) sprite[newSpr].var[2]=1-sprite[newSpr].var[2];
            this.setCollisionPhaseCallback( this.collision.bind( this,0 ) );
            this.attrib.disableGravity = true;
            break;
        case "zako11": //불기둥
            super( "zako",{ x:                  _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 270 + 100 ), y:                  _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 30 ),
                            action:             15,
                            life:               hp * 10,
                            targetPlayerNumber: _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 ),
                            scoreBonus:         5000,
            } );
            this.animationStopCounter = 300;
            // s.velocity.y=1;
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null || _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].gameOver ) this.targetPlayerNumber = 1 - this.targetPlayerNumber;
            this.attrib.disableGravity = true;
            this.AI = this.AI_zako11;
            break;
        case "monitor":
            super( "zako",{ x:          _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 270 ), y:          _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( -30 ),
                            action:     17,
                            life:       120,
                            scoreBonus: 5000,
            } );
            this.attrib.disableGravity = true;
            this.velocity.x = -1;
            this.velocity.y = 1;
            this.AI = this.AI_monitor;
            // TODO: 대사 처리 해야함
            // showMessage(119);
            // currentMessage=119;
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "dialog",{ msg: "monitor" } ) );                    
            break;
        case "zako12": //제목보스
            super( "effect",{ x:                      x, y:                      y,
                              action:                 2,
                              life:                   hp * 10,
                              exprosionPower:         4,
                              exprosionParticleCount: 15,
                              scoreBonus:             10000,
            } );
            this.attrib.disableGravity = true;
            this.AI = this.AI_zako12;
            break;
        case "zako12-1": //제목보스
            super( "effect",{ x:      x, y:      y,
                              action: 5,
                              life:   hp * 10,
            } );
            this.attrib.disableGravity = true;
            break;
        case "zako13": // 해골브라
            super( "zako",{ x:                      x + 21, y:                      y - 57,
                            action:                 18,
                            life:                   hp * 10,
                            exprosionPower:         4,
                            exprosionParticleCount: 15,
                            scoreBonus:             10000,
            } );
            this.status3 = 1;
            this.attrib.disableGravity = true;
            // 얼굴을 깔아놓는다
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer1.addChild( new Zako( { type: "face",x: x, y: y } ) );
            this.AI = this.AI_zako13;
            break;
        case "face": // 얼굴
            super( "zako",{ x:                      x + 21, y:                      y - 59,
                            action:                 19,
                            life:                   10000,
                            exprosionPower:         4,
                            exprosionParticleCount: 15,
                            scoreBonus:             10000,
            } );
            this.status3 = 1;
            this.attrib.disableGravity = true;
            break;
        case "swordtrail": // 불기둥 검광
            super( "zako",{ x:          x, y:          y,
                            action:     16,
                            life:       10000,
                            scoreBonus: 20000,
            } );
            this.attrib.disableGravity = true;
            break;
        default:
            super( "zako" );
        }

        this.life = this.life;
        this.level = this.level;
        this.targetPlayerNumber = this.targetPlayerNumber;
        this.scoreBonus = this.scoreBonus;
        this.explosionParticleCount = this.explosionParticleCount;
        this.explosionPower = this.explosionPower;
        this.isDropPowerUp = this.isDropPowerUp;
        this.isShootWhenDie = this.isShootWhenDie;
        this.speed = this.speed;
        // let t = new VsSystemText( e.type );
        // s.addChild( t );
        this.isEnemy = true;
        // this.shoot( this.x,this.y,-1,0 );
        this.setUpdatePhaseCallback( this.update );
        if ( this.collisionCallback == null ) {
            this.setCollisionPhaseCallback( this.collision.bind( this,100 ) );
        }
        // this.attrib.enableDebug = true;
        this.on( "hit",this.onHit );
        this.status4 = 0;
        this.on( "cleanUp",this.onHit );
    }

    update() {
        this.white = 0;
        // if ( this.breakFlag ) {
        //     console.log( vsStage.world.getStageX( this.x ),vsStage.world.getStageY( this.y ) );
        //     console.assert();   
        // }
        if ( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageX( this.x ) < -this.getWidth() * 0.5
            || _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageX( this.x ) > _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.logicalViewport.width * 1.5 
            || _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageY( this.y ) < -this.getHeight() ) {
            this.remove( "autoRemoveComponent" );
            // 
        }
        if ( this.AI ) this.AI();
    }

    collision( damage ) {
        const checkPlayer = ( p ) => {
            const player = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[p];

            if ( player && player.readyTimer == 0 ) {
                if ( player.shield ) {
                    // 쉴드에 충돌했는가
                    if ( this.checkRange( player.shield,0,0 ) ) {
                        if ( damage > 0 ) {
                            player.shield.dispatchEvent( "hit",{ type: "collision", damage: damage } );
                        }
                        this.dispatchEvent( "hit",{ type: "collision",damage: 100,owner: player } );
                    }
                }
                if ( this.life >= 0 && this.checkRange( player,0,0 ) ) {
                    if ( damage > 0 ) {
                        player.dispatchEvent( "hit",{ type: "collision", damage: damage } );
                    }
                    this.dispatchEvent( "hit",{ type: "collision",damage: 100,owner: player } );
                }
            }
        };

        checkPlayer( 1 );
        checkPlayer( 2 );
    }

    onHit( e ) {
        let { damage,owner } = e;

        if ( this.action == 19 ) {
            damage += 100;
        }
        this.life -= damage;
        this.white = 1;
        owner.score += this.scoreBonus;
        if ( this.life <= 0 ) {
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "explosion", { x: this.x,y: this.y,count: this.explosionParticleCount || 0 ,power: this.explosionPower || 0 } );

            if ( this.isDropPowerUp > 0 ) {
                this.dropPowerUp( this.x + _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0, 0 ),this.y,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,7 ) );
            }
            this.remove( "die" );

            if ( this.scoreBonus >= 5000 ) {
                // 보스?
                if ( this.action == 15 ) {
                    // 불기둥
                    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "dialog",{ msg: "ending" } ) );                    
                } else if ( this.action == 17 ) {
                    // 모니터
                    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "dialog",{ msg: "monitorBroken" } ) );                    
                    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "gameOver" );                    
                } else if ( this.action != 15 ) {
                    // 불기둥 터질 때 클린업 처리하면 모니터가 터져서 안됨
                    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "cleanUp", { type: "cleanUp",damage: 2000 } );
                    if ( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x == 0 ) {
                        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "bgm",{ filename: `space` } );
                        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x = 0.5;
                        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.eventTarget.velocity.x = 0.5;        
                    }
                }
                _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.palette.fade( { start: 1,end: 0, duration: 40, range: [0,254] } );
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `bang.wav` );
            } else {
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `zako.wav` );
            }

            // if ( this.action == 18 ) {
            //     // 해골브라
            //     let spr = new VsSprite( "zako",{ x: this.x,y: this.y,action: 19 } );
            //     spr.attrib.enableAutoRemoveStageOut = true;
            //     spr.life = 3000;
            //     spr.scoreBonus = 5000;
            //     spr.status = 1;
            //     vsStage.world.layer1.addChild( spr );
            // }
            // if ( this.action == 19 ) {
            //     // 미안브라
            //     let spr = new VsSprite( "zako",{ x: this.x,y: this.y,action: 20 } );
            //     spr.attrib.enableAutoRemoveStageOut = true;
            //     spr.life = 5000;
            //     spr.status = 1;
            //     vsStage.world.layer1.addChild( spr );
            // }
            if ( this.action == 17 ) {
                // 모니터
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `bang.wav` );
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "explosion",{ x: this.x,y: this.y,count: 20,power: 4 } );
                _global__WEBPACK_IMPORTED_MODULE_1__["default"].restCoin = 0;
                // rest[0]=0;
                // rest[1]=0;
                // readyTimer[0]=0;
                // readyTimer[1]=0;
                // playerDie(0);
                // playerDie(1);
            }
            if ( this.action == 15 ) {
                owner.score += 30000;
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `bang.wav` );
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "explosion",{ x: this.x,y: this.y,count: 20,power: 4 } );
            }
            if ( this.isShootWhenDie > 0 ) {
                for ( let i = 0; i < 360; i += 22.5 ) {
                    this.shoot( this.x,this.y, ...angleToXY( i,1.5 ) );
                }
                _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `bang.wav` );
            }
    
            // 스코어 리프래시
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "refreshUI",{ player: owner.player } );
        } else {
            // 탄 맞고 안죽었을 때
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `zako.wav` );
        }
    }

    shoot( x,y,vx,vy ) {
        let spr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( "effect",{
            x:      x,
            y:      y,
            action: 6
        } );

        spr.velocity.x = vx;
        spr.velocity.y = vy;
        spr.autoRemoveTimer = 60 * 100;
        spr.attrib.enableAutoRemoveStageOut = true;
        spr.attrib.disableGravity = true;
        spr.attrib.enableMapCollisionTop = true;
        spr.attrib.enableMapCollisionBottom = true;
        spr.attrib.enableMapCollisionLeft = true;
        spr.attrib.enableMapCollisionRight = true;
        //@ts-ignore
        spr.life = 1;
        spr.setCollisionPhaseCallback( this.collision.bind( spr,10 ) );
        spr.setMapCollisionPhaseCallback( ( touchedMapAttrib )=>{
            if ( touchedMapAttrib ) spr.remove( "block" );
        } );
        spr.on( "hit",( )=>{
            spr.remove( "damage" );
        } );
        spr.on( "cleanUp",( )=>{
            spr.remove( "cleanUp" );
        } );
        //@ts-ignore
        spr.status1 = 44; // ?
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer4.addChild( spr );
    }

    dropPowerUp( x,y,type ) {
        let spr = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( "p_hal",{ x,y,action: type > 0 ? 9 : 10 } );

        spr.attrib.disableGravity = true;
        let players = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players;

        spr.setCollisionPhaseCallback( ()=>{
            function checkPlayer( p ) {
                if ( players[p] && spr.checkRange( players[p],0,0 ) ) {
                    if ( spr.action == 10 ) {
                        // 전소폭탄
                        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `clear.wav` );
                        spr.remove( "cleanUp" );
                        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.dispatchEventWithChildren( "cleanUp", { type: "cleanUp",damage: 100, owner: players[p] } );                        
                    } else {
                        // 일반 파워업
                        players[p].power = ( players[p].power + 1 ) % 7;
                        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.playSound( `item.wav` );
                        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "refreshUI",{ player: p } );
                        spr.remove( "powerUp" );
                    }
                }
            }
            checkPlayer( 1 );
            checkPlayer( 2 );
        } );
        spr.setUpdatePhaseCallback( ()=>{
            if ( _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageX( spr.x ) < -this.getWidth() ) {
                spr.remove( "autoRemoveComponent" );
            }
        } );
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer4.addChild( spr );
    }


    AI_zako1() {
        this.status4 += 2;
        if ( this.status4 > 180 ) {
            this.status4 -= 360;
        }

        if ( this.level > 1 ) {
            this.velocity.y = Math.sin( this.status4 * Math.PI / 180 ) * 0.5;
        }
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,( 5 - this.level ) * 100 + 50 ) == 0 ) {
            let a = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,359 );

            this.shoot( this.x,this.y,...angleToXY( a,0.4 ) );
        }

        if ( this.x < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 25 ) ) {
            this.velocity.x = _global__WEBPACK_IMPORTED_MODULE_1__["default"].scrollSpeed + 1;
        }
    }

    AI_zako2() {
        if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null ) return;
        let targetY = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].y;

        this.timer--;
        if ( this.timer == 0 || this.timer < -255 ) {
            this.velocity.x = -5;
            this.velocity.y = 0;
            this.AI = null;
            return;
        }
        if ( this.y < targetY - 5 ) this.velocity.y = 1;
        else if ( this.y > targetY + 5 ) this.velocity.y = -1;
        if ( this.x < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 235 ) ) {
            this.velocity.x = 0;
            //		cspr.x=WORLD_X(235);
        }
    }

    AI_zako3() {
        if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null ) return;
        let targetX = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].x;
        let targetY = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].y;
    
        if ( this.y < targetY - 5 ) this.velocity.y = this.speed;
        else if ( this.y > targetY + 5 ) this.velocity.y = - this.speed;
        if ( this.x < targetX + 45 ) this.velocity.x = 2;
        else if ( this.x > targetX + 50 ) this.velocity.x = -2;
    }

    AI_zako4() {
        if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null ) return;
        let targetX = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].x;
        let targetY = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].y;

        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,50 ) == 0 ) {
            this.targetPlayerNumber = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 );
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null || _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].gameOver ) this.targetPlayerNumber = 1 - this.targetPlayerNumber;
        }
        if ( targetY < this.y ) {
            if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,150 - this.level * 10 ) == 0 ) {
                let a = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,90 ) * Math.PI / 180;

                if ( targetX < this.x ) {
                    this.shoot( this.x,this.y - 4,Math.cos( a + 90 * Math.PI / 180 ) * 0.5,-Math.sin( a + 90 * Math.PI / 180 ) * 0.5 );
                } else {
                    this.shoot( this.x,this.y - 4,Math.cos( a ) * 0.5,-Math.sin( a ) * 0.5 );
                }
            }
        }
    }

    AI_zako7() {
        this.timer++;
        if ( this.timer > 240 + this.level * 20 ) {
            this.timer = 0;
            this.flipX = true;
        } else if ( this.timer > 200 && ( this.timer & 7 ) == 0 ) {
            this.shoot( this.x,this.y,-4,0 );
        } else if ( this.timer > 150 ) {
            this.flipX = false;
        }
    
        if ( this.level != 0 ) {
            if ( this.status2 == 1 && _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,100 - this.level * 10 ) == 0 ) {
                this.velocity.y = -this.level;
                this.status2 = 0;
            }
        }
    }

    AI_zako8() {
        if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null ) return;
        let targetX = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].x;
        let targetY = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].y;
    
        this.status4++;
        if ( this.status4 > 120 ) {
            this.attrib.enableFlicker = false;
            this.setCollisionPhaseCallback( this.collision.bind( this,100 ) );
    
            if ( this.y < targetY - 5 ) {
                this.velocity.y = ( this.level + 1 ) * 0.25 * 0.5;
            } else if ( this.y > targetY + 5 ) {
                this.velocity.y = -( this.level + 1 ) * 0.25 * 0.5;
            } else {
                this.velocity.y = 0;
            }
    
            if ( this.x < targetX - 5 ) {
                this.velocity.x = ( this.level + 1 ) * 0.25 * 0.5 + _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x;
            } else if ( this.x > targetX + 5 ) {
                this.velocity.x = -( this.level + 1 ) * 0.25 * 0.5 + _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x;
            } else {
                this.velocity.x = _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.scrollTarget.velocity.x;
            }
        } else { 
            this.velocity.y = 0; 
            this.velocity.x = 0; 
            this.setCollisionPhaseCallback( null );
        }
    }

    AI_zako9() {
        if ( this.status4++ > 120 ) {
            this.attrib.enableFlicker = false;
            this.setCollisionPhaseCallback( this.collision.bind( this,100 ) );
        } else {
            this.setCollisionPhaseCallback( null );
        }
    
        if ( this.y < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 10 ) ) this.velocity.y = 1;
        if ( this.y > _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 195 ) ) this.velocity.y = -1;
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,99 ) == 0 ) {
            this.shoot( this.x,this.y,...angleToXY( 170,2 ) );
            this.shoot( this.x,this.y,...angleToXY( 180,2 ) );
            this.shoot( this.x,this.y,...angleToXY( 190,2 ) );
        }
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,99 ) == 0 ) {
            let spr = new Zako( { type: "miniDuck",x: this.x,y: this.y } );

            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
        }
    }


    AI_monitor() {
        if ( this.x < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 10 ) ) this.velocity.x = 1;
        if ( this.x > _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 245 ) ) this.velocity.x = -1;
        if ( this.y < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 10 ) ) this.velocity.y = 1;
        if ( this.y > _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 195 ) ) this.velocity.y = -1;
    }

    AI_zako11() {
        let targetY;
        let targetX;

        //TODO: 불기둥 AI인데 플레이어가 다 죽으면 화면 밖으로 나가는 문제가 있다
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,49 ) == 0 ) {
            this.targetPlayerNumber = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,1 );
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] == null ) return;
        }
        if ( this.life < 300 && this.refSpr == null ) {
            let spr = new Zako( {
                type: "monitor",
                x:    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 270 ),
                y:    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( -30 ),
            } );

            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChildAt( spr );
            this.refSpr = spr;
            _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event( "dialog",{ msg: "monitor" } ) );
        }
        if ( this.status4 != 0 || this.refSpr == null ) {
            if ( _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1] != null ) {
                targetX = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].x;
                targetY = _global__WEBPACK_IMPORTED_MODULE_1__["default"].players[this.targetPlayerNumber + 1].y;
            }
            if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,99 ) == 0 ) this.status4 = 1;
        } else {
            // 모니터 뒤에 숨기
            targetY = this.refSpr.y;
            targetX = this.refSpr.x -  40;
            if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,199 ) == 0 ) this.status4 = 0;
        }
    
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,50 ) == 0 ) {
            // 정지했다가 이동했다가
            this.status4 = 1 - this.status4;
        }
    
        if ( this.y < targetY -  5 ) this.velocity.y = 1 + this.status4;
        else if ( this.y > targetY +  5 )  this.velocity.y = -( 1 + this.status4 );
        else this.velocity.y = 0;
    
        if ( this.x < targetX + 100 && this.x < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldX( 235 ) ) {
            this.velocity.x =  1 + this.status4;
        } else if ( this.x > targetX +  210 ) {
            this.velocity.x = - ( 1 + this.status4 );
        } else {
            this.velocity.x = 0;
        }

        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,100 ) == 0 ) {
            // 검광 발사
            let spr = new Zako( { type: "swordtrail",x: this.x,y: this.y ,hp: 100000 } );

            spr.velocity.x = -1;
            spr.acceleration.x = -0.05;
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
        }
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,119 ) == 0 ) {
            let a = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,359 );

            this.shoot( this.x,this.y -  4 ,...angleToXY( a,0.5 ) );
        }
    }

    AI_zako12() {
        if ( this.status4++ > 120 ) {
            this.attrib.enableFlicker = false;
        }

        if ( this.y < _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 10 ) ) this.velocity.y = 1;
        if ( this.y >  _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getWorldY( 195 ) ) this.velocity.y = -1;
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,70 ) == 0 ) {
            let spr = new Zako( { type: "zako2",x: this.x,y: this.y ,hp: 2,timer: 10 } );

            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
        }
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,120 ) == 0 ) {
            let spr = new Zako( { type: "zako12-1",x: this.x,y: this.y ,hp: 20 } );

            spr.velocity = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( ...angleToXY( 170,2 ) );
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
            spr = new Zako( { type: "zako12-1",x: this.x,y: this.y ,hp: 20 } );
            spr.velocity = new _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Point( ...angleToXY( 190,2 ) );
            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
        }
    }

    AI_zako13() {
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,200 ) == 0 ) {
            let spr = new Zako( { type: "zako4",x: this.x,y: this.y,hp: 5,subType: 1 } );

            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
            spr.level = 13;
            spr.velocity.y = -1;
            spr.velocity.x = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( -4,1 ) * 0.1;
        }
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,300 ) == 0 ) {
            let spr = new Zako( { type: "zako3",x: _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.getStageX( 260 ),y: this.y,hp: 20,subType: 1 } );

            _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
        }
        if ( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,90 ) == 0 ) {
            let a = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 140,220 );

            this.shoot( this.x,this.y,...angleToXY( a - 30,1 ) );
            this.shoot( this.x,this.y,...angleToXY( a - 20,1 ) );
            this.shoot( this.x,this.y,...angleToXY( a - 10,1 ) );
            this.shoot( this.x,this.y,...angleToXY( a,1 ) );
            this.shoot( this.x,this.y,...angleToXY( a + 10,1 ) );
            this.shoot( this.x,this.y,...angleToXY( a + 20,1 ) );
            this.shoot( this.x,this.y,...angleToXY( a + 30,1 ) );
        }
    }
}

function spawnZako( e ) {
    let spr = new Zako( e );

    _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer3.addChild( spr );
}

function explosion( e ) {
    for ( let i = 0; i < ( e.count || 1 ); i++ ) {
        let s = new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.VsSprite( "effect",{ x: e.x,y: e.y } );

        s.animationStopCounter = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,e.count );
        s.attrib.disableGravity = true;
        s.attrib.enableAutoRemoveStageOut = true;
        let rad = _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,359 ) * Math.PI / 180;

        s.velocity.x = Math.cos( rad ) * _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,e.power * 100 ) / 100;
        s.velocity.y = Math.sin( rad ) * _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Utils.random( 0,e.power * 100 ) / 100;
        _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_2__.vsStage.world.layer4.addChild( s );
    }
}

_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "spawn:zako", spawnZako );
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.on( "explosion", explosion );


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {



var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js":
/*!***********************************************************!*\
  !*** ./node_modules/twgl.js/dist/4.x/twgl-full.module.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addExtensionsToContext": () => (/* binding */ addExtensionsToContext),
/* harmony export */   "attributes": () => (/* binding */ attributes),
/* harmony export */   "bindFramebufferInfo": () => (/* binding */ bindFramebufferInfo),
/* harmony export */   "bindTransformFeedbackInfo": () => (/* binding */ bindTransformFeedbackInfo),
/* harmony export */   "bindUniformBlock": () => (/* binding */ bindUniformBlock),
/* harmony export */   "canFilter": () => (/* binding */ canFilter),
/* harmony export */   "canGenerateMipmap": () => (/* binding */ canGenerateMipmap),
/* harmony export */   "createAttribsFromArrays": () => (/* binding */ createAttribsFromArrays),
/* harmony export */   "createAttributeSetters": () => (/* binding */ createAttributeSetters),
/* harmony export */   "createBufferFromArray": () => (/* binding */ createBufferFromArray),
/* harmony export */   "createBufferFromTypedArray": () => (/* binding */ createBufferFromTypedArray),
/* harmony export */   "createBufferInfoFromArrays": () => (/* binding */ createBufferInfoFromArrays),
/* harmony export */   "createBuffersFromArrays": () => (/* binding */ createBuffersFromArrays),
/* harmony export */   "createFramebufferInfo": () => (/* binding */ createFramebufferInfo),
/* harmony export */   "createProgram": () => (/* binding */ createProgram),
/* harmony export */   "createProgramFromScripts": () => (/* binding */ createProgramFromScripts),
/* harmony export */   "createProgramFromSources": () => (/* binding */ createProgramFromSources),
/* harmony export */   "createProgramInfo": () => (/* binding */ createProgramInfo),
/* harmony export */   "createProgramInfoFromProgram": () => (/* binding */ createProgramInfoFromProgram),
/* harmony export */   "createSampler": () => (/* binding */ createSampler),
/* harmony export */   "createSamplers": () => (/* binding */ createSamplers),
/* harmony export */   "createTexture": () => (/* binding */ createTexture),
/* harmony export */   "createTextures": () => (/* binding */ createTextures),
/* harmony export */   "createTransformFeedback": () => (/* binding */ createTransformFeedback),
/* harmony export */   "createTransformFeedbackInfo": () => (/* binding */ createTransformFeedbackInfo),
/* harmony export */   "createUniformBlockInfo": () => (/* binding */ createUniformBlockInfo),
/* harmony export */   "createUniformBlockInfoFromProgram": () => (/* binding */ createUniformBlockInfoFromProgram),
/* harmony export */   "createUniformBlockSpecFromProgram": () => (/* binding */ createUniformBlockSpecFromProgram),
/* harmony export */   "createUniformSetters": () => (/* binding */ createUniformSetters),
/* harmony export */   "createVAOAndSetAttributes": () => (/* binding */ createVAOAndSetAttributes),
/* harmony export */   "createVAOFromBufferInfo": () => (/* binding */ createVAOFromBufferInfo),
/* harmony export */   "createVertexArrayInfo": () => (/* binding */ createVertexArrayInfo),
/* harmony export */   "draw": () => (/* binding */ draw),
/* harmony export */   "drawBufferInfo": () => (/* binding */ drawBufferInfo),
/* harmony export */   "drawObjectList": () => (/* binding */ drawObjectList),
/* harmony export */   "framebuffers": () => (/* binding */ framebuffers),
/* harmony export */   "getArray_": () => (/* binding */ getArray),
/* harmony export */   "getBytesPerElementForInternalFormat": () => (/* binding */ getBytesPerElementForInternalFormat),
/* harmony export */   "getContext": () => (/* binding */ getContext),
/* harmony export */   "getFormatAndTypeForInternalFormat": () => (/* binding */ getFormatAndTypeForInternalFormat),
/* harmony export */   "getGLTypeForTypedArray": () => (/* binding */ getGLTypeForTypedArray),
/* harmony export */   "getGLTypeForTypedArrayType": () => (/* binding */ getGLTypeForTypedArrayType),
/* harmony export */   "getNumComponentsForFormat": () => (/* binding */ getNumComponentsForFormat),
/* harmony export */   "getNumComponents_": () => (/* binding */ getNumComponents),
/* harmony export */   "getTypedArrayTypeForGLType": () => (/* binding */ getTypedArrayTypeForGLType),
/* harmony export */   "getWebGLContext": () => (/* binding */ getWebGLContext),
/* harmony export */   "glEnumToString": () => (/* binding */ glEnumToString),
/* harmony export */   "isArrayBuffer": () => (/* binding */ isArrayBuffer),
/* harmony export */   "isWebGL1": () => (/* binding */ isWebGL1),
/* harmony export */   "isWebGL2": () => (/* binding */ isWebGL2),
/* harmony export */   "loadTextureFromUrl": () => (/* binding */ loadTextureFromUrl),
/* harmony export */   "m4": () => (/* binding */ m4),
/* harmony export */   "primitives": () => (/* binding */ primitives),
/* harmony export */   "programs": () => (/* binding */ programs),
/* harmony export */   "resizeCanvasToDisplaySize": () => (/* binding */ resizeCanvasToDisplaySize),
/* harmony export */   "resizeFramebufferInfo": () => (/* binding */ resizeFramebufferInfo),
/* harmony export */   "resizeTexture": () => (/* binding */ resizeTexture),
/* harmony export */   "setAttribInfoBufferFromArray": () => (/* binding */ setAttribInfoBufferFromArray),
/* harmony export */   "setAttributeDefaults_": () => (/* binding */ setDefaults),
/* harmony export */   "setAttributePrefix": () => (/* binding */ setAttributePrefix),
/* harmony export */   "setAttributes": () => (/* binding */ setAttributes),
/* harmony export */   "setBlockUniforms": () => (/* binding */ setBlockUniforms),
/* harmony export */   "setBuffersAndAttributes": () => (/* binding */ setBuffersAndAttributes),
/* harmony export */   "setDefaultTextureColor": () => (/* binding */ setDefaultTextureColor),
/* harmony export */   "setDefaults": () => (/* binding */ setDefaults$2),
/* harmony export */   "setEmptyTexture": () => (/* binding */ setEmptyTexture),
/* harmony export */   "setSamplerParameters": () => (/* binding */ setSamplerParameters),
/* harmony export */   "setTextureDefaults_": () => (/* binding */ setDefaults$1),
/* harmony export */   "setTextureFilteringForSize": () => (/* binding */ setTextureFilteringForSize),
/* harmony export */   "setTextureFromArray": () => (/* binding */ setTextureFromArray),
/* harmony export */   "setTextureFromElement": () => (/* binding */ setTextureFromElement),
/* harmony export */   "setTextureParameters": () => (/* binding */ setTextureParameters),
/* harmony export */   "setUniformBlock": () => (/* binding */ setUniformBlock),
/* harmony export */   "setUniforms": () => (/* binding */ setUniforms),
/* harmony export */   "setUniformsAndBindTextures": () => (/* binding */ setUniformsAndBindTextures),
/* harmony export */   "textures": () => (/* binding */ textures),
/* harmony export */   "typedarrays": () => (/* binding */ typedarrays),
/* harmony export */   "utils": () => (/* binding */ utils),
/* harmony export */   "v3": () => (/* binding */ v3),
/* harmony export */   "vertexArrays": () => (/* binding */ vertexArrays)
/* harmony export */ });
/* @license twgl.js 4.21.2 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
Available via the MIT license.
see: http://github.com/greggman/twgl.js for details */
/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 *
 * Vec3 math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new Vec3. In other words you can do this
 *
 *     var v = v3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.
 *
 * or
 *
 *     var v = v3.create();
 *     v3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any vector as the destination. So for example
 *
 *     v3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 * @module twgl/v3
 */

let VecType = Float32Array;

/**
 * A JavaScript array with 3 values or a Float32Array with 3 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/v3.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Vec3
 * @memberOf module:twgl/v3
 */

/**
 * Sets the type this library creates for a Vec3
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Vec3
 * @memberOf module:twgl/v3
 */
function setDefaultType(ctor) {
  const oldType = VecType;
  VecType = ctor;
  return oldType;
}

/**
 * Creates a vec3; may be called with x, y, z to set initial values.
 * @param {number} [x] Initial x value.
 * @param {number} [y] Initial y value.
 * @param {number} [z] Initial z value.
 * @return {module:twgl/v3.Vec3} the created vector
 * @memberOf module:twgl/v3
 */
function create(x, y, z) {
  const dst = new VecType(3);
  if (x) {
    dst[0] = x;
  }
  if (y) {
    dst[1] = y;
  }
  if (z) {
    dst[2] = z;
  }
  return dst;
}

/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector tha tis the sum of a and b.
 * @memberOf module:twgl/v3
 */
function add(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];

  return dst;
}

/**
 * Subtracts two vectors.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector that is the difference of a and b.
 * @memberOf module:twgl/v3
 */
function subtract(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];

  return dst;
}

/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {number} t Interpolation coefficient.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The linear interpolated result.
 * @memberOf module:twgl/v3
 */
function lerp(a, b, t, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);

  return dst;
}

/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} t Interpolation coefficients vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} the linear interpolated result.
 * @memberOf module:twgl/v3
 */
function lerpV(a, b, t, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);

  return dst;
}

/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The max components vector.
 * @memberOf module:twgl/v3
 */
function max(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);

  return dst;
}

/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The min components vector.
 * @memberOf module:twgl/v3
 */
function min(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);

  return dst;
}

/**
 * Multiplies a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */
function mulScalar(v, k, dst) {
  dst = dst || new VecType(3);

  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;

  return dst;
}

/**
 * Divides a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */
function divScalar(v, k, dst) {
  dst = dst || new VecType(3);

  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;

  return dst;
}

/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of a cross b.
 * @memberOf module:twgl/v3
 */
function cross(a, b, dst) {
  dst = dst || new VecType(3);

  const t1 = a[2] * b[0] - a[0] * b[2];
  const t2 = a[0] * b[1] - a[1] * b[0];
  dst[0] = a[1] * b[2] - a[2] * b[1];
  dst[1] = t1;
  dst[2] = t2;

  return dst;
}

/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @return {number} dot product
 * @memberOf module:twgl/v3
 */
function dot(a, b) {
  return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
}

/**
 * Computes the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} length of vector.
 * @memberOf module:twgl/v3
 */
function length$1(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

/**
 * Computes the square of the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} square of the length of vector.
 * @memberOf module:twgl/v3
 */
function lengthSq(v) {
  return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
}

/**
 * Computes the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} distance between a and b
 * @memberOf module:twgl/v3
 */
function distance(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

/**
 * Computes the square of the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} square of the distance between a and b
 * @memberOf module:twgl/v3
 */
function distanceSq(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return dx * dx + dy * dy + dz * dz;
}

/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param {module:twgl/v3.Vec3} a The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The normalized vector.
 * @memberOf module:twgl/v3
 */
function normalize(a, dst) {
  dst = dst || new VecType(3);

  const lenSq = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
  const len = Math.sqrt(lenSq);
  if (len > 0.00001) {
    dst[0] = a[0] / len;
    dst[1] = a[1] / len;
    dst[2] = a[2] / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
  }

  return dst;
}

/**
 * Negates a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} -v.
 * @memberOf module:twgl/v3
 */
function negate(v, dst) {
  dst = dst || new VecType(3);

  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];

  return dst;
}

/**
 * Copies a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A copy of v.
 * @memberOf module:twgl/v3
 */
function copy(v, dst) {
  dst = dst || new VecType(3);

  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];

  return dst;
}

/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of products of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */
function multiply(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];

  return dst;
}

/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of quotients of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */
function divide(a, b, dst) {
  dst = dst || new VecType(3);

  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];

  return dst;
}

var v3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add,
  copy: copy,
  create: create,
  cross: cross,
  distance: distance,
  distanceSq: distanceSq,
  divide: divide,
  divScalar: divScalar,
  dot: dot,
  lerp: lerp,
  lerpV: lerpV,
  length: length$1,
  lengthSq: lengthSq,
  max: max,
  min: min,
  mulScalar: mulScalar,
  multiply: multiply,
  negate: negate,
  normalize: normalize,
  setDefaultType: setDefaultType,
  subtract: subtract
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * 4x4 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = m4.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = m4.create();
 *     m4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = m4.identity();
 *     const trans = m4.translation([1, 2, 3]);
 *     m4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 * @module twgl/m4
 */
let MatType = Float32Array;

/**
 * A JavaScript array with 16 values or a Float32Array with 16 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/m4.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Mat4
 * @memberOf module:twgl/m4
 */

/**
 * Sets the type this library creates for a Mat4
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Mat4
 * @memberOf module:twgl/m4
 */
function setDefaultType$1(ctor) {
  const oldType = MatType;
  MatType = ctor;
  return oldType;
}

/**
 * Negates a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} -m.
 * @memberOf module:twgl/m4
 */
function negate$1(m, dst) {
  dst = dst || new MatType(16);

  dst[ 0] = -m[ 0];
  dst[ 1] = -m[ 1];
  dst[ 2] = -m[ 2];
  dst[ 3] = -m[ 3];
  dst[ 4] = -m[ 4];
  dst[ 5] = -m[ 5];
  dst[ 6] = -m[ 6];
  dst[ 7] = -m[ 7];
  dst[ 8] = -m[ 8];
  dst[ 9] = -m[ 9];
  dst[10] = -m[10];
  dst[11] = -m[11];
  dst[12] = -m[12];
  dst[13] = -m[13];
  dst[14] = -m[14];
  dst[15] = -m[15];

  return dst;
}

/**
 * Copies a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] The matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A copy of m.
 * @memberOf module:twgl/m4
 */
function copy$1(m, dst) {
  dst = dst || new MatType(16);

  dst[ 0] = m[ 0];
  dst[ 1] = m[ 1];
  dst[ 2] = m[ 2];
  dst[ 3] = m[ 3];
  dst[ 4] = m[ 4];
  dst[ 5] = m[ 5];
  dst[ 6] = m[ 6];
  dst[ 7] = m[ 7];
  dst[ 8] = m[ 8];
  dst[ 9] = m[ 9];
  dst[10] = m[10];
  dst[11] = m[11];
  dst[12] = m[12];
  dst[13] = m[13];
  dst[14] = m[14];
  dst[15] = m[15];

  return dst;
}

/**
 * Creates an n-by-n identity matrix.
 *
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} An n-by-n identity matrix.
 * @memberOf module:twgl/m4
 */
function identity(dst) {
  dst = dst || new MatType(16);

  dst[ 0] = 1;
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = 1;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Takes the transpose of a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The transpose of m.
 * @memberOf module:twgl/m4
 */
 function transpose(m, dst) {
  dst = dst || new MatType(16);
  if (dst === m) {
    let t;

    t = m[1];
    m[1] = m[4];
    m[4] = t;

    t = m[2];
    m[2] = m[8];
    m[8] = t;

    t = m[3];
    m[3] = m[12];
    m[12] = t;

    t = m[6];
    m[6] = m[9];
    m[9] = t;

    t = m[7];
    m[7] = m[13];
    m[13] = t;

    t = m[11];
    m[11] = m[14];
    m[14] = t;
    return dst;
  }

  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];

  dst[ 0] = m00;
  dst[ 1] = m10;
  dst[ 2] = m20;
  dst[ 3] = m30;
  dst[ 4] = m01;
  dst[ 5] = m11;
  dst[ 6] = m21;
  dst[ 7] = m31;
  dst[ 8] = m02;
  dst[ 9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m03;
  dst[13] = m13;
  dst[14] = m23;
  dst[15] = m33;

  return dst;
}

/**
 * Computes the inverse of a 4-by-4 matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The inverse of m.
 * @memberOf module:twgl/m4
 */
function inverse(m, dst) {
  dst = dst || new MatType(16);

  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  const tmp_0  = m22 * m33;
  const tmp_1  = m32 * m23;
  const tmp_2  = m12 * m33;
  const tmp_3  = m32 * m13;
  const tmp_4  = m12 * m23;
  const tmp_5  = m22 * m13;
  const tmp_6  = m02 * m33;
  const tmp_7  = m32 * m03;
  const tmp_8  = m02 * m23;
  const tmp_9  = m22 * m03;
  const tmp_10 = m02 * m13;
  const tmp_11 = m12 * m03;
  const tmp_12 = m20 * m31;
  const tmp_13 = m30 * m21;
  const tmp_14 = m10 * m31;
  const tmp_15 = m30 * m11;
  const tmp_16 = m10 * m21;
  const tmp_17 = m20 * m11;
  const tmp_18 = m00 * m31;
  const tmp_19 = m30 * m01;
  const tmp_20 = m00 * m21;
  const tmp_21 = m20 * m01;
  const tmp_22 = m00 * m11;
  const tmp_23 = m10 * m01;

  const t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -
      (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
  const t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -
      (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
  const t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -
      (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
  const t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -
      (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);

  const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);

  dst[ 0] = d * t0;
  dst[ 1] = d * t1;
  dst[ 2] = d * t2;
  dst[ 3] = d * t3;
  dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -
          (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
  dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -
          (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
  dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -
          (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
  dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -
          (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
  dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -
          (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
  dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -
          (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
  dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -
          (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
  dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -
          (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
  dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -
          (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
  dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -
          (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
  dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -
          (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
  dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -
          (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));

  return dst;
}

/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right
 * @param {module:twgl/m4.Mat4} a The matrix on the left.
 * @param {module:twgl/m4.Mat4} b The matrix on the right.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix product of a and b.
 * @memberOf module:twgl/m4
 */
function multiply$1(a, b, dst) {
  dst = dst || new MatType(16);

  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a03 = a[3];
  const a10 = a[ 4 + 0];
  const a11 = a[ 4 + 1];
  const a12 = a[ 4 + 2];
  const a13 = a[ 4 + 3];
  const a20 = a[ 8 + 0];
  const a21 = a[ 8 + 1];
  const a22 = a[ 8 + 2];
  const a23 = a[ 8 + 3];
  const a30 = a[12 + 0];
  const a31 = a[12 + 1];
  const a32 = a[12 + 2];
  const a33 = a[12 + 3];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b03 = b[3];
  const b10 = b[ 4 + 0];
  const b11 = b[ 4 + 1];
  const b12 = b[ 4 + 2];
  const b13 = b[ 4 + 3];
  const b20 = b[ 8 + 0];
  const b21 = b[ 8 + 1];
  const b22 = b[ 8 + 2];
  const b23 = b[ 8 + 3];
  const b30 = b[12 + 0];
  const b31 = b[12 + 1];
  const b32 = b[12 + 2];
  const b33 = b[12 + 3];

  dst[ 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
  dst[ 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
  dst[ 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
  dst[ 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
  dst[ 4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
  dst[ 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
  dst[ 6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
  dst[ 7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
  dst[ 8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
  dst[ 9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
  dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
  dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
  dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
  dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
  dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;

  return dst;
}

/**
 * Sets the translation component of a 4-by-4 matrix to the given
 * vector.
 * @param {module:twgl/m4.Mat4} a The matrix.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with translation set.
 * @memberOf module:twgl/m4
 */
function setTranslation(a, v, dst) {
  dst = dst || identity();
  if (a !== dst) {
    dst[ 0] = a[ 0];
    dst[ 1] = a[ 1];
    dst[ 2] = a[ 2];
    dst[ 3] = a[ 3];
    dst[ 4] = a[ 4];
    dst[ 5] = a[ 5];
    dst[ 6] = a[ 6];
    dst[ 7] = a[ 7];
    dst[ 8] = a[ 8];
    dst[ 9] = a[ 9];
    dst[10] = a[10];
    dst[11] = a[11];
  }
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}

/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The translation component of m.
 * @memberOf module:twgl/m4
 */
function getTranslation(m, dst) {
  dst = dst || create();
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}

/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} axis The axis 0 = x, 1 = y, 2 = z;
 * @return {module:twgl/v3.Vec3} [dst] vector.
 * @return {module:twgl/v3.Vec3} The axis component of m.
 * @memberOf module:twgl/m4
 */
function getAxis(m, axis, dst) {
  dst = dst || create();
  const off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}

/**
 * Sets an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v the axis vector
 * @param {number} axis The axis  0 = x, 1 = y, 2 = z;
 * @param {module:twgl/m4.Mat4} [dst] The matrix to set. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with axis set.
 * @memberOf module:twgl/m4
 */
function setAxis(a, v, axis, dst) {
  if (dst !== a) {
    dst = copy$1(a, dst);
  }
  const off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  dst[off + 2] = v[2];
  return dst;
}

/**
 * Computes a 4-by-4 perspective transformation matrix given the angular height
 * of the frustum, the aspect ratio, and the near and far clipping planes.  The
 * arguments define a frustum extending in the negative z direction.  The given
 * angle is the vertical angle of the frustum, and the horizontal angle is
 * determined to produce the given aspect ratio.  The arguments near and far are
 * the distances to the near and far clipping planes.  Note that near and far
 * are not z coordinates, but rather they are distances along the negative
 * z-axis.  The matrix generated sends the viewing frustum to the unit box.
 * We assume a unit box extending from -1 to 1 in the x and y dimensions and
 * from 0 to 1 in the z dimension.
 * @param {number} fieldOfViewYInRadians The camera angle from top to bottom (in radians).
 * @param {number} aspect The aspect ratio width / height.
 * @param {number} zNear The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} zFar The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */
function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
  dst = dst || new MatType(16);

  const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
  const rangeInv = 1.0 / (zNear - zFar);

  dst[0]  = f / aspect;
  dst[1]  = 0;
  dst[2]  = 0;
  dst[3]  = 0;

  dst[4]  = 0;
  dst[5]  = f;
  dst[6]  = 0;
  dst[7]  = 0;

  dst[8]  = 0;
  dst[9]  = 0;
  dst[10] = (zNear + zFar) * rangeInv;
  dst[11] = -1;

  dst[12] = 0;
  dst[13] = 0;
  dst[14] = zNear * zFar * rangeInv * 2;
  dst[15] = 0;

  return dst;
}

/**
 * Computes a 4-by-4 orthogonal transformation matrix given the left, right,
 * bottom, and top dimensions of the near clipping plane as well as the
 * near and far clipping plane distances.
 * @param {number} left Left side of the near clipping plane viewport.
 * @param {number} right Right side of the near clipping plane viewport.
 * @param {number} bottom Bottom of the near clipping plane viewport.
 * @param {number} top Top of the near clipping plane viewport.
 * @param {number} near The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} far The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */
function ortho(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);

  dst[0]  = 2 / (right - left);
  dst[1]  = 0;
  dst[2]  = 0;
  dst[3]  = 0;

  dst[4]  = 0;
  dst[5]  = 2 / (top - bottom);
  dst[6]  = 0;
  dst[7]  = 0;

  dst[8]  = 0;
  dst[9]  = 0;
  dst[10] = 2 / (near - far);
  dst[11] = 0;

  dst[12] = (right + left) / (left - right);
  dst[13] = (top + bottom) / (bottom - top);
  dst[14] = (far + near) / (near - far);
  dst[15] = 1;

  return dst;
}

/**
 * Computes a 4-by-4 perspective transformation matrix given the left, right,
 * top, bottom, near and far clipping planes. The arguments define a frustum
 * extending in the negative z direction. The arguments near and far are the
 * distances to the near and far clipping planes. Note that near and far are not
 * z coordinates, but rather they are distances along the negative z-axis. The
 * matrix generated sends the viewing frustum to the unit box. We assume a unit
 * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
 * dimension.
 * @param {number} left The x coordinate of the left plane of the box.
 * @param {number} right The x coordinate of the right plane of the box.
 * @param {number} bottom The y coordinate of the bottom plane of the box.
 * @param {number} top The y coordinate of the right plane of the box.
 * @param {number} near The negative z coordinate of the near plane of the box.
 * @param {number} far The negative z coordinate of the far plane of the box.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective projection matrix.
 * @memberOf module:twgl/m4
 */
function frustum(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);

  const dx = (right - left);
  const dy = (top - bottom);
  const dz = (near - far);

  dst[ 0] = 2 * near / dx;
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = 2 * near / dy;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = (left + right) / dx;
  dst[ 9] = (top + bottom) / dy;
  dst[10] = far / dz;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = near * far / dz;
  dst[15] = 0;

  return dst;
}

let xAxis;
let yAxis;
let zAxis;

/**
 * Computes a 4-by-4 look-at transformation.
 *
 * This is a matrix which positions the camera itself. If you want
 * a view matrix (a matrix which moves things in front of the camera)
 * take the inverse of this.
 *
 * @param {module:twgl/v3.Vec3} eye The position of the eye.
 * @param {module:twgl/v3.Vec3} target The position meant to be viewed.
 * @param {module:twgl/v3.Vec3} up A vector pointing up.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The look-at matrix.
 * @memberOf module:twgl/m4
 */
function lookAt(eye, target, up, dst) {
  dst = dst || new MatType(16);

  xAxis = xAxis || create();
  yAxis = yAxis || create();
  zAxis = zAxis || create();

  normalize(
      subtract(eye, target, zAxis), zAxis);
  normalize(cross(up, zAxis, xAxis), xAxis);
  normalize(cross(zAxis, xAxis, yAxis), yAxis);

  dst[ 0] = xAxis[0];
  dst[ 1] = xAxis[1];
  dst[ 2] = xAxis[2];
  dst[ 3] = 0;
  dst[ 4] = yAxis[0];
  dst[ 5] = yAxis[1];
  dst[ 6] = yAxis[2];
  dst[ 7] = 0;
  dst[ 8] = zAxis[0];
  dst[ 9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = eye[0];
  dst[13] = eye[1];
  dst[14] = eye[2];
  dst[15] = 1;

  return dst;
}

/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translation matrix.
 * @memberOf module:twgl/m4
 */
function translation(v, dst) {
  dst = dst || new MatType(16);

  dst[ 0] = 1;
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = 1;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}

/**
 * Translates the given 4-by-4 matrix by the given vector v.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translated matrix.
 * @memberOf module:twgl/m4
 */
function translate(m, v, dst) {
  dst = dst || new MatType(16);

  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];

  if (m !== dst) {
    dst[ 0] = m00;
    dst[ 1] = m01;
    dst[ 2] = m02;
    dst[ 3] = m03;
    dst[ 4] = m10;
    dst[ 5] = m11;
    dst[ 6] = m12;
    dst[ 7] = m13;
    dst[ 8] = m20;
    dst[ 9] = m21;
    dst[10] = m22;
    dst[11] = m23;
  }

  dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
  dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
  dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
  dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;

  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationX(angleInRadians, dst) {
  dst = dst || new MatType(16);

  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = 1;
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = c;
  dst[ 6] = s;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = -s;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateX(m, angleInRadians, dst) {
  dst = dst || new MatType(16);

  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[4]  = c * m10 + s * m20;
  dst[5]  = c * m11 + s * m21;
  dst[6]  = c * m12 + s * m22;
  dst[7]  = c * m13 + s * m23;
  dst[8]  = c * m20 - s * m10;
  dst[9]  = c * m21 - s * m11;
  dst[10] = c * m22 - s * m12;
  dst[11] = c * m23 - s * m13;

  if (m !== dst) {
    dst[ 0] = m[ 0];
    dst[ 1] = m[ 1];
    dst[ 2] = m[ 2];
    dst[ 3] = m[ 3];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationY(angleInRadians, dst) {
  dst = dst || new MatType(16);

  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = c;
  dst[ 1] = 0;
  dst[ 2] = -s;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = 1;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = s;
  dst[ 9] = 0;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateY(m, angleInRadians, dst) {
  dst = dst || new MatType(16);

  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = c * m00 - s * m20;
  dst[ 1] = c * m01 - s * m21;
  dst[ 2] = c * m02 - s * m22;
  dst[ 3] = c * m03 - s * m23;
  dst[ 8] = c * m20 + s * m00;
  dst[ 9] = c * m21 + s * m01;
  dst[10] = c * m22 + s * m02;
  dst[11] = c * m23 + s * m03;

  if (m !== dst) {
    dst[ 4] = m[ 4];
    dst[ 5] = m[ 5];
    dst[ 6] = m[ 6];
    dst[ 7] = m[ 7];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationZ(angleInRadians, dst) {
  dst = dst || new MatType(16);

  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = c;
  dst[ 1] = s;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = -s;
  dst[ 5] = c;
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateZ(m, angleInRadians, dst) {
  dst = dst || new MatType(16);

  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);

  dst[ 0] = c * m00 + s * m10;
  dst[ 1] = c * m01 + s * m11;
  dst[ 2] = c * m02 + s * m12;
  dst[ 3] = c * m03 + s * m13;
  dst[ 4] = c * m10 - s * m00;
  dst[ 5] = c * m11 - s * m01;
  dst[ 6] = c * m12 - s * m02;
  dst[ 7] = c * m13 - s * m03;

  if (m !== dst) {
    dst[ 8] = m[ 8];
    dst[ 9] = m[ 9];
    dst[10] = m[10];
    dst[11] = m[11];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A matrix which rotates angle radians
 *     around the axis.
 * @memberOf module:twgl/m4
 */
function axisRotation(axis, angleInRadians, dst) {
  dst = dst || new MatType(16);

  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;

  dst[ 0] = xx + (1 - xx) * c;
  dst[ 1] = x * y * oneMinusCosine + z * s;
  dst[ 2] = x * z * oneMinusCosine - y * s;
  dst[ 3] = 0;
  dst[ 4] = x * y * oneMinusCosine - z * s;
  dst[ 5] = yy + (1 - yy) * c;
  dst[ 6] = y * z * oneMinusCosine + x * s;
  dst[ 7] = 0;
  dst[ 8] = x * z * oneMinusCosine + y * s;
  dst[ 9] = y * z * oneMinusCosine - x * s;
  dst[10] = zz + (1 - zz) * c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function axisRotate(m, axis, angleInRadians, dst) {
  dst = dst || new MatType(16);

  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;

  const r00 = xx + (1 - xx) * c;
  const r01 = x * y * oneMinusCosine + z * s;
  const r02 = x * z * oneMinusCosine - y * s;
  const r10 = x * y * oneMinusCosine - z * s;
  const r11 = yy + (1 - yy) * c;
  const r12 = y * z * oneMinusCosine + x * s;
  const r20 = x * z * oneMinusCosine + y * s;
  const r21 = y * z * oneMinusCosine - x * s;
  const r22 = zz + (1 - zz) * c;

  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];

  dst[ 0] = r00 * m00 + r01 * m10 + r02 * m20;
  dst[ 1] = r00 * m01 + r01 * m11 + r02 * m21;
  dst[ 2] = r00 * m02 + r01 * m12 + r02 * m22;
  dst[ 3] = r00 * m03 + r01 * m13 + r02 * m23;
  dst[ 4] = r10 * m00 + r11 * m10 + r12 * m20;
  dst[ 5] = r10 * m01 + r11 * m11 + r12 * m21;
  dst[ 6] = r10 * m02 + r11 * m12 + r12 * m22;
  dst[ 7] = r10 * m03 + r11 * m13 + r12 * m23;
  dst[ 8] = r20 * m00 + r21 * m10 + r22 * m20;
  dst[ 9] = r20 * m01 + r21 * m11 + r22 * m21;
  dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
  dst[11] = r20 * m03 + r21 * m13 + r22 * m23;

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param {module:twgl/v3.Vec3} v A vector of
 *     three entries specifying the factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaling matrix.
 * @memberOf module:twgl/m4
 */
function scaling(v, dst) {
  dst = dst || new MatType(16);

  dst[ 0] = v[0];
  dst[ 1] = 0;
  dst[ 2] = 0;
  dst[ 3] = 0;
  dst[ 4] = 0;
  dst[ 5] = v[1];
  dst[ 6] = 0;
  dst[ 7] = 0;
  dst[ 8] = 0;
  dst[ 9] = 0;
  dst[10] = v[2];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;

  return dst;
}

/**
 * Scales the given 4-by-4 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param {module:twgl/m4.Mat4} m The matrix to be modified.
 * @param {module:twgl/v3.Vec3} v A vector of three entries specifying the
 *     factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaled matrix.
 * @memberOf module:twgl/m4
 */
function scale(m, v, dst) {
  dst = dst || new MatType(16);

  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];

  dst[ 0] = v0 * m[0 * 4 + 0];
  dst[ 1] = v0 * m[0 * 4 + 1];
  dst[ 2] = v0 * m[0 * 4 + 2];
  dst[ 3] = v0 * m[0 * 4 + 3];
  dst[ 4] = v1 * m[1 * 4 + 0];
  dst[ 5] = v1 * m[1 * 4 + 1];
  dst[ 6] = v1 * m[1 * 4 + 2];
  dst[ 7] = v1 * m[1 * 4 + 3];
  dst[ 8] = v2 * m[2 * 4 + 0];
  dst[ 9] = v2 * m[2 * 4 + 1];
  dst[10] = v2 * m[2 * 4 + 2];
  dst[11] = v2 * m[2 * 4 + 3];

  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }

  return dst;
}

/**
 * Takes a 4-by-4 matrix and a vector with 3 entries,
 * interprets the vector as a point, transforms that point by the matrix, and
 * returns the result as a vector with 3 entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The point.
 * @param {module:twgl/v3.Vec3} [dst] optional vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed point.
 * @memberOf module:twgl/m4
 */
function transformPoint(m, v, dst) {
  dst = dst || create();
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];

  dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;
  dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;
  dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;

  return dst;
}

/**
 * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a
 * direction, transforms that direction by the matrix, and returns the result;
 * assumes the transformation of 3-dimensional space represented by the matrix
 * is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion. Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The direction.
 * @param {module:twgl/v3.Vec3} [dst] optional Vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed direction.
 * @memberOf module:twgl/m4
 */
function transformDirection(m, v, dst) {
  dst = dst || create();

  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];

  dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];

  return dst;
}

/**
 * Takes a 4-by-4 matrix m and a vector v with 3 entries, interprets the vector
 * as a normal to a surface, and computes a vector which is normal upon
 * transforming that surface by the matrix. The effect of this function is the
 * same as transforming v (as a direction) by the inverse-transpose of m.  This
 * function assumes the transformation of 3-dimensional space represented by the
 * matrix is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion.  Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The normal.
 * @param {module:twgl/v3.Vec3} [dst] The direction. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed normal.
 * @memberOf module:twgl/m4
 */
function transformNormal(m, v, dst) {
  dst = dst || create();
  const mi = inverse(m);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];

  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];

  return dst;
}

var m4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  axisRotate: axisRotate,
  axisRotation: axisRotation,
  copy: copy$1,
  frustum: frustum,
  getAxis: getAxis,
  getTranslation: getTranslation,
  identity: identity,
  inverse: inverse,
  lookAt: lookAt,
  multiply: multiply$1,
  negate: negate$1,
  ortho: ortho,
  perspective: perspective,
  rotateX: rotateX,
  rotateY: rotateY,
  rotateZ: rotateZ,
  rotationX: rotationX,
  rotationY: rotationY,
  rotationZ: rotationZ,
  scale: scale,
  scaling: scaling,
  setAxis: setAxis,
  setDefaultType: setDefaultType$1,
  setTranslation: setTranslation,
  transformDirection: transformDirection,
  transformNormal: transformNormal,
  transformPoint: transformPoint,
  translate: translate,
  translation: translation,
  transpose: transpose
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* DataType */
const BYTE                           = 0x1400;
const UNSIGNED_BYTE                  = 0x1401;
const SHORT                          = 0x1402;
const UNSIGNED_SHORT                 = 0x1403;
const INT                            = 0x1404;
const UNSIGNED_INT                   = 0x1405;
const FLOAT                          = 0x1406;
const UNSIGNED_SHORT_4_4_4_4       = 0x8033;
const UNSIGNED_SHORT_5_5_5_1       = 0x8034;
const UNSIGNED_SHORT_5_6_5         = 0x8363;
const HALF_FLOAT                   = 0x140B;
const UNSIGNED_INT_2_10_10_10_REV  = 0x8368;
const UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
const UNSIGNED_INT_5_9_9_9_REV     = 0x8C3E;
const FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
const UNSIGNED_INT_24_8            = 0x84FA;

const glTypeToTypedArray = {};
{
  const tt = glTypeToTypedArray;
  tt[BYTE]                           = Int8Array;
  tt[UNSIGNED_BYTE]                  = Uint8Array;
  tt[SHORT]                          = Int16Array;
  tt[UNSIGNED_SHORT]                 = Uint16Array;
  tt[INT]                            = Int32Array;
  tt[UNSIGNED_INT]                   = Uint32Array;
  tt[FLOAT]                          = Float32Array;
  tt[UNSIGNED_SHORT_4_4_4_4]         = Uint16Array;
  tt[UNSIGNED_SHORT_5_5_5_1]         = Uint16Array;
  tt[UNSIGNED_SHORT_5_6_5]           = Uint16Array;
  tt[HALF_FLOAT]                     = Uint16Array;
  tt[UNSIGNED_INT_2_10_10_10_REV]    = Uint32Array;
  tt[UNSIGNED_INT_10F_11F_11F_REV]   = Uint32Array;
  tt[UNSIGNED_INT_5_9_9_9_REV]       = Uint32Array;
  tt[FLOAT_32_UNSIGNED_INT_24_8_REV] = Uint32Array;
  tt[UNSIGNED_INT_24_8]              = Uint32Array;
}

/**
 * Get the GL type for a typedArray
 * @param {ArrayBufferView} typedArray a typedArray
 * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */
function getGLTypeForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array)         { return BYTE; }           // eslint-disable-line
  if (typedArray instanceof Uint8Array)        { return UNSIGNED_BYTE; }  // eslint-disable-line
  if (typedArray instanceof Uint8ClampedArray) { return UNSIGNED_BYTE; }  // eslint-disable-line
  if (typedArray instanceof Int16Array)        { return SHORT; }          // eslint-disable-line
  if (typedArray instanceof Uint16Array)       { return UNSIGNED_SHORT; } // eslint-disable-line
  if (typedArray instanceof Int32Array)        { return INT; }            // eslint-disable-line
  if (typedArray instanceof Uint32Array)       { return UNSIGNED_INT; }   // eslint-disable-line
  if (typedArray instanceof Float32Array)      { return FLOAT; }          // eslint-disable-line
  throw new Error('unsupported typed array type');
}

/**
 * Get the GL type for a typedArray type
 * @param {ArrayBufferView} typedArrayType a typedArray constructor
 * @return {number} the GL type for type. For example pass in `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */
function getGLTypeForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array)         { return BYTE; }           // eslint-disable-line
  if (typedArrayType === Uint8Array)        { return UNSIGNED_BYTE; }  // eslint-disable-line
  if (typedArrayType === Uint8ClampedArray) { return UNSIGNED_BYTE; }  // eslint-disable-line
  if (typedArrayType === Int16Array)        { return SHORT; }          // eslint-disable-line
  if (typedArrayType === Uint16Array)       { return UNSIGNED_SHORT; } // eslint-disable-line
  if (typedArrayType === Int32Array)        { return INT; }            // eslint-disable-line
  if (typedArrayType === Uint32Array)       { return UNSIGNED_INT; }   // eslint-disable-line
  if (typedArrayType === Float32Array)      { return FLOAT; }          // eslint-disable-line
  throw new Error('unsupported typed array type');
}

/**
 * Get the typed array constructor for a given GL type
 * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)
 * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).
 * @memberOf module:twgl/typedArray
 */
function getTypedArrayTypeForGLType(type) {
  const CTOR = glTypeToTypedArray[type];
  if (!CTOR) {
    throw new Error('unknown gl type');
  }
  return CTOR;
}

const isArrayBuffer = typeof SharedArrayBuffer !== 'undefined'
  ? function isArrayBufferOrSharedArrayBuffer(a) {
    return a && a.buffer && (a.buffer instanceof ArrayBuffer || a.buffer instanceof SharedArrayBuffer);
  }
  : function isArrayBuffer(a) {
    return a && a.buffer && a.buffer instanceof ArrayBuffer;
  };

var typedarrays = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getGLTypeForTypedArray: getGLTypeForTypedArray,
  getGLTypeForTypedArrayType: getGLTypeForTypedArrayType,
  getTypedArrayTypeForGLType: getTypedArrayTypeForGLType,
  isArrayBuffer: isArrayBuffer
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* eslint no-console: "off" */

/**
 * Copy named properties
 *
 * @param {string[]} names names of properties to copy
 * @param {object} src object to copy properties from
 * @param {object} dst object to copy properties to
 * @private
 */
function copyNamedProperties(names, src, dst) {
  names.forEach(function(name) {
    const value = src[name];
    if (value !== undefined) {
      dst[name] = value;
    }
  });
}

/**
 * Copies properties from source to dest only if a matching key is in dest
 *
 * @param {Object.<string, ?>} src the source
 * @param {Object.<string, ?>} dst the dest
 * @private
 */
function copyExistingProperties(src, dst) {
  Object.keys(dst).forEach(function(key) {
    if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {  /* eslint no-prototype-builtins: 0 */
      dst[key] = src[key];
    }
  });
}

function error(...args) {
  console.error(...args);
}

function warn(...args) {
  console.warn(...args);
}

function isBuffer(gl, t) {
  return typeof WebGLBuffer !== 'undefined' && t instanceof WebGLBuffer;
}

function isRenderbuffer(gl, t) {
  return typeof WebGLRenderbuffer !== 'undefined' && t instanceof WebGLRenderbuffer;
}

function isShader(gl, t) {
  return typeof WebGLShader !== 'undefined' && t instanceof WebGLShader;
}

function isTexture(gl, t) {
  return typeof WebGLTexture !== 'undefined' && t instanceof WebGLTexture;
}

function isSampler(gl, t) {
  return typeof WebGLSampler !== 'undefined' && t instanceof WebGLSampler;
}

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const STATIC_DRAW                  = 0x88e4;
const ARRAY_BUFFER                 = 0x8892;
const ELEMENT_ARRAY_BUFFER         = 0x8893;
const BUFFER_SIZE                  = 0x8764;

const BYTE$1                         = 0x1400;
const UNSIGNED_BYTE$1                = 0x1401;
const SHORT$1                        = 0x1402;
const UNSIGNED_SHORT$1               = 0x1403;
const INT$1                          = 0x1404;
const UNSIGNED_INT$1                 = 0x1405;
const FLOAT$1                        = 0x1406;
const defaults = {
  attribPrefix: "",
};

/**
 * Sets the default attrib prefix
 *
 * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 * as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 * In other words I'll create arrays of geometry like this
 *
 *     var arrays = {
 *       position: ...
 *       normal: ...
 *       texcoord: ...
 *     };
 *
 * But need those mapped to attributes and my attributes start with `a_`.
 *
 * @deprecated see {@link module:twgl.setDefaults}
 * @param {string} prefix prefix for attribs
 * @memberOf module:twgl/attributes
 */
function setAttributePrefix(prefix) {
  defaults.attribPrefix = prefix;
}

function setDefaults(newDefaults) {
  copyExistingProperties(newDefaults, defaults);
}

function setBufferFromTypedArray(gl, type, buffer, array, drawType) {
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, array, drawType || STATIC_DRAW);
}

/**
 * Given typed array creates a WebGLBuffer and copies the typed array
 * into it.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken
 * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.
 * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.
 * @return {WebGLBuffer} the created WebGLBuffer
 * @memberOf module:twgl/attributes
 */
function createBufferFromTypedArray(gl, typedArray, type, drawType) {
  if (isBuffer(gl, typedArray)) {
    return typedArray;
  }
  type = type || ARRAY_BUFFER;
  const buffer = gl.createBuffer();
  setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);
  return buffer;
}

function isIndices(name) {
  return name === "indices";
}

// This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?
function getNormalizationForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line
  if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line
  return false;
}

// This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?
function getNormalizationForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array)    { return true; }  // eslint-disable-line
  if (typedArrayType === Uint8Array)   { return true; }  // eslint-disable-line
  return false;
}

function getArray(array) {
  return array.length ? array : array.data;
}

const texcoordRE = /coord|texture/i;
const colorRE = /color|colour/i;

function guessNumComponentsFromName(name, length) {
  let numComponents;
  if (texcoordRE.test(name)) {
    numComponents = 2;
  } else if (colorRE.test(name)) {
    numComponents = 4;
  } else {
    numComponents = 3;  // position, normals, indices ...
  }

  if (length % numComponents > 0) {
    throw new Error(`Can not guess numComponents for attribute '${name}'. Tried ${numComponents} but ${length} values is not evenly divisible by ${numComponents}. You should specify it.`);
  }

  return numComponents;
}

function getNumComponents(array, arrayName) {
  return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);
}

function makeTypedArray(array, name) {
  if (isArrayBuffer(array)) {
    return array;
  }

  if (isArrayBuffer(array.data)) {
    return array.data;
  }

  if (Array.isArray(array)) {
    array = {
      data: array,
    };
  }

  let Type = array.type;
  if (!Type) {
    if (isIndices(name)) {
      Type = Uint16Array;
    } else {
      Type = Float32Array;
    }
  }
  return new Type(array.data);
}

/**
 * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer
 * for the attribute.
 *
 * @typedef {Object} AttribInfo
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {number} [numComponents] the number of components for this attribute.
 * @property {number} [size] synonym for `numComponents`.
 * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`
 * @property {boolean} [normalize] whether or not to normalize the data. Default = false
 * @property {number} [offset] offset into buffer in bytes. Default = 0
 * @property {number} [stride] the stride in bytes per element. Default = 0
 * @property {number} [divisor] the divisor in instances. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute
 * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW
 * @memberOf module:twgl
 */

/**
 * Use this type of array spec when TWGL can't guess the type or number of components of an array
 * @typedef {Object} FullArraySpec
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {(number|number[]|ArrayBufferView)} data The data of the array. A number alone becomes the number of elements of type.
 * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.
 *    If `coord` is in the name assumes `numComponents = 2`.
 *    If `color` is in the name assumes `numComponents = 4`.
 *    otherwise assumes `numComponents = 3`
 * @property {constructor} [type] type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).
 * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.
 * @property {number} [size] synonym for `numComponents`.
 * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.
 * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0
 * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0
 * @property {number} [divisor] divisor for `vertexAttribDivisor`. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.
 * @property {string} [name] synonym for `attrib`.
 * @property {string} [attribName] synonym for `attrib`.
 * @property {WebGLBuffer} [buffer] Buffer to use for this attribute. This lets you use your own buffer
 *    but you will need to supply `numComponents` and `type`. You can effectively pass an `AttribInfo`
 *    to provide this. Example:
 *
 *         const bufferInfo1 = twgl.createBufferInfoFromArrays(gl, {
 *           position: [1, 2, 3, ... ],
 *         });
 *         const bufferInfo2 = twgl.createBufferInfoFromArrays(gl, {
 *           position: bufferInfo1.attribs.position,  // use the same buffer from bufferInfo1
 *         });
 *
 * @memberOf module:twgl
 */

/**
 * An individual array in {@link module:twgl.Arrays}
 *
 * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBufferView`
 * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will
 * be `Float32Array`. If an ArraySpec is a number it's the number of floats for an empty (zeroed) buffer.
 *
 * @typedef {(number|number[]|ArrayBufferView|module:twgl.FullArraySpec)} ArraySpec
 * @memberOf module:twgl
 */

/**
 * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your
 * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * Objects with various fields. See {@link module:twgl.FullArraySpec}.
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays
 * @memberOf module:twgl
 */


/**
 * Creates a set of attribute data and WebGLBuffers from set of arrays
 *
 * Given
 *
 *      var arrays = {
 *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },
 *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *      };
 *
 * returns something like
 *
 *      var attribs = {
 *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },
 *      };
 *
 * notes:
 *
 * *   Arrays can take various forms
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * @param {WebGLRenderingContext} gl The webgl rendering context.
 * @param {module:twgl.Arrays} arrays The arrays
 * @param {module:twgl.BufferInfo} [srcBufferInfo] a BufferInfo to copy from
 *   This lets you share buffers. Any arrays you supply will override
 *   the buffers from srcBufferInfo.
 * @return {Object.<string, module:twgl.AttribInfo>} the attribs
 * @memberOf module:twgl/attributes
 */
function createAttribsFromArrays(gl, arrays) {
  const attribs = {};
  Object.keys(arrays).forEach(function(arrayName) {
    if (!isIndices(arrayName)) {
      const array = arrays[arrayName];
      const attribName = array.attrib || array.name || array.attribName || (defaults.attribPrefix + arrayName);
      if (array.value) {
        if (!Array.isArray(array.value) && !isArrayBuffer(array.value)) {
          throw new Error('array.value is not array or typedarray');
        }
        attribs[attribName] = {
          value: array.value,
        };
      } else {
        let buffer;
        let type;
        let normalization;
        let numComponents;
        if (array.buffer && array.buffer instanceof WebGLBuffer) {
          buffer = array.buffer;
          numComponents = array.numComponents || array.size;
          type = array.type;
          normalization = array.normalize;
        } else if (typeof array === "number" || typeof array.data === "number") {
          const numValues = array.data || array;
          const arrayType = array.type || Float32Array;
          const numBytes = numValues * arrayType.BYTES_PER_ELEMENT;
          type = getGLTypeForTypedArrayType(arrayType);
          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArrayType(arrayType);
          numComponents = array.numComponents || array.size || guessNumComponentsFromName(arrayName, numValues);
          buffer = gl.createBuffer();
          gl.bindBuffer(ARRAY_BUFFER, buffer);
          gl.bufferData(ARRAY_BUFFER, numBytes, array.drawType || STATIC_DRAW);
        } else {
          const typedArray = makeTypedArray(array, arrayName);
          buffer = createBufferFromTypedArray(gl, typedArray, undefined, array.drawType);
          type = getGLTypeForTypedArray(typedArray);
          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray);
          numComponents = getNumComponents(array, arrayName);
        }
        attribs[attribName] = {
          buffer:        buffer,
          numComponents: numComponents,
          type:          type,
          normalize:     normalization,
          stride:        array.stride || 0,
          offset:        array.offset || 0,
          divisor:       array.divisor === undefined ? undefined : array.divisor,
          drawType:      array.drawType,
        };
      }
    }
  });
  gl.bindBuffer(ARRAY_BUFFER, null);
  return attribs;
}

/**
 * Sets the contents of a buffer attached to an attribInfo
 *
 * This is helper function to dynamically update a buffer.
 *
 * Let's say you make a bufferInfo
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 *  And you want to dynamically update the positions. You could do this
 *
 *     // assuming arrays.position has already been updated with new data.
 *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);
 *
 * @param {WebGLRenderingContext} gl
 * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix
 *   the name of the attribute will include the prefix.
 * @param {ArraySpec} array Note: it is arguably inefficient to pass in anything but a typed array because anything
 *    else will have to be converted to a typed array before it can be used by WebGL. During init time that
 *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.
 * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer
 *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`
 *    for the portion of the array you want to use.
 *
 *        var someArray = new Float32Array(1000); // an array with 1000 floats
 *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray
 *
 *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`
 * @memberOf module:twgl/attributes
 */
function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {
  array = makeTypedArray(array);
  if (offset !== undefined) {
    gl.bindBuffer(ARRAY_BUFFER, attribInfo.buffer);
    gl.bufferSubData(ARRAY_BUFFER, offset, array);
  } else {
    setBufferFromTypedArray(gl, ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);
  }
}

function getBytesPerValueForGLType(gl, type) {
  if (type === BYTE$1)           return 1;  // eslint-disable-line
  if (type === UNSIGNED_BYTE$1)  return 1;  // eslint-disable-line
  if (type === SHORT$1)          return 2;  // eslint-disable-line
  if (type === UNSIGNED_SHORT$1) return 2;  // eslint-disable-line
  if (type === INT$1)            return 4;  // eslint-disable-line
  if (type === UNSIGNED_INT$1)   return 4;  // eslint-disable-line
  if (type === FLOAT$1)          return 4;  // eslint-disable-line
  return 0;
}

// Tries to get the number of elements from a set of arrays.
const positionKeys = ['position', 'positions', 'a_position'];
function getNumElementsFromNonIndexedArrays(arrays) {
  let key;
  let ii;
  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];
    if (key in arrays) {
      break;
    }
  }
  if (ii === positionKeys.length) {
    key = Object.keys(arrays)[0];
  }
  const array = arrays[key];
  const length = getArray(array).length;
  const numComponents = getNumComponents(array, key);
  const numElements = length / numComponents;
  if (length % numComponents > 0) {
    throw new Error(`numComponents ${numComponents} not correct for length ${length}`);
  }
  return numElements;
}

function getNumElementsFromAttributes(gl, attribs) {
  let key;
  let ii;
  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];
    if (key in attribs) {
      break;
    }
    key = defaults.attribPrefix + key;
    if (key in attribs) {
      break;
    }
  }
  if (ii === positionKeys.length) {
    key = Object.keys(attribs)[0];
  }
  const attrib = attribs[key];
  gl.bindBuffer(ARRAY_BUFFER, attrib.buffer);
  const numBytes = gl.getBufferParameter(ARRAY_BUFFER, BUFFER_SIZE);
  gl.bindBuffer(ARRAY_BUFFER, null);

  const bytesPerValue = getBytesPerValueForGLType(gl, attrib.type);
  const totalElements = numBytes / bytesPerValue;
  const numComponents = attrib.numComponents || attrib.size;
  // TODO: check stride
  const numElements = totalElements / numComponents;
  if (numElements % 1 !== 0) {
    throw new Error(`numComponents ${numComponents} not correct for length ${length}`);
  }
  return numElements;
}

/**
 * @typedef {Object} BufferInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.
 * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs appropriate to call `setAttributes`
 * @memberOf module:twgl
 */

/**
 * Creates a BufferInfo from an object of arrays.
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * Given an object like
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 *  Creates an BufferInfo like this
 *
 *     bufferInfo = {
 *       numElements: 4,        // or whatever the number of elements is
 *       indices: WebGLBuffer,  // this property will not exist if there are no indices
 *       attribs: {
 *         position: { buffer: WebGLBuffer, numComponents: 3, },
 *         normal:   { buffer: WebGLBuffer, numComponents: 3, },
 *         texcoord: { buffer: WebGLBuffer, numComponents: 2, },
 *       },
 *     };
 *
 *  The properties of arrays can be JavaScript arrays in which case the number of components
 *  will be guessed.
 *
 *     var arrays = {
 *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
 *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
 *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
 *        indices:  [0, 1, 2, 1, 2, 3],
 *     };
 *
 *  They can also be TypedArrays
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *
 *  Or AugmentedTypedArrays
 *
 *     var positions = createAugmentedTypedArray(3, 4);
 *     var texcoords = createAugmentedTypedArray(2, 4);
 *     var normals   = createAugmentedTypedArray(3, 4);
 *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);
 *
 *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);
 *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);
 *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
 *     indices.push([0, 1, 2, 1, 2, 3]);
 *
 *     var arrays = {
 *        position: positions,
 *        texcoord: texcoords,
 *        normal:   normals,
 *        indices:  indices,
 *     };
 *
 * For the last example it is equivalent to
 *
 *     var bufferInfo = {
 *       attribs: {
 *         position: { numComponents: 3, buffer: gl.createBuffer(), },
 *         texcoord: { numComponents: 2, buffer: gl.createBuffer(), },
 *         normal: { numComponents: 3, buffer: gl.createBuffer(), },
 *       },
 *       indices: gl.createBuffer(),
 *       numElements: 6,
 *     };
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.position.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.texcoord.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.normal.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);
 *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.Arrays} arrays Your data
 * @param {module:twgl.BufferInfo} [srcBufferInfo] An existing
 *        buffer info to start from. WebGLBuffers etc specified
 *        in the srcBufferInfo will be used in a new BufferInfo
 *        with any arrays specified overriding the ones in
 *        srcBufferInfo.
 * @return {module:twgl.BufferInfo} A BufferInfo
 * @memberOf module:twgl/attributes
 */
function createBufferInfoFromArrays(gl, arrays, srcBufferInfo) {
  const newAttribs = createAttribsFromArrays(gl, arrays);
  const bufferInfo = Object.assign({}, srcBufferInfo ? srcBufferInfo : {});
  bufferInfo.attribs = Object.assign({}, srcBufferInfo ? srcBufferInfo.attribs : {}, newAttribs);
  const indices = arrays.indices;
  if (indices) {
    const newIndices = makeTypedArray(indices, "indices");
    bufferInfo.indices = createBufferFromTypedArray(gl, newIndices, ELEMENT_ARRAY_BUFFER);
    bufferInfo.numElements = newIndices.length;
    bufferInfo.elementType = getGLTypeForTypedArray(newIndices);
  } else if (!bufferInfo.numElements) {
    bufferInfo.numElements = getNumElementsFromAttributes(gl, bufferInfo.attribs);
  }

  return bufferInfo;
}

/**
 * Creates a buffer from an array, typed array, or array spec
 *
 * Given something like this
 *
 *     [1, 2, 3],
 *
 * or
 *
 *     new Uint16Array([1,2,3]);
 *
 * or
 *
 *     {
 *        data: [1, 2, 3],
 *        type: Uint8Array,
 *     }
 *
 * returns a WebGLBuffer that contains the given data.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.
 * @param {string} arrayName name of array. Used to guess the type if type can not be derived otherwise.
 * @return {WebGLBuffer} a WebGLBuffer containing the data in array.
 * @memberOf module:twgl/attributes
 */
function createBufferFromArray(gl, array, arrayName) {
  const type = arrayName === "indices" ? ELEMENT_ARRAY_BUFFER : ARRAY_BUFFER;
  const typedArray = makeTypedArray(array, arrayName);
  return createBufferFromTypedArray(gl, typedArray, type);
}

/**
 * Creates buffers from arrays or typed arrays
 *
 * Given something like this
 *
 *     var arrays = {
 *        positions: [1, 2, 3],
 *        normals: [0, 0, 1],
 *     }
 *
 * returns something like
 *
 *     buffers = {
 *       positions: WebGLBuffer,
 *       normals: WebGLBuffer,
 *     }
 *
 * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.Arrays} arrays
 * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array
 * @memberOf module:twgl/attributes
 */
function createBuffersFromArrays(gl, arrays) {
  const buffers = { };
  Object.keys(arrays).forEach(function(key) {
    buffers[key] = createBufferFromArray(gl, arrays[key], key);
  });

  // Ugh!
  if (arrays.indices) {
    buffers.numElements = arrays.indices.length;
    buffers.elementType = getGLTypeForTypedArray(makeTypedArray(arrays.indices));
  } else {
    buffers.numElements = getNumElementsFromNonIndexedArrays(arrays);
  }

  return buffers;
}

var attributes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createAttribsFromArrays: createAttribsFromArrays,
  createBuffersFromArrays: createBuffersFromArrays,
  createBufferFromArray: createBufferFromArray,
  createBufferFromTypedArray: createBufferFromTypedArray,
  createBufferInfoFromArrays: createBufferInfoFromArrays,
  setAttribInfoBufferFromArray: setAttribInfoBufferFromArray,
  setAttributePrefix: setAttributePrefix,
  setAttributeDefaults_: setDefaults,
  getNumComponents_: getNumComponents,
  getArray_: getArray
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const getArray$1 = getArray;  // eslint-disable-line
const getNumComponents$1 = getNumComponents;  // eslint-disable-line

/**
 * @typedef {(Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array)} TypedArray
 */

/**
 * Add `push` to a typed array. It just keeps a 'cursor'
 * and allows use to `push` values into the array so we
 * don't have to manually compute offsets
 * @param {TypedArray} typedArray TypedArray to augment
 * @param {number} numComponents number of components.
 * @private
 */
function augmentTypedArray(typedArray, numComponents) {
  let cursor = 0;
  typedArray.push = function() {
    for (let ii = 0; ii < arguments.length; ++ii) {
      const value = arguments[ii];
      if (value instanceof Array || isArrayBuffer(value)) {
        for (let jj = 0; jj < value.length; ++jj) {
          typedArray[cursor++] = value[jj];
        }
      } else {
        typedArray[cursor++] = value;
      }
    }
  };
  typedArray.reset = function(opt_index) {
    cursor = opt_index || 0;
  };
  typedArray.numComponents = numComponents;
  Object.defineProperty(typedArray, 'numElements', {
    get: function() {
      return this.length / this.numComponents | 0;
    },
  });
  return typedArray;
}

/**
 * creates a typed array with a `push` function attached
 * so that you can easily *push* values.
 *
 * `push` can take multiple arguments. If an argument is an array each element
 * of the array will be added to the typed array.
 *
 * Example:
 *
 *     const array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values
 *     array.push(1, 2, 3);
 *     array.push([4, 5, 6]);
 *     // array now contains [1, 2, 3, 4, 5, 6]
 *
 * Also has `numComponents` and `numElements` properties.
 *
 * @param {number} numComponents number of components
 * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.
 * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.
 * @return {ArrayBufferView} A typed array.
 * @memberOf module:twgl/primitives
 */
function createAugmentedTypedArray(numComponents, numElements, opt_type) {
  const Type = opt_type || Float32Array;
  return augmentTypedArray(new Type(numComponents * numElements), numComponents);
}

function allButIndices(name) {
  return name !== "indices";
}

/**
 * Given indexed vertices creates a new set of vertices un-indexed by expanding the indexed vertices.
 * @param {Object.<string, TypedArray>} vertices The indexed vertices to deindex
 * @return {Object.<string, TypedArray>} The deindexed vertices
 * @memberOf module:twgl/primitives
 */
function deindexVertices(vertices) {
  const indices = vertices.indices;
  const newVertices = {};
  const numElements = indices.length;

  function expandToUnindexed(channel) {
    const srcBuffer = vertices[channel];
    const numComponents = srcBuffer.numComponents;
    const dstBuffer = createAugmentedTypedArray(numComponents, numElements, srcBuffer.constructor);
    for (let ii = 0; ii < numElements; ++ii) {
      const ndx = indices[ii];
      const offset = ndx * numComponents;
      for (let jj = 0; jj < numComponents; ++jj) {
        dstBuffer.push(srcBuffer[offset + jj]);
      }
    }
    newVertices[channel] = dstBuffer;
  }

  Object.keys(vertices).filter(allButIndices).forEach(expandToUnindexed);

  return newVertices;
}

/**
 * flattens the normals of deindexed vertices in place.
 * @param {Object.<string, TypedArray>} vertices The deindexed vertices who's normals to flatten
 * @return {Object.<string, TypedArray>} The flattened vertices (same as was passed in)
 * @memberOf module:twgl/primitives
 */
function flattenNormals(vertices) {
  if (vertices.indices) {
    throw new Error('can not flatten normals of indexed vertices. deindex them first');
  }

  const normals = vertices.normal;
  const numNormals = normals.length;
  for (let ii = 0; ii < numNormals; ii += 9) {
    // pull out the 3 normals for this triangle
    const nax = normals[ii + 0];
    const nay = normals[ii + 1];
    const naz = normals[ii + 2];

    const nbx = normals[ii + 3];
    const nby = normals[ii + 4];
    const nbz = normals[ii + 5];

    const ncx = normals[ii + 6];
    const ncy = normals[ii + 7];
    const ncz = normals[ii + 8];

    // add them
    let nx = nax + nbx + ncx;
    let ny = nay + nby + ncy;
    let nz = naz + nbz + ncz;

    // normalize them
    const length = Math.sqrt(nx * nx + ny * ny + nz * nz);

    nx /= length;
    ny /= length;
    nz /= length;

    // copy them back in
    normals[ii + 0] = nx;
    normals[ii + 1] = ny;
    normals[ii + 2] = nz;

    normals[ii + 3] = nx;
    normals[ii + 4] = ny;
    normals[ii + 5] = nz;

    normals[ii + 6] = nx;
    normals[ii + 7] = ny;
    normals[ii + 8] = nz;
  }

  return vertices;
}

function applyFuncToV3Array(array, matrix, fn) {
  const len = array.length;
  const tmp = new Float32Array(3);
  for (let ii = 0; ii < len; ii += 3) {
    fn(matrix, [array[ii], array[ii + 1], array[ii + 2]], tmp);
    array[ii    ] = tmp[0];
    array[ii + 1] = tmp[1];
    array[ii + 2] = tmp[2];
  }
}

function transformNormal$1(mi, v, dst) {
  dst = dst || create();
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];

  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];

  return dst;
}

/**
 * Reorients directions by the given matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientDirections(array, matrix) {
  applyFuncToV3Array(array, matrix, transformDirection);
  return array;
}

/**
 * Reorients normals by the inverse-transpose of the given
 * matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientNormals(array, matrix) {
  applyFuncToV3Array(array, inverse(matrix), transformNormal$1);
  return array;
}

/**
 * Reorients positions by the given matrix. In other words, it
 * multiplies each vertex by the given matrix.
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientPositions(array, matrix) {
  applyFuncToV3Array(array, matrix, transformPoint);
  return array;
}

/**
 * @typedef {(number[]|TypedArray)} NativeArrayOrTypedArray
 */

/**
 * Reorients arrays by the given matrix. Assumes arrays have
 * names that contains 'pos' could be reoriented as positions,
 * 'binorm' or 'tan' as directions, and 'norm' as normals.
 *
 * @param {Object.<string, NativeArrayOrTypedArray>} arrays The vertices to reorient
 * @param {module:twgl/m4.Mat4} matrix matrix to reorient by.
 * @return {Object.<string, NativeArrayOrTypedArray>} same arrays that were passed in.
 * @memberOf module:twgl/primitives
 */
function reorientVertices(arrays, matrix) {
  Object.keys(arrays).forEach(function(name) {
    const array = arrays[name];
    if (name.indexOf("pos") >= 0) {
      reorientPositions(array, matrix);
    } else if (name.indexOf("tan") >= 0 || name.indexOf("binorm") >= 0) {
      reorientDirections(array, matrix);
    } else if (name.indexOf("norm") >= 0) {
      reorientNormals(array, matrix);
    }
  });
  return arrays;
}

/**
 * Creates XY quad BufferInfo
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, WebGLBuffer>} the created XY Quad BufferInfo
 * @memberOf module:twgl/primitives
 * @function createXYQuadBuffers
 */

/**
 * Creates XY quad Buffers
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {module:twgl.BufferInfo} the created XY Quad buffers
 * @memberOf module:twgl/primitives
 * @function createXYQuadBufferInfo
 */

/**
 * Creates XY quad vertices
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0, 0.5);
 *
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, TypedArray>} the created XY Quad vertices
 * @memberOf module:twgl/primitives
 */
function createXYQuadVertices(size, xOffset, yOffset) {
  size = size || 2;
  xOffset = xOffset || 0;
  yOffset = yOffset || 0;
  size *= 0.5;
  return {
    position: {
      numComponents: 2,
      data: [
        xOffset + -1 * size, yOffset + -1 * size,
        xOffset +  1 * size, yOffset + -1 * size,
        xOffset + -1 * size, yOffset +  1 * size,
        xOffset +  1 * size, yOffset +  1 * size,
      ],
    },
    normal: [
      0, 0, 1,
      0, 0, 1,
      0, 0, 1,
      0, 0, 1,
    ],
    texcoord: [
      0, 0,
      1, 0,
      0, 1,
      1, 1,
    ],
    indices: [ 0, 1, 2, 2, 1, 3 ],
  };
}

/**
 * Creates XZ plane BufferInfo.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {module:twgl.BufferInfo} The created plane BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createPlaneBufferInfo
 */

/**
 * Creates XZ plane buffers.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, WebGLBuffer>} The created plane buffers.
 * @memberOf module:twgl/primitives
 * @function createPlaneBuffers
 */

/**
 * Creates XZ plane vertices.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, TypedArray>} The created plane vertices.
 * @memberOf module:twgl/primitives
 */
function createPlaneVertices(
    width,
    depth,
    subdivisionsWidth,
    subdivisionsDepth,
    matrix) {
  width = width || 1;
  depth = depth || 1;
  subdivisionsWidth = subdivisionsWidth || 1;
  subdivisionsDepth = subdivisionsDepth || 1;
  matrix = matrix || identity();

  const numVertices = (subdivisionsWidth + 1) * (subdivisionsDepth + 1);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);

  for (let z = 0; z <= subdivisionsDepth; z++) {
    for (let x = 0; x <= subdivisionsWidth; x++) {
      const u = x / subdivisionsWidth;
      const v = z / subdivisionsDepth;
      positions.push(
          width * u - width * 0.5,
          0,
          depth * v - depth * 0.5);
      normals.push(0, 1, 0);
      texcoords.push(u, v);
    }
  }

  const numVertsAcross = subdivisionsWidth + 1;
  const indices = createAugmentedTypedArray(
      3, subdivisionsWidth * subdivisionsDepth * 2, Uint16Array);

  for (let z = 0; z < subdivisionsDepth; z++) {  // eslint-disable-line
    for (let x = 0; x < subdivisionsWidth; x++) {  // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push(
          (z + 0) * numVertsAcross + x,
          (z + 1) * numVertsAcross + x,
          (z + 0) * numVertsAcross + x + 1);

      // Make triangle 2 of quad.
      indices.push(
          (z + 1) * numVertsAcross + x,
          (z + 1) * numVertsAcross + x + 1,
          (z + 0) * numVertsAcross + x + 1);
    }
  }

  const arrays = reorientVertices({
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  }, matrix);
  return arrays;
}

/**
 * Creates sphere BufferInfo.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {module:twgl.BufferInfo} The created sphere BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createSphereBufferInfo
 */

/**
 * Creates sphere buffers.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, WebGLBuffer>} The created sphere buffers.
 * @memberOf module:twgl/primitives
 * @function createSphereBuffers
 */

/**
 * Creates sphere vertices.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, TypedArray>} The created sphere vertices.
 * @memberOf module:twgl/primitives
 */
function createSphereVertices(
    radius,
    subdivisionsAxis,
    subdivisionsHeight,
    opt_startLatitudeInRadians,
    opt_endLatitudeInRadians,
    opt_startLongitudeInRadians,
    opt_endLongitudeInRadians) {
  if (subdivisionsAxis <= 0 || subdivisionsHeight <= 0) {
    throw new Error('subdivisionAxis and subdivisionHeight must be > 0');
  }

  opt_startLatitudeInRadians = opt_startLatitudeInRadians || 0;
  opt_endLatitudeInRadians = opt_endLatitudeInRadians || Math.PI;
  opt_startLongitudeInRadians = opt_startLongitudeInRadians || 0;
  opt_endLongitudeInRadians = opt_endLongitudeInRadians || (Math.PI * 2);

  const latRange = opt_endLatitudeInRadians - opt_startLatitudeInRadians;
  const longRange = opt_endLongitudeInRadians - opt_startLongitudeInRadians;

  // We are going to generate our sphere by iterating through its
  // spherical coordinates and generating 2 triangles for each quad on a
  // ring of the sphere.
  const numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals   = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);

  // Generate the individual vertices in our vertex buffer.
  for (let y = 0; y <= subdivisionsHeight; y++) {
    for (let x = 0; x <= subdivisionsAxis; x++) {
      // Generate a vertex based on its spherical coordinates
      const u = x / subdivisionsAxis;
      const v = y / subdivisionsHeight;
      const theta = longRange * u + opt_startLongitudeInRadians;
      const phi = latRange * v + opt_startLatitudeInRadians;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      positions.push(radius * ux, radius * uy, radius * uz);
      normals.push(ux, uy, uz);
      texcoords.push(1 - u, v);
    }
  }

  const numVertsAround = subdivisionsAxis + 1;
  const indices = createAugmentedTypedArray(3, subdivisionsAxis * subdivisionsHeight * 2, Uint16Array);
  for (let x = 0; x < subdivisionsAxis; x++) {  // eslint-disable-line
    for (let y = 0; y < subdivisionsHeight; y++) {  // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push(
          (y + 0) * numVertsAround + x,
          (y + 0) * numVertsAround + x + 1,
          (y + 1) * numVertsAround + x);

      // Make triangle 2 of quad.
      indices.push(
          (y + 1) * numVertsAround + x,
          (y + 0) * numVertsAround + x + 1,
          (y + 1) * numVertsAround + x + 1);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  };
}

/**
 * Array of the indices of corners of each face of a cube.
 * @type {Array.<number[]>}
 * @private
 */
const CUBE_FACE_INDICES = [
  [3, 7, 5, 1],  // right
  [6, 2, 0, 4],  // left
  [6, 7, 3, 2],  // ??
  [0, 1, 5, 4],  // ??
  [7, 6, 4, 5],  // front
  [2, 3, 1, 0],  // back
];

/**
 * Creates a BufferInfo for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCubeBufferInfo
 */

/**
 * Creates the buffers and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCubeBuffers
 */

/**
 * Creates the vertices and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createCubeVertices(size) {
  size = size || 1;
  const k = size / 2;

  const cornerVertices = [
    [-k, -k, -k],
    [+k, -k, -k],
    [-k, +k, -k],
    [+k, +k, -k],
    [-k, -k, +k],
    [+k, -k, +k],
    [-k, +k, +k],
    [+k, +k, +k],
  ];

  const faceNormals = [
    [+1, +0, +0],
    [-1, +0, +0],
    [+0, +1, +0],
    [+0, -1, +0],
    [+0, +0, +1],
    [+0, +0, -1],
  ];

  const uvCoords = [
    [1, 0],
    [0, 0],
    [0, 1],
    [1, 1],
  ];

  const numVertices = 6 * 4;
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals   = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2 , numVertices);
  const indices   = createAugmentedTypedArray(3, 6 * 2, Uint16Array);

  for (let f = 0; f < 6; ++f) {
    const faceIndices = CUBE_FACE_INDICES[f];
    for (let v = 0; v < 4; ++v) {
      const position = cornerVertices[faceIndices[v]];
      const normal = faceNormals[f];
      const uv = uvCoords[v];

      // Each face needs all four vertices because the normals and texture
      // coordinates are not all the same.
      positions.push(position);
      normals.push(normal);
      texcoords.push(uv);

    }
    // Two triangles make a square face.
    const offset = 4 * f;
    indices.push(offset + 0, offset + 1, offset + 2);
    indices.push(offset + 0, offset + 2, offset + 3);
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  };
}

/**
 * Creates a BufferInfo for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created cone BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBufferInfo
 */

/**
 * Creates buffers for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created cone buffers.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBuffers
 */

/**
 * Creates vertices for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis. .
 *
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created cone vertices.
 * @memberOf module:twgl/primitives
 */
function createTruncatedConeVertices(
    bottomRadius,
    topRadius,
    height,
    radialSubdivisions,
    verticalSubdivisions,
    opt_topCap,
    opt_bottomCap) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }

  if (verticalSubdivisions < 1) {
    throw new Error('verticalSubdivisions must be 1 or greater');
  }

  const topCap = (opt_topCap === undefined) ? true : opt_topCap;
  const bottomCap = (opt_bottomCap === undefined) ? true : opt_bottomCap;

  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);

  const numVertices = (radialSubdivisions + 1) * (verticalSubdivisions + 1 + extra);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals   = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  const indices   = createAugmentedTypedArray(3, radialSubdivisions * (verticalSubdivisions + extra / 2) * 2, Uint16Array);

  const vertsAroundEdge = radialSubdivisions + 1;

  // The slant of the cone is constant across its surface
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const cosSlant = Math.cos(slant);
  const sinSlant = Math.sin(slant);

  const start = topCap ? -2 : 0;
  const end = verticalSubdivisions + (bottomCap ? 2 : 0);

  for (let yy = start; yy <= end; ++yy) {
    let v = yy / verticalSubdivisions;
    let y = height * v;
    let ringRadius;
    if (yy < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (yy > verticalSubdivisions) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius +
        (topRadius - bottomRadius) * (yy / verticalSubdivisions);
    }
    if (yy === -2 || yy === verticalSubdivisions + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let ii = 0; ii < vertsAroundEdge; ++ii) {
      const sin = Math.sin(ii * Math.PI * 2 / radialSubdivisions);
      const cos = Math.cos(ii * Math.PI * 2 / radialSubdivisions);
      positions.push(sin * ringRadius, y, cos * ringRadius);
      if (yy < 0) {
        normals.push(0, -1, 0);
      } else if (yy > verticalSubdivisions) {
        normals.push(0, 1, 0);
      } else if (ringRadius === 0.0) {
        normals.push(0, 0, 0);
      } else {
        normals.push(sin * cosSlant, sinSlant, cos * cosSlant);
      }
      texcoords.push((ii / radialSubdivisions), 1 - v);
    }
  }

  for (let yy = 0; yy < verticalSubdivisions + extra; ++yy) {  // eslint-disable-line
    if (yy === 1 && topCap || yy === verticalSubdivisions + extra - 2 && bottomCap) {
      continue;
    }
    for (let ii = 0; ii < radialSubdivisions; ++ii) {  // eslint-disable-line
      indices.push(vertsAroundEdge * (yy + 0) + 0 + ii,
                   vertsAroundEdge * (yy + 0) + 1 + ii,
                   vertsAroundEdge * (yy + 1) + 1 + ii);
      indices.push(vertsAroundEdge * (yy + 0) + 0 + ii,
                   vertsAroundEdge * (yy + 1) + 1 + ii,
                   vertsAroundEdge * (yy + 1) + 0 + ii);
    }
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  };
}

/**
 * Expands RLE data
 * @param {number[]} rleData data in format of run-length, x, y, z, run-length, x, y, z
 * @param {number[]} [padding] value to add each entry with.
 * @return {number[]} the expanded rleData
 * @private
 */
function expandRLEData(rleData, padding) {
  padding = padding || [];
  const data = [];
  for (let ii = 0; ii < rleData.length; ii += 4) {
    const runLength = rleData[ii];
    const element = rleData.slice(ii + 1, ii + 4);
    element.push.apply(element, padding);
    for (let jj = 0; jj < runLength; ++jj) {
      data.push.apply(data, element);
    }
  }
  return data;
}

/**
 * Creates 3D 'F' BufferInfo.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function create3DFBufferInfo
 */

/**
 * Creates 3D 'F' buffers.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function create3DFBuffers
 */

/**
 * Creates 3D 'F' vertices.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color arrays.
 *
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function create3DFVertices() {

  const positions = [
    // left column front
    0,   0,  0,
    0, 150,  0,
    30,   0,  0,
    0, 150,  0,
    30, 150,  0,
    30,   0,  0,

    // top rung front
    30,   0,  0,
    30,  30,  0,
    100,   0,  0,
    30,  30,  0,
    100,  30,  0,
    100,   0,  0,

    // middle rung front
    30,  60,  0,
    30,  90,  0,
    67,  60,  0,
    30,  90,  0,
    67,  90,  0,
    67,  60,  0,

    // left column back
      0,   0,  30,
     30,   0,  30,
      0, 150,  30,
      0, 150,  30,
     30,   0,  30,
     30, 150,  30,

    // top rung back
     30,   0,  30,
    100,   0,  30,
     30,  30,  30,
     30,  30,  30,
    100,   0,  30,
    100,  30,  30,

    // middle rung back
     30,  60,  30,
     67,  60,  30,
     30,  90,  30,
     30,  90,  30,
     67,  60,  30,
     67,  90,  30,

    // top
      0,   0,   0,
    100,   0,   0,
    100,   0,  30,
      0,   0,   0,
    100,   0,  30,
      0,   0,  30,

    // top rung front
    100,   0,   0,
    100,  30,   0,
    100,  30,  30,
    100,   0,   0,
    100,  30,  30,
    100,   0,  30,

    // under top rung
    30,   30,   0,
    30,   30,  30,
    100,  30,  30,
    30,   30,   0,
    100,  30,  30,
    100,  30,   0,

    // between top rung and middle
    30,   30,   0,
    30,   60,  30,
    30,   30,  30,
    30,   30,   0,
    30,   60,   0,
    30,   60,  30,

    // top of middle rung
    30,   60,   0,
    67,   60,  30,
    30,   60,  30,
    30,   60,   0,
    67,   60,   0,
    67,   60,  30,

    // front of middle rung
    67,   60,   0,
    67,   90,  30,
    67,   60,  30,
    67,   60,   0,
    67,   90,   0,
    67,   90,  30,

    // bottom of middle rung.
    30,   90,   0,
    30,   90,  30,
    67,   90,  30,
    30,   90,   0,
    67,   90,  30,
    67,   90,   0,

    // front of bottom
    30,   90,   0,
    30,  150,  30,
    30,   90,  30,
    30,   90,   0,
    30,  150,   0,
    30,  150,  30,

    // bottom
    0,   150,   0,
    0,   150,  30,
    30,  150,  30,
    0,   150,   0,
    30,  150,  30,
    30,  150,   0,

    // left side
    0,   0,   0,
    0,   0,  30,
    0, 150,  30,
    0,   0,   0,
    0, 150,  30,
    0, 150,   0,
  ];

  const texcoords = [
    // left column front
    0.22, 0.19,
    0.22, 0.79,
    0.34, 0.19,
    0.22, 0.79,
    0.34, 0.79,
    0.34, 0.19,

    // top rung front
    0.34, 0.19,
    0.34, 0.31,
    0.62, 0.19,
    0.34, 0.31,
    0.62, 0.31,
    0.62, 0.19,

    // middle rung front
    0.34, 0.43,
    0.34, 0.55,
    0.49, 0.43,
    0.34, 0.55,
    0.49, 0.55,
    0.49, 0.43,

    // left column back
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1,

    // top rung back
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1,

    // middle rung back
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1,

    // top
    0, 0,
    1, 0,
    1, 1,
    0, 0,
    1, 1,
    0, 1,

    // top rung front
    0, 0,
    1, 0,
    1, 1,
    0, 0,
    1, 1,
    0, 1,

    // under top rung
    0, 0,
    0, 1,
    1, 1,
    0, 0,
    1, 1,
    1, 0,

    // between top rung and middle
    0, 0,
    1, 1,
    0, 1,
    0, 0,
    1, 0,
    1, 1,

    // top of middle rung
    0, 0,
    1, 1,
    0, 1,
    0, 0,
    1, 0,
    1, 1,

    // front of middle rung
    0, 0,
    1, 1,
    0, 1,
    0, 0,
    1, 0,
    1, 1,

    // bottom of middle rung.
    0, 0,
    0, 1,
    1, 1,
    0, 0,
    1, 1,
    1, 0,

    // front of bottom
    0, 0,
    1, 1,
    0, 1,
    0, 0,
    1, 0,
    1, 1,

    // bottom
    0, 0,
    0, 1,
    1, 1,
    0, 0,
    1, 1,
    1, 0,

    // left side
    0, 0,
    0, 1,
    1, 1,
    0, 0,
    1, 1,
    1, 0,
  ];

  const normals = expandRLEData([
    // left column front
    // top rung front
    // middle rung front
    18, 0, 0, 1,

    // left column back
    // top rung back
    // middle rung back
    18, 0, 0, -1,

    // top
    6, 0, 1, 0,

    // top rung front
    6, 1, 0, 0,

    // under top rung
    6, 0, -1, 0,

    // between top rung and middle
    6, 1, 0, 0,

    // top of middle rung
    6, 0, 1, 0,

    // front of middle rung
    6, 1, 0, 0,

    // bottom of middle rung.
    6, 0, -1, 0,

    // front of bottom
    6, 1, 0, 0,

    // bottom
    6, 0, -1, 0,

    // left side
    6, -1, 0, 0,
  ]);

  const colors = expandRLEData([
        // left column front
        // top rung front
        // middle rung front
      18, 200,  70, 120,

        // left column back
        // top rung back
        // middle rung back
      18, 80, 70, 200,

        // top
      6, 70, 200, 210,

        // top rung front
      6, 200, 200, 70,

        // under top rung
      6, 210, 100, 70,

        // between top rung and middle
      6, 210, 160, 70,

        // top of middle rung
      6, 70, 180, 210,

        // front of middle rung
      6, 100, 70, 210,

        // bottom of middle rung.
      6, 76, 210, 100,

        // front of bottom
      6, 140, 210, 80,

        // bottom
      6, 90, 130, 110,

        // left side
      6, 160, 160, 220,
  ], [255]);

  const numVerts = positions.length / 3;

  const arrays = {
    position: createAugmentedTypedArray(3, numVerts),
    texcoord: createAugmentedTypedArray(2,  numVerts),
    normal: createAugmentedTypedArray(3, numVerts),
    color: createAugmentedTypedArray(4, numVerts, Uint8Array),
    indices: createAugmentedTypedArray(3, numVerts / 3, Uint16Array),
  };

  arrays.position.push(positions);
  arrays.texcoord.push(texcoords);
  arrays.normal.push(normals);
  arrays.color.push(colors);

  for (let ii = 0; ii < numVerts; ++ii) {
    arrays.indices.push(ii);
  }

  return arrays;
}

/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCresentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCrescentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCrescentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
 function createCrescentVertices(
    verticalRadius,
    outerRadius,
    innerRadius,
    thickness,
    subdivisionsDown,
    startOffset,
    endOffset) {
  if (subdivisionsDown <= 0) {
    throw new Error('subdivisionDown must be > 0');
  }

  startOffset = startOffset || 0;
  endOffset   = endOffset || 1;

  const subdivisionsThick = 2;

  const offsetRange = endOffset - startOffset;
  const numVertices = (subdivisionsDown + 1) * 2 * (2 + subdivisionsThick);
  const positions   = createAugmentedTypedArray(3, numVertices);
  const normals     = createAugmentedTypedArray(3, numVertices);
  const texcoords   = createAugmentedTypedArray(2, numVertices);

  function lerp(a, b, s) {
    return a + (b - a) * s;
  }

  function createArc(arcRadius, x, normalMult, normalAdd, uMult, uAdd) {
    for (let z = 0; z <= subdivisionsDown; z++) {
      const uBack = x / (subdivisionsThick - 1);
      const v = z / subdivisionsDown;
      const xBack = (uBack - 0.5) * 2;
      const angle = (startOffset + (v * offsetRange)) * Math.PI;
      const s = Math.sin(angle);
      const c = Math.cos(angle);
      const radius = lerp(verticalRadius, arcRadius, s);
      const px = xBack * thickness;
      const py = c * verticalRadius;
      const pz = s * radius;
      positions.push(px, py, pz);
      const n = add(multiply([0, s, c], normalMult), normalAdd);
      normals.push(n);
      texcoords.push(uBack * uMult + uAdd, v);
    }
  }

  // Generate the individual vertices in our vertex buffer.
  for (let x = 0; x < subdivisionsThick; x++) {
    const uBack = (x / (subdivisionsThick - 1) - 0.5) * 2;
    createArc(outerRadius, x, [1, 1, 1], [0,     0, 0], 1, 0);
    createArc(outerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 0);
    createArc(innerRadius, x, [1, 1, 1], [0,     0, 0], 1, 0);
    createArc(innerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 1);
  }

  // Do outer surface.
  const indices = createAugmentedTypedArray(3, (subdivisionsDown * 2) * (2 + subdivisionsThick), Uint16Array);

  function createSurface(leftArcOffset, rightArcOffset) {
    for (let z = 0; z < subdivisionsDown; ++z) {
      // Make triangle 1 of quad.
      indices.push(
          leftArcOffset + z + 0,
          leftArcOffset + z + 1,
          rightArcOffset + z + 0);

      // Make triangle 2 of quad.
      indices.push(
          leftArcOffset + z + 1,
          rightArcOffset + z + 1,
          rightArcOffset + z + 0);
    }
  }

  const numVerticesDown = subdivisionsDown + 1;
  // front
  createSurface(numVerticesDown * 0, numVerticesDown * 4);
  // right
  createSurface(numVerticesDown * 5, numVerticesDown * 7);
  // back
  createSurface(numVerticesDown * 6, numVerticesDown * 2);
  // left
  createSurface(numVerticesDown * 3, numVerticesDown * 1);

  return {
    position: positions,
    normal:   normals,
    texcoord: texcoords,
    indices:  indices,
  };
}

/**
 * Creates cylinder BufferInfo. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCylinderBufferInfo
 */

 /**
  * Creates cylinder buffers. The cylinder will be created around the origin
  * along the y-axis.
  *
  * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
  * @param {number} radius Radius of cylinder.
  * @param {number} height Height of cylinder.
  * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
  * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
  * @param {boolean} [topCap] Create top cap. Default = true.
  * @param {boolean} [bottomCap] Create bottom cap. Default = true.
  * @return {Object.<string, WebGLBuffer>} The created buffers.
  * @memberOf module:twgl/primitives
  * @function createCylinderBuffers
  */

 /**
  * Creates cylinder vertices. The cylinder will be created around the origin
  * along the y-axis.
  *
  * @param {number} radius Radius of cylinder.
  * @param {number} height Height of cylinder.
  * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
  * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
  * @param {boolean} [topCap] Create top cap. Default = true.
  * @param {boolean} [bottomCap] Create bottom cap. Default = true.
  * @return {Object.<string, TypedArray>} The created vertices.
  * @memberOf module:twgl/primitives
  */
function createCylinderVertices(
    radius,
    height,
    radialSubdivisions,
    verticalSubdivisions,
    topCap,
    bottomCap) {
  return createTruncatedConeVertices(
      radius,
      radius,
      height,
      radialSubdivisions,
      verticalSubdivisions,
      topCap,
      bottomCap);
}

/**
 * Creates BufferInfo for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTorusBufferInfo
 */

/**
 * Creates buffers for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createTorusBuffers
 */

/**
 * Creates vertices for a torus
 *
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createTorusVertices(
    radius,
    thickness,
    radialSubdivisions,
    bodySubdivisions,
    startAngle,
    endAngle) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }

  if (bodySubdivisions < 3) {
    throw new Error('verticalSubdivisions must be 3 or greater');
  }

  startAngle = startAngle || 0;
  endAngle = endAngle || Math.PI * 2;
  const range = endAngle - startAngle;

  const radialParts = radialSubdivisions + 1;
  const bodyParts   = bodySubdivisions + 1;
  const numVertices = radialParts * bodyParts;
  const positions   = createAugmentedTypedArray(3, numVertices);
  const normals     = createAugmentedTypedArray(3, numVertices);
  const texcoords   = createAugmentedTypedArray(2, numVertices);
  const indices     = createAugmentedTypedArray(3, (radialSubdivisions) * (bodySubdivisions) * 2, Uint16Array);

  for (let slice = 0; slice < bodyParts; ++slice) {
    const v = slice / bodySubdivisions;
    const sliceAngle = v * Math.PI * 2;
    const sliceSin = Math.sin(sliceAngle);
    const ringRadius = radius + sliceSin * thickness;
    const ny = Math.cos(sliceAngle);
    const y = ny * thickness;
    for (let ring = 0; ring < radialParts; ++ring) {
      const u = ring / radialSubdivisions;
      const ringAngle = startAngle + u * range;
      const xSin = Math.sin(ringAngle);
      const zCos = Math.cos(ringAngle);
      const x = xSin * ringRadius;
      const z = zCos * ringRadius;
      const nx = xSin * sliceSin;
      const nz = zCos * sliceSin;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      texcoords.push(u, 1 - v);
    }
  }

  for (let slice = 0; slice < bodySubdivisions; ++slice) {  // eslint-disable-line
    for (let ring = 0; ring < radialSubdivisions; ++ring) {  // eslint-disable-line
      const nextRingIndex  = 1 + ring;
      const nextSliceIndex = 1 + slice;
      indices.push(radialParts * slice          + ring,
                   radialParts * nextSliceIndex + ring,
                   radialParts * slice          + nextRingIndex);
      indices.push(radialParts * nextSliceIndex + ring,
                   radialParts * nextSliceIndex + nextRingIndex,
                   radialParts * slice          + nextRingIndex);
    }
  }

  return {
    position: positions,
    normal:   normals,
    texcoord: texcoords,
    indices:  indices,
  };
}


/**
 * Creates a disc BufferInfo. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createDiscBufferInfo
 */

/**
 * Creates disc buffers. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createDiscBuffers
 */

/**
 * Creates disc vertices. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createDiscVertices(
    radius,
    divisions,
    stacks,
    innerRadius,
    stackPower) {
  if (divisions < 3) {
    throw new Error('divisions must be at least 3');
  }

  stacks = stacks ? stacks : 1;
  stackPower = stackPower ? stackPower : 1;
  innerRadius = innerRadius ? innerRadius : 0;

  // Note: We don't share the center vertex because that would
  // mess up texture coordinates.
  const numVertices = (divisions + 1) * (stacks + 1);

  const positions = createAugmentedTypedArray(3, numVertices);
  const normals   = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  const indices   = createAugmentedTypedArray(3, stacks * divisions * 2, Uint16Array);

  let firstIndex = 0;
  const radiusSpan = radius - innerRadius;
  const pointsPerStack = divisions + 1;

  // Build the disk one stack at a time.
  for (let stack = 0; stack <= stacks; ++stack) {
    const stackRadius = innerRadius + radiusSpan * Math.pow(stack / stacks, stackPower);

    for (let i = 0; i <= divisions; ++i) {
      const theta = 2.0 * Math.PI * i / divisions;
      const x = stackRadius * Math.cos(theta);
      const z = stackRadius * Math.sin(theta);

      positions.push(x, 0, z);
      normals.push(0, 1, 0);
      texcoords.push(1 - (i / divisions), stack / stacks);
      if (stack > 0 && i !== divisions) {
        // a, b, c and d are the indices of the vertices of a quad.  unless
        // the current stack is the one closest to the center, in which case
        // the vertices a and b connect to the center vertex.
        const a = firstIndex + (i + 1);
        const b = firstIndex + i;
        const c = firstIndex + i - pointsPerStack;
        const d = firstIndex + (i + 1) - pointsPerStack;

        // Make a quad of the vertices a, b, c, d.
        indices.push(a, b, c);
        indices.push(a, c, d);
      }
    }

    firstIndex += divisions + 1;
  }

  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices,
  };
}

/**
 * creates a random integer between 0 and range - 1 inclusive.
 * @param {number} range
 * @return {number} random value between 0 and range - 1 inclusive.
 * @private
 */
function randInt(range) {
  return Math.random() * range | 0;
}

/**
 * Used to supply random colors
 * @callback RandomColorFunc
 * @param {number} ndx index of triangle/quad if unindexed or index of vertex if indexed
 * @param {number} channel 0 = red, 1 = green, 2 = blue, 3 = alpha
 * @return {number} a number from 0 to 255
 * @memberOf module:twgl/primitives
 */

/**
 * @typedef {Object} RandomVerticesOptions
 * @property {number} [vertsPerColor] Defaults to 3 for non-indexed vertices
 * @property {module:twgl/primitives.RandomColorFunc} [rand] A function to generate random numbers
 * @memberOf module:twgl/primitives
 */

/**
 * Creates an augmentedTypedArray of random vertex colors.
 * If the vertices are indexed (have an indices array) then will
 * just make random colors. Otherwise assumes they are triangles
 * and makes one random color for every 3 vertices.
 * @param {Object.<string, AugmentedTypedArray>} vertices Vertices as returned from one of the createXXXVertices functions.
 * @param {module:twgl/primitives.RandomVerticesOptions} [options] options.
 * @return {Object.<string, AugmentedTypedArray>} same vertices as passed in with `color` added.
 * @memberOf module:twgl/primitives
 */
function makeRandomVertexColors(vertices, options) {
  options = options || {};
  const numElements = vertices.position.numElements;
  const vColors = createAugmentedTypedArray(4, numElements, Uint8Array);
  const rand = options.rand || function(ndx, channel) {
    return channel < 3 ? randInt(256) : 255;
  };
  vertices.color = vColors;
  if (vertices.indices) {
    // just make random colors if index
    for (let ii = 0; ii < numElements; ++ii) {
      vColors.push(rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3));
    }
  } else {
    // make random colors per triangle
    const numVertsPerColor = options.vertsPerColor || 3;
    const numSets = numElements / numVertsPerColor;
    for (let ii = 0; ii < numSets; ++ii) {  // eslint-disable-line
      const color = [rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3)];
      for (let jj = 0; jj < numVertsPerColor; ++jj) {
        vColors.push(color);
      }
    }
  }
  return vertices;
}

/**
 * creates a function that calls fn to create vertices and then
 * creates a buffers for them
 * @private
 */
function createBufferFunc(fn) {
  return function(gl) {
    const arrays = fn.apply(this, Array.prototype.slice.call(arguments, 1));
    return createBuffersFromArrays(gl, arrays);
  };
}

/**
 * creates a function that calls fn to create vertices and then
 * creates a bufferInfo object for them
 * @private
 */
function createBufferInfoFunc(fn) {
  return function(gl) {
    const arrays = fn.apply(null,  Array.prototype.slice.call(arguments, 1));
    return createBufferInfoFromArrays(gl, arrays);
  };
}

const arraySpecPropertyNames = [
  "numComponents",
  "size",
  "type",
  "normalize",
  "stride",
  "offset",
  "attrib",
  "name",
  "attribName",
];

/**
 * Copy elements from one array to another
 *
 * @param {Array|TypedArray} src source array
 * @param {Array|TypedArray} dst dest array
 * @param {number} dstNdx index in dest to copy src
 * @param {number} [offset] offset to add to copied values
 * @private
 */
function copyElements(src, dst, dstNdx, offset) {
  offset = offset || 0;
  const length = src.length;
  for (let ii = 0; ii < length; ++ii) {
    dst[dstNdx + ii] = src[ii] + offset;
  }
}

/**
 * Creates an array of the same time
 *
 * @param {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} srcArray array who's type to copy
 * @param {number} length size of new array
 * @return {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} array with same type as srcArray
 * @private
 */
function createArrayOfSameType(srcArray, length) {
  const arraySrc = getArray$1(srcArray);
  const newArray = new arraySrc.constructor(length);
  let newArraySpec = newArray;
  // If it appears to have been augmented make new one augmented
  if (arraySrc.numComponents && arraySrc.numElements) {
    augmentTypedArray(newArray, arraySrc.numComponents);
  }
  // If it was a full spec make new one a full spec
  if (srcArray.data) {
    newArraySpec = {
      data: newArray,
    };
    copyNamedProperties(arraySpecPropertyNames, srcArray, newArraySpec);
  }
  return newArraySpec;
}

/**
 * Concatenates sets of vertices
 *
 * Assumes the vertices match in composition. For example
 * if one set of vertices has positions, normals, and indices
 * all sets of vertices must have positions, normals, and indices
 * and of the same type.
 *
 * Example:
 *
 *      const cubeVertices = twgl.primitives.createCubeVertices(2);
 *      const sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);
 *      // move the sphere 2 units up
 *      twgl.primitives.reorientVertices(
 *          sphereVertices, twgl.m4.translation([0, 2, 0]));
 *      // merge the sphere with the cube
 *      const cubeSphereVertices = twgl.primitives.concatVertices(
 *          [cubeVertices, sphereVertices]);
 *      // turn them into WebGL buffers and attrib data
 *      const bufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);
 *
 * @param {module:twgl.Arrays[]} arrays Array of arrays of vertices
 * @return {module:twgl.Arrays} The concatenated vertices.
 * @memberOf module:twgl/primitives
 */
function concatVertices(arrayOfArrays) {
  const names = {};
  let baseName;
  // get names of all arrays.
  // and numElements for each set of vertices
  for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
    const arrays = arrayOfArrays[ii];
    Object.keys(arrays).forEach(function(name) {  // eslint-disable-line
      if (!names[name]) {
        names[name] = [];
      }
      if (!baseName && name !== 'indices') {
        baseName = name;
      }
      const arrayInfo = arrays[name];
      const numComponents = getNumComponents$1(arrayInfo, name);
      const array = getArray$1(arrayInfo);
      const numElements = array.length / numComponents;
      names[name].push(numElements);
    });
  }

  // compute length of combined array
  // and return one for reference
  function getLengthOfCombinedArrays(name) {
    let length = 0;
    let arraySpec;
    for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
      const arrays = arrayOfArrays[ii];
      const arrayInfo = arrays[name];
      const array = getArray$1(arrayInfo);
      length += array.length;
      if (!arraySpec || arrayInfo.data) {
        arraySpec = arrayInfo;
      }
    }
    return {
      length: length,
      spec: arraySpec,
    };
  }

  function copyArraysToNewArray(name, base, newArray) {
    let baseIndex = 0;
    let offset = 0;
    for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
      const arrays = arrayOfArrays[ii];
      const arrayInfo = arrays[name];
      const array = getArray$1(arrayInfo);
      if (name === 'indices') {
        copyElements(array, newArray, offset, baseIndex);
        baseIndex += base[ii];
      } else {
        copyElements(array, newArray, offset);
      }
      offset += array.length;
    }
  }

  const base = names[baseName];

  const newArrays = {};
  Object.keys(names).forEach(function(name) {
    const info = getLengthOfCombinedArrays(name);
    const newArraySpec = createArrayOfSameType(info.spec, info.length);
    copyArraysToNewArray(name, base, getArray$1(newArraySpec));
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}

/**
 * Creates a duplicate set of vertices
 *
 * This is useful for calling reorientVertices when you
 * also want to keep the original available
 *
 * @param {module:twgl.Arrays} arrays of vertices
 * @return {module:twgl.Arrays} The duplicated vertices.
 * @memberOf module:twgl/primitives
 */
function duplicateVertices(arrays) {
  const newArrays = {};
  Object.keys(arrays).forEach(function(name) {
    const arraySpec = arrays[name];
    const srcArray = getArray$1(arraySpec);
    const newArraySpec = createArrayOfSameType(arraySpec, srcArray.length);
    copyElements(srcArray, getArray$1(newArraySpec), 0);
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}

const create3DFBufferInfo = createBufferInfoFunc(create3DFVertices);
const create3DFBuffers = createBufferFunc(create3DFVertices);
const createCubeBufferInfo = createBufferInfoFunc(createCubeVertices);
const createCubeBuffers = createBufferFunc(createCubeVertices);
const createPlaneBufferInfo = createBufferInfoFunc(createPlaneVertices);
const createPlaneBuffers = createBufferFunc(createPlaneVertices);
const createSphereBufferInfo = createBufferInfoFunc(createSphereVertices);
const createSphereBuffers = createBufferFunc(createSphereVertices);
const createTruncatedConeBufferInfo = createBufferInfoFunc(createTruncatedConeVertices);
const createTruncatedConeBuffers = createBufferFunc(createTruncatedConeVertices);
const createXYQuadBufferInfo = createBufferInfoFunc(createXYQuadVertices);
const createXYQuadBuffers = createBufferFunc(createXYQuadVertices);
const createCrescentBufferInfo = createBufferInfoFunc(createCrescentVertices);
const createCrescentBuffers = createBufferFunc(createCrescentVertices);
const createCylinderBufferInfo = createBufferInfoFunc(createCylinderVertices);
const createCylinderBuffers = createBufferFunc(createCylinderVertices);
const createTorusBufferInfo = createBufferInfoFunc(createTorusVertices);
const createTorusBuffers = createBufferFunc(createTorusVertices);
const createDiscBufferInfo = createBufferInfoFunc(createDiscVertices);
const createDiscBuffers = createBufferFunc(createDiscVertices);

// these were mis-spelled until 4.12
const createCresentBufferInfo = createCrescentBufferInfo;
const createCresentBuffers = createCrescentBuffers;
const createCresentVertices = createCrescentVertices;

var primitives = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create3DFBufferInfo: create3DFBufferInfo,
  create3DFBuffers: create3DFBuffers,
  create3DFVertices: create3DFVertices,
  createAugmentedTypedArray: createAugmentedTypedArray,
  createCubeBufferInfo: createCubeBufferInfo,
  createCubeBuffers: createCubeBuffers,
  createCubeVertices: createCubeVertices,
  createPlaneBufferInfo: createPlaneBufferInfo,
  createPlaneBuffers: createPlaneBuffers,
  createPlaneVertices: createPlaneVertices,
  createSphereBufferInfo: createSphereBufferInfo,
  createSphereBuffers: createSphereBuffers,
  createSphereVertices: createSphereVertices,
  createTruncatedConeBufferInfo: createTruncatedConeBufferInfo,
  createTruncatedConeBuffers: createTruncatedConeBuffers,
  createTruncatedConeVertices: createTruncatedConeVertices,
  createXYQuadBufferInfo: createXYQuadBufferInfo,
  createXYQuadBuffers: createXYQuadBuffers,
  createXYQuadVertices: createXYQuadVertices,
  createCresentBufferInfo: createCresentBufferInfo,
  createCresentBuffers: createCresentBuffers,
  createCresentVertices: createCresentVertices,
  createCrescentBufferInfo: createCrescentBufferInfo,
  createCrescentBuffers: createCrescentBuffers,
  createCrescentVertices: createCrescentVertices,
  createCylinderBufferInfo: createCylinderBufferInfo,
  createCylinderBuffers: createCylinderBuffers,
  createCylinderVertices: createCylinderVertices,
  createTorusBufferInfo: createTorusBufferInfo,
  createTorusBuffers: createTorusBuffers,
  createTorusVertices: createTorusVertices,
  createDiscBufferInfo: createDiscBufferInfo,
  createDiscBuffers: createDiscBuffers,
  createDiscVertices: createDiscVertices,
  deindexVertices: deindexVertices,
  flattenNormals: flattenNormals,
  makeRandomVertexColors: makeRandomVertexColors,
  reorientDirections: reorientDirections,
  reorientNormals: reorientNormals,
  reorientPositions: reorientPositions,
  reorientVertices: reorientVertices,
  concatVertices: concatVertices,
  duplicateVertices: duplicateVertices
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Gets the gl version as a number
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {number} version of gl
 * @private
 */
//function getVersionAsNumber(gl) {
//  return parseFloat(gl.getParameter(gl.VERSION).substr(6));
//}

/**
 * Check if context is WebGL 2.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 2.0
 * @memberOf module:twgl
 */
function isWebGL2(gl) {
  // This is the correct check but it's slow
  //  return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0") === 0;
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGL2RenderingContext;
  return !!gl.texStorage2D;
}

/**
 * Check if context is WebGL 1.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 1.0
 * @memberOf module:twgl
 */
function isWebGL1(gl) {
  // This is the correct check but it's slow
  // const version = getVersionAsNumber(gl);
  // return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGLRenderingContext;
  return !gl.texStorage2D;
}

/**
 * Gets a string for WebGL enum
 *
 * Note: Several enums are the same. Without more
 * context (which function) it's impossible to always
 * give the correct enum. As it is, for matching values
 * it gives all enums. Checking the WebGL2RenderingContext
 * that means
 *
 *      0     = ZERO | POINT | NONE | NO_ERROR
 *      1     = ONE | LINES | SYNC_FLUSH_COMMANDS_BIT
 *      32777 = BLEND_EQUATION_RGB | BLEND_EQUATION_RGB
 *      36662 = COPY_READ_BUFFER | COPY_READ_BUFFER_BINDING
 *      36663 = COPY_WRITE_BUFFER | COPY_WRITE_BUFFER_BINDING
 *      36006 = FRAMEBUFFER_BINDING | DRAW_FRAMEBUFFER_BINDING
 *
 * It's also not useful for bits really unless you pass in individual bits.
 * In other words
 *
 *     const bits = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
 *     twgl.glEnumToString(gl, bits);  // not going to work
 *
 * Note that some enums only exist on extensions. If you
 * want them to show up you need to pass the extension at least
 * once. For example
 *
 *     const ext = gl.getExtension('WEBGL_compressed_texture_s3tc');
 *     if (ext) {
 *        twgl.glEnumToString(ext, 0);  // just prime the function
 *
 *        ..later..
 *
 *        const internalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
 *        console.log(twgl.glEnumToString(gl, internalFormat));
 *
 * Notice I didn't have to pass the extension the second time. This means
 * you can have place that generically gets an enum for texture formats for example.
 * and as long as you primed the function with the extensions
 *
 * If you're using `twgl.addExtensionsToContext` to enable your extensions
 * then twgl will automatically get the extension's enums.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext or any extension object
 * @param {number} value the value of the enum you want to look up.
 * @return {string} enum string or hex value
 * @memberOf module:twgl
 * @function glEnumToString
 */
const glEnumToString = (function() {
  const haveEnumsForType = {};
  const enums = {};

  function addEnums(gl) {
    const type = gl.constructor.name;
    if (!haveEnumsForType[type]) {
      for (const key in gl) {
        if (typeof gl[key] === 'number') {
          const existing = enums[gl[key]];
          enums[gl[key]] = existing ? `${existing} | ${key}` : key;
        }
      }
      haveEnumsForType[type] = true;
    }
  }

  return function glEnumToString(gl, value) {
    addEnums(gl);
    return enums[value] || (typeof value === 'number' ? `0x${value.toString(16)}` : value);
  };
}());

var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  glEnumToString: glEnumToString,
  isWebGL1: isWebGL1,
  isWebGL2: isWebGL2
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
const defaults$1 = {
  textureColor: new Uint8Array([128, 192, 255, 255]),
  textureOptions: {},
  crossOrigin: undefined,
};
const isArrayBuffer$1 = isArrayBuffer;

// Should we make this on demand?
const getShared2DContext = function() {
  let s_ctx;
  return function getShared2DContext() {
    s_ctx = s_ctx ||
        ((typeof document !== 'undefined' && document.createElement)
          ? document.createElement("canvas").getContext("2d")
          : null);
    return s_ctx;
  };
}();

// NOTE: Chrome supports 2D canvas in a Worker (behind flag as of v64 but
//       not only does Firefox NOT support it but Firefox freezes immediately
//       if you try to create one instead of just returning null and continuing.
//  : (global.OffscreenCanvas && (new global.OffscreenCanvas(1, 1)).getContext("2d"));  // OffscreenCanvas may not support 2d

// NOTE: We can maybe remove some of the need for the 2d canvas. In WebGL2
// we can use the various unpack settings. Otherwise we could try using
// the ability of an ImageBitmap to be cut. Unfortunately cutting an ImageBitmap
// is async and the current TWGL code expects a non-Async result though that
// might not be a problem. ImageBitmap though is not available in Edge or Safari
// as of 2018-01-02

/* PixelFormat */
const ALPHA                          = 0x1906;
const RGB                            = 0x1907;
const RGBA                           = 0x1908;
const LUMINANCE                      = 0x1909;
const LUMINANCE_ALPHA                = 0x190A;
const DEPTH_COMPONENT                = 0x1902;
const DEPTH_STENCIL                  = 0x84F9;

/* TextureWrapMode */
// const REPEAT                         = 0x2901;
// const MIRRORED_REPEAT                = 0x8370;
const CLAMP_TO_EDGE                  = 0x812f;

/* TextureMagFilter */
const NEAREST                        = 0x2600;
const LINEAR                         = 0x2601;

/* TextureMinFilter */
// const NEAREST_MIPMAP_NEAREST         = 0x2700;
// const LINEAR_MIPMAP_NEAREST          = 0x2701;
// const NEAREST_MIPMAP_LINEAR          = 0x2702;
// const LINEAR_MIPMAP_LINEAR           = 0x2703;

/* Texture Target */
const TEXTURE_2D                     = 0x0de1;
const TEXTURE_CUBE_MAP               = 0x8513;
const TEXTURE_3D                     = 0x806f;
const TEXTURE_2D_ARRAY               = 0x8c1a;

/* Cubemap Targets */
const TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
const TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
const TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
const TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
const TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
const TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851a;

/* Texture Parameters */
const TEXTURE_MIN_FILTER             = 0x2801;
const TEXTURE_MAG_FILTER             = 0x2800;
const TEXTURE_WRAP_S                 = 0x2802;
const TEXTURE_WRAP_T                 = 0x2803;
const TEXTURE_WRAP_R                 = 0x8072;
const TEXTURE_MIN_LOD                = 0x813a;
const TEXTURE_MAX_LOD                = 0x813b;
const TEXTURE_BASE_LEVEL             = 0x813c;
const TEXTURE_MAX_LEVEL              = 0x813d;


/* Pixel store */
const UNPACK_ALIGNMENT                   = 0x0cf5;
const UNPACK_ROW_LENGTH                  = 0x0cf2;
const UNPACK_IMAGE_HEIGHT                = 0x806e;
const UNPACK_SKIP_PIXELS                 = 0x0cf4;
const UNPACK_SKIP_ROWS                   = 0x0cf3;
const UNPACK_SKIP_IMAGES                 = 0x806d;
const UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
const UNPACK_PREMULTIPLY_ALPHA_WEBGL     = 0x9241;
const UNPACK_FLIP_Y_WEBGL                = 0x9240;

const R8                           = 0x8229;
const R8_SNORM                     = 0x8F94;
const R16F                         = 0x822D;
const R32F                         = 0x822E;
const R8UI                         = 0x8232;
const R8I                          = 0x8231;
const RG16UI                       = 0x823A;
const RG16I                        = 0x8239;
const RG32UI                       = 0x823C;
const RG32I                        = 0x823B;
const RG8                          = 0x822B;
const RG8_SNORM                    = 0x8F95;
const RG16F                        = 0x822F;
const RG32F                        = 0x8230;
const RG8UI                        = 0x8238;
const RG8I                         = 0x8237;
const R16UI                        = 0x8234;
const R16I                         = 0x8233;
const R32UI                        = 0x8236;
const R32I                         = 0x8235;
const RGB8                         = 0x8051;
const SRGB8                        = 0x8C41;
const RGB565                       = 0x8D62;
const RGB8_SNORM                   = 0x8F96;
const R11F_G11F_B10F               = 0x8C3A;
const RGB9_E5                      = 0x8C3D;
const RGB16F                       = 0x881B;
const RGB32F                       = 0x8815;
const RGB8UI                       = 0x8D7D;
const RGB8I                        = 0x8D8F;
const RGB16UI                      = 0x8D77;
const RGB16I                       = 0x8D89;
const RGB32UI                      = 0x8D71;
const RGB32I                       = 0x8D83;
const RGBA8                        = 0x8058;
const SRGB8_ALPHA8                 = 0x8C43;
const RGBA8_SNORM                  = 0x8F97;
const RGB5_A1                      = 0x8057;
const RGBA4                        = 0x8056;
const RGB10_A2                     = 0x8059;
const RGBA16F                      = 0x881A;
const RGBA32F                      = 0x8814;
const RGBA8UI                      = 0x8D7C;
const RGBA8I                       = 0x8D8E;
const RGB10_A2UI                   = 0x906F;
const RGBA16UI                     = 0x8D76;
const RGBA16I                      = 0x8D88;
const RGBA32I                      = 0x8D82;
const RGBA32UI                     = 0x8D70;

const DEPTH_COMPONENT16            = 0x81A5;
const DEPTH_COMPONENT24            = 0x81A6;
const DEPTH_COMPONENT32F           = 0x8CAC;
const DEPTH32F_STENCIL8            = 0x8CAD;
const DEPTH24_STENCIL8             = 0x88F0;

/* DataType */
const BYTE$2                         = 0x1400;
const UNSIGNED_BYTE$2                = 0x1401;
const SHORT$2                        = 0x1402;
const UNSIGNED_SHORT$2               = 0x1403;
const INT$2                          = 0x1404;
const UNSIGNED_INT$2                 = 0x1405;
const FLOAT$2                        = 0x1406;
const UNSIGNED_SHORT_4_4_4_4$1       = 0x8033;
const UNSIGNED_SHORT_5_5_5_1$1       = 0x8034;
const UNSIGNED_SHORT_5_6_5$1         = 0x8363;
const HALF_FLOAT$1                   = 0x140B;
const HALF_FLOAT_OES               = 0x8D61;  // Thanks Khronos for making this different >:(
const UNSIGNED_INT_2_10_10_10_REV$1  = 0x8368;
const UNSIGNED_INT_10F_11F_11F_REV$1 = 0x8C3B;
const UNSIGNED_INT_5_9_9_9_REV$1     = 0x8C3E;
const FLOAT_32_UNSIGNED_INT_24_8_REV$1 = 0x8DAD;
const UNSIGNED_INT_24_8$1            = 0x84FA;

const RG                           = 0x8227;
const RG_INTEGER                   = 0x8228;
const RED                          = 0x1903;
const RED_INTEGER                  = 0x8D94;
const RGB_INTEGER                  = 0x8D98;
const RGBA_INTEGER                 = 0x8D99;

const formatInfo = {};
{
  // NOTE: this is named `numColorComponents` vs `numComponents` so we can let Uglify mangle
  // the name.
  const f = formatInfo;
  f[ALPHA]           = { numColorComponents: 1, };
  f[LUMINANCE]       = { numColorComponents: 1, };
  f[LUMINANCE_ALPHA] = { numColorComponents: 2, };
  f[RGB]             = { numColorComponents: 3, };
  f[RGBA]            = { numColorComponents: 4, };
  f[RED]             = { numColorComponents: 1, };
  f[RED_INTEGER]     = { numColorComponents: 1, };
  f[RG]              = { numColorComponents: 2, };
  f[RG_INTEGER]      = { numColorComponents: 2, };
  f[RGB]             = { numColorComponents: 3, };
  f[RGB_INTEGER]     = { numColorComponents: 3, };
  f[RGBA]            = { numColorComponents: 4, };
  f[RGBA_INTEGER]    = { numColorComponents: 4, };
  f[DEPTH_COMPONENT] = { numColorComponents: 1, };
  f[DEPTH_STENCIL]   = { numColorComponents: 2, };
}

/**
 * @typedef {Object} TextureFormatDetails
 * @property {number} textureFormat format to pass texImage2D and similar functions.
 * @property {boolean} colorRenderable true if you can render to this format of texture.
 * @property {boolean} textureFilterable true if you can filter the texture, false if you can ony use `NEAREST`.
 * @property {number[]} type Array of possible types you can pass to texImage2D and similar function
 * @property {Object.<number,number>} bytesPerElementMap A map of types to bytes per element
 * @private
 */

let s_textureInternalFormatInfo;
function getTextureInternalFormatInfo(internalFormat) {
  if (!s_textureInternalFormatInfo) {
    // NOTE: these properties need unique names so we can let Uglify mangle the name.
    const t = {};
    // unsized formats
    t[ALPHA]              = { textureFormat: ALPHA,           colorRenderable: true,  textureFilterable: true,  bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2], };
    t[LUMINANCE]          = { textureFormat: LUMINANCE,       colorRenderable: true,  textureFilterable: true,  bytesPerElement: [1, 2, 2, 4],        type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2], };
    t[LUMINANCE_ALPHA]    = { textureFormat: LUMINANCE_ALPHA, colorRenderable: true,  textureFilterable: true,  bytesPerElement: [2, 4, 4, 8],        type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2], };
    t[RGB]                = { textureFormat: RGB,             colorRenderable: true,  textureFilterable: true,  bytesPerElement: [3, 6, 6, 12, 2],    type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2, UNSIGNED_SHORT_5_6_5$1], };
    t[RGBA]               = { textureFormat: RGBA,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4, 8, 8, 16, 2, 2], type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2, UNSIGNED_SHORT_4_4_4_4$1, UNSIGNED_SHORT_5_5_5_1$1], };
    t[DEPTH_COMPONENT]    = { textureFormat: DEPTH_COMPONENT, colorRenderable: true,  textureFilterable: false, bytesPerElement: [2, 4],              type: [UNSIGNED_INT$2, UNSIGNED_SHORT$2], };

    // sized formats
    t[R8]                 = { textureFormat: RED,             colorRenderable: true,  textureFilterable: true,  bytesPerElement: [1],        type: [UNSIGNED_BYTE$2], };
    t[R8_SNORM]           = { textureFormat: RED,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [1],        type: [BYTE$2], };
    t[R16F]               = { textureFormat: RED,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [4, 2],     type: [FLOAT$2, HALF_FLOAT$1], };
    t[R32F]               = { textureFormat: RED,             colorRenderable: false, textureFilterable: false, bytesPerElement: [4],        type: [FLOAT$2], };
    t[R8UI]               = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [1],        type: [UNSIGNED_BYTE$2], };
    t[R8I]                = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [1],        type: [BYTE$2], };
    t[R16UI]              = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [2],        type: [UNSIGNED_SHORT$2], };
    t[R16I]               = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [2],        type: [SHORT$2], };
    t[R32UI]              = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_INT$2], };
    t[R32I]               = { textureFormat: RED_INTEGER,     colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [INT$2], };
    t[RG8]                = { textureFormat: RG,              colorRenderable: true,  textureFilterable: true,  bytesPerElement: [2],        type: [UNSIGNED_BYTE$2], };
    t[RG8_SNORM]          = { textureFormat: RG,              colorRenderable: false, textureFilterable: true,  bytesPerElement: [2],        type: [BYTE$2], };
    t[RG16F]              = { textureFormat: RG,              colorRenderable: false, textureFilterable: true,  bytesPerElement: [8, 4],     type: [FLOAT$2, HALF_FLOAT$1], };
    t[RG32F]              = { textureFormat: RG,              colorRenderable: false, textureFilterable: false, bytesPerElement: [8],        type: [FLOAT$2], };
    t[RG8UI]              = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [2],        type: [UNSIGNED_BYTE$2], };
    t[RG8I]               = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [2],        type: [BYTE$2], };
    t[RG16UI]             = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_SHORT$2], };
    t[RG16I]              = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [SHORT$2], };
    t[RG32UI]             = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [8],        type: [UNSIGNED_INT$2], };
    t[RG32I]              = { textureFormat: RG_INTEGER,      colorRenderable: true,  textureFilterable: false, bytesPerElement: [8],        type: [INT$2], };
    t[RGB8]               = { textureFormat: RGB,             colorRenderable: true,  textureFilterable: true,  bytesPerElement: [3],        type: [UNSIGNED_BYTE$2], };
    t[SRGB8]              = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [3],        type: [UNSIGNED_BYTE$2], };
    t[RGB565]             = { textureFormat: RGB,             colorRenderable: true,  textureFilterable: true,  bytesPerElement: [3, 2],     type: [UNSIGNED_BYTE$2, UNSIGNED_SHORT_5_6_5$1], };
    t[RGB8_SNORM]         = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [3],        type: [BYTE$2], };
    t[R11F_G11F_B10F]     = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [12, 6, 4], type: [FLOAT$2, HALF_FLOAT$1, UNSIGNED_INT_10F_11F_11F_REV$1], };
    t[RGB9_E5]            = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [12, 6, 4], type: [FLOAT$2, HALF_FLOAT$1, UNSIGNED_INT_5_9_9_9_REV$1], };
    t[RGB16F]             = { textureFormat: RGB,             colorRenderable: false, textureFilterable: true,  bytesPerElement: [12, 6],    type: [FLOAT$2, HALF_FLOAT$1], };
    t[RGB32F]             = { textureFormat: RGB,             colorRenderable: false, textureFilterable: false, bytesPerElement: [12],       type: [FLOAT$2], };
    t[RGB8UI]             = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [3],        type: [UNSIGNED_BYTE$2], };
    t[RGB8I]              = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [3],        type: [BYTE$2], };
    t[RGB16UI]            = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [6],        type: [UNSIGNED_SHORT$2], };
    t[RGB16I]             = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [6],        type: [SHORT$2], };
    t[RGB32UI]            = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [12],       type: [UNSIGNED_INT$2], };
    t[RGB32I]             = { textureFormat: RGB_INTEGER,     colorRenderable: false, textureFilterable: false, bytesPerElement: [12],       type: [INT$2], };
    t[RGBA8]              = { textureFormat: RGBA,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4],        type: [UNSIGNED_BYTE$2], };
    t[SRGB8_ALPHA8]       = { textureFormat: RGBA,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4],        type: [UNSIGNED_BYTE$2], };
    t[RGBA8_SNORM]        = { textureFormat: RGBA,            colorRenderable: false, textureFilterable: true,  bytesPerElement: [4],        type: [BYTE$2], };
    t[RGB5_A1]            = { textureFormat: RGBA,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4, 2, 4],  type: [UNSIGNED_BYTE$2, UNSIGNED_SHORT_5_5_5_1$1, UNSIGNED_INT_2_10_10_10_REV$1], };
    t[RGBA4]              = { textureFormat: RGBA,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4, 2],     type: [UNSIGNED_BYTE$2, UNSIGNED_SHORT_4_4_4_4$1], };
    t[RGB10_A2]           = { textureFormat: RGBA,            colorRenderable: true,  textureFilterable: true,  bytesPerElement: [4],        type: [UNSIGNED_INT_2_10_10_10_REV$1], };
    t[RGBA16F]            = { textureFormat: RGBA,            colorRenderable: false, textureFilterable: true,  bytesPerElement: [16, 8],    type: [FLOAT$2, HALF_FLOAT$1], };
    t[RGBA32F]            = { textureFormat: RGBA,            colorRenderable: false, textureFilterable: false, bytesPerElement: [16],       type: [FLOAT$2], };
    t[RGBA8UI]            = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_BYTE$2], };
    t[RGBA8I]             = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [BYTE$2], };
    t[RGB10_A2UI]         = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_INT_2_10_10_10_REV$1], };
    t[RGBA16UI]           = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [8],        type: [UNSIGNED_SHORT$2], };
    t[RGBA16I]            = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [8],        type: [SHORT$2], };
    t[RGBA32I]            = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [16],       type: [INT$2], };
    t[RGBA32UI]           = { textureFormat: RGBA_INTEGER,    colorRenderable: true,  textureFilterable: false, bytesPerElement: [16],       type: [UNSIGNED_INT$2], };
    // Sized Internal
    t[DEPTH_COMPONENT16]  = { textureFormat: DEPTH_COMPONENT, colorRenderable: true,  textureFilterable: false, bytesPerElement: [2, 4],     type: [UNSIGNED_SHORT$2, UNSIGNED_INT$2], };
    t[DEPTH_COMPONENT24]  = { textureFormat: DEPTH_COMPONENT, colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_INT$2], };
    t[DEPTH_COMPONENT32F] = { textureFormat: DEPTH_COMPONENT, colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [FLOAT$2], };
    t[DEPTH24_STENCIL8]   = { textureFormat: DEPTH_STENCIL,   colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [UNSIGNED_INT_24_8$1], };
    t[DEPTH32F_STENCIL8]  = { textureFormat: DEPTH_STENCIL,   colorRenderable: true,  textureFilterable: false, bytesPerElement: [4],        type: [FLOAT_32_UNSIGNED_INT_24_8_REV$1], };

    Object.keys(t).forEach(function(internalFormat) {
      const info = t[internalFormat];
      info.bytesPerElementMap = {};
      info.bytesPerElement.forEach(function(bytesPerElement, ndx) {
        const type = info.type[ndx];
        info.bytesPerElementMap[type] = bytesPerElement;
      });
    });
    s_textureInternalFormatInfo = t;
  }
  return s_textureInternalFormatInfo[internalFormat];
}

/**
 * Gets the number of bytes per element for a given internalFormat / type
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @param {number} type The type parameter for texImage2D etc..
 * @return {number} the number of bytes per element for the given internalFormat, type combo
 * @memberOf module:twgl/textures
 */
function getBytesPerElementForInternalFormat(internalFormat, type) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  const bytesPerElement = info.bytesPerElementMap[type];
  if (bytesPerElement === undefined) {
    throw "unknown internal format";
  }
  return bytesPerElement;
}

/**
 * Info related to a specific texture internalFormat as returned
 * from {@link module:twgl/textures.getFormatAndTypeForInternalFormat}.
 *
 * @typedef {Object} TextureFormatInfo
 * @property {number} format Format to pass to texImage2D and related functions
 * @property {number} type Type to pass to texImage2D and related functions
 * @memberOf module:twgl/textures
 */

/**
 * Gets the format and type for a given internalFormat
 *
 * @param {number} internalFormat The internal format
 * @return {module:twgl/textures.TextureFormatInfo} the corresponding format and type,
 * @memberOf module:twgl/textures
 */
function getFormatAndTypeForInternalFormat(internalFormat) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return {
    format: info.textureFormat,
    type: info.type[0],
  };
}

/**
 * Returns true if value is power of 2
 * @param {number} value number to check.
 * @return true if value is power of 2
 * @private
 */
function isPowerOf2(value) {
  return (value & (value - 1)) === 0;
}

/**
 * Gets whether or not we can generate mips for the given
 * internal format.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number} width The width parameter from texImage2D etc..
 * @param {number} height The height parameter from texImage2D etc..
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */
function canGenerateMipmap(gl, width, height, internalFormat) {
  if (!isWebGL2(gl)) {
    return isPowerOf2(width) && isPowerOf2(height);
  }
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return info.colorRenderable && info.textureFilterable;
}

/**
 * Gets whether or not we can generate mips for the given format
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */
function canFilter(internalFormat) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return info.textureFilterable;
}

/**
 * Gets the number of components for a given image format.
 * @param {number} format the format.
 * @return {number} the number of components for the format.
 * @memberOf module:twgl/textures
 */
function getNumComponentsForFormat(format) {
  const info = formatInfo[format];
  if (!info) {
    throw "unknown format: " + format;
  }
  return info.numColorComponents;
}

/**
 * Gets the texture type for a given array type.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @return {number} the gl texture type
 * @private
 */
function getTextureTypeForArrayType(gl, src, defaultType) {
  if (isArrayBuffer$1(src)) {
    return getGLTypeForTypedArray(src);
  }
  return defaultType || UNSIGNED_BYTE$2;
}

function guessDimensions(gl, target, width, height, numElements) {
  if (numElements % 1 !== 0) {
    throw "can't guess dimensions";
  }
  if (!width && !height) {
    const size = Math.sqrt(numElements / (target === TEXTURE_CUBE_MAP ? 6 : 1));
    if (size % 1 === 0) {
      width = size;
      height = size;
    } else {
      width = numElements;
      height = 1;
    }
  } else if (!height) {
    height = numElements / width;
    if (height % 1) {
      throw "can't guess dimensions";
    }
  } else if (!width) {
    width = numElements / height;
    if (width % 1) {
      throw "can't guess dimensions";
    }
  }
  return {
    width: width,
    height: height,
  };
}

/**
 * Sets the default texture color.
 *
 * The default texture color is used when loading textures from
 * urls. Because the URL will be loaded async we'd like to be
 * able to use the texture immediately. By putting a 1x1 pixel
 * color in the texture we can start using the texture before
 * the URL has loaded.
 *
 * @param {number[]} color Array of 4 values in the range 0 to 1
 * @deprecated see {@link module:twgl.setDefaults}
 * @memberOf module:twgl/textures
 */
function setDefaultTextureColor(color) {
  defaults$1.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}

function setDefaults$1(newDefaults) {
  copyExistingProperties(newDefaults, defaults$1);
  if (newDefaults.textureColor) {
    setDefaultTextureColor(newDefaults.textureColor);
  }
}

/**
 * A function to generate the source for a texture.
 * @callback TextureFunc
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options the texture options
 * @return {*} Returns any of the things documented for `src` for {@link module:twgl.TextureOptions}.
 * @memberOf module:twgl
 */

/**
 * Texture options passed to most texture functions. Each function will use whatever options
 * are appropriate for its needs. This lets you pass the same options to all functions.
 *
 * Note: A `TexImageSource` is defined in the WebGL spec as a `HTMLImageElement`, `HTMLVideoElement`,
 * `HTMLCanvasElement`, `ImageBitmap`, or `ImageData`.
 *
 * @typedef {Object} TextureOptions
 * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.
 * @property {number} [level] the mip level to affect. Defaults to 0. Note, if set auto will be considered false unless explicitly set to true.
 * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.
 * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.
 * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .
 * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`
 *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.
 * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`
 * @property {number} [minMag] both the min and mag filter settings.
 * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`
 * @property {number} [format] format for texture. Defaults to `gl.RGBA`.
 * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBufferView. If `src`
 *     is ArrayBufferView defaults to type that matches ArrayBufferView type.
 * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D or WebGLSampler). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube
 * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [minLod] TEXTURE_MIN_LOD setting
 * @property {number} [maxLod] TEXTURE_MAX_LOD setting
 * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting
 * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting
 * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.
 * @property {number[]|ArrayBufferView} [color] Color to initialize this texture with if loading an image asynchronously.
 *     The default use a blue 1x1 pixel texture. You can set another default by calling `twgl.setDefaults`
 *     or you can set an individual texture's initial color by setting this property. Example: `[1, .5, .5, 1]` = pink
 * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {boolean} [auto] If `undefined` or `true`, in WebGL1, texture filtering is set automatically for non-power of 2 images and
 *    mips are generated for power of 2 images. In WebGL2 mips are generated if they can be. Note: if `level` is set above
 *    then then `auto` is assumed to be `false` unless explicity set to `true`.
 * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is
 *
 *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
 *
 * @property {(number[]|ArrayBufferView|TexImageSource|TexImageSource[]|string|string[]|module:twgl.TextureFunc)} [src] source for texture
 *
 *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable
 *    1x1 pixel texture will be returned immediately. The texture will be updated once the image has downloaded.
 *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.
 *    The pieces will be uploaded in `cubeFaceOrder`
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_CUBE_MAP` then it must have 6 entries, one for each face of a cube map.
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_2D_ARRAY` then each entry is a slice of the a 2d array texture
 *    and will be scaled to the specified width and height OR to the size of the first image that loads.
 *
 *    If `TexImageSource` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,
 *    `HTMLCanvasElement`, `HTMLVideoElement`.
 *
 *    If `number[]` or `ArrayBufferView` it's assumed to be data for a texture. If `width` or `height` is
 *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponents`
 *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided
 *    by 6. Then
 *
 *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height
 *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.
 *
 *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.
 *
 * If `number[]` will be converted to `type`.
 *
 * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.
 * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`
 * an array etc...
 *
 * If `src` is undefined then an empty texture will be created of size `width` by `height`.
 *
 * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.
 *    default: undefined. Also see {@link module:twgl.setDefaults}.
 *
 * @memberOf module:twgl
 */

/**
 * Sets any packing state that will be set based on the options.
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */
function setPackState(gl, options) {
  if (options.colorspaceConversion !== undefined) {
    gl.pixelStorei(UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);
  }
  if (options.premultiplyAlpha !== undefined) {
    gl.pixelStorei(UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);
  }
  if (options.flipY !== undefined) {
    gl.pixelStorei(UNPACK_FLIP_Y_WEBGL, options.flipY);
  }
}

/**
 * Set skip state to defaults
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */
function setSkipStateToDefault(gl) {
  gl.pixelStorei(UNPACK_ALIGNMENT, 4);
  if (isWebGL2(gl)) {
    gl.pixelStorei(UNPACK_ROW_LENGTH, 0);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_PIXELS, 0);
    gl.pixelStorei(UNPACK_SKIP_ROWS, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
  }
}

/**
 * Sets the parameters of a texture or sampler
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number|WebGLSampler} target texture target or sampler
 * @param {function()} parameteriFn texParameteri or samplerParameteri fn
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @private
 */
function setTextureSamplerParameters(gl, target, parameteriFn, options) {
  if (options.minMag) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.minMag);
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.minMag);
  }
  if (options.min) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.min);
  }
  if (options.mag) {
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.mag);
  }
  if (options.wrap) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrap);
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrap);
    if (target === TEXTURE_3D || isSampler(gl, target)) {
      parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrap);
    }
  }
  if (options.wrapR) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrapR);
  }
  if (options.wrapS) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrapS);
  }
  if (options.wrapT) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrapT);
  }
  if (options.minLod) {
    parameteriFn.call(gl, target, TEXTURE_MIN_LOD, options.minLod);
  }
  if (options.maxLod) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LOD, options.maxLod);
  }
  if (options.baseLevel) {
    parameteriFn.call(gl, target, TEXTURE_BASE_LEVEL, options.baseLevel);
  }
  if (options.maxLevel) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LEVEL, options.maxLevel);
  }
}

/**
 * Sets the texture parameters of a texture.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */
function setTextureParameters(gl, tex, options) {
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  setTextureSamplerParameters(gl, target, gl.texParameteri, options);
}

/**
 * Sets the sampler parameters of a sampler.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLSampler} sampler the WebGLSampler to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */
function setSamplerParameters(gl, sampler, options) {
  setTextureSamplerParameters(gl, sampler, gl.samplerParameteri, options);
}

/**
 * Creates a new sampler object and sets parameters.
 *
 * Example:
 *
 *      const sampler = twgl.createSampler(gl, {
 *        minMag: gl.NEAREST,         // sets both TEXTURE_MIN_FILTER and TEXTURE_MAG_FILTER
 *        wrap: gl.CLAMP_TO_NEAREST,  // sets both TEXTURE_WRAP_S and TEXTURE_WRAP_T and TEXTURE_WRAP_R
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per sampler.
 * @return {Object.<string,WebGLSampler>} the created samplers by name
 * @private
 */
function createSampler(gl, options) {
  const sampler = gl.createSampler();
  setSamplerParameters(gl, sampler, options);
  return sampler;
}

/**
 * Creates a multiple sampler objects and sets parameters on each.
 *
 * Example:
 *
 *      const samplers = twgl.createSamplers(gl, {
 *        nearest: {
 *          minMag: gl.NEAREST,
 *        },
 *        nearestClampS: {
 *          minMag: gl.NEAREST,
 *          wrapS: gl.CLAMP_TO_NEAREST,
 *        },
 *        linear: {
 *          minMag: gl.LINEAR,
 *        },
 *        nearestClamp: {
 *          minMag: gl.NEAREST,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClamp: {
 *          minMag: gl.LINEAR,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClampT: {
 *          minMag: gl.LINEAR,
 *          wrapT: gl.CLAMP_TO_EDGE,
 *        },
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set on the sampler
 * @private
 */
function createSamplers(gl, samplerOptions) {
  const samplers = {};
  Object.keys(samplerOptions).forEach(function(name) {
    samplers[name] = createSampler(gl, samplerOptions[name]);
  });
  return samplers;
}

/**
 * Makes a 1x1 pixel
 * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.
 * @param {(number[]|ArrayBufferView)} [color] The color using 0-1 values
 * @return {Uint8Array} Unit8Array with color.
 * @private
 */
function make1Pixel(color) {
  color = color || defaults$1.textureColor;
  if (isArrayBuffer$1(color)) {
    return color;
  }
  return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}

/**
 * Sets filtering or generates mips for texture based on width or height
 * If width or height is not passed in uses `options.width` and//or `options.height`
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @param {number} [width] width of texture
 * @param {number} [height] height of texture
 * @param {number} [internalFormat] The internalFormat parameter from texImage2D etc..
 * @memberOf module:twgl/textures
 */
function setTextureFilteringForSize(gl, tex, options, width, height, internalFormat) {
  options = options || defaults$1.textureOptions;
  internalFormat = internalFormat || RGBA;
  const target = options.target || TEXTURE_2D;
  width = width || options.width;
  height = height || options.height;
  gl.bindTexture(target, tex);
  if (canGenerateMipmap(gl, width, height, internalFormat)) {
    gl.generateMipmap(target);
  } else {
    const filtering = canFilter(internalFormat) ? LINEAR : NEAREST;
    gl.texParameteri(target, TEXTURE_MIN_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_MAG_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
  }
}

function shouldAutomaticallySetTextureFilteringForSize(options) {
  return options.auto === true || (options.auto === undefined && options.level === undefined);
}

/**
 * Gets an array of cubemap face enums
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @return {number[]} cubemap face enums
 * @private
 */
function getCubeFaceOrder(gl, options) {
  options = options || {};
  return options.cubeFaceOrder || [
      TEXTURE_CUBE_MAP_POSITIVE_X,
      TEXTURE_CUBE_MAP_NEGATIVE_X,
      TEXTURE_CUBE_MAP_POSITIVE_Y,
      TEXTURE_CUBE_MAP_NEGATIVE_Y,
      TEXTURE_CUBE_MAP_POSITIVE_Z,
      TEXTURE_CUBE_MAP_NEGATIVE_Z,
    ];
}

/**
 * @typedef {Object} FaceInfo
 * @property {number} face gl enum for texImage2D
 * @property {number} ndx face index (0 - 5) into source data
 * @ignore
 */

/**
 * Gets an array of FaceInfos
 * There's a bug in some NVidia drivers that will crash the driver if
 * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take
 * the user's desired order from his faces to WebGL and make sure we
 * do the faces in WebGL order
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundant but
 *    it's needed internally to sort the array of `ndx` properties by `face`.
 * @private
 */
function getCubeFacesWithNdx(gl, options) {
  const faces = getCubeFaceOrder(gl, options);
  // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(
  const facesWithNdx = faces.map(function(face, ndx) {
    return { face: face, ndx: ndx };
  });
  facesWithNdx.sort(function(a, b) {
    return a.face - b.face;
  });
  return facesWithNdx;
}

/**
 * Set a texture from the contents of an element. Will also set
 * texture filtering or generate mips based on the dimensions of the element
 * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will
 * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {HTMLElement} element a canvas, img, or video element.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 * @kind function
 */
function setTextureFromElement(gl, tex, element, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D;
  const level = options.level || 0;
  let width = element.width;
  let height = element.height;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || formatType.type;
  setPackState(gl, options);
  gl.bindTexture(target, tex);
  if (target === TEXTURE_CUBE_MAP) {
    // guess the parts
    const imgWidth  = element.width;
    const imgHeight = element.height;
    let size;
    let slices;
    if (imgWidth / 6 === imgHeight) {
      // It's 6x1
      size = imgHeight;
      slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];
    } else if (imgHeight / 6 === imgWidth) {
      // It's 1x6
      size = imgWidth;
      slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];
    } else if (imgWidth / 3 === imgHeight / 2) {
      // It's 3x2
      size = imgWidth / 3;
      slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];
    } else if (imgWidth / 2 === imgHeight / 3) {
      // It's 2x3
      size = imgWidth / 2;
      slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];
    } else {
      throw "can't figure out cube map from element: " + (element.src ? element.src : element.nodeName);
    }
    const ctx = getShared2DContext();
    if (ctx) {
      ctx.canvas.width = size;
      ctx.canvas.height = size;
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function(f) {
        const xOffset = slices[f.ndx * 2 + 0] * size;
        const yOffset = slices[f.ndx * 2 + 1] * size;
        ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);
        gl.texImage2D(f.face, level, internalFormat, format, type, ctx.canvas);
      });
      // Free up the canvas memory
      ctx.canvas.width = 1;
      ctx.canvas.height = 1;
    } else if (typeof createImageBitmap !== 'undefined') {
      // NOTE: It seems like we should prefer ImageBitmap because unlike canvas it's
      // note lossy? (alpha is not premultiplied? although I'm not sure what
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function(f) {
        const xOffset = slices[f.ndx * 2 + 0] * size;
        const yOffset = slices[f.ndx * 2 + 1] * size;
        // We can't easily use a default texture color here as it would have to match
        // the type across all faces where as with a 2D one there's only one face
        // so we're replacing everything all at once. It also has to be the correct size.
        // On the other hand we need all faces to be the same size so as one face loads
        // the rest match else the texture will be un-renderable.
        gl.texImage2D(f.face, level, internalFormat, size, size, 0, format, type, null);
        createImageBitmap(element, xOffset, yOffset, size, size, {
          premultiplyAlpha: 'none',
          colorSpaceConversion: 'none',
        })
        .then(function(imageBitmap) {
          setPackState(gl, options);
          gl.bindTexture(target, tex);
          gl.texImage2D(f.face, level, internalFormat, format, type, imageBitmap);
          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
          }
        });
      });
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    const smallest = Math.min(element.width, element.height);
    const largest = Math.max(element.width, element.height);
    const depth = largest / smallest;
    if (depth % 1 !== 0) {
      throw "can not compute 3D dimensions of element";
    }
    const xMult = element.width  === largest ? 1 : 0;
    const yMult = element.height === largest ? 1 : 0;
    gl.pixelStorei(UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(UNPACK_ROW_LENGTH, element.width);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
    gl.texImage3D(target, level, internalFormat, smallest, smallest, smallest, 0, format, type, null);
    for (let d = 0; d < depth; ++d) {
      const srcX = d * smallest * xMult;
      const srcY = d * smallest * yMult;
      gl.pixelStorei(UNPACK_SKIP_PIXELS, srcX);
      gl.pixelStorei(UNPACK_SKIP_ROWS, srcY);
      gl.texSubImage3D(target, level, 0, 0, d, smallest, smallest, 1, format, type, element);
    }
    setSkipStateToDefault(gl);
  } else {
    gl.texImage2D(target, level, internalFormat, format, type, element);
  }
  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }
  setTextureParameters(gl, tex, options);
}

function noop() {
}

/**
 * Checks whether the url's origin is the same so that we can set the `crossOrigin`
 * @param {string} url url to image
 * @returns {boolean} true if the window's origin is the same as image's url
 * @private
 */
function urlIsSameOrigin(url) {
  if (typeof document !== 'undefined') {
    // for IE really
    const a = document.createElement('a');
    a.href = url;
    return a.hostname === location.hostname &&
           a.port     === location.port &&
           a.protocol === location.protocol;
  } else {
    const localOrigin = (new URL(location.href)).origin;
    const urlOrigin = (new URL(url, location.href)).origin;
    return urlOrigin === localOrigin;
  }
}

function setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin) {
  return crossOrigin === undefined && !urlIsSameOrigin(url)
     ? 'anonymous'
     : crossOrigin;
}

/**
 * Loads an image
 * @param {string} url url to image
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @return {HTMLImageElement} the image being loaded.
 * @private
 */
function loadImage(url, crossOrigin, callback) {
  callback = callback || noop;
  let img;
  crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults$1.crossOrigin;
  crossOrigin = setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin);
  if (typeof Image !== 'undefined') {
    img = new Image();
    if (crossOrigin !== undefined) {
      img.crossOrigin = crossOrigin;
    }

    const clearEventHandlers = function clearEventHandlers() {
      img.removeEventListener('error', onError);  // eslint-disable-line
      img.removeEventListener('load', onLoad);  // eslint-disable-line
      img = null;
    };

    const onError = function onError() {
      const msg = "couldn't load image: " + url;
      error(msg);
      callback(msg, img);
      clearEventHandlers();
    };

    const onLoad = function onLoad() {
      callback(null, img);
      clearEventHandlers();
    };

    img.addEventListener('error', onError);
    img.addEventListener('load', onLoad);
    img.src = url;
    return img;
  } else if (typeof ImageBitmap !== 'undefined') {
    let err;
    let bm;
    const cb = function cb() {
      callback(err, bm);
    };

    const options = {};
    if (crossOrigin) {
      options.mode = 'cors'; // TODO: not sure how to translate image.crossOrigin
    }
    fetch(url, options).then(function(response) {
      if (!response.ok) {
        throw response;
      }
      return response.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, {
        premultiplyAlpha: 'none',
        colorSpaceConversion: 'none',
      });
    }).then(function(bitmap) {
      // not sure if this works. We don't want
      // to catch the user's error. So, call
      // the callback in a timeout so we're
      // not in this scope inside the promise.
      bm = bitmap;
      setTimeout(cb);
    }).catch(function(e) {
      err = e;
      setTimeout(cb);
    });
    img = null;
  }
  return img;
}

/**
 * check if object is a TexImageSource
 *
 * @param {Object} obj Object to test
 * @return {boolean} true if object is a TexImageSource
 * @private
 */
function isTexImageSource(obj) {
  return (typeof ImageBitmap !== 'undefined' && obj instanceof ImageBitmap) ||
         (typeof ImageData !== 'undefined'  && obj instanceof ImageData) ||
         (typeof HTMLElement !== 'undefined'  && obj instanceof HTMLElement);
}

/**
 * if obj is an TexImageSource then just
 * uses it otherwise if obj is a string
 * then load it first.
 *
 * @param {string|TexImageSource} obj
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @private
 */
function loadAndUseImage(obj, crossOrigin, callback) {
  if (isTexImageSource(obj)) {
    setTimeout(function() {
      callback(null, obj);
    });
    return obj;
  }

  return loadImage(obj, crossOrigin, callback);
}

/**
 * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set
 * the default texture color is used which can be set by calling `setDefaultTextureColor`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */
function setTextureTo1PixelColor(gl, tex, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  if (options.color === false) {
    return;
  }
  // Assume it's a URL
  // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.
  const color = make1Pixel(options.color);
  if (target === TEXTURE_CUBE_MAP) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, RGBA, 1, 1, 0, RGBA, UNSIGNED_BYTE$2, color);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, 0, RGBA, 1, 1, 1, 0, RGBA, UNSIGNED_BYTE$2, color);
  } else {
    gl.texImage2D(target, 0, RGBA, 1, 1, 0, RGBA, UNSIGNED_BYTE$2, color);
  }
}

/**
 * The src image(s) used to create a texture.
 *
 * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}
 * you can pass in urls for images to load into the textures. If it's a single url
 * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap
 * this will be a corresponding array of images for the cubemap.
 *
 * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback TextureReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} texture the texture.
 * @param {module:twgl.TextureSrc} source image(s) used to as the src for the texture
 * @memberOf module:twgl
 */

/**
 * A callback for when all images have finished downloading and been uploaded into their respective textures
 * @callback TexturesReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.
 * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback CubemapReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each face.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback ThreeDReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each slice.
 * @memberOf module:twgl
 */

/**
 * Loads a texture from an image from a Url as specified in `options.src`
 * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is
 * immediately useable. It will be updated with the contents of the image once the image has finished
 * downloading. Filtering options will be set as appropriate for image unless `options.auto === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will
 *    be non null if there was an error.
 * @return {HTMLImageElement} the image being downloaded.
 * @memberOf module:twgl/textures
 */
function loadTextureFromUrl(gl, tex, options, callback) {
  callback = callback || noop;
  options = options || defaults$1.textureOptions;
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  const img = loadAndUseImage(options.src, options.crossOrigin, function(err, img) {
    if (err) {
      callback(err, tex, img);
    } else {
      setTextureFromElement(gl, tex, img, options);
      callback(null, tex, img);
    }
  });
  return img;
}

/**
 * Loads a cubemap from 6 urls or TexImageSources as specified in `options.src`. Will set the cubemap to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 */
function loadCubemapFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  const urls = options.src;
  if (urls.length !== 6) {
    throw "there must be 6 urls for a cubemap";
  }
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || UNSIGNED_BYTE$2;
  const target = options.target || TEXTURE_2D;
  if (target !== TEXTURE_CUBE_MAP) {
    throw "target must be TEXTURE_CUBE_MAP";
  }
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  let numToLoad = 6;
  const errors = [];
  const faces = getCubeFaceOrder(gl, options);
  let imgs;  // eslint-disable-line

  function uploadImg(faceTarget) {
    return function(err, img) {
      --numToLoad;
      if (err) {
        errors.push(err);
      } else {
        if (img.width !== img.height) {
          errors.push("cubemap face img is not a square: " + img.src);
        } else {
          setPackState(gl, options);
          gl.bindTexture(target, tex);

          // So assuming this is the first image we now have one face that's img sized
          // and 5 faces that are 1x1 pixel so size the other faces
          if (numToLoad === 5) {
            // use the default order
            getCubeFaceOrder().forEach(function(otherTarget) {
              // Should we re-use the same face or a color?
              gl.texImage2D(otherTarget, level, internalFormat, format, type, img);
            });
          } else {
            gl.texImage2D(faceTarget, level, internalFormat, format, type, img);
          }

          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            gl.generateMipmap(target);
          }
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function(url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(faces[ndx]));
  });
}

/**
 * Loads a 2d array or 3d texture from urls OR TexImageSources as specified in `options.src`.
 * Will set the texture to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 *
 * If the width and height is not specified the width and height of the first
 * image loaded will be used. Note that since images are loaded async
 * which image downloads first is unknown.
 *
 * If an image is not the same size as the width and height it will be scaled
 * to that width and height.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.ThreeDReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 */
function loadSlicesFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  const urls = options.src;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || UNSIGNED_BYTE$2;
  const target = options.target || TEXTURE_2D_ARRAY;
  if (target !== TEXTURE_3D && target !== TEXTURE_2D_ARRAY) {
    throw "target must be TEXTURE_3D or TEXTURE_2D_ARRAY";
  }
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  let numToLoad = urls.length;
  const errors = [];
  let imgs;  // eslint-disable-line
  const level = options.level || 0;
  let width = options.width;
  let height = options.height;
  const depth = urls.length;
  let firstImage = true;

  function uploadImg(slice) {
    return function(err, img) {
      --numToLoad;
      if (err) {
        errors.push(err);
      } else {
        setPackState(gl, options);
        gl.bindTexture(target, tex);

        if (firstImage) {
          firstImage = false;
          width = options.width || img.width;
          height = options.height || img.height;
          gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null);

          // put it in every slice otherwise some slices will be 0,0,0,0
          for (let s = 0; s < depth; ++s) {
            gl.texSubImage3D(target, level, 0, 0, s, width, height, 1, format, type, img);
          }
        } else {
          let src = img;
          let ctx;
          if (img.width !== width || img.height !== height) {
            // Size the image to fix
            ctx = getShared2DContext();
            src = ctx.canvas;
            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
          }

          gl.texSubImage3D(target, level, 0, 0, slice, width, height, 1, format, type, src);

          // free the canvas memory
          if (ctx && src === ctx.canvas) {
            ctx.canvas.width = 0;
            ctx.canvas.height = 0;
          }
        }

        if (shouldAutomaticallySetTextureFilteringForSize(options)) {
          gl.generateMipmap(target);
        }
      }

      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }

  imgs = urls.map(function(url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(ndx));
  });
}

/**
 * Sets a texture from an array or typed array. If the width or height is not provided will attempt to
 * guess the size. See {@link module:twgl.TextureOptions}.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {(number[]|ArrayBufferView)} src An array or typed arry with texture data.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */
function setTextureFromArray(gl, tex, src, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  let width = options.width;
  let height = options.height;
  let depth = options.depth;
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  if (!isArrayBuffer$1(src)) {
    const Type = getTypedArrayTypeForGLType(type);
    src = new Type(src);
  } else if (src instanceof Uint8ClampedArray) {
    src = new Uint8Array(src.buffer);
  }

  const bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
  const numElements = src.byteLength / bytesPerElement;  // TODO: check UNPACK_ALIGNMENT?
  if (numElements % 1) {
    throw "length wrong size for format: " + glEnumToString(gl, format);
  }
  let dimensions;
  if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    if (!width && !height && !depth) {
      const size = Math.cbrt(numElements);
      if (size % 1 !== 0) {
        throw "can't guess cube size of array of numElements: " + numElements;
      }
      width = size;
      height = size;
      depth = size;
    } else if (width && (!height || !depth)) {
      dimensions = guessDimensions(gl, target, height, depth, numElements / width);
      height = dimensions.width;
      depth = dimensions.height;
    } else if (height && (!width || !depth)) {
      dimensions = guessDimensions(gl, target, width, depth, numElements / height);
      width = dimensions.width;
      depth = dimensions.height;
    } else {
      dimensions = guessDimensions(gl, target, width, height, numElements / depth);
      width = dimensions.width;
      height = dimensions.height;
    }
  } else {
    dimensions = guessDimensions(gl, target, width, height, numElements);
    width = dimensions.width;
    height = dimensions.height;
  }
  setSkipStateToDefault(gl);
  gl.pixelStorei(UNPACK_ALIGNMENT, options.unpackAlignment || 1);
  setPackState(gl, options);
  if (target === TEXTURE_CUBE_MAP) {
    const elementsPerElement = bytesPerElement / src.BYTES_PER_ELEMENT;
    const faceSize = numElements / 6 * elementsPerElement;

    getCubeFacesWithNdx(gl, options).forEach(f => {
      const offset = faceSize * f.ndx;
      const data = src.subarray(offset, offset + faceSize);
      gl.texImage2D(f.face, level, internalFormat, width, height, 0, format, type, data);
    });
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, src);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, src);
  }
  return {
    width: width,
    height: height,
    depth: depth,
    type: type,
  };
}

/**
 * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.
 * You must set `options.width` and `options.height`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */
function setEmptyTexture(gl, tex, options) {
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || formatType.type;
  setPackState(gl, options);
  if (target === TEXTURE_CUBE_MAP) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, options.width, options.height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, options.width, options.height, options.depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, options.width, options.height, 0, format, type, null);
  }
}

/**
 * Creates a texture based on the options passed in.
 *
 * Note: may reset UNPACK_ALIGNMENT, UNPACK_ROW_LENGTH, UNPACK_IMAGE_HEIGHT, UNPACK_SKIP_IMAGES
 * UNPACK_SKIP_PIXELS, and UNPACK_SKIP_ROWS
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.
 * @return {WebGLTexture} the created texture.
 * @memberOf module:twgl/textures
 */
function createTexture(gl, options, callback) {
  callback = callback || noop;
  options = options || defaults$1.textureOptions;
  const tex = gl.createTexture();
  const target = options.target || TEXTURE_2D;
  let width  = options.width  || 1;
  let height = options.height || 1;
  const internalFormat = options.internalFormat || RGBA;
  gl.bindTexture(target, tex);
  if (target === TEXTURE_CUBE_MAP) {
    // this should have been the default for cubemaps :(
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
  }
  let src = options.src;
  if (src) {
    if (typeof src === "function") {
      src = src(gl, options);
    }
    if (typeof (src) === "string") {
      loadTextureFromUrl(gl, tex, options, callback);
    } else if (isArrayBuffer$1(src) ||
               (Array.isArray(src) && (
                    typeof src[0] === 'number' ||
                    Array.isArray(src[0]) ||
                    isArrayBuffer$1(src[0]))
               )
              ) {
      const dimensions = setTextureFromArray(gl, tex, src, options);
      width  = dimensions.width;
      height = dimensions.height;
    } else if (Array.isArray(src) && (typeof (src[0]) === 'string' || isTexImageSource(src[0]))) {
      if (target === TEXTURE_CUBE_MAP) {
        loadCubemapFromUrls(gl, tex, options, callback);
      } else {
        loadSlicesFromUrls(gl, tex, options, callback);
      }
    } else { // if (isTexImageSource(src))
      setTextureFromElement(gl, tex, src, options);
      width  = src.width;
      height = src.height;
    }
  } else {
    setEmptyTexture(gl, tex, options);
  }
  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }
  setTextureParameters(gl, tex, options);
  return tex;
}

/**
 * Resizes a texture based on the options passed in.
 *
 * Note: This is not a generic resize anything function.
 * It's mostly used by {@link module:twgl.resizeFramebufferInfo}
 * It will use `options.src` if it exists to try to determine a `type`
 * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided
 * for the texture. Texture parameters will be set accordingly
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the texture to resize
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {number} [width] the new width. If not passed in will use `options.width`
 * @param {number} [height] the new height. If not passed in will use `options.height`
 * @param {number} [depth] the new depth. If not passed in will use `options.depth`
 * @memberOf module:twgl/textures
 */
function resizeTexture(gl, tex, options, width, height, depth) {
  width = width || options.width;
  height = height || options.height;
  depth = depth || options.depth;
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  let type;
  const src = options.src;
  if (!src) {
    type = options.type || formatType.type;
  } else if (isArrayBuffer$1(src) || (Array.isArray(src) && typeof (src[0]) === 'number')) {
    type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  } else {
    type = options.type || formatType.type;
  }
  if (target === TEXTURE_CUBE_MAP) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, width, height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);
  }
}

/**
 * Check if a src is an async request.
 * if src is a string we're going to download an image
 * if src is an array of strings we're going to download cubemap images
 * @param {*} src The src from a TextureOptions
 * @returns {bool} true if src is async.
 * @private
 */
function isAsyncSrc(src) {
  return typeof src === 'string' ||
         (Array.isArray(src) && typeof src[0] === 'string');
}

/**
 * Creates a bunch of textures based on the passed in options.
 *
 * Example:
 *
 *     const textures = twgl.createTextures(gl, {
 *       // a power of 2 image
 *       hftIcon: { src: "images/hft-icon-16.png", mag: gl.NEAREST },
 *       // a non-power of 2 image
 *       clover: { src: "images/clover.jpg" },
 *       // From a canvas
 *       fromCanvas: { src: ctx.canvas },
 *       // A cubemap from 6 images
 *       yokohama: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: [
 *           'images/yokohama/posx.jpg',
 *           'images/yokohama/negx.jpg',
 *           'images/yokohama/posy.jpg',
 *           'images/yokohama/negy.jpg',
 *           'images/yokohama/posz.jpg',
 *           'images/yokohama/negz.jpg',
 *         ],
 *       },
 *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)
 *       goldengate: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: 'images/goldengate.jpg',
 *       },
 *       // A 2x2 pixel texture from a JavaScript array
 *       checker: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         src: [
 *           255,255,255,255,
 *           192,192,192,255,
 *           192,192,192,255,
 *           255,255,255,255,
 *         ],
 *       },
 *       // a 1x2 pixel texture from a typed array.
 *       stripe: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         format: gl.LUMINANCE,
 *         src: new Uint8Array([
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *         ]),
 *         width: 1,
 *       },
 *     });
 *
 * Now
 *
 * *   `textures.hftIcon` will be a 2d texture
 * *   `textures.clover` will be a 2d texture
 * *   `textures.fromCanvas` will be a 2d texture
 * *   `textures.yohohama` will be a cubemap texture
 * *   `textures.goldengate` will be a cubemap texture
 * *   `textures.checker` will be a 2d texture
 * *   `textures.stripe` will be a 2d texture
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.
 * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.
 * @return {Object.<string,WebGLTexture>} the created textures by name
 * @memberOf module:twgl/textures
 */
function createTextures(gl, textureOptions, callback) {
  callback = callback || noop;
  let numDownloading = 0;
  const errors = [];
  const textures = {};
  const images = {};

  function callCallbackIfReady() {
    if (numDownloading === 0) {
      setTimeout(function() {
        callback(errors.length ? errors : undefined, textures, images);
      }, 0);
    }
  }

  Object.keys(textureOptions).forEach(function(name) {
    const options = textureOptions[name];
    let onLoadFn;
    if (isAsyncSrc(options.src)) {
      onLoadFn = function(err, tex, img) {
        images[name] = img;
        --numDownloading;
        if (err) {
          errors.push(err);
        }
        callCallbackIfReady();
      };
      ++numDownloading;
    }
    textures[name] = createTexture(gl, options, onLoadFn);
  });

  // queue the callback if there are no images to download.
  // We do this because if your code is structured to wait for
  // images to download but then you comment out all the async
  // images your code would break.
  callCallbackIfReady();

  return textures;
}

var textures = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setTextureDefaults_: setDefaults$1,
  createSampler: createSampler,
  createSamplers: createSamplers,
  setSamplerParameters: setSamplerParameters,
  createTexture: createTexture,
  setEmptyTexture: setEmptyTexture,
  setTextureFromArray: setTextureFromArray,
  loadTextureFromUrl: loadTextureFromUrl,
  setTextureFromElement: setTextureFromElement,
  setTextureFilteringForSize: setTextureFilteringForSize,
  setTextureParameters: setTextureParameters,
  setDefaultTextureColor: setDefaultTextureColor,
  createTextures: createTextures,
  resizeTexture: resizeTexture,
  canGenerateMipmap: canGenerateMipmap,
  canFilter: canFilter,
  getNumComponentsForFormat: getNumComponentsForFormat,
  getBytesPerElementForInternalFormat: getBytesPerElementForInternalFormat,
  getFormatAndTypeForInternalFormat: getFormatAndTypeForInternalFormat
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Low level shader program related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.programs` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/programs
 */

const error$1 = error;
const warn$1 = warn;
function getElementById(id) {
  return (typeof document !== 'undefined' && document.getElementById)
      ? document.getElementById(id)
      : null;
}

const TEXTURE0                       = 0x84c0;
const DYNAMIC_DRAW                   = 0x88e8;

const ARRAY_BUFFER$1                   = 0x8892;
const ELEMENT_ARRAY_BUFFER$1           = 0x8893;
const UNIFORM_BUFFER                 = 0x8a11;
const TRANSFORM_FEEDBACK_BUFFER      = 0x8c8e;

const TRANSFORM_FEEDBACK             = 0x8e22;

const COMPILE_STATUS                 = 0x8b81;
const LINK_STATUS                    = 0x8b82;
const FRAGMENT_SHADER                = 0x8b30;
const VERTEX_SHADER                  = 0x8b31;
const SEPARATE_ATTRIBS               = 0x8c8d;

const ACTIVE_UNIFORMS                = 0x8b86;
const ACTIVE_ATTRIBUTES              = 0x8b89;
const TRANSFORM_FEEDBACK_VARYINGS    = 0x8c83;
const ACTIVE_UNIFORM_BLOCKS          = 0x8a36;
const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER   = 0x8a44;
const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8a46;
const UNIFORM_BLOCK_DATA_SIZE                     = 0x8a40;
const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES        = 0x8a43;

const FLOAT$3                         = 0x1406;
const FLOAT_VEC2                    = 0x8B50;
const FLOAT_VEC3                    = 0x8B51;
const FLOAT_VEC4                    = 0x8B52;
const INT$3                           = 0x1404;
const INT_VEC2                      = 0x8B53;
const INT_VEC3                      = 0x8B54;
const INT_VEC4                      = 0x8B55;
const BOOL                          = 0x8B56;
const BOOL_VEC2                     = 0x8B57;
const BOOL_VEC3                     = 0x8B58;
const BOOL_VEC4                     = 0x8B59;
const FLOAT_MAT2                    = 0x8B5A;
const FLOAT_MAT3                    = 0x8B5B;
const FLOAT_MAT4                    = 0x8B5C;
const SAMPLER_2D                    = 0x8B5E;
const SAMPLER_CUBE                  = 0x8B60;
const SAMPLER_3D                    = 0x8B5F;
const SAMPLER_2D_SHADOW             = 0x8B62;
const FLOAT_MAT2x3                  = 0x8B65;
const FLOAT_MAT2x4                  = 0x8B66;
const FLOAT_MAT3x2                  = 0x8B67;
const FLOAT_MAT3x4                  = 0x8B68;
const FLOAT_MAT4x2                  = 0x8B69;
const FLOAT_MAT4x3                  = 0x8B6A;
const SAMPLER_2D_ARRAY              = 0x8DC1;
const SAMPLER_2D_ARRAY_SHADOW       = 0x8DC4;
const SAMPLER_CUBE_SHADOW           = 0x8DC5;
const UNSIGNED_INT$3                  = 0x1405;
const UNSIGNED_INT_VEC2             = 0x8DC6;
const UNSIGNED_INT_VEC3             = 0x8DC7;
const UNSIGNED_INT_VEC4             = 0x8DC8;
const INT_SAMPLER_2D                = 0x8DCA;
const INT_SAMPLER_3D                = 0x8DCB;
const INT_SAMPLER_CUBE              = 0x8DCC;
const INT_SAMPLER_2D_ARRAY          = 0x8DCF;
const UNSIGNED_INT_SAMPLER_2D       = 0x8DD2;
const UNSIGNED_INT_SAMPLER_3D       = 0x8DD3;
const UNSIGNED_INT_SAMPLER_CUBE     = 0x8DD4;
const UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;

const TEXTURE_2D$1                    = 0x0DE1;
const TEXTURE_CUBE_MAP$1              = 0x8513;
const TEXTURE_3D$1                    = 0x806F;
const TEXTURE_2D_ARRAY$1              = 0x8C1A;

const typeMap = {};

/**
 * Returns the corresponding bind point for a given sampler type
 */
function getBindPointForSamplerType(gl, type) {
  return typeMap[type].bindPoint;
}

// This kind of sucks! If you could compose functions as in `var fn = gl[name];`
// this code could be a lot smaller but that is sadly really slow (T_T)

function floatSetter(gl, location) {
  return function(v) {
    gl.uniform1f(location, v);
  };
}

function floatArraySetter(gl, location) {
  return function(v) {
    gl.uniform1fv(location, v);
  };
}

function floatVec2Setter(gl, location) {
  return function(v) {
    gl.uniform2fv(location, v);
  };
}

function floatVec3Setter(gl, location) {
  return function(v) {
    gl.uniform3fv(location, v);
  };
}

function floatVec4Setter(gl, location) {
  return function(v) {
    gl.uniform4fv(location, v);
  };
}

function intSetter(gl, location) {
  return function(v) {
    gl.uniform1i(location, v);
  };
}

function intArraySetter(gl, location) {
  return function(v) {
    gl.uniform1iv(location, v);
  };
}

function intVec2Setter(gl, location) {
  return function(v) {
    gl.uniform2iv(location, v);
  };
}

function intVec3Setter(gl, location) {
  return function(v) {
    gl.uniform3iv(location, v);
  };
}

function intVec4Setter(gl, location) {
  return function(v) {
    gl.uniform4iv(location, v);
  };
}

function uintSetter(gl, location) {
  return function(v) {
    gl.uniform1ui(location, v);
  };
}

function uintArraySetter(gl, location) {
  return function(v) {
    gl.uniform1uiv(location, v);
  };
}

function uintVec2Setter(gl, location) {
  return function(v) {
    gl.uniform2uiv(location, v);
  };
}

function uintVec3Setter(gl, location) {
  return function(v) {
    gl.uniform3uiv(location, v);
  };
}

function uintVec4Setter(gl, location) {
  return function(v) {
    gl.uniform4uiv(location, v);
  };
}

function floatMat2Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix2fv(location, false, v);
  };
}

function floatMat3Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix3fv(location, false, v);
  };
}

function floatMat4Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix4fv(location, false, v);
  };
}

function floatMat23Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix2x3fv(location, false, v);
  };
}

function floatMat32Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix3x2fv(location, false, v);
  };
}

function floatMat24Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix2x4fv(location, false, v);
  };
}

function floatMat42Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix4x2fv(location, false, v);
  };
}

function floatMat34Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix3x4fv(location, false, v);
  };
}

function floatMat43Setter(gl, location) {
  return function(v) {
    gl.uniformMatrix4x3fv(location, false, v);
  };
}

function samplerSetter(gl, type, unit, location) {
  const bindPoint = getBindPointForSamplerType(gl, type);
  return isWebGL2(gl) ? function(textureOrPair) {
    let texture;
    let sampler;
    if (isTexture(gl, textureOrPair)) {
      texture = textureOrPair;
      sampler = null;
    } else {
      texture = textureOrPair.texture;
      sampler = textureOrPair.sampler;
    }
    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
    gl.bindSampler(unit, sampler);
  } : function(texture) {
    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
  };
}

function samplerArraySetter(gl, type, unit, location, size) {
  const bindPoint = getBindPointForSamplerType(gl, type);
  const units = new Int32Array(size);
  for (let ii = 0; ii < size; ++ii) {
    units[ii] = unit + ii;
  }

  return isWebGL2(gl) ? function(textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function(textureOrPair, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      let texture;
      let sampler;
      if (isTexture(gl, textureOrPair)) {
        texture = textureOrPair;
        sampler = null;
      } else {
        texture = textureOrPair.texture;
        sampler = textureOrPair.sampler;
      }
      gl.bindSampler(unit, sampler);
      gl.bindTexture(bindPoint, texture);
    });
  } : function(textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function(texture, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      gl.bindTexture(bindPoint, texture);
    });
  };
}

typeMap[FLOAT$3]                         = { Type: Float32Array, size:  4, setter: floatSetter,      arraySetter: floatArraySetter, };
typeMap[FLOAT_VEC2]                    = { Type: Float32Array, size:  8, setter: floatVec2Setter,  cols: 2, };
typeMap[FLOAT_VEC3]                    = { Type: Float32Array, size: 12, setter: floatVec3Setter,  cols: 3, };
typeMap[FLOAT_VEC4]                    = { Type: Float32Array, size: 16, setter: floatVec4Setter,  cols: 4, };
typeMap[INT$3]                           = { Type: Int32Array,   size:  4, setter: intSetter,        arraySetter: intArraySetter, };
typeMap[INT_VEC2]                      = { Type: Int32Array,   size:  8, setter: intVec2Setter,    cols: 2, };
typeMap[INT_VEC3]                      = { Type: Int32Array,   size: 12, setter: intVec3Setter,    cols: 3, };
typeMap[INT_VEC4]                      = { Type: Int32Array,   size: 16, setter: intVec4Setter,    cols: 4, };
typeMap[UNSIGNED_INT$3]                  = { Type: Uint32Array,  size:  4, setter: uintSetter,       arraySetter: uintArraySetter, };
typeMap[UNSIGNED_INT_VEC2]             = { Type: Uint32Array,  size:  8, setter: uintVec2Setter,   cols: 2, };
typeMap[UNSIGNED_INT_VEC3]             = { Type: Uint32Array,  size: 12, setter: uintVec3Setter,   cols: 3, };
typeMap[UNSIGNED_INT_VEC4]             = { Type: Uint32Array,  size: 16, setter: uintVec4Setter,   cols: 4, };
typeMap[BOOL]                          = { Type: Uint32Array,  size:  4, setter: intSetter,        arraySetter: intArraySetter, };
typeMap[BOOL_VEC2]                     = { Type: Uint32Array,  size:  8, setter: intVec2Setter,    cols: 2, };
typeMap[BOOL_VEC3]                     = { Type: Uint32Array,  size: 12, setter: intVec3Setter,    cols: 3, };
typeMap[BOOL_VEC4]                     = { Type: Uint32Array,  size: 16, setter: intVec4Setter,    cols: 4, };
typeMap[FLOAT_MAT2]                    = { Type: Float32Array, size: 32, setter: floatMat2Setter,  rows: 2, cols: 2, };
typeMap[FLOAT_MAT3]                    = { Type: Float32Array, size: 48, setter: floatMat3Setter,  rows: 3, cols: 3, };
typeMap[FLOAT_MAT4]                    = { Type: Float32Array, size: 64, setter: floatMat4Setter,  rows: 4, cols: 4, };
typeMap[FLOAT_MAT2x3]                  = { Type: Float32Array, size: 32, setter: floatMat23Setter, rows: 2, cols: 3, };
typeMap[FLOAT_MAT2x4]                  = { Type: Float32Array, size: 32, setter: floatMat24Setter, rows: 2, cols: 4, };
typeMap[FLOAT_MAT3x2]                  = { Type: Float32Array, size: 48, setter: floatMat32Setter, rows: 3, cols: 2, };
typeMap[FLOAT_MAT3x4]                  = { Type: Float32Array, size: 48, setter: floatMat34Setter, rows: 3, cols: 4, };
typeMap[FLOAT_MAT4x2]                  = { Type: Float32Array, size: 64, setter: floatMat42Setter, rows: 4, cols: 2, };
typeMap[FLOAT_MAT4x3]                  = { Type: Float32Array, size: 64, setter: floatMat43Setter, rows: 4, cols: 3, };
typeMap[SAMPLER_2D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D$1,       };
typeMap[SAMPLER_CUBE]                  = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP$1, };
typeMap[SAMPLER_3D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D$1,       };
typeMap[SAMPLER_2D_SHADOW]             = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D$1,       };
typeMap[SAMPLER_2D_ARRAY]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY$1, };
typeMap[SAMPLER_2D_ARRAY_SHADOW]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY$1, };
typeMap[SAMPLER_CUBE_SHADOW]           = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP$1, };
typeMap[INT_SAMPLER_2D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D$1,       };
typeMap[INT_SAMPLER_3D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D$1,       };
typeMap[INT_SAMPLER_CUBE]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP$1, };
typeMap[INT_SAMPLER_2D_ARRAY]          = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY$1, };
typeMap[UNSIGNED_INT_SAMPLER_2D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D$1,       };
typeMap[UNSIGNED_INT_SAMPLER_3D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D$1,       };
typeMap[UNSIGNED_INT_SAMPLER_CUBE]     = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP$1, };
typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY$1, };

function floatAttribSetter(gl, index) {
  return function(b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      switch (b.value.length) {
        case 4:
          gl.vertexAttrib4fv(index, b.value);
          break;
        case 3:
          gl.vertexAttrib3fv(index, b.value);
          break;
        case 2:
          gl.vertexAttrib2fv(index, b.value);
          break;
        case 1:
          gl.vertexAttrib1fv(index, b.value);
          break;
        default:
          throw new Error('the length of a float constant value must be between 1 and 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER$1, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribPointer(
          index, b.numComponents || b.size, b.type || FLOAT$3, b.normalize || false, b.stride || 0, b.offset || 0);
      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function intAttribSetter(gl, index) {
  return function(b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      if (b.value.length === 4) {
        gl.vertexAttrib4iv(index, b.value);
      } else {
        throw new Error('The length of an integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER$1, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(
          index, b.numComponents || b.size, b.type || INT$3, b.stride || 0, b.offset || 0);
      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function uintAttribSetter(gl, index) {
  return function(b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      if (b.value.length === 4) {
        gl.vertexAttrib4uiv(index, b.value);
      } else {
        throw new Error('The length of an unsigned integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER$1, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(
          index, b.numComponents || b.size, b.type || UNSIGNED_INT$3, b.stride || 0, b.offset || 0);
      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}

function matAttribSetter(gl, index, typeInfo) {
  const defaultSize = typeInfo.size;
  const count = typeInfo.count;

  return function(b) {
    gl.bindBuffer(ARRAY_BUFFER$1, b.buffer);
    const numComponents = b.size || b.numComponents || defaultSize;
    const size = numComponents / count;
    const type = b.type || FLOAT$3;
    const typeInfo = typeMap[type];
    const stride = typeInfo.size * numComponents;
    const normalize = b.normalize || false;
    const offset = b.offset || 0;
    const rowOffset = stride / count;
    for (let i = 0; i < count; ++i) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(
          index + i, size, type, normalize, stride, offset + rowOffset * i);
      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index + i, b.divisor);
      }
    }
  };
}



const attrTypeMap = {};
attrTypeMap[FLOAT$3]             = { size:  4, setter: floatAttribSetter, };
attrTypeMap[FLOAT_VEC2]        = { size:  8, setter: floatAttribSetter, };
attrTypeMap[FLOAT_VEC3]        = { size: 12, setter: floatAttribSetter, };
attrTypeMap[FLOAT_VEC4]        = { size: 16, setter: floatAttribSetter, };
attrTypeMap[INT$3]               = { size:  4, setter: intAttribSetter,   };
attrTypeMap[INT_VEC2]          = { size:  8, setter: intAttribSetter,   };
attrTypeMap[INT_VEC3]          = { size: 12, setter: intAttribSetter,   };
attrTypeMap[INT_VEC4]          = { size: 16, setter: intAttribSetter,   };
attrTypeMap[UNSIGNED_INT$3]      = { size:  4, setter: uintAttribSetter,  };
attrTypeMap[UNSIGNED_INT_VEC2] = { size:  8, setter: uintAttribSetter,  };
attrTypeMap[UNSIGNED_INT_VEC3] = { size: 12, setter: uintAttribSetter,  };
attrTypeMap[UNSIGNED_INT_VEC4] = { size: 16, setter: uintAttribSetter,  };
attrTypeMap[BOOL]              = { size:  4, setter: intAttribSetter,   };
attrTypeMap[BOOL_VEC2]         = { size:  8, setter: intAttribSetter,   };
attrTypeMap[BOOL_VEC3]         = { size: 12, setter: intAttribSetter,   };
attrTypeMap[BOOL_VEC4]         = { size: 16, setter: intAttribSetter,   };
attrTypeMap[FLOAT_MAT2]        = { size:  4, setter: matAttribSetter,   count: 2, };
attrTypeMap[FLOAT_MAT3]        = { size:  9, setter: matAttribSetter,   count: 3, };
attrTypeMap[FLOAT_MAT4]        = { size: 16, setter: matAttribSetter,   count: 4, };

const errorRE = /ERROR:\s*\d+:(\d+)/gi;
function addLineNumbersWithError(src, log = '', lineOffset = 0) {
  // Note: Error message formats are not defined by any spec so this may or may not work.
  const matches = [...log.matchAll(errorRE)];
  const lineNoToErrorMap = new Map(matches.map((m, ndx) => {
    const lineNo = parseInt(m[1]);
    const next = matches[ndx + 1];
    const end = next ? next.index : log.length;
    const msg = log.substring(m.index, end);
    return [lineNo - 1, msg];
  }));
  return src.split('\n').map((line, lineNo) => {
    const err = lineNoToErrorMap.get(lineNo);
    return `${lineNo + 1 + lineOffset}: ${line}${err ? `\n\n^^^ ${err}` : ''}`;
  }).join('\n');
}

/**
 * Error Callback
 * @callback ErrorCallback
 * @param {string} msg error message.
 * @param {number} [lineOffset] amount to add to line number
 * @memberOf module:twgl
 */

const spaceRE = /^[ \t]*\n/;

/**
 * Loads a shader.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} shaderSource The shader source.
 * @param {number} shaderType The type of shader.
 * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.
 * @return {WebGLShader} The created shader.
 * @private
 */
function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {
  const errFn = opt_errorCallback || error$1;
  // Create the shader object
  const shader = gl.createShader(shaderType);

  // Remove the first end of line because WebGL 2.0 requires
  // #version 300 es
  // as the first line. No whitespace allowed before that line
  // so
  //
  // <script>
  // #version 300 es
  // </script>
  //
  // Has one line before it which is invalid according to GLSL ES 3.00
  //
  let lineOffset = 0;
  if (spaceRE.test(shaderSource)) {
    lineOffset = 1;
    shaderSource = shaderSource.replace(spaceRE, '');
  }

  // Load the shader source
  gl.shaderSource(shader, shaderSource);

  // Compile the shader
  gl.compileShader(shader);

  // Check the compile status
  const compiled = gl.getShaderParameter(shader, COMPILE_STATUS);
  if (!compiled) {
    // Something went wrong during compilation; get the error
    const lastError = gl.getShaderInfoLog(shader);
    errFn(`${addLineNumbersWithError(shaderSource, lastError, lineOffset)}\nError compiling ${glEnumToString(gl, shaderType)}: ${lastError}`);
    gl.deleteShader(shader);
    return null;
  }

  return shader;
}

/**
 * @typedef {Object} ProgramOptions
 * @property {function(string)} [errorCallback] callback for errors
 * @property {Object.<string,number>} [attribLocations] a attribute name to location map
 * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed
 *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise
 *   you can pass an array of names.
 * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.
 * @memberOf module:twgl
 */

/**
 * Gets the program options based on all these optional arguments
 * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramOptions} an instance of ProgramOptions based on the arguments passed in
 * @private
 */
function getProgramOptions(opt_attribs, opt_locations, opt_errorCallback) {
  let transformFeedbackVaryings;
  let transformFeedbackMode;
  if (typeof opt_locations === 'function') {
    opt_errorCallback = opt_locations;
    opt_locations = undefined;
  }
  if (typeof opt_attribs === 'function') {
    opt_errorCallback = opt_attribs;
    opt_attribs = undefined;
  } else if (opt_attribs && !Array.isArray(opt_attribs)) {
    // If we have an errorCallback we can just return this object
    // Otherwise we need to construct one with default errorCallback
    if (opt_attribs.errorCallback) {
      return opt_attribs;
    }
    const opt = opt_attribs;
    opt_errorCallback = opt.errorCallback;
    opt_attribs = opt.attribLocations;
    transformFeedbackVaryings = opt.transformFeedbackVaryings;
    transformFeedbackMode = opt.transformFeedbackMode;
  }

  const options = {
    errorCallback: opt_errorCallback || error$1,
    transformFeedbackVaryings: transformFeedbackVaryings,
    transformFeedbackMode: transformFeedbackMode,
  };

  if (opt_attribs) {
    let attribLocations = {};
    if (Array.isArray(opt_attribs)) {
      opt_attribs.forEach(function(attrib,  ndx) {
        attribLocations[attrib] = opt_locations ? opt_locations[ndx] : ndx;
      });
    } else {
      attribLocations = opt_attribs;
    }
    options.attribLocations = attribLocations;
  }

  return options;
}

const defaultShaderType = [
  "VERTEX_SHADER",
  "FRAGMENT_SHADER",
];

function getShaderTypeFromScriptType(gl, scriptType) {
  if (scriptType.indexOf("frag") >= 0) {
    return FRAGMENT_SHADER;
  } else if (scriptType.indexOf("vert") >= 0) {
    return VERTEX_SHADER;
  }
  return undefined;
}

function deleteShaders(gl, shaders) {
  shaders.forEach(function(shader) {
    gl.deleteShader(shader);
  });
}

/**
 * Creates a program, attaches (and/or compiles) shaders, binds attrib locations, links the
 * program and calls useProgram.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgram(gl, [vs, fs], options);
 *     twgl.createProgram(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */
function createProgram(
    gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const realShaders = [];
  const newShaders = [];
  for (let ndx = 0; ndx < shaders.length; ++ndx) {
    let shader = shaders[ndx];
    if (typeof (shader) === 'string') {
      const elem = getElementById(shader);
      const src = elem ? elem.text : shader;
      let type = gl[defaultShaderType[ndx]];
      if (elem && elem.type) {
        type = getShaderTypeFromScriptType(gl, elem.type) || type;
      }
      shader = loadShader(gl, src, type, progOptions.errorCallback);
      newShaders.push(shader);
    }
    if (isShader(gl, shader)) {
      realShaders.push(shader);
    }
  }

  if (realShaders.length !== shaders.length) {
    progOptions.errorCallback("not enough shaders for program");
    deleteShaders(gl, newShaders);
    return null;
  }

  const program = gl.createProgram();
  realShaders.forEach(function(shader) {
    gl.attachShader(program, shader);
  });
  if (progOptions.attribLocations) {
    Object.keys(progOptions.attribLocations).forEach(function(attrib) {
      gl.bindAttribLocation(program, progOptions.attribLocations[attrib], attrib);
    });
  }
  let varyings = progOptions.transformFeedbackVaryings;
  if (varyings) {
    if (varyings.attribs) {
      varyings = varyings.attribs;
    }
    if (!Array.isArray(varyings)) {
      varyings = Object.keys(varyings);
    }
    gl.transformFeedbackVaryings(program, varyings, progOptions.transformFeedbackMode || SEPARATE_ATTRIBS);
  }
  gl.linkProgram(program);

  // Check the link status
  const linked = gl.getProgramParameter(program, LINK_STATUS);
  if (!linked) {
    // something went wrong with the link
    const lastError = gl.getProgramInfoLog(program);
    progOptions.errorCallback(`${
      realShaders.map(shader => {
        const src = addLineNumbersWithError(gl.getShaderSource(shader), '', 0);
        const type = gl.getShaderParameter(shader, gl.SHADER_TYPE);
        return `${glEnumToString(gl, type)}\n${src}}`;
      }).join('\n')
    }\nError in program linking: ${lastError}`);

    gl.deleteProgram(program);
    deleteShaders(gl, newShaders);
    return null;
  }
  return program;
}

/**
 * Loads a shader from a script tag.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} scriptId The id of the script tag.
 * @param {number} [opt_shaderType] The type of shader. If not passed in it will
 *     be derived from the type of the script tag.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.
 * @return {WebGLShader?} The created shader or null if error.
 * @private
 */
function createShaderFromScript(
    gl, scriptId, opt_shaderType, opt_errorCallback) {
  let shaderSource = "";
  const shaderScript = getElementById(scriptId);
  if (!shaderScript) {
    throw new Error(`unknown script element: ${scriptId}`);
  }
  shaderSource = shaderScript.text;

  const shaderType = opt_shaderType || getShaderTypeFromScriptType(gl, shaderScript.type);
  if (!shaderType) {
    throw new Error('unknown shader type');
  }

  return loadShader(gl, shaderSource, shaderType, opt_errorCallback);
}

/**
 * Creates a program from 2 script tags.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderScriptIds Array of ids of the script
 *        tags for the shaders. The first is assumed to be the
 *        vertex shader, the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */
function createProgramFromScripts(
    gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const shaders = [];
  for (let ii = 0; ii < shaderScriptIds.length; ++ii) {
    const shader = createShaderFromScript(
        gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);
    if (!shader) {
      return null;
    }
    shaders.push(shader);
  }
  return createProgram(gl, shaders, progOptions);
}

/**
 * Creates a program from 2 sources.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error.
 * @memberOf module:twgl/programs
 */
function createProgramFromSources(
    gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const shaders = [];
  for (let ii = 0; ii < shaderSources.length; ++ii) {
    const shader = loadShader(
        gl, shaderSources[ii], gl[defaultShaderType[ii]], progOptions.errorCallback);
    if (!shader) {
      return null;
    }
    shaders.push(shader);
  }
  return createProgram(gl, shaders, progOptions);
}

/**
 * Returns true if attribute/uniform is a reserved/built in
 *
 * It makes no sense to me why GL returns these because it's
 * illegal to call `gl.getUniformLocation` and `gl.getAttribLocation`
 * with names that start with `gl_` (and `webgl_` in WebGL)
 *
 * I can only assume they are there because they might count
 * when computing the number of uniforms/attributes used when you want to
 * know if you are near the limit. That doesn't really make sense
 * to me but the fact that these get returned are in the spec.
 *
 * @param {WebGLActiveInfo} info As returned from `gl.getActiveUniform` or
 *    `gl.getActiveAttrib`.
 * @return {bool} true if it's reserved
 * @private
 */
function isBuiltIn(info) {
  const name = info.name;
  return name.startsWith("gl_") || name.startsWith("webgl_");
}

const tokenRE = /(\.|\[|]|\w+)/g;
const isDigit = s => s >= '0' && s <= '9';
function addSetterToUniformTree(fullPath, setter, node, uniformSetters) {
  const tokens = fullPath.split(tokenRE).filter(s => s !== '');
  let tokenNdx = 0;
  let path = '';

  for (;;) {
    const token = tokens[tokenNdx++];  // has to be name or number
    path += token;
    const isArrayIndex = isDigit(token[0]);
    const accessor = isArrayIndex
        ? parseInt(token)
        : token;
    if (isArrayIndex) {
      path += tokens[tokenNdx++];  // skip ']'
    }
    const isLastToken = tokenNdx === tokens.length;
    if (isLastToken) {
      node[accessor] = setter;
      break;
    } else {
      const token = tokens[tokenNdx++];  // has to be . or [
      const isArray = token === '[';
      const child = node[accessor] || (isArray ? [] : {});
      node[accessor] = child;
      node = child;
      uniformSetters[path] = uniformSetters[path] || function(node) {
        return function(value) {
          setUniformTree(node, value);
        };
      }(child);
      path += token;
    }
  }
}

/**
 * Creates setter functions for all uniforms of a shader
 * program.
 *
 * @see {@link module:twgl.setUniforms}
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @returns {Object.<string, function>} an object with a setter by name for each uniform
 * @memberOf module:twgl/programs
 */
function createUniformSetters(gl, program) {
  let textureUnit = 0;

  /**
   * Creates a setter for a uniform of the given program with it's
   * location embedded in the setter.
   * @param {WebGLProgram} program
   * @param {WebGLUniformInfo} uniformInfo
   * @returns {function} the created setter.
   */
  function createUniformSetter(program, uniformInfo, location) {
    const isArray = uniformInfo.name.endsWith("[0]");
    const type = uniformInfo.type;
    const typeInfo = typeMap[type];
    if (!typeInfo) {
      throw new Error(`unknown type: 0x${type.toString(16)}`); // we should never get here.
    }
    let setter;
    if (typeInfo.bindPoint) {
      // it's a sampler
      const unit = textureUnit;
      textureUnit += uniformInfo.size;
      if (isArray) {
        setter = typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);
      } else {
        setter = typeInfo.setter(gl, type, unit, location, uniformInfo.size);
      }
    } else {
      if (typeInfo.arraySetter && isArray) {
        setter = typeInfo.arraySetter(gl, location);
      } else {
        setter = typeInfo.setter(gl, location);
      }
    }
    setter.location = location;
    return setter;
  }

  const uniformSetters = {};
  const uniformTree = {};
  const numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);

  for (let ii = 0; ii < numUniforms; ++ii) {
    const uniformInfo = gl.getActiveUniform(program, ii);
    if (isBuiltIn(uniformInfo)) {
      continue;
    }
    let name = uniformInfo.name;
    // remove the array suffix.
    if (name.endsWith("[0]")) {
      name = name.substr(0, name.length - 3);
    }
    const location = gl.getUniformLocation(program, uniformInfo.name);
    // the uniform will have no location if it's in a uniform block
    if (location) {
      const setter = createUniformSetter(program, uniformInfo, location);
      uniformSetters[name] = setter;
      addSetterToUniformTree(name, setter, uniformTree, uniformSetters);
    }
  }

  return uniformSetters;
}

/**
 * @typedef {Object} TransformFeedbackInfo
 * @property {number} index index of transform feedback
 * @property {number} type GL type
 * @property {number} size 1 - 4
 * @memberOf module:twgl
 */

/**
 * Create TransformFeedbackInfo for passing to bindTransformFeedbackInfo.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {Object<string, module:twgl.TransformFeedbackInfo>}
 * @memberOf module:twgl
 */
function createTransformFeedbackInfo(gl, program) {
  const info = {};
  const numVaryings = gl.getProgramParameter(program, TRANSFORM_FEEDBACK_VARYINGS);
  for (let ii = 0; ii < numVaryings; ++ii) {
    const varying = gl.getTransformFeedbackVarying(program, ii);
    info[varying.name] = {
      index: ii,
      type: varying.type,
      size: varying.size,
    };
  }
  return info;
}

/**
 * Binds buffers for transform feedback.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @memberOf module:twgl
 */
function bindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {
  if (transformFeedbackInfo.transformFeedbackInfo) {
    transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;
  }
  if (bufferInfo.attribs) {
    bufferInfo = bufferInfo.attribs;
  }
  for (const name in bufferInfo) {
    const varying = transformFeedbackInfo[name];
    if (varying) {
      const buf = bufferInfo[name];
      if (buf.offset) {
        gl.bindBufferRange(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer, buf.offset, buf.size);
      } else {
        gl.bindBufferBase(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer);
      }
    }
  }
}

/**
 * Creates a transform feedback and sets the buffers
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @return {WebGLTransformFeedback} the created transform feedback
 * @memberOf module:twgl
 */
function createTransformFeedback(gl, programInfo, bufferInfo) {
  const tf = gl.createTransformFeedback();
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, tf);
  gl.useProgram(programInfo.program);
  bindTransformFeedbackInfo(gl, programInfo, bufferInfo);
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, null);
  return tf;
}

/**
 * @typedef {Object} UniformData
 * @property {string} name The name of the uniform
 * @property {number} type The WebGL type enum for this uniform
 * @property {number} size The number of elements for this uniform
 * @property {number} blockNdx The block index this uniform appears in
 * @property {number} offset The byte offset in the block for this uniform's value
 * @memberOf module:twgl
 */

/**
 * The specification for one UniformBlockObject
 *
 * @typedef {Object} BlockSpec
 * @property {number} index The index of the block.
 * @property {number} size The size in bytes needed for the block
 * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices
 *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.
 * @property {bool} usedByVertexShader Self explanatory
 * @property {bool} usedByFragmentShader Self explanatory
 * @property {bool} used Self explanatory
 * @memberOf module:twgl
 */

/**
 * A `UniformBlockSpec` represents the data needed to create and bind
 * UniformBlockObjects for a given program
 *
 * @typedef {Object} UniformBlockSpec
 * @property {Object.<string, module:twgl.BlockSpec>} blockSpecs The BlockSpec for each block by block name
 * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.
 * @memberOf module:twgl
 */

/**
 * Creates a UniformBlockSpec for the given program.
 *
 * A UniformBlockSpec represents the data needed to create and bind
 * UniformBlockObjects
 *
 * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context
 * @param {WebGLProgram} program A WebGLProgram for a successfully linked program
 * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec
 * @memberOf module:twgl/programs
 */
function createUniformBlockSpecFromProgram(gl, program) {
  const numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);
  const uniformData = [];
  const uniformIndices = [];

  for (let ii = 0; ii < numUniforms; ++ii) {
    uniformIndices.push(ii);
    uniformData.push({});
    const uniformInfo = gl.getActiveUniform(program, ii);
    uniformData[ii].name = uniformInfo.name;
  }

  [
    [ "UNIFORM_TYPE", "type" ],
    [ "UNIFORM_SIZE", "size" ],  // num elements
    [ "UNIFORM_BLOCK_INDEX", "blockNdx" ],
    [ "UNIFORM_OFFSET", "offset", ],
  ].forEach(function(pair) {
    const pname = pair[0];
    const key = pair[1];
    gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function(value, ndx) {
      uniformData[ndx][key] = value;
    });
  });

  const blockSpecs = {};

  const numUniformBlocks = gl.getProgramParameter(program, ACTIVE_UNIFORM_BLOCKS);
  for (let ii = 0; ii < numUniformBlocks; ++ii) {
    const name = gl.getActiveUniformBlockName(program, ii);
    const blockSpec = {
      index: gl.getUniformBlockIndex(program, name),
      usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
      usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
      size: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_DATA_SIZE),
      uniformIndices: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),
    };
    blockSpec.used = blockSpec.usedByVertexShader || blockSpec.usedByFragmentShader;
    blockSpecs[name] = blockSpec;
  }

  return {
    blockSpecs: blockSpecs,
    uniformData: uniformData,
  };
}

const arraySuffixRE = /\[\d+\]\.$/;  // better way to check?

const pad = (v, padding) => ((v + (padding - 1)) / padding | 0) * padding;

function createUniformBlockUniformSetter(view, isArray, rows, cols) {
  if (isArray || rows) {
    cols = cols || 1;
    const numElements = view.length;
    const totalRows = numElements / 4;
    return function(value) {
      let dst = 0;
      let src = 0;
      for (let row = 0; row < totalRows; ++row) {
        for (let col = 0; col < cols; ++col) {
          view[dst++] = value[src++];
        }
        dst += 4 - cols;
      }
    };
  } else {
    return function(value) {
      if (value.length) {
        view.set(value);
      } else {
        view[0] = value;
      }
    };
  }
}

/**
 * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values
 * and a corresponding WebGLBuffer to hold those values on the GPU
 *
 * @typedef {Object} UniformBlockInfo
 * @property {string} name The name of the block
 * @property {ArrayBuffer} array The array buffer that contains the uniform values
 * @property {Float32Array} asFloat A float view on the array buffer. This is useful
 *    inspecting the contents of the buffer in the debugger.
 * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.
 * @property {number} [offset] offset into buffer
 * @property {Object<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.
 *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset
 *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`
 *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an
 *   `Int32Array` view, etc.
 * @property {Object<string, function>} setters A setter for this uniform.
 *   The reason to use setters is elements of arrays are padded to vec4 sizes which
 *   means if you want to set an array of 4 floats you'd need to set 16 values
 *   (or set elements 0, 4, 8, 12). In other words
 *   `someBlockInfo.uniforms.some4FloatArrayUniform.set([0, , , , 1, , , , 2, , , , 3])`
 *   where as the setter handles just passing in [0, 1, 2, 3] either directly as in
 *   `someBlockInfo.setter.some4FloatArrayUniform.set([0, 1, 2, 3])` (not recommended)
 *   or via {@link module:twgl.setBlockUniforms}
 * @memberOf module:twgl
 */

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {WebGLProgram} program A WebGLProgram
 * @param {module:twgl.UniformBlockSpec} uniformBlockSpec. A UniformBlockSpec as returned
 *     from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */
function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {
  const blockSpecs = uniformBlockSpec.blockSpecs;
  const uniformData = uniformBlockSpec.uniformData;
  const blockSpec = blockSpecs[blockName];
  if (!blockSpec) {
    warn$1("no uniform block object named:", blockName);
    return {
      name: blockName,
      uniforms: {},
    };
  }
  const array = new ArrayBuffer(blockSpec.size);
  const buffer = gl.createBuffer();
  const uniformBufferIndex = blockSpec.index;
  gl.bindBuffer(UNIFORM_BUFFER, buffer);
  gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);

  let prefix = blockName + ".";
  if (arraySuffixRE.test(prefix)) {
    prefix = prefix.replace(arraySuffixRE, ".");
  }
  const uniforms = {};
  const setters = {};
  const setterTree = {};
  blockSpec.uniformIndices.forEach(function(uniformNdx) {
    const data = uniformData[uniformNdx];
    let name = data.name;
    if (name.startsWith(prefix)) {
      name = name.substr(prefix.length);
    }
    const isArray = name.endsWith('[0]');
    if (isArray) {
      name = name.substr(0, name.length - 3);
    }
    const typeInfo = typeMap[data.type];
    const Type = typeInfo.Type;
    const byteLength = isArray
        ? pad(typeInfo.size, 16) * data.size
        : typeInfo.size * data.size;
    const uniformView = new Type(array, data.offset, byteLength / Type.BYTES_PER_ELEMENT);
    uniforms[name] = uniformView;
    // Note: I'm not sure what to do here. The original
    // idea was to create TypedArray views into each part
    // of the block. This is useful, for example if you have
    // a block with { mat4: model; mat4 view; mat4 projection; }
    // you'll get a Float32Array for each one suitable for
    // passing to most JS math libraries including twgl's and glMatrix.js.
    //
    // But, if you have a an array of structures, especially if that
    // array is large, you get a whole bunch of TypedArray views.
    // Every one of them has overhead and switching between them all
    // is probably a cache miss. In that case it would really be better
    // to just have one view (asFloat) and have all the setters
    // just reference the correct portion. But, then you can't easily
    // treat a matrix, or a vec4, as a standalone thing like you can
    // with all the views.
    //
    // Another problem with the views is they are not shared. With
    // uniforms you have one set of setters. With UniformBlockInfo
    // you have a set of setters *pre block instance*. That's because
    // TypedArray views can't be mapped to different buffers.
    //
    // My gut right now is if you really want the speed and compactness
    // then you should probably roll your own solution. TWGL's goal
    // here is ease of use as AFAICT there is no simple generic efficient
    // solution.
    const setter = createUniformBlockUniformSetter(uniformView, isArray, typeInfo.rows, typeInfo.cols);
    setters[name] = setter;
    addSetterToUniformTree(name, setter, setterTree, setters);
  });
  return {
    name: blockName,
    array,
    asFloat: new Float32Array(array),  // for debugging
    buffer,
    uniforms,
    setters,
  };
}

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo}
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */
function createUniformBlockInfo(gl, programInfo, blockName) {
  return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);
}

/**
 * Binds a uniform block to the matching uniform block point.
 * Matches by blocks by name so blocks must have the same name not just the same
 * structure.
 *
 * If you have changed any values and you upload the values into the corresponding WebGLBuffer
 * call {@link module:twgl.setUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name
 *     no buffer is bound.
 * @memberOf module:twgl/programs
 */
function bindUniformBlock(gl, programInfo, uniformBlockInfo) {
  const uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;
  const blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];
  if (blockSpec) {
    const bufferBindIndex = blockSpec.index;
    gl.bindBufferRange(UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);
    return true;
  }
  return false;
}

/**
 * Uploads the current uniform values to the corresponding WebGLBuffer
 * and binds that buffer to the program's corresponding bind point for the uniform block object.
 *
 * If you haven't changed any values and you only need to bind the uniform block object
 * call {@link module:twgl.bindUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @memberOf module:twgl/programs
 */
function setUniformBlock(gl, programInfo, uniformBlockInfo) {
  if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {
    gl.bufferData(UNIFORM_BUFFER, uniformBlockInfo.array, DYNAMIC_DRAW);
  }
}

/**
 * Sets values of a uniform block object
 *
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.
 * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given
 *    type of uniform. So for example given a block like
 *
 *       uniform SomeBlock {
 *         float someFloat;
 *         vec2 someVec2;
 *         vec3 someVec3Array[2];
 *         int someInt;
 *       }
 *
 *  You can set the values of the uniform block with
 *
 *       twgl.setBlockUniforms(someBlockInfo, {
 *          someFloat: 12.3,
 *          someVec2: [1, 2],
 *          someVec3Array: [1, 2, 3, 4, 5, 6],
 *          someInt: 5,
 *       }
 *
 *  Arrays can be JavaScript arrays or typed arrays
 *
 *  You can also fill out structure and array values either via
 *  shortcut. Example
 *
 *     // -- in shader --
 *     struct Light {
 *       float intensity;
 *       vec4 color;
 *     };
 *     uniform Lights {
 *       Light lights[2];
 *     };
 *
 *     // in JavaScript
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       lights: [
 *         { intensity: 5.0, color: [1, 0, 0, 1] },
 *         { intensity: 2.0, color: [0, 0, 1, 1] },
 *       ],
 *     });
 *
 *     // or the more traditional way
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       "lights[0].intensity": 5.0,
 *       "lights[0].color": [1, 0, 0, 1],
 *       "lights[1].intensity": 2.0,
 *       "lights[1].color": [0, 0, 1, 1],
 *     });
 *
 *   You can also specify partial paths
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       'lights[1]: { intensity: 5.0, color: [1, 0, 0, 1] },
 *     });
 *
 *   But you can not specify leaf array indices.
 *
 *  **IMPORTANT!**, packing in a UniformBlock is unintuitive.
 *  For example the actual layout of `someVec3Array` above in memory
 *  is `1, 2, 3, unused, 4, 5, 6, unused`. twgl takes in 6 values
 *  as shown about and copies them, skipping the padding. This might
 *  be confusing if you're already familiar with Uniform blocks.
 *
 *  If you want to deal with the padding yourself you can access the array
 *  buffer views directly. eg:
 *
 *      someBlockInfo.someVec3Array.set([1, 2, 3, 0, 4, 5, 6, 0]);
 *
 *  Any name that doesn't match will be ignored
 * @memberOf module:twgl/programs
 */
function setBlockUniforms(uniformBlockInfo, values) {
  const setters = uniformBlockInfo.setters;
  for (const name in values) {
    const setter = setters[name];
    if (setter) {
      const value = values[name];
      setter(value);
    }
  }
}

function setUniformTree(tree, values) {
  for (const name in values) {
    const prop = tree[name];
    if (typeof prop === 'function') {
      prop(values[name]);
    } else {
      setUniformTree(tree[name], values[name]);
    }
  }
}

/**
 * Set uniforms and binds related textures.
 *
 * example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs"]);
 *
 *     const tex1 = gl.createTexture();
 *     const tex2 = gl.createTexture();
 *
 *     ... assume we setup the textures with data ...
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the textures AND set the
 * uniforms.
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *
 * For the example above it is equivalent to
 *
 *     var texUnit = 0;
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex1);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex2);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
 *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
 *     gl.uniformMatrix4fv(u_someMatrix, false, [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ]);
 *
 * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *     };
 *
 *     const moreUniforms {
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *     twgl.setUniforms(programInfo, moreUniforms);
 *
 * You can also add WebGLSamplers to uniform samplers as in
 *
 *     const uniforms = {
 *       u_someSampler: {
 *         texture: someWebGLTexture,
 *         sampler: someWebGLSampler,
 *       },
 *     };
 *
 * In which case both the sampler and texture will be bound to the
 * same unit.
 *
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 *        uniforms.
 *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example
 *
 *     const sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     const localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, sharedUniforms);
 *     twgl.setUniforms(programInfo, localUniforms};
 *
 *   You can also fill out structure and array values either via
 *   shortcut. Example
 *
 *     // -- in shader --
 *     struct Light {
 *       float intensity;
 *       vec4 color;
 *     };
 *     uniform Light lights[2];
 *
 *     // in JavaScript
 *
 *     twgl.setUniforms(programInfo, {
 *       lights: [
 *         { intensity: 5.0, color: [1, 0, 0, 1] },
 *         { intensity: 2.0, color: [0, 0, 1, 1] },
 *       ],
 *     });
 *
 *   or the more traditional way
 *
 *     twgl.setUniforms(programInfo, {
 *       "lights[0].intensity": 5.0,
 *       "lights[0].color": [1, 0, 0, 1],
 *       "lights[1].intensity": 2.0,
 *       "lights[1].color": [0, 0, 1, 1],
 *     });
 *
 *   You can also specify partial paths
 *
 *     twgl.setUniforms(programInfo, {
 *       'lights[1]: { intensity: 5.0, color: [1, 0, 0, 1] },
 *     });
 *
 *   But you can not specify leaf array indices
 *
 * @memberOf module:twgl/programs
 */
function setUniforms(setters, ...args) {  // eslint-disable-line
  const actualSetters = setters.uniformSetters || setters;
  const numArgs = args.length;
  for (let aNdx = 0; aNdx < numArgs; ++aNdx) {
    const values = args[aNdx];
    if (Array.isArray(values)) {
      const numValues = values.length;
      for (let ii = 0; ii < numValues; ++ii) {
        setUniforms(actualSetters, values[ii]);
      }
    } else {
      for (const name in values) {
        const setter = actualSetters[name];
        if (setter) {
          setter(values[name]);
        }
      }
    }
  }
}

/**
 * Alias for `setUniforms`
 * @function
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 * @memberOf module:twgl/programs
 */
const setUniformsAndBindTextures = setUniforms;

/**
 * Creates setter functions for all attributes of a shader
 * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.
 *
 * @see {@link module:twgl.setAttributes} for example
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @return {Object.<string, function>} an object with a setter for each attribute by name.
 * @memberOf module:twgl/programs
 */
function createAttributeSetters(gl, program) {
  const attribSetters = {
  };

  const numAttribs = gl.getProgramParameter(program, ACTIVE_ATTRIBUTES);
  for (let ii = 0; ii < numAttribs; ++ii) {
    const attribInfo = gl.getActiveAttrib(program, ii);
    if (isBuiltIn(attribInfo)) {
      continue;
    }
    const index = gl.getAttribLocation(program, attribInfo.name);
    const typeInfo = attrTypeMap[attribInfo.type];
    const setter = typeInfo.setter(gl, index, typeInfo);
    setter.location = index;
    attribSetters[attribInfo.name] = setter;
  }

  return attribSetters;
}

/**
 * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})
 *
 * Example:
 *
 *     const program = createProgramFromScripts(
 *         gl, ["some-vs", "some-fs");
 *
 *     const attribSetters = createAttributeSetters(program);
 *
 *     const positionBuffer = gl.createBuffer();
 *     const texcoordBuffer = gl.createBuffer();
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setAttributes(attribSetters, attribs);
 *
 * Properties of attribs. For each attrib you can add
 * properties:
 *
 * *   type: the type of data in the buffer. Default = gl.FLOAT
 * *   normalize: whether or not to normalize the data. Default = false
 * *   stride: the stride. Default = 0
 * *   offset: offset into the buffer. Default = 0
 * *   divisor: the divisor for instances. Default = undefined
 *
 * For example if you had 3 value float positions, 2 value
 * float texcoord and 4 value uint8 colors you'd setup your
 * attribs like this
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *       a_color: {
 *         buffer: colorBuffer,
 *         numComponents: 4,
 *         type: gl.UNSIGNED_BYTE,
 *         normalize: true,
 *       },
 *     };
 *
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.
 * @memberOf module:twgl/programs
 * @deprecated use {@link module:twgl.setBuffersAndAttributes}
 */
function setAttributes(setters, buffers) {
  for (const name in buffers) {
    const setter = setters[name];
    if (setter) {
      setter(buffers[name]);
    }
  }
}

/**
 * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate
 *
 * Example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs");
 *
 *     const arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *     };
 *
 *     const bufferInfo = createBufferInfoFromArrays(gl, arrays);
 *
 *     gl.useProgram(programInfo.program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setBuffersAndAttributes(gl, programInfo, bufferInfo);
 *
 * For the example above it is equivalent to
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
 *     gl.enableVertexAttribArray(a_positionLocation);
 *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
 *     gl.enableVertexAttribArray(a_texcoordLocation);
 *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgramInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.
 *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}
 * @memberOf module:twgl/programs
 */
function setBuffersAndAttributes(gl, programInfo, buffers) {
  if (buffers.vertexArrayObject) {
    gl.bindVertexArray(buffers.vertexArrayObject);
  } else {
    setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);
    if (buffers.indices) {
      gl.bindBuffer(ELEMENT_ARRAY_BUFFER$1, buffers.indices);
    }
  }
}

/**
 * @typedef {Object} ProgramInfo
 * @property {WebGLProgram} program A shader program
 * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,
 * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,
 * @property {module:twgl.UniformBlockSpec} [uniformBlockSpec] a uniform block spec for making UniformBlockInfos with createUniformBlockInfo etc..
 * @property {Object<string, module:twgl.TransformFeedbackInfo>} [transformFeedbackInfo] info for transform feedbacks
 * @memberOf module:twgl
 */

/**
 * Creates a ProgramInfo from an existing program.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {module:twgl.ProgramInfo} The created ProgramInfo.
 * @memberOf module:twgl/programs
 */
function createProgramInfoFromProgram(gl, program) {
  const uniformSetters = createUniformSetters(gl, program);
  const attribSetters = createAttributeSetters(gl, program);
  const programInfo = {
    program,
    uniformSetters,
    attribSetters,
  };

  if (isWebGL2(gl)) {
    programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);
    programInfo.transformFeedbackInfo = createTransformFeedbackInfo(gl, program);
  }

  return programInfo;
}

/**
 * Creates a ProgramInfo from 2 sources.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramInfo(gl, [vs, fs], options);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders or ids. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile
 * @memberOf module:twgl/programs
 */
function createProgramInfo(
    gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  let good = true;
  shaderSources = shaderSources.map(function(source) {
    // Lets assume if there is no \n it's an id
    if (source.indexOf("\n") < 0) {
      const script = getElementById(source);
      if (!script) {
        progOptions.errorCallback("no element with id: " + source);
        good = false;
      } else {
        source = script.text;
      }
    }
    return source;
  });
  if (!good) {
    return null;
  }
  const program = createProgramFromSources(gl, shaderSources, progOptions);
  if (!program) {
    return null;
  }
  return createProgramInfoFromProgram(gl, program);
}

var programs = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createAttributeSetters: createAttributeSetters,
  createProgram: createProgram,
  createProgramFromScripts: createProgramFromScripts,
  createProgramFromSources: createProgramFromSources,
  createProgramInfo: createProgramInfo,
  createProgramInfoFromProgram: createProgramInfoFromProgram,
  createUniformSetters: createUniformSetters,
  createUniformBlockSpecFromProgram: createUniformBlockSpecFromProgram,
  createUniformBlockInfoFromProgram: createUniformBlockInfoFromProgram,
  createUniformBlockInfo: createUniformBlockInfo,
  createTransformFeedback: createTransformFeedback,
  createTransformFeedbackInfo: createTransformFeedbackInfo,
  bindTransformFeedbackInfo: bindTransformFeedbackInfo,
  setAttributes: setAttributes,
  setBuffersAndAttributes: setBuffersAndAttributes,
  setUniforms: setUniforms,
  setUniformsAndBindTextures: setUniformsAndBindTextures,
  setUniformBlock: setUniformBlock,
  setBlockUniforms: setBlockUniforms,
  bindUniformBlock: bindUniformBlock
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const TRIANGLES                      = 0x0004;
const UNSIGNED_SHORT$3                 = 0x1403;

/**
 * Drawing related functions
 *
 * For backward compatibility they are available at both `twgl.draw` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/draw
 */

/**
 * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate
 *
 * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself
 * but calling this means if you switch from indexed data to non-indexed
 * data you don't have to remember to update your draw call.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or
 *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @param {number} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`
 * @param {number} [count] An optional count. Defaults to bufferInfo.numElements
 * @param {number} [offset] An optional offset. Defaults to 0.
 * @param {number} [instanceCount] An optional instanceCount. if set then `drawArraysInstanced` or `drawElementsInstanced` will be called
 * @memberOf module:twgl/draw
 */
function drawBufferInfo(gl, bufferInfo, type, count, offset, instanceCount) {
  type = type === undefined ? TRIANGLES : type;
  const indices = bufferInfo.indices;
  const elementType = bufferInfo.elementType;
  const numElements = count === undefined ? bufferInfo.numElements : count;
  offset = offset === undefined ? 0 : offset;
  if (elementType || indices) {
    if (instanceCount !== undefined) {
      gl.drawElementsInstanced(type, numElements, elementType === undefined ? UNSIGNED_SHORT$3 : bufferInfo.elementType, offset, instanceCount);
    } else {
      gl.drawElements(type, numElements, elementType === undefined ? UNSIGNED_SHORT$3 : bufferInfo.elementType, offset);
    }
  } else {
    if (instanceCount !== undefined) {
      gl.drawArraysInstanced(type, offset, numElements, instanceCount);
    } else {
      gl.drawArrays(type, offset, numElements);
    }
  }
}

/**
 * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.
 *
 * You need either a `BufferInfo` or a `VertexArrayInfo`.
 *
 * @typedef {Object} DrawObject
 * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In other words `undefined` = `true`
 * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...
 * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}
 * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @property {Object<string, ?>} uniforms The values for the uniforms.
 *   You can pass multiple objects by putting them in an array. For example
 *
 *     var sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     var localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     var drawObj = {
 *       ...
 *       uniforms: [sharedUniforms, localUniforms],
 *     };
 *
 * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.
 * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to bufferInfo.numElements.
 * @property {number} [instanceCount] the number of instances. Defaults to undefined.
 * @memberOf module:twgl
 */

/**
 * Draws a list of objects
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {DrawObject[]} objectsToDraw an array of objects to draw.
 * @memberOf module:twgl/draw
 */
function drawObjectList(gl, objectsToDraw) {
  let lastUsedProgramInfo = null;
  let lastUsedBufferInfo = null;

  objectsToDraw.forEach(function(object) {
    if (object.active === false) {
      return;
    }

    const programInfo = object.programInfo;
    const bufferInfo = object.vertexArrayInfo || object.bufferInfo;
    let bindBuffers = false;
    const type = object.type === undefined ? TRIANGLES : object.type;

    if (programInfo !== lastUsedProgramInfo) {
      lastUsedProgramInfo = programInfo;
      gl.useProgram(programInfo.program);

      // We have to rebind buffers when changing programs because we
      // only bind buffers the program uses. So if 2 programs use the same
      // bufferInfo but the 1st one uses only positions the when the
      // we switch to the 2nd one some of the attributes will not be on.
      bindBuffers = true;
    }

    // Setup all the needed attributes.
    if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
      if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {
        gl.bindVertexArray(null);
      }
      lastUsedBufferInfo = bufferInfo;
      setBuffersAndAttributes(gl, programInfo, bufferInfo);
    }

    // Set the uniforms.
    setUniforms(programInfo, object.uniforms);

    // Draw
    drawBufferInfo(gl, bufferInfo, type, object.count, object.offset, object.instanceCount);
  });

  if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject) {
    gl.bindVertexArray(null);
  }
}

var draw = /*#__PURE__*/Object.freeze({
  __proto__: null,
  drawBufferInfo: drawBufferInfo,
  drawObjectList: drawObjectList
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const FRAMEBUFFER                    = 0x8d40;
const RENDERBUFFER                   = 0x8d41;
const TEXTURE_2D$2                     = 0x0de1;

const UNSIGNED_BYTE$3                  = 0x1401;

/* PixelFormat */
const DEPTH_COMPONENT$1                = 0x1902;
const RGBA$1                           = 0x1908;
const DEPTH_COMPONENT24$1              = 0x81a6;
const DEPTH_COMPONENT32F$1             = 0x8cac;
const DEPTH24_STENCIL8$1               = 0x88f0;
const DEPTH32F_STENCIL8$1              = 0x8cad;

/* Framebuffer Object. */
const RGBA4$1                          = 0x8056;
const RGB5_A1$1                        = 0x8057;
const RGB565$1                         = 0x8D62;
const DEPTH_COMPONENT16$1              = 0x81A5;
const STENCIL_INDEX                  = 0x1901;
const STENCIL_INDEX8                 = 0x8D48;
const DEPTH_STENCIL$1                  = 0x84F9;
const COLOR_ATTACHMENT0              = 0x8CE0;
const DEPTH_ATTACHMENT               = 0x8D00;
const STENCIL_ATTACHMENT             = 0x8D20;
const DEPTH_STENCIL_ATTACHMENT       = 0x821A;

/* TextureWrapMode */
const CLAMP_TO_EDGE$1                  = 0x812F;

/* TextureMagFilter */
const LINEAR$1                         = 0x2601;

/**
 * The options for a framebuffer attachment.
 *
 * Note: For a `format` that is a texture include all the texture
 * options from {@link module:twgl.TextureOptions} for example
 * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}
 * `auto` defaults to `false` for attachment textures but `min` and `mag` default
 * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`
 *
 * @typedef {Object} AttachmentOptions
 * @property {number} [attachmentPoint] The attachment point. Defaults
 *   to `gl.COLOR_ATTACHMENT0 + ndx` unless type is a depth or stencil type
 *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending
 *   on the format or attachment type.
 * @property {number} [format] The format. If one of `gl.RGBA4`,
 *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,
 *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a
 *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`
 * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.
 * @property {number} [target] The texture target for `gl.framebufferTexture2D`.
 *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.
 * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.
 * @property {number} [layer] layer for `gl.framebufferTextureLayer`. Defaults to undefined.
 *   If set then `gl.framebufferTextureLayer` is called, if not then `gl.framebufferTexture2D`
 * @property {(WebGLRenderbuffer | WebGLTexture)} [attachment] An existing renderbuffer or texture.
 *    If provided will attach this Object. This allows you to share
 *    attachments across framebuffers.
 * @memberOf module:twgl
 * @mixes module:twgl.TextureOptions
 */

const defaultAttachments = [
  { format: RGBA$1, type: UNSIGNED_BYTE$3, min: LINEAR$1, wrap: CLAMP_TO_EDGE$1, },
  { format: DEPTH_STENCIL$1, },
];

const attachmentsByFormat = {};
attachmentsByFormat[DEPTH_STENCIL$1] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT$1] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT16$1] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT24$1] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT32F$1] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH24_STENCIL8$1] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH32F_STENCIL8$1] = DEPTH_STENCIL_ATTACHMENT;

function getAttachmentPointForFormat(format, internalFormat) {
  return attachmentsByFormat[format] || attachmentsByFormat[internalFormat];
}

const renderbufferFormats = {};
renderbufferFormats[RGBA4$1] = true;
renderbufferFormats[RGB5_A1$1] = true;
renderbufferFormats[RGB565$1] = true;
renderbufferFormats[DEPTH_STENCIL$1] = true;
renderbufferFormats[DEPTH_COMPONENT16$1] = true;
renderbufferFormats[STENCIL_INDEX] = true;
renderbufferFormats[STENCIL_INDEX8] = true;

function isRenderbufferFormat(format) {
  return renderbufferFormats[format];
}

/**
 * @typedef {Object} FramebufferInfo
 * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo
 * @property {Array.<(WebGLRenderbuffer | WebGLTexture)>} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.
 * @property {number} width The width of the framebuffer and its attachments
 * @property {number} height The width of the framebuffer and its attachments
 * @memberOf module:twgl
 */

/**
 * Creates a framebuffer and attachments.
 *
 * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 * Passing in a specific size
 *
 *     const width = 256;
 *     const height = 256;
 *     const fbi = twgl.createFramebufferInfo(gl, attachments, width, height);
 *
 * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.
 * [WebGL1 only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an
 *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.
 * @memberOf module:twgl/framebuffers
 */
function createFramebufferInfo(gl, attachments, width, height) {
  const target = FRAMEBUFFER;
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(target, fb);
  width  = width  || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  attachments = attachments || defaultAttachments;
  let colorAttachmentCount = 0;
  const framebufferInfo = {
    framebuffer: fb,
    attachments: [],
    width: width,
    height: height,
  };
  attachments.forEach(function(attachmentOptions) {
    let attachment = attachmentOptions.attachment;
    const format = attachmentOptions.format;
    let attachmentPoint = attachmentOptions.attachmentPoint || getAttachmentPointForFormat(format, attachmentOptions.internalFormat);
    if (!attachmentPoint) {
      attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;
    }
    if (!attachment) {
      if (isRenderbufferFormat(format)) {
        attachment = gl.createRenderbuffer();
        gl.bindRenderbuffer(RENDERBUFFER, attachment);
        gl.renderbufferStorage(RENDERBUFFER, format, width, height);
      } else {
        const textureOptions = Object.assign({}, attachmentOptions);
        textureOptions.width = width;
        textureOptions.height = height;
        if (textureOptions.auto === undefined) {
          textureOptions.auto = false;
          textureOptions.min = textureOptions.min || textureOptions.minMag || LINEAR$1;
          textureOptions.mag = textureOptions.mag || textureOptions.minMag || LINEAR$1;
          textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || CLAMP_TO_EDGE$1;
          textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || CLAMP_TO_EDGE$1;
        }
        attachment = createTexture(gl, textureOptions);
      }
    }
    if (isRenderbuffer(gl, attachment)) {
      gl.framebufferRenderbuffer(target, attachmentPoint, RENDERBUFFER, attachment);
    } else if (isTexture(gl, attachment)) {
      if (attachmentOptions.layer !== undefined) {
        gl.framebufferTextureLayer(
          target,
          attachmentPoint,
          attachment,
          attachmentOptions.level || 0,
          attachmentOptions.layer);
      } else {
        gl.framebufferTexture2D(
            target,
            attachmentPoint,
            attachmentOptions.target || TEXTURE_2D$2,
            attachment,
            attachmentOptions.level || 0);
      }
    } else {
      throw new Error('unknown attachment type');
    }
    framebufferInfo.attachments.push(attachment);
  });
  return framebufferInfo;
}

/**
 * Resizes the attachments of a framebuffer.
 *
 * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebufferInfo}
 * because TWGL has no idea the format/type of each attachment.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments
 *         twgl.resizeFramebufferInfo(gl, fbi);
 *       }
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments to match
 *         twgl.resizeFramebufferInfo(gl, fbi, attachments);
 *       }
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebufferInfo}.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @memberOf module:twgl/framebuffers
 */
function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {
  width  = width  || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  framebufferInfo.width = width;
  framebufferInfo.height = height;
  attachments = attachments || defaultAttachments;
  attachments.forEach(function(attachmentOptions, ndx) {
    const attachment = framebufferInfo.attachments[ndx];
    const format = attachmentOptions.format;
    if (isRenderbuffer(gl, attachment)) {
      gl.bindRenderbuffer(RENDERBUFFER, attachment);
      gl.renderbufferStorage(RENDERBUFFER, format, width, height);
    } else if (isTexture(gl, attachment)) {
      resizeTexture(gl, attachment, attachmentOptions, width, height);
    } else {
      throw new Error('unknown attachment type');
    }
  });
}

/**
 * Binds a framebuffer
 *
 * This function pretty much solely exists because I spent hours
 * trying to figure out why something I wrote wasn't working only
 * to realize I forget to set the viewport dimensions.
 * My hope is this function will fix that.
 *
 * It is effectively the same as
 *
 *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);
 *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo|null} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 *   If falsy will bind the canvas.
 * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.
 * @memberOf module:twgl/framebuffers
 */

function bindFramebufferInfo(gl, framebufferInfo, target) {
  target = target || FRAMEBUFFER;
  if (framebufferInfo) {
    gl.bindFramebuffer(target, framebufferInfo.framebuffer);
    gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);
  } else {
    gl.bindFramebuffer(target, null);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
}

var framebuffers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bindFramebufferInfo: bindFramebufferInfo,
  createFramebufferInfo: createFramebufferInfo,
  resizeFramebufferInfo: resizeFramebufferInfo
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * vertex array object related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/vertexArrays
 */

const ELEMENT_ARRAY_BUFFER$2           = 0x8893;

/**
 * @typedef {Object} VertexArrayInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLVertexArrayObject} [vertexArrayObject] a vertex array object
 * @memberOf module:twgl
 */

/**
 * Creates a VertexArrayInfo from a BufferInfo and one or more ProgramInfos
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects
 *   assign buffers to specific attributes at creation time. That means they can only be used with programs
 *   who's attributes use the same attribute locations for the same purposes.
 *
 * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}
 *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.
 *
 * also
 *
 * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object
 *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**
 *   will affect the Vertex Array Object state.
 *
 * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 *
 *    You need to make sure every attribute that will be used is bound. So for example assume shader 1
 *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo
 *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't
 *    now attribute D's location.
 *
 *    So, you can pass in both shader 1 and shader 2's programInfo
 *
 * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo
 *
 * @memberOf module:twgl/vertexArrays
 */
function createVertexArrayInfo(gl, programInfos, bufferInfo) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  if (!programInfos.length) {
    programInfos = [programInfos];
  }
  programInfos.forEach(function(programInfo) {
    setBuffersAndAttributes(gl, programInfo, bufferInfo);
  });
  gl.bindVertexArray(null);
  return {
    numElements: bufferInfo.numElements,
    elementType: bufferInfo.elementType,
    vertexArrayObject: vao,
  };
}

/**
 * Creates a vertex array object and then sets the attributes on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} attribs AttribInfos mapped by attribute name.
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 * @memberOf module:twgl/vertexArrays
 */
function createVAOAndSetAttributes(gl, setters, attribs, indices) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  setAttributes(setters, attribs);
  if (indices) {
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER$2, indices);
  }
  // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER
  // like when creating buffers for other stuff will mess up this VAO's binding
  gl.bindVertexArray(null);
  return vao;
}

/**
 * Creates a vertex array object and then sets the attributes
 * on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {Object.<string, function>| module:twgl.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 * @memberOf module:twgl/vertexArrays
 */
function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {
  return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);
}

var vertexArrays = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createVertexArrayInfo: createVertexArrayInfo,
  createVAOAndSetAttributes: createVAOAndSetAttributes,
  createVAOFromBufferInfo: createVAOFromBufferInfo
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
const defaults$2 = {
  addExtensionsToContext: true,
};

/**
 * Various default settings for twgl.
 *
 * Note: You can call this any number of times. Example:
 *
 *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });
 *     twgl.setDefaults({ attribPrefix: 'a_' });
 *
 * is equivalent to
 *
 *     twgl.setDefaults({
 *       textureColor: [1, 0, 0, 1],
 *       attribPrefix: 'a_',
 *     });
 *
 * @typedef {Object} Defaults
 * @property {string} [attribPrefix] The prefix to stick on attributes
 *
 *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 *   as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 *   In other words I'll create arrays of geometry like this
 *
 *       const arrays = {
 *         position: ...
 *         normal: ...
 *         texcoord: ...
 *       };
 *
 *   But need those mapped to attributes and my attributes start with `a_`.
 *
 *   Default: `""`
 *
 * @property {number[]} [textureColor] Array of 4 values in the range 0 to 1
 *
 *   The default texture color is used when loading textures from
 *   urls. Because the URL will be loaded async we'd like to be
 *   able to use the texture immediately. By putting a 1x1 pixel
 *   color in the texture we can start using the texture before
 *   the URL has loaded.
 *
 *   Default: `[0.5, 0.75, 1, 1]`
 *
 * @property {string} [crossOrigin]
 *
 *   If not undefined sets the crossOrigin attribute on images
 *   that twgl creates when downloading images for textures.
 *
 *   Also see {@link module:twgl.TextureOptions}.
 *
 * @property {bool} [addExtensionsToContext]
 *
 *   If true, then, when twgl will try to add any supported WebGL extensions
 *   directly to the context under their normal GL names. For example
 *   if ANGLE_instances_arrays exists then twgl would enable it,
 *   add the functions `vertexAttribDivisor`, `drawArraysInstanced`,
 *   `drawElementsInstanced`, and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR`
 *   to the `WebGLRenderingContext`.
 *
 * @memberOf module:twgl
 */

/**
 * Sets various defaults for twgl.
 *
 * In the interest of terseness which is kind of the point
 * of twgl I've integrated a few of the older functions here
 *
 * @param {module:twgl.Defaults} newDefaults The default settings.
 * @memberOf module:twgl
 */
function setDefaults$2(newDefaults) {
  copyExistingProperties(newDefaults, defaults$2);
  setDefaults(newDefaults);  // eslint-disable-line
  setDefaults$1(newDefaults);  // eslint-disable-line
}

const prefixRE = /^(.*?)_/;
function addExtensionToContext(gl, extensionName) {
  glEnumToString(gl, 0);
  const ext = gl.getExtension(extensionName);
  if (ext) {
    const enums = {};
    const fnSuffix = prefixRE.exec(extensionName)[1];
    const enumSuffix = '_' + fnSuffix;
    for (const key in ext) {
      const value = ext[key];
      const isFunc = typeof (value) === 'function';
      const suffix = isFunc ? fnSuffix : enumSuffix;
      let name = key;
      // examples of where this is not true are WEBGL_compressed_texture_s3tc
      // and WEBGL_compressed_texture_pvrtc
      if (key.endsWith(suffix)) {
        name = key.substring(0, key.length - suffix.length);
      }
      if (gl[name] !== undefined) {
        if (!isFunc && gl[name] !== value) {
          warn(name, gl[name], value, key);
        }
      } else {
        if (isFunc) {
          gl[name] = function(origFn) {
            return function() {
              return origFn.apply(ext, arguments);
            };
          }(value);
        } else {
          gl[name] = value;
          enums[name] = value;
        }
      }
    }
    // pass the modified enums to glEnumToString
    enums.constructor = {
      name: ext.constructor.name,
    };
    glEnumToString(enums, 0);
  }
  return ext;
}

/*
 * If you're wondering why the code doesn't just iterate
 * over all extensions using `gl.getExtensions` is that it's possible
 * some future extension is incompatible with this code. Rather than
 * have thing suddenly break it seems better to manually add to this
 * list.
 *
 */
const supportedExtensions = [
  'ANGLE_instanced_arrays',
  'EXT_blend_minmax',
  'EXT_color_buffer_float',
  'EXT_color_buffer_half_float',
  'EXT_disjoint_timer_query',
  'EXT_disjoint_timer_query_webgl2',
  'EXT_frag_depth',
  'EXT_sRGB',
  'EXT_shader_texture_lod',
  'EXT_texture_filter_anisotropic',
  'OES_element_index_uint',
  'OES_standard_derivatives',
  'OES_texture_float',
  'OES_texture_float_linear',
  'OES_texture_half_float',
  'OES_texture_half_float_linear',
  'OES_vertex_array_object',
  'WEBGL_color_buffer_float',
  'WEBGL_compressed_texture_atc',
  'WEBGL_compressed_texture_etc1',
  'WEBGL_compressed_texture_pvrtc',
  'WEBGL_compressed_texture_s3tc',
  'WEBGL_compressed_texture_s3tc_srgb',
  'WEBGL_depth_texture',
  'WEBGL_draw_buffers',
];

/**
 * Attempts to enable all of the following extensions
 * and add their functions and constants to the
 * `WebGLRenderingContext` using their normal non-extension like names.
 *
 *      ANGLE_instanced_arrays
 *      EXT_blend_minmax
 *      EXT_color_buffer_float
 *      EXT_color_buffer_half_float
 *      EXT_disjoint_timer_query
 *      EXT_disjoint_timer_query_webgl2
 *      EXT_frag_depth
 *      EXT_sRGB
 *      EXT_shader_texture_lod
 *      EXT_texture_filter_anisotropic
 *      OES_element_index_uint
 *      OES_standard_derivatives
 *      OES_texture_float
 *      OES_texture_float_linear
 *      OES_texture_half_float
 *      OES_texture_half_float_linear
 *      OES_vertex_array_object
 *      WEBGL_color_buffer_float
 *      WEBGL_compressed_texture_atc
 *      WEBGL_compressed_texture_etc1
 *      WEBGL_compressed_texture_pvrtc
 *      WEBGL_compressed_texture_s3tc
 *      WEBGL_compressed_texture_s3tc_srgb
 *      WEBGL_depth_texture
 *      WEBGL_draw_buffers
 *
 * For example if `ANGLE_instanced_arrays` exists then the functions
 * `drawArraysInstanced`, `drawElementsInstanced`, `vertexAttribDivisor`
 * and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR` are added to the
 * `WebGLRenderingContext`.
 *
 * Note that if you want to know if the extension exists you should
 * probably call `gl.getExtension` for each extension. Alternatively
 * you can check for the existence of the functions or constants that
 * are expected to be added. For example
 *
 *    if (gl.drawBuffers) {
 *      // Either WEBGL_draw_buffers was enabled OR you're running in WebGL2
 *      ....
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @memberOf module:twgl
 */
function addExtensionsToContext(gl) {
  for (let ii = 0; ii < supportedExtensions.length; ++ii) {
    addExtensionToContext(gl, supportedExtensions[ii]);
  }
}

/**
 * Creates a webgl context.
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 * @private
 */
function create3DContext(canvas, opt_attribs) {
  const names = ["webgl", "experimental-webgl"];
  let context = null;
  for (let ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);
    if (context) {
      if (defaults$2.addExtensionsToContext) {
        addExtensionsToContext(context);
      }
      break;
    }
  }
  return context;
}

/**
 * Gets a WebGL1 context.
 *
 * Note: Will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */
function getWebGLContext(canvas, opt_attribs) {
  const gl = create3DContext(canvas, opt_attribs);
  return gl;
}

/**
 * Creates a webgl context.
 *
 * Will return a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *     twgl.isWebGL2(gl);
 *
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 */
function createContext(canvas, opt_attribs) {
  const names = ["webgl2", "webgl", "experimental-webgl"];
  let context = null;
  for (let ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);
    if (context) {
      if (defaults$2.addExtensionsToContext) {
        addExtensionsToContext(context);
      }
      break;
    }
  }
  return context;
}

/**
 * Gets a WebGL context.  Will create a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *    function isWebGL2(gl) {
 *      return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0 ") == 0;
 *    }
 *
 * Note: For a WebGL1 context will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */
function getContext(canvas, opt_attribs) {
  const gl = createContext(canvas, opt_attribs);
  return gl;
}

/**
 * Resize a canvas to match the size it's displayed.
 * @param {HTMLCanvasElement} canvas The canvas to resize.
 * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` or other scale value if you want to.
 * @return {boolean} true if the canvas was resized.
 * @memberOf module:twgl
 */
function resizeCanvasToDisplaySize(canvas, multiplier) {
  multiplier = multiplier || 1;
  multiplier = Math.max(0, multiplier);
  const width  = canvas.clientWidth  * multiplier | 0;
  const height = canvas.clientHeight * multiplier | 0;
  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    return true;
  }
  return false;
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*********************************!*\
  !*** ./games/PALO2/src/main.js ***!
  \*********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @engine/flatfast */ "./engine/src/flatfast.js");
/* harmony import */ var _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vsWrapper/vs */ "./games/PALO2/src/vsWrapper/vs.js");
/* harmony import */ var _intro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./intro */ "./games/PALO2/src/intro.js");
/* harmony import */ var _title__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./title */ "./games/PALO2/src/title.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dialog */ "./games/PALO2/src/dialog.js");
/* harmony import */ var _gameEvent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gameEvent */ "./games/PALO2/src/gameEvent.js");
/* harmony import */ var _zako__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zako */ "./games/PALO2/src/zako.js");
/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./player */ "./games/PALO2/src/player.js");
/* harmony import */ var _gameLoop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gameLoop */ "./games/PALO2/src/gameLoop.js");
//  ___  ___  _    ___  ___ 
// | . \| . || |  | . |<_  >
// |  _/|   || |_ | | | / / 
// |_|  |_|_||___|`___'<___>
//
// 85되었수다! 100K 스페셜 / 삭제되었수다!                         




// 256x200 프레임버퍼
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.init( 256,200 ,60,_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Application.ScaleModes.LETTERBOX );
// DOS시절 쓰던 VisualShocker Engine
_vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.VsStage.init();
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.setBackgroundColor( 0x000000 );









// vsStage.setCacheMode( 2 );

_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.stage.addChild( new _vsWrapper_vs__WEBPACK_IMPORTED_MODULE_1__.VsPad( ) );
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.stage.on( _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Event.STAGE_VISIBLE,( e )=>{
    // 인트로에서 문제가 된다
    if ( !e.visible ) {
        _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.Sound.stopAllSingleSound();
    }
    _engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.setPaused( !e.visible );
} );
_engine_flatfast__WEBPACK_IMPORTED_MODULE_0__.application.dispatchEvent( "mode:title" ); 


})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdkRBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ2tDO0FBQ0Y7QUFDQTtBQUNZO0FBQzVDO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUNBQUssRUFBRSxnREFBWSxJQUFJLDZDQUE2QztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsdUNBQUk7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsdUNBQUk7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsdUNBQUk7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHVDQUFJOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix1Q0FBSTs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsV0FBVztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHVDQUFJOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFdBQVc7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsdUNBQUk7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsV0FBVztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHVDQUFJOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVDQUFJOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxtQ0FBbUMscURBQWlCO0FBQ3BEO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUFNO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQVM7QUFDckM7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQSwyQkFBMkIsdURBQVk7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHNDQUFzQyxxREFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsNkNBQVM7QUFDL0IscUNBQXFDOztBQUVyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDMTNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFdBQVcsV0FBVztBQUN0QixXQUFXLFVBQVU7QUFDckIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxRQUFRO0FBQ25CLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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LFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwwQkFBMEIsWUFBWTtBQUM1RCx1QkFBdUIsMkJBQTJCLFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHdDQUF3QztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRCxXQUFXLDhDQUE4QztBQUN6RCxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWMsU0FBUztBQUM1QztBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNEQUFzRDtBQUNqRSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxzREFBc0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVUsSUFBSSxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFVBQVU7QUFDeEIsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyw2REFBNkQ7QUFDdEU7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLDRDQUE0QztBQUN2RCxXQUFXLG1DQUFtQztBQUM5QyxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtFQUErRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsNkNBQTZDO0FBQzdDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDZDQUE2QztBQUM3QywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQywyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNS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QUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc3FEOzs7Ozs7O1VDLzVTdHFEO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBIO0FBQ2pFO0FBQ3pEO0FBQ0E7QUFDQSw4REFBZ0IsY0FBYyw4RUFBZ0M7QUFDOUQ7QUFDQSx1REFBWTtBQUNaLDRFQUE4QjtBQUM5QjtBQUNpQjtBQUNBO0FBQ0M7QUFDRztBQUNMO0FBQ0U7QUFDRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw0REFBYyxNQUFNLGdEQUFLO0FBQ3pCLHNEQUFRLEVBQUUsaUVBQW1CO0FBQzdCO0FBQ0E7QUFDQSxRQUFRLHNFQUF3QjtBQUNoQztBQUNBLElBQUksbUVBQXFCO0FBQ3pCLEVBQUU7QUFDRix1RUFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvQXBwbGljYXRpb24uanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL0Fzc2V0LmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9CaXRtYXAuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL0JpdG1hcEZvbnQuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvQ29tcG9uZW50SG9sZGVyLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9FdmVudC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9Gb250QmFzZS5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvS2V5Q29kZS5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvTGF5b3V0LmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9NYXRyaXguanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL01lc2guanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL01vdmllQ2xpcC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvTXNkZkZvbnQuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL1BhcnRpY2xlcy5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvUGl4ZWwuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL1JlbmRlclRhcmdldC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvU2NlbmVNYW5hZ2VyLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9TZXJpYWxpemVyLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9TaGFkZXIuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL1NoYXBlLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9Tb3VuZC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvU3BpbmUuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL1Nwcml0ZS5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvU3RhZ2UuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL1RleHRGaWVsZC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvVGV4dHVyZUJhc2UuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL1RleHR1cmVQYWNrLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9UaWxlTWFwLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9UaW1lci5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvVHJhbnNmb3JtLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9UcnVlVHlwZUZvbnQuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL1R3ZWVuLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZW5naW5lL3NyYy9UeXBlcy5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvVXRpbHMuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL2Vhc2luZy5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2VuZ2luZS9zcmMvZmxhdGZhc3QuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9lbmdpbmUvc3JjL2hhbmd1bC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2dhbWVzL1BBTE8yL3NyYy9kaWFsb2cuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9nYW1lcy9QQUxPMi9zcmMvZ2FtZUV2ZW50LmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZ2FtZXMvUEFMTzIvc3JjL2dhbWVMb29wLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZ2FtZXMvUEFMTzIvc3JjL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2dhbWVzL1BBTE8yL3NyYy9pbnRyby5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2dhbWVzL1BBTE8yL3NyYy9wbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9nYW1lcy9QQUxPMi9zcmMvdGl0bGUuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9nYW1lcy9QQUxPMi9zcmMvdnNXcmFwcGVyL3ZzLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vZ2FtZXMvUEFMTzIvc3JjL3ZzV3JhcHBlci92c0hhbmd1bC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2dhbWVzL1BBTE8yL3NyYy92c1dyYXBwZXIvdnNQYWQuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9nYW1lcy9QQUxPMi9zcmMvdnNXcmFwcGVyL3ZzUGFsZXR0ZS5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2dhbWVzL1BBTE8yL3NyYy92c1dyYXBwZXIvdnNTcHJpdGUuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9nYW1lcy9QQUxPMi9zcmMvdnNXcmFwcGVyL3ZzU3RhZ2UuanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9nYW1lcy9QQUxPMi9zcmMvdnNXcmFwcGVyL3ZzU3lzdGVtVGV4dC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2dhbWVzL1BBTE8yL3NyYy92c1dyYXBwZXIvdnNXb3JsZC5qcyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC8uL2dhbWVzL1BBTE8yL3NyYy96YWtvLmpzIiwid2VicGFjazovL2ZsYXRmYXN0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9ub2RlX21vZHVsZXMvdHdnbC5qcy9kaXN0LzQueC90d2dsLWZ1bGwubW9kdWxlLmpzIiwid2VicGFjazovL2ZsYXRmYXN0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2ZsYXRmYXN0L3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2ZsYXRmYXN0L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9mbGF0ZmFzdC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2ZsYXRmYXN0L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZmxhdGZhc3QvLi9nYW1lcy9QQUxPMi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3NldCB9IGZyb20gJy4vQXNzZXQnO1xyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlJztcclxuaW1wb3J0IHsgU3RhZ2UgfSBmcm9tICcuL1N0YWdlJztcclxuaW1wb3J0IHsgUG9pbnQsIFJlY3QgfSBmcm9tICcuL1R5cGVzJztcclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL1V0aWxzJztcclxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcclxuXHJcbmNvbnN0IE1BWF9VUERBVEVfUEVSX0xPR0lDX1RJQ0sgPSA1O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgQXBwbGljYXRpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcHBsaWNhdGlvbiBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCBcIvCfjq4gQXBwbGljYXRpb24gc3RhcnQuXCIgKTtcclxuICAgICAgICB0aGlzLnN0YWdlID0gbmV3IFN0YWdlKCk7XHJcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgb25tZXNzYWdlID0gdGhpcy5vblJlbmRlck1lc3NhZ2UuYmluZCggdGhpcyApO1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnB1dEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucGh5c2ljc1JlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5waHlzaWNzV29ya2VyID0gbmV3IFdvcmtlciggXCJwaHlzaWNzLmpzXCIgKTtcclxuICAgICAgICB0aGlzLnBoeXNpY3NXb3JrZXIub25tZXNzYWdlID0gdGhpcy5vblBoeXNpY3NNZXNzYWdlLmJpbmQoIHRoaXMgKTtcclxuICAgICAgICB0aGlzLnBoeXNpY3NXb3JrZXIucG9zdE1lc3NhZ2UoIHsgbXNnOiBcInNldFN0YWdlQm91bmRcIixhcmdzOiBbNjQwLDQ4MCx0cnVlLHRydWUsdHJ1ZSx0cnVlXSB9ICk7XHJcblxyXG4gICAgICAgIHRoaXMudG91Y2hFbmFibGVkID0gc2VsZi5fZGV2aWNlSW5mby50b3VjaEVuYWJsZWQ7XHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIOuFvOumrOyggeyduCDrt7Dtj6ztirjrpbwg7Ja764qU64ukXHJcbiAgICAgICAgICogcG9zaXRpb27snYAgcmVuZGVyVmlld3BvcnTroZzrtoDthLDsnZgg7JyE7LmYXHJcbiAgICAgICAgICogc2l6ZeuKlCDrhbzrpqwg67ew7Y+s7Yq4IO2BrOq4sCBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvZ2ljYWxWaWV3cG9ydCA9IG5ldyBSZWN0KCAwLDAsMCwwICk7XHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIOugjOuNlCDrt7Dtj6ztirjsnZgg7KKM7IOB64uoIOyngOygkOyXkOyEnCDroZzsp4Dsu6wg67ew7Y+s7Yq47J2YIOybkOygkOq5jOyngOydmCDroZzsp4Dsu6wg7KKM7ZGc6rOE66GcIOqxsOumrCBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvZ2ljYWxWaWV3cG9ydE9mZnNldCA9IG5ldyBQb2ludCggc2VsZi5fZGV2aWNlSW5mby5sb2dpY2FsVmlld3BvcnRPZmZzZXQgKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDroIzrjZQg67ew7Y+s7Yq4IO2BrOq4sDrroZzsp4Eg67ew7Y+s7Yq4IO2BrOq4sFxyXG4gICAgICAgICAqIOuhnOyngeydtCDroIzrjZTrs7Tri6Qg7YGs66m0IDEg66+466eMXHJcbiAgICAgICAgICog66CM642U6rCAIOuhnOyngeuztOuLpCDtgazrqbQgMSDstIjqs7wgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb2dpY2FsVmlld3BvcnRTY2FsZSA9IG5ldyBQb2ludCggc2VsZi5fZGV2aWNlSW5mby5sb2dpY2FsVmlld3BvcnRTY2FsZSApO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOuUlOuwlOydtOyKpOyDgeydmCDtlbTsg4Hrj4Trpbwg7Ja764qU64ukXHJcbiAgICAgICAgICogcG9zaXRpb27snYAgaHRtbOy9mO2FjeyKpO2KuCDsg4Hsl5DshJzsnZgg7KKM7ZGcXHJcbiAgICAgICAgICogc2l6ZSDrlJTrsJTsnbTsiqQg67ew7Y+s7Yq4IO2BrOq4sFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGV2aWNlVmlld3BvcnQgPSBuZXcgUmVjdCggc2VsZi5fZGV2aWNlSW5mby5kZXZpY2VWaWV3cG9ydCApO1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICB0aGlzLmluaXQoIDY0MCw0ODAsNjAsQXBwbGljYXRpb24uU2NhbGVNb2Rlcy5MRVRURVJCT1ggKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KCB3aWR0aCxoZWlnaHQsZnBzID0gNjAsc2NhbGVNb2RlID0gQXBwbGljYXRpb24uU2NhbGVNb2Rlcy5MRVRURVJCT1ggKSB7XHJcbiAgICAgICAgdGhpcy5sb2dpY2FsVmlld3BvcnQgPSBuZXcgUmVjdCggMCwwLHdpZHRoLGhlaWdodCApO1xyXG4gICAgICAgIHRoaXMuc2V0VXBkYXRlRlBTKCBmcHMgKTtcclxuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlVG9SZW5kZXIoIHsgbXNnOiBcImFkZENvbW1hbmRcIixjbGFzczogXCJBcHBsaWNhdGlvblwiLG1ldGhvZDogXCJzZXRMb2dpY2FsVmlld3BvcnRcIixhcmdzOiBbdGhpcy5sb2dpY2FsVmlld3BvcnQueHl3aCxzY2FsZU1vZGVdIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICBvblBoeXNpY3NNZXNzYWdlKCBtc2cgKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IG1zZy5kYXRhO1xyXG5cclxuICAgICAgICBpZiAoIGRhdGEubXNnID09IFwicmVhZHlcIiApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coIFwi8J+RjSBQaHlzaWNzIHJlYWR5LlwiICk7ICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmICggZGF0YS5tc2cgPT0gXCJkZXZpY2VJbmZvXCIgKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX2RldmljZUluZm8gPSBtc2cuZGF0YS5pbmZvO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIEV2ZW50LlJFU0laRSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvblJlbmRlck1lc3NhZ2UoIG1zZyApIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gbXNnLmRhdGE7XHJcblxyXG4gICAgICAgIGlmICggZGF0YS5tc2cgPT0gXCJyZW5kZXJcIiApIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWNrKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICggZGF0YS5tc2cgPT0gXCJkZXZpY2VJbmZvXCIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGV2aWNlVmlld3BvcnQgPSBuZXcgUmVjdCggZGF0YS5pbmZvLmRldmljZVZpZXdwb3J0ICk7XHJcbiAgICAgICAgICAgIHRoaXMubG9naWNhbFZpZXdwb3J0T2Zmc2V0ID0gbmV3IFBvaW50KCBkYXRhLmluZm8ubG9naWNhbFZpZXdwb3J0T2Zmc2V0ICk7XHJcbiAgICAgICAgICAgIHRoaXMubG9naWNhbFZpZXdwb3J0U2NhbGUgPSBuZXcgUG9pbnQoIGRhdGEuaW5mby5sb2dpY2FsVmlld3BvcnRTY2FsZSApO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIEV2ZW50LlJFU0laRSApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGRhdGEubXNnID09IFwiQXNzZXRfbG9hZENvbXBsZXRlZFwiICkge1xyXG4gICAgICAgICAgICBBc3NldC5kaXNwYXRjaExvYWRlZEV2ZW50KCBkYXRhLmlkICk7XHJcbiAgICAgICAgfSBlbHNlIGlmICggZGF0YS5tc2cgPT0gXCJpbnB1dFwiICYmIHRoaXMuZW5hYmxlSW5wdXQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25JbnB1dE1lc3NhZ2UoIGRhdGEuaW5wdXRUeXBlLGRhdGEuc2Vjb25kbHlJbnB1dFR5cGUsZGF0YS5pbnB1dERhdGEgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyggXCJvblJlbmRlck1lc3NhZ2VcIixtc2cgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICog66Gc7KeBIOu3sO2PrO2KuOyXkOyEnOydmCDroIzrjZQg67ew7Y+s7Yq47J2YIOuylOychFxyXG4gICAgICog7J20IOuylOychOuhnCDrsJXsiqTrpbwg7IOd7ISx7ZWY66m0IO2ZlOuptOydhCDrqqjrkZAg6rCA66a0IOyImCDsnojri6QgXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2dpY2FsUmVuZGVyQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCggLXRoaXMubG9naWNhbFZpZXdwb3J0T2Zmc2V0LngsLXRoaXMubG9naWNhbFZpZXdwb3J0T2Zmc2V0LnksdGhpcy5sb2dpY2FsVmlld3BvcnQud2lkdGggKyB0aGlzLmxvZ2ljYWxWaWV3cG9ydE9mZnNldC54ICogMix0aGlzLmxvZ2ljYWxWaWV3cG9ydC5oZWlnaHQgKyB0aGlzLmxvZ2ljYWxWaWV3cG9ydE9mZnNldC55ICogMiApO1xyXG4gICAgfVxyXG5cclxuICAgIG9uSW5wdXRNZXNzYWdlKCBpbnB1dFR5cGUsIHNlY29uZGx5SW5wdXRUeXBlLCBpbnB1dERhdGEgKSB7XHJcbiAgICAgICAgY29uc3QgZSA9IG5ldyBFdmVudCggaW5wdXRUeXBlICk7XHJcblxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIGUsaW5wdXREYXRhICk7XHJcbiAgICAgICAgdGhpcy5zdGFnZS5kaXNwYXRjaEV2ZW50V2l0aENoaWxkcmVuKCBlICk7XHJcbiAgICAgICAgaWYgKCAhZS5zdG9wcGVkICYmIHNlY29uZGx5SW5wdXRUeXBlICkge1xyXG4gICAgICAgICAgICBlLm5hbWUgPSBzZWNvbmRseUlucHV0VHlwZTtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5kaXNwYXRjaEV2ZW50V2l0aENoaWxkcmVuKCBlICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclRpY2soKSB7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSAgKCBub3cgLSB0aGlzLmxhc3RVcGRhdGUgKSAvICggMTAwMCAvIHRoaXMudXBkYXRlRlBTICk7XHJcbiAgICAgICAgLy8g7ZSE66CI7J6EIOqyveqzhOyXkOyEnCDslYjrp57snYTquYzrtJAgcm91bmTsspjrpqwg7ZW067SEXHJcbiAgICAgICAgY29uc3QgbnVtT2ZVcGRhdGUgPSBNYXRoLnJvdW5kKCBkZWx0YSApO1xyXG5cclxuICAgICAgICBpZiAoICF0aGlzLnBhdXNlZCApIHtcclxuICAgICAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oIE1BWF9VUERBVEVfUEVSX0xPR0lDX1RJQ0ssbnVtT2ZVcGRhdGUgKTsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RVcGRhdGUgKz0gKCAxMDAwIC8gdGhpcy51cGRhdGVGUFMgKSAqIG51bU9mVXBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3RhZ2Xsl5AgdXBkYXRl66mU7Iuc7KeA66W8IOuwnOyGoe2VmOqzoFxyXG4gICAgICogc3ByaXRlIOyDge2DnOulvCBtYWluIHRocmVhZOuhnCDrs7Trgrjri6RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQXBwbGljYXRpb25cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggRXZlbnQuQkVGT1JFX1VQREFURSApO1xyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5kb0VudGVyRnJhbWUoKTtcclxuICAgICAgICBsZXQgW2J1Zix0cmFuc2Zlckxpc3RdID0gdGhpcy5zdGFnZS5lbmNvZGVSZW5kZXJpbmdJbmZvV2l0aENoaWxkcmVuKCk7XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBidWYsZXh0cmFCdWYsc3RyaW5ncyApO1xyXG4gICAgICAgIGlmICggdGhpcy5waHlzaWNzUmVhZHkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc1dvcmtlci5wb3N0TWVzc2FnZSggeyBtc2c6IFwidXBkYXRlXCIgfSApO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgdGhpcy5wb3N0TWVzc2FnZVRvUmVuZGVyKCB7IG1zZzogXCJ1cGRhdGVcIixyZW5kZXJpbmdJbmZvOiBidWYgfSwgdHJhbnNmZXJMaXN0ICk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBFdmVudC5BRlRFUl9VUERBVEUgKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRVcGRhdGVGUFMoIEZQUyApIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZQUyA9IEZQUztcclxuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlVG9SZW5kZXIoIHsgbXNnOiBcImFkZENvbW1hbmRcIiwgY2xhc3M6IFwiQXBwbGljYXRpb25cIixtZXRob2Q6IFwic2V0VXBkYXRlRlBTXCIsYXJnczogW3RoaXMudXBkYXRlRlBTXSB9ICk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog7JeU7KeE7J2EIOyZhOyghO2eiCDsoJXsp4Dsi5ztgqTqsbDrgpgg64uk7IucIOy8oOuLpC5cclxuICAgICAqIEVOVEVSX0ZSQU1F6rO8IOyeheugpSDsnbTrsqTtirjrpbwg66mI7LaU64qUIOqyg1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdlxyXG4gICAgICogQG1lbWJlcm9mIEFwcGxpY2F0aW9uXHJcbiAgICAgKi9cclxuICAgIHNldFBhdXNlZCggdiApIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHY7XHJcbiAgICAgICAgdGhpcy5lbmFibGVJbnB1dCggIXYgKTtcclxuICAgIH1cclxuXHJcbiAgICBlbmFibGVJbnB1dCggdiApIHtcclxuICAgICAgICB0aGlzLmlucHV0RW5hYmxlZCA9IHY7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QmFja2dyb3VuZENvbG9yKCBjICkge1xyXG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2VUb1JlbmRlciggeyBtc2c6IFwiYWRkQ29tbWFuZFwiLCBjbGFzczogXCJBcHBsaWNhdGlvblwiLCBtZXRob2Q6IFwic2V0QmFja2dyb3VuZENvbG9yXCIsYXJnczogW1V0aWxzLmhleDJyZ2JhKCBjICldIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICBwb3N0TWVzc2FnZVRvUmVuZGVyKCBtc2csdHJhbnNmZXIgKSB7XHJcbiAgICAgICAgcG9zdE1lc3NhZ2UoIG1zZyx0cmFuc2ZlciApO1xyXG4gICAgfVxyXG5cclxuICAgIHByZWxvYWQoIGFzc2V0RmlsZW5hbWVzLHByb2dyZXNzQ2FsbGJhY2sgKSB7XHJcbiAgICAgICAgcmV0dXJuIEFzc2V0LnByZWxvYWQoIGFzc2V0RmlsZW5hbWVzLHByb2dyZXNzQ2FsbGJhY2sgKTtcclxuICAgIH1cclxufVxyXG5cclxuQXBwbGljYXRpb24uU2NhbGVNb2RlcyA9IHtcclxuICAgIE5PX1NDQUxFOiAgIFwiTk9fU0NBTEVcIixcclxuICAgIENFTlRFUjogICAgIFwiQ0VOVEVSXCIsXHJcbiAgICBDUk9QOiAgICAgICBcIkNST1BcIixcclxuICAgIExFVFRFUkJPWDogIFwiTEVUVEVSQk9YXCIsXHJcbiAgICBTVFJFVENIOiAgICBcIlNUUkVUQ0hcIixcclxuICAgIEZJVF9XSURUSDogIFwiRklUX1dJRFRIXCIsXHJcbiAgICBGSVRfSEVJR0hUOiBcIkZJVF9IRUlHSFRcIixcclxufTtcclxuXHJcblxyXG4vL0B0cy1pZ25vcmVcclxuaWYgKCBzZWxmLmFwcGxpY2F0aW9uID09IG51bGwgKSB7XHJcbiAgICAvL0B0cy1pZ25vcmVcclxuICAgIHNlbGYuYXBwbGljYXRpb24gPSBuZXcgQXBwbGljYXRpb24oKTtcclxufSBcclxuXHJcbi8qKiBAdHlwZSB7QXBwbGljYXRpb259ICovXHJcbi8vQHRzLWlnbm9yZVxyXG5leHBvcnQgY29uc3QgYXBwbGljYXRpb24gPSBzZWxmLmFwcGxpY2F0aW9uO1xyXG4vKiogQHR5cGUge1N0YWdlfSAqL1xyXG4vL0B0cy1pZ25vcmVcclxuZXhwb3J0IGNvbnN0IHN0YWdlID0gc2VsZi5hcHBsaWNhdGlvbi5zdGFnZTtcclxuXHJcbmNvbnNvbGUuYXNzZXJ0KCBVdGlscy5pc1dlYldvcmtlcigpLGBBcHBsaWNhdGlvbuydhCDrqZTsnbjsk7DroIjrk5zsl5Ag66eM65Ok66Ck6rOgIO2VmOqzoCDsnojsnYxgICk7XHJcbiIsImltcG9ydCB7IGFwcGxpY2F0aW9uIH0gZnJvbSAnLi9BcHBsaWNhdGlvbic7XHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL1V0aWxzJztcclxuXHJcbmNvbnN0IGZvbnRJbmZvQ2FjaGUgPSB7fTtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQXNzZXQgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEFzc2V0UHJveHkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUg6rSA66as65CY64qUIOydtOumhC4g7J2066aE7J20IOqwmeycvOuptCDqsJnsnYAg7Ja07IWL7Jy866GcIOqwhOyjvOuQnOuLpC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXNzZXRUeXBlIOyWtOyFi+ydmCDsooXrpZhcclxuICAgICAqIEBtZW1iZXJvZiBBc3NldFByb3h5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCBuYW1lLCBhc3NldFR5cGUgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gQXNzZXQubGFzdElkKys7XHJcbiAgICAgICAgaWYgKCBuYW1lICE9IG51bGwgJiYgbmFtZS5pbmRleE9mKCBcIipcIiApID49IDAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWUucmVwbGFjZSggXCIqXCIsdGhpcy5pZC50b1N0cmluZygpICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZSA9PSBudWxsID8gXCJcIiA6IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHlwZSA9IGFzc2V0VHlwZSA9PSBudWxsID8gQXNzZXQuZ3Vlc3NUeXBlKCB0aGlzLm5hbWUgKSA6IGFzc2V0VHlwZTtcclxuXHJcbiAgICAgICAgQXNzZXQuZmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIoIHRoaXMseyB0aGlzT2JqSWQ6IHRoaXMuaWQsIHRoaXNUeXBlOiB0aGlzLnR5cGUgfSApO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm9uTG9hZGVkSGFuZGxlciA9IHRoaXMub25Mb2FkZWQuYmluZCggdGhpcywgW3RoaXMuaWRdICk7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy50eXBlID09IEFzc2V0LkFzc2V0VHlwZXMuVHJ1ZVR5cGVGb250XHJcbiAgICAgICAgICAgIHx8IHRoaXMudHlwZSA9PSBBc3NldC5Bc3NldFR5cGVzLkJpdG1hcEZvbnRcclxuICAgICAgICAgICAgfHwgdGhpcy50eXBlID09IEFzc2V0LkFzc2V0VHlwZXMuU291bmRcclxuICAgICAgICAgICAgfHwgdGhpcy50eXBlID09IEFzc2V0LkFzc2V0VHlwZXMuVGV4dHVyZSApIHtcclxuICAgICAgICAgICAgLy9MT0FERUQg7J2067Kk7Yq466W8IOuwm+yVhOyVvCDtlZjripQg7YOA7J6F66eMIOqxuOyWtOykgOuLpFxyXG4gICAgICAgICAgICBBc3NldC5sb2FkZWRFdmVudERpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lciggRXZlbnQuTE9BREVELHRoaXMub25Mb2FkZWRIYW5kbGVyICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9hZEZvbnRJbmZvKCBuYW1lICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDtj7Dtirjrpbwg66Gc65Sp7ZWY64qUIOqyveyasCDtj7Dtirgg7KCV67O06rCAIOuUsOuhnCDtlYTsmpTtlZjri6RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IG5hbWVcclxuICAgICAqIEBtZW1iZXJvZiBBc3NldFxyXG4gICAgICovXHJcbiAgICBsb2FkRm9udEluZm8oIG5hbWUgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLnR5cGUgPT0gQXNzZXQuQXNzZXRUeXBlcy5UcnVlVHlwZUZvbnQgKSB7XHJcbiAgICAgICAgICAgIGlmICggZm9udEluZm9DYWNoZVtuYW1lXSApIHtcclxuICAgICAgICAgICAgICAgIC8vIOy6kOyLnOyXkCDsnojripQg6rK97JqwXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvbnRJbmZvID0gZm9udEluZm9DYWNoZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBg7Y+w7Yq4ICR7dGhpcy5uYW1lfSDroZzrk5wg7JmE66OMLijsupDsi5wpYCApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBFdmVudC5MT0FERUQgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZldGNoKCBgYXNzZXQvJHtuYW1lfS5qc29uYCApXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oIHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIHJlc3BvbnNlLm9rLGBhc3NldC8ke25hbWV9Lmpzb24g66Gc65Oc7ZWY7KeAIOuqu+2WiOydjC5gICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSApXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oIGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbnRJbmZvID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmZvbnRMb2FkZWQgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250SW5mb0NhY2hlW3RoaXMubmFtZV0gPSB0aGlzLmZvbnRJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIGDtj7DtirggJHt0aGlzLm5hbWV9IOuhnOuTnCDsmYTro4wuKGpzb27snYQg64qm6rKMIOuhnOuUqSlgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIEV2ZW50LkxPQURFRCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICggdGhpcy50eXBlID09IEFzc2V0LkFzc2V0VHlwZXMuQml0bWFwRm9udCB8fCB0aGlzLnR5cGUgPT0gQXNzZXQuQXNzZXRUeXBlcy5Nc2RmRm9udCApIHtcclxuICAgICAgICAgICAgLy8g67mE7Yq466e164+EIGpzb27snYQg65Sw66GcIOuhnOuUqe2VmOuKlCDsspjrpqwg7ZWE7JqUXHJcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBVdGlscy5nZXRFbWJlZGRlZEZpbGUoIG5hbWUgKyBcIi5qc29uXCIgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZm9udEluZm8gPSBKU09OLnBhcnNlKCBqc29uICk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXHJcbiAgICAgKiBAcGFyYW0ge2FueT19IGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzT25jZT1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtBc3NldH1cclxuICAgICAqIEBtZW1iZXJvZiBBc3NldFxyXG4gICAgICovXHJcbiAgICBhZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIGZ1bmMsIGNvbnRleHQgPSBudWxsLCBpc09uY2UgPSBmYWxzZSApIHtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICByZXR1cm4gc3VwZXIuYWRkRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBmdW5jLCBjb250ZXh0LCBpc09uY2UgKTtcclxuICAgIH1cclxuXHJcbiAgICByZWxlYXNlKCkge1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLnBvc3RNZXNzYWdlVG9SZW5kZXIoIHsgbXNnOiBcImFkZENvbW1hbmRcIiwgY2xhc3M6IFwiQXNzZXRcIiwgbWV0aG9kOiBcInJlbGVhc2VcIixhcmdzOiBbdGhpcy5pZF0gfSApO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWQoIGV4dHJhRGF0YSApIHtcclxuICAgICAgICAvLyBhc3NldC5leHRyYURhdGEgPSBleHRyYURhdGE7XHJcbiAgICAgICAgYXBwbGljYXRpb24ucG9zdE1lc3NhZ2VUb1JlbmRlciggeyBcclxuICAgICAgICAgICAgbXNnOiAgICBcImV4ZWN1dGVDb21tYW5kXCIsXHJcbiAgICAgICAgICAgIGNsYXNzOiAgXCJBc3NldFwiLFxyXG4gICAgICAgICAgICBtZXRob2Q6IFwibG9hZFwiLFxyXG4gICAgICAgICAgICBhcmdzOiAgIFtcclxuICAgICAgICAgICAgICAgIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICAgICAgICB0aGlzLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgdGhpcy50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICAgICAgdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhRGF0YTogZXh0cmFEYXRhLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoIGV4dHJhRGF0YSApIHtcclxuICAgICAgICAvLyBhc3NldC5leHRyYURhdGEgPSBleHRyYURhdGE7XHJcbiAgICAgICAgYXBwbGljYXRpb24ucG9zdE1lc3NhZ2VUb1JlbmRlciggeyBcclxuICAgICAgICAgICAgbXNnOiAgICBcImFkZENvbW1hbmRcIixcclxuICAgICAgICAgICAgY2xhc3M6ICBcIkFzc2V0XCIsXHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJsb2FkXCIsXHJcbiAgICAgICAgICAgIGFyZ3M6ICAgW1xyXG4gICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICBpZDogICAgICAgIHRoaXMuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogICAgICB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFEYXRhOiBleHRyYURhdGEsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0gfSApO1xyXG4gICAgfVxyXG5cclxuICAgIG9uTG9hZGVkKCBpZCwgZXZlbnQgKSB7XHJcbiAgICAgICAgaWYgKCBpZCA9PSBldmVudC5pZCApIHtcclxuICAgICAgICAgICAgLy8g64K0IOqyg+qzvCDqsJnsnYAgaWTsnbgg6rK97Jqw7JeQ66eMIOydtOuypO2KuOulvCDrtoDrpbjri6RcclxuICAgICAgICAgICAgQXNzZXQubG9hZGVkRXZlbnREaXNwYXRjaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoIEV2ZW50LkxPQURFRCx0aGlzLm9uTG9hZGVkSGFuZGxlciApO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggQXNzZXQubG9hZGVkRXZlbnREaXNwYXRjaGVyLmV2ZW50RW1pdHRlciApO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMudHlwZSA9PSBBc3NldC5Bc3NldFR5cGVzLlRydWVUeXBlRm9udCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9udExvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuZm9udEluZm8gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9udEluZm9DYWNoZVt0aGlzLm5hbWVdID0gdGhpcy5mb250SW5mbztcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggYO2PsO2KuCAke3RoaXMubmFtZX0g66Gc65OcIOyZhOujjC4odHRm64qm6rKMIOuhnOuUqSlgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggRXZlbnQuTE9BREVEICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIEV2ZW50LkxPQURFRCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmaW5hbGl6ZUhhbmRsZXIoIG9iaiApIHtcclxuICAgICAgICAvLyBHQ+yXkCDsnZjtlbQg7IiY6rGw65CY7JeI7Jy866m0IOumtOumrOymiOulvCDrs7Trgrjri6QuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coIGBHQyAke29iai50aGlzT2JqSWR9YCApO1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLnBvc3RNZXNzYWdlVG9SZW5kZXIoIHsgbXNnOiBcImFkZENvbW1hbmRcIiwgY2xhc3M6IFwiQXNzZXRcIiwgbWV0aG9kOiBcInJlbGVhc2VcIixhcmdzOiBbb2JqLnRoaXNPYmpJZF0gfSApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkaXNwYXRjaExvYWRlZEV2ZW50KCBpZCApIHtcclxuICAgICAgICBBc3NldC5sb2FkZWRFdmVudERpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudCggRXZlbnQuTE9BREVELHsgaWQgfSApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBndWVzc1R5cGUoIG5hbWUgKSB7XHJcbiAgICAgICAgY29uc3QgZXh0TWF0Y2ggPSAvXFwuW14uXSskLy5leGVjKCBuYW1lICk7XHJcbiAgICAgICAgY29uc3QgZXh0ID0gZXh0TWF0Y2ggIT0gbnVsbCA/IGV4dE1hdGNoWzBdLnRvTG93ZXJDYXNlKCkgOiBcIlwiO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKCBleHQgPT0gXCIucG5nXCIgfHwgZXh0ID09IFwiLmpwZ1wiICkge1xyXG4gICAgICAgICAgICByZXR1cm4gQXNzZXQuQXNzZXRUeXBlcy5UZXh0dXJlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGV4dCA9PSBcIi53YXZcIiB8fCBleHQgPT0gXCIubXAzXCIgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBBc3NldC5Bc3NldFR5cGVzLlNvdW5kO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGV4dCA9PSBcIi50dGZcIiApIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFzc2V0LkFzc2V0VHlwZXMuVHJ1ZVR5cGVGb250O1xyXG4gICAgICAgIC8vIH0gZWxzZSBpZiAoIGV4dCA9PSBcIi5mbnRcIikge1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gQXNzZXQuQXNzZXRUeXBlcy5CaXRtYXBGb250O1xyXG4gICAgICAgIC8vIH0gZWxzZSBpZiAoIGV4dCA9PSBcIi5tc2RmXCIpIHtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIEFzc2V0LkFzc2V0VHlwZXMuTXNkZkZvbnQ7XHJcbiAgICAgICAgfSByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZmluZFByZWxvYWRlZEFzc2V0KCBuYW1lICkge1xyXG4gICAgICAgIGZvciAoIGxldCBhc3NldCBvZiBBc3NldC5wcmVsb2FkQXNzZXRzICkge1xyXG4gICAgICAgICAgICBpZiAoIGFzc2V0Lm5hbWUgPT0gbmFtZSApIHJldHVybiBhc3NldDtcclxuICAgICAgICB9IFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwcmVsb2FkKCBhc3NldEZpbGVuYW1lcyxwcm9ncmVzc0NhbGxiYWNrICkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLHJlamVjdCApPT57XHJcbiAgICAgICAgICAgIGZvciAoIGxldCBuYW1lIG9mIGFzc2V0RmlsZW5hbWVzICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZXQgPSBuZXcgQXNzZXQoIG5hbWUgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBhc3NldC5sb2FkKCk7XHJcbiAgICAgICAgICAgICAgICBBc3NldC5wcmVsb2FkQXNzZXRzLnB1c2goIGFzc2V0ICk7XHJcbiAgICAgICAgICAgICAgICBBc3NldC5wcmVsb2FkQXNzZXRQcm9taXNlcy5wdXNoKCBhc3NldC5ldmVudFRvUHJvbWlzZSggRXZlbnQuTE9BREVEICkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBQcm9taXNlLmFsbCggQXNzZXQucHJlbG9hZEFzc2V0UHJvbWlzZXMgKS50aGVuKCByZXNvbHZlICk7XHJcbiAgICAgICAgfSApO1xyXG4gICAgfVxyXG59XHJcbkFzc2V0LkFzc2V0VHlwZXMgPSB7XHJcbiAgICBUZXh0dXJlOiAgICAgICAgICAgXCJUZXh0dXJlXCIsXHJcbiAgICBSZW5kZXJUYXJnZXQ6ICAgICAgXCJSZW5kZXJUYXJnZXRcIixcclxuICAgIFNvdW5kOiAgICAgICAgICAgICBcIlNvdW5kXCIsXHJcbiAgICBTaGFkZXI6ICAgICAgICAgICAgXCJTaGFkZXJcIixcclxuICAgIFRydWVUeXBlRm9udDogICAgICBcIlRydWVUeXBlRm9udFwiLFxyXG4gICAgTXNkZkZvbnQ6ICAgICAgICAgIFwiTXNkZkZvbnRcIixcclxuICAgIEJpdG1hcEZvbnQ6ICAgICAgICBcIkJpdG1hcEZvbnRcIixcclxuICAgIFBvc3RQcm9jZXNzRmlsdGVyOiBcIlBvc3RQcm9jZXNzRmlsdGVyXCIsXHJcbn07XHJcbkFzc2V0Lmxhc3RJZCA9IDE7XHJcbkFzc2V0LmZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCBBc3NldC5maW5hbGl6ZUhhbmRsZXIgKTtcclxuQXNzZXQubG9hZGVkRXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG5cclxuQXNzZXQucHJlbG9hZEFzc2V0cyA9IFtdO1xyXG5Bc3NldC5wcmVsb2FkQXNzZXRQcm9taXNlcyA9IFtdO1xyXG4iLCJpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL1Nwcml0ZSc7XHJcbmltcG9ydCB7IFRleHR1cmVCYXNlIH0gZnJvbSAnLi9UZXh0dXJlQmFzZSc7XHJcblxyXG5leHBvcnQgY2xhc3MgQml0bWFwIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaXRtYXAuXHJcbiAgICAgKiBAcGFyYW0ge1RleHR1cmVCYXNlfSB0ZXh0dXJlXHJcbiAgICAgKiBAbWVtYmVyb2YgQml0bWFwXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCB0ZXh0dXJlICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fJCRzcHJpdGVUeXBlID0gU3ByaXRlLlNwcml0ZVR5cGVzLkJJVE1BUDtcclxuICAgICAgICB0aGlzLl8kJHVwZGF0ZUNvZGUgPSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgdGhpcy5fJCRsb2NhbEJvdW5kcy54ID0gMDtcclxuICAgICAgICB0aGlzLl8kJGxvY2FsQm91bmRzLnkgPSAwO1xyXG4gICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMud2lkdGggPSB0ZXh0dXJlLndpZHRoO1xyXG4gICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMuaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZW5jb2RlRXh0cmFSZW5kZXJpbmdJbmZvKCkge1xyXG4gICAgICAgIGxldCBlbmNvZGVkQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggOSApO1xyXG5cclxuICAgICAgICBlbmNvZGVkQnVmZmVyWzBdID0gdGhpcy50ZXh0dXJlLmFzc2V0LmlkO1xyXG4gICAgICAgIGVuY29kZWRCdWZmZXIuc2V0KCB0aGlzLnRleHR1cmUudXZSZWN0LmdldENvcm5lclBvaW50cygpLDEgKTtcclxuICAgICAgICByZXR1cm4gW2VuY29kZWRCdWZmZXJdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog67mE7Yq466e17J2YIO2FjeyKpOyzkOulvCDqtZDssrTtlZzri6QuXHJcbiAgICAgKiDthY3siqTss5Drp4wg67CU64CM6rOgIOu5hO2KuOunteydmCDtgazquLDripQg67OA7ZWY7KeAIOyViuuKlOuLpC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1RleHR1cmVCYXNlfSB0ZXh0dXJlXHJcbiAgICAgKiBAbWVtYmVyb2YgQml0bWFwXHJcbiAgICAgKi9cclxuICAgIHNldFRleHR1cmUoIHRleHR1cmUgKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICB0aGlzLl8kJHVwZGF0ZUNvZGUgfD0gU3ByaXRlLlVwZGF0ZUNvZGVzLlVQREFURV9FWFRSQTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBc3NldCB9IGZyb20gJy4vQXNzZXQnO1xuaW1wb3J0IHsgRm9udEJhc2UgfSBmcm9tICcuL0ZvbnRCYXNlJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi9VdGlscyc7XG5cbmV4cG9ydCBjbGFzcyBCaXRtYXBGb250IGV4dGVuZHMgRm9udEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCBiaXRtYXBGb250TmFtZSxyZWZlcmVuY2VTaXplLCBzdHlsZXMsIGZpbHRlciApIHtcbiAgICAgICAgc3VwZXIoIGJpdG1hcEZvbnROYW1lLCByZWZlcmVuY2VTaXplLCBzdHlsZXMgKTtcbiAgICAgICAgLy8gQml0bWFwXG4gICAgICAgIHRoaXMuYXNzZXQgPSBuZXcgQXNzZXQoIGJpdG1hcEZvbnROYW1lLEFzc2V0LkFzc2V0VHlwZXMuQml0bWFwRm9udCApO1xuICAgICAgICAvLyDtjpjsnbTsp4DqsIAg7Jes65+s6rCcIOyeiOuKlCDtj7DtirjripQg7JWE7KeBIOyymOumrCDrqrvtlahcbiAgICAgICAgY29uc3QgcGFnZSA9IHRoaXMuYXNzZXQuZm9udEluZm8ucGFnZXNbMF07XG4gICAgICAgIGNvbnN0IHBuZ1NpemUgPSBVdGlscy5nZXRJbWFnZVNpemUoIHBhZ2UuZmlsZSApO1xuXG4gICAgICAgIHRoaXMuYXNzZXQubG9hZCggeyBcbiAgICAgICAgICAgIGJpdG1hcDogICAgICAgIHBhZ2UuZmlsZSwgXG4gICAgICAgICAgICB3aWR0aDogICAgICAgICBwbmdTaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiAgICAgICAgcG5nU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICByZWZlcmVuY2VTaXplOiB0aGlzLnJlZmVyZW5jZVNpemUsXG4gICAgICAgICAgICBzdHlsZXM6ICAgICAgICB0aGlzLnN0eWxlcyxcbiAgICAgICAgICAgIGZvbnRJbmZvOiAgICAgIHRoaXMuYXNzZXQuZm9udEluZm8sXG4gICAgICAgICAgICBmaWx0ZXI6ICAgICAgICBmaWx0ZXJcbiAgICAgICAgfSApO1xuICAgICAgICB0aGlzLmZvbnRMb2FkZWQgPSBmYWxzZTtcbiAgICB9ICAgIFxuXG4gICAgbWVhc3VyZVRleHRXaWR0aCggc3RyLHNpemUgKSB7XG4gICAgICAgIHN1cGVyLm1lYXN1cmVUZXh0V2lkdGgoIHN0cixzaXplICk7XG5cbiAgICAgICAgY29uc3QgZm9udEluZm8gPSB0aGlzLmFzc2V0LmZvbnRJbmZvO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHNpemUgPyBzaXplIC8gZm9udEluZm8uaW5mby5zaXplIDogMTtcblxuICAgICAgICBsZXQgd2lkdGggPSAwO1xuXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckNvZGVBdCggaSApO1xuICAgICAgICAgICAgY29uc3QgY2hhckluZm8gPSBmb250SW5mby5jaGFyc1tjaGFyXTtcblxuICAgICAgICAgICAgd2lkdGggKz0gY2hhckluZm8ueGFkdmFuY2UgKiBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGg7ICAgICAgICBcbiAgICB9XG59XG5cblxuIiwiaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcclxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBDb21wb25lbnRIb2xkZXIgfSBmcm9tICcuL0NvbXBvbmVudEhvbGRlcic7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiDsnbQg7YG0656Y7Iqk66W8IOyDgeyGje2VtOyEnCDquLDriqXsnYQg6rWs7ZiE7ZWc64ukLlxyXG4gKiDsu7Ttj6zrhIztirjripQgQ29tcG9uZW50SG9sZGVy7JeQIOyekOycoOuhreqyjCBhZGQsIHJlbW92Ze2VoCDsiJgg7J6I64ukLlxyXG4gKiBhZGQg65CgIOuVjOuKlCBvbkFkZCggaG9sZGVyICnqsIAgcmVtb3ZlIOuQoCDrlYzripQgb25SZW1vdmUoIGhvbGRlciAp6rCAIO2YuOy2nOuQnOuLpC5cclxuICogXHJcbiAqIEBjbGFzcyBDb21wb25lbnRcclxuICogXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIC8qKiBcclxuICAgICAgICAvLyAgKiDsu7Ttj6zrhIztirjqsIAgaG9sZGVy7JeQIOy2lOqwgOuQoCDrlYwg7Zi47Lac65Cc64ukLlxyXG4gICAgICAgIC8vICAqIEBjYWxsYmFja1xyXG4gICAgICAgIC8vICAqIEBwYXJhbSB7Q29tcG9uZW50SG9sZGVyPX0gaG9sZGVyXHJcbiAgICAgICAgLy8gICogQG1lbWJlcm9mIENvbXBvbmVudFxyXG4gICAgICAgIC8vICAqL1xyXG4gICAgICAgIC8vIHRoaXMub25BZGRlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyAvKiogXHJcbiAgICAgICAgLy8gICog7Lu07Y+s64SM7Yq46rCAIGhvbGRlcuyXkOyEnCDrtoTrpqzrkKAg65WMIO2YuOy2nOuQnOuLpC5cclxuICAgICAgICAvLyAgKiBAY2FsbGJhY2tcclxuICAgICAgICAvLyAgKiBAcGFyYW0ge0NvbXBvbmVudEhvbGRlcj19IGhvbGRlclxyXG4gICAgICAgIC8vICAqIEBtZW1iZXJvZiBDb21wb25lbnRcclxuICAgICAgICAvLyAgKi9cclxuICAgICAgICAvLyB0aGlzLm9uUmVtb3ZlZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIOydtCDsu7Ttj6zrhIztirjqsIAg67aZ7J2AIENvbXBvbmVudEhvbGRlciDqsJzssrQuXHJcbiAgICAgICAgICog7J20IOqwnOyytOuKlCBhZGRFdmVudExpc3RlbmVy66W8IO2bhO2Cue2VtOyEnCDsoIDsnqXtlbTrkZDqs6Ag7J6I7Jy866+A66GcXHJcbiAgICAgICAgICog66qF7Iuc7KCB7Jy866GcIOu2hOumrO2VmOyngCDslYrslYTrj4Qg7J6Q64+Z7Jy866GcIOyymOumrOuQnOuLpC5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7Q29tcG9uZW50SG9sZGVyfVxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaG9sZGVyID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLFtdPn0gKi9cclxuICAgICAgICB0aGlzLl9fc2F2ZWRIYW5kbGVycyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdGhpcy5fX25hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICB9XHJcbiAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiDsnbQg6rCc7LK07JeQIO2KuOumrOqxsOulvCDstpTqsIDtlaAg7IiYIOyeiOuPhOuhnSBUcmlnZ2VyYWJsZSBQcm94eeulvCDrsJjtmZjtlZzri6RcclxuICAgICAqIFxyXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudH0gLSBFdmVudERpc3BhdGNoZXLsnZggUHJveHnrpbwg66as7YS07ZWc64ukXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHRyaWdnZXJhYmxlKCkge1xyXG4gICAgICAgIC8vIEV2ZW50RGlzcGF0Y2hlcuydmCB0cmlnZ2VyYWJsZeydhCDruYzroKTshJwg7JO064ukLlxyXG4gICAgICAgIC8vIGRpc3BhdGNoRXZlbnTrpbwg6rWs7ZiE7ZaI6riwIOuVjOusuOyXkCDruYzroKTsjajrj4Qg6rSc7LCu64ukLlxyXG4gICAgICAgIHJldHVybiBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnRyaWdnZXJhYmxlLmNhbGwoIHRoaXMgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOydtCDqsJzssrTsnZggaG9sZGVy6rCAIOyGjOycoO2VnCDsnbTrsqTtirjrpbwg7IOd7ISx7ZWc64ukLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD19IGV4dGVuZWRWYWx1ZXMgXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGV2ZW50TmFtZSBcclxuICAgICAqIEByZXR1cm5zIHtFdmVudH1cclxuICAgICAqIEBtZW1iZXJvZiBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgbmV3RXZlbnQoIGV4dGVuZWRWYWx1ZXMsZXZlbnROYW1lICkge1xyXG4gICAgICAgIHJldHVybiBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm5ld0V2ZW50LmNhbGwoIHRoaXMuaG9sZGVyLCBleHRlbmVkVmFsdWVzLCBldmVudE5hbWUgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICog7J20IOqwnOyytOydmCBob2xkZXLqsIAg7IaM7Jyg7ZWcIO2KuOumrOqxsOulvCDsg53shLHtlZzri6QuXHJcbiAgICAgKiDtirjrpqzqsbDripQg7J20IOqwnOyytOydmCDtirnsoJUg7ZSE66Gc7Y287Yuw6rCS7J20IOuwlOuAlCDrlYwg7J6Q64+Z7Jy866GcIOydtOuypO2KuOqwgCDrsJzsg53rkJjrj4TroZ0g7ZWgIOyImCDsnojri6QuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIO2KuOumrOqxsOulvCDqsbgg7ZSE66Gc7Y287Yuw7J2YIOuqqeuhnS4geyBhOnRydWUsIGI6ZmFsc2UgfSDroZwg7ZWY66m0IGHsl5DripQg6rG46rOgIGLsl5DripQg7KeA7Jq064ukLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbj19IGZpbHRlckZ1bmN0aW9uIC0gdHJ1ZeulvCDrpqzthLTtlZwg6rK97Jqw7JeQ66eMIOydtOuypO2KuOqwgCDsi6TtlonrkJzri6RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZXZlbnROYW1lIC0g7IOd65617ZWY66m0IOyekOuPmeycvOuhnCDsnbTrsqTtirgg7J2066aE7J20IOu2gOyXrOuQnOuLpFxyXG4gICAgICogQHJldHVybnMge0V2ZW50fVxyXG4gICAgICogQG1lbWJlcm9mIENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBuZXdUcmlnZ2VyKCBwcm9wcywgZmlsdGVyRnVuY3Rpb24sIGV2ZW50TmFtZSApIHtcclxuICAgICAgICByZXR1cm4gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5uZXdUcmlnZ2VyLmNhbGwoIHRoaXMsIHByb3BzLCBmaWx0ZXJGdW5jdGlvbiwgZXZlbnROYW1lICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDsu7Ttj6zrhIztirjsnZgg7J2066aE7J2EIOuPjOugpOykgOuLpFxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBnZXROYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOy7tO2PrOuEjO2KuOydmCDsnbTrpoTsnYQg7ISk7KCV7ZWc64ukLiDquLDrs7gg6rCS7J2AIO2BtOuemOyKpCDsnbTrpoTsnbTri6QuXHJcbiAgICAgKiDsnbQg6rCS7J2EIOuwlOq/lOyEnCDqsJnsnYAg7YOA7J6F7J2YIOy7tO2PrOuEjO2KuOulvCDsl6zrn6zqsJwg67aZ7J28IOyImCDsnojri6QuXHJcbiAgICAgKiDrp4zslb0g7J2066aE7J20IOqwmeuLpOuptCDsm5Drnpgg7J6I642YIOy7tO2PrOuEjO2KuOuKlCDrtoTrpqzrkJzri6QuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2XHJcbiAgICAgKiBAbWVtYmVyb2YgQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHNldE5hbWUoIHYgKSB7XHJcbiAgICAgICAgdGhpcy5fX25hbWUgPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fHN0cmluZ30gZXZlbnRPck5hbWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gZXh0ZW5kZWRWYWx1ZXNcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQG1lbWJlcm9mIENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBkaXNwYXRjaEV2ZW50KCBldmVudE9yTmFtZSwgZXh0ZW5kZWRWYWx1ZXMgKSB7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoIHRoaXMuaG9sZGVyLCBg7Lu07Y+s64SM7Yq4IO2ZgOuNlOqwgCDsl4bripTrjbAg7J2067Kk7Yq466W8IOuwnOyDneyLnO2CpOugpOqzoCDtlZzri6RgICk7XHJcbiAgICAgICAgbGV0IGV2ZW50O1xyXG5cclxuICAgICAgICBpZiAoIHR5cGVvZiBldmVudE9yTmFtZSA9PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICBldmVudCA9IG5ldyBFdmVudCggZXZlbnRPck5hbWUgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudCA9IGV2ZW50T3JOYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcy5ob2xkZXI7XHJcbiAgICAgICAgZXZlbnQuY29tcG9uZW50ID0gdGhpcztcclxuICAgICAgICBPYmplY3QuYXNzaWduKCBldmVudCxleHRlbmRlZFZhbHVlcyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5ob2xkZXIuZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaXNBZGRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob2xkZXIgIT0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVGcm9tSG9sZGVyKCkge1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KCB0aGlzLmhvbGRlciwgYOy7tO2PrOuEjO2KuCDtmYDrjZTqsIAg7JeG64qU642wIOygnOqxsO2VmOugpOqzoCDtlZzri6RgICk7XHJcbiAgICAgICAgdGhpcy5ob2xkZXIucmVtb3ZlQ29tcG9uZW50KCB0aGlzICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi9VdGlscyc7XG5cbmNvbnN0IHNlYXJjaE1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cblxuZXhwb3J0IGNsYXNzIENvbXBvbmVudEhvbGRlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX19jb21wb25lbnRzID0ge307XG4gICAgfVxuXG4gICAgYWRkQ29tcG9uZW50KCBjb20gKSB7XG4gICAgICAgIGNvbnN0IGNvbU5hbWUgPSBjb20uZ2V0TmFtZSgpO1xuXG4gICAgICAgIGlmICggY29tLmhvbGRlciAhPSBudWxsICkge1xuICAgICAgICAgICAgLy8g67aZ7J2066Ck64qUIOy7tO2PrOuEjO2KuOqwgCDri6TrpbjrjbAg67aZ7Ja07J6I7JeI642YIOqyveyasCDsoJzqsbBcbiAgICAgICAgICAgIGNvbS5yZW1vdmVGcm9tSG9sZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCB0aGlzLl9fY29tcG9uZW50c1tjb21OYW1lXSAhPSBudWxsICkge1xuICAgICAgICAgICAgLy8g6rCZ7J2AIOydtOumhOydmCDsu7Ttj6zrhIztirjqsIAg67aZ7Ja07J6I642YIOqyveyasCDsnbTsoIQg7Lu07Y+s64SM7Yq466W8IOygnOqxsFxuICAgICAgICAgICAgdGhpcy5fX2NvbXBvbmVudHNbY29tTmFtZV0ucmVtb3ZlRnJvbUhvbGRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jb21wb25lbnRzW2NvbU5hbWVdID0gY29tO1xuICAgICAgICBjb25zdCBhcnIgPSBzZWFyY2hNYXAuZ2V0KCBjb20uY29uc3RydWN0b3IgKSB8fCBbXTtcblxuICAgICAgICBpZiAoICFhcnIuaW5jbHVkZXMoIGNvbSApICkge1xuICAgICAgICAgICAgYXJyLnB1c2goIGNvbSApO1xuICAgICAgICAgICAgc2VhcmNoTWFwLnNldCggY29tLmNvbnN0cnVjdG9yLGFyciApO1xuICAgICAgICB9XG4gICAgICAgIGNvbS5ob2xkZXIgPSBuZXcgUHJveHkoIHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKCB0LGsgKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCBrID09IFwiYWRkRXZlbnRMaXN0ZW5lclwiICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGV2ZW50TmFtZSwgZnVuYywgY29udGV4dCwgaXNPbmNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGAke2NvbU5hbWV97J2YICR7ZXZlbnROYW1lfeydtOuypO2KuCDtlbjrk6Trn6zrpbwg7ZuE7YK57ZW07IScIOyggOyepe2VnOuLpGAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbS5fX3NhdmVkSGFuZGxlcnMgPSBjb20uX19zYXZlZEhhbmRsZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tLl9fc2F2ZWRIYW5kbGVyc1tldmVudE5hbWVdID0gY29tLl9fc2F2ZWRIYW5kbGVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tLl9fc2F2ZWRIYW5kbGVyc1tldmVudE5hbWVdLnB1c2goIFtmdW5jLGNvbnRleHRdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL+ybkOuzuOydhCDsi6TtlontlbTspIDri6RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgdC5hZGRFdmVudExpc3RlbmVyKCAuLi5hcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgcmV0dXJuIHRba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gKTtcbiAgICAgICAgaWYgKCBjb20ub25BZGRlZCApIHtcbiAgICAgICAgICAgIGNvbS5vbkFkZGVkLmNhbGwoIGNvbSwgY29tLmhvbGRlciApO1xuICAgICAgICB9IGVsc2UgaWYgKCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIGNvbSApLm9uQWRkZWQgKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIGNvbSApLm9uQWRkZWQuY2FsbCggY29tLCBjb20uaG9sZGVyICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvbXBvbmVudCggY2xhc3NUeXBlLG9iaiApIHtcbiAgICAgICAgY29uc3QgbmV3Q29tID0gbmV3IGNsYXNzVHlwZSgpO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KCBPYmplY3QuYXNzaWduKCBuZXdDb20sb2JqICkgKTtcblxuICAgICAgICByZXR1cm4gbmV3Q29tO1xuICAgIH1cblxuXG4gICAgcmVtb3ZlQ29tcG9uZW50KCBjb20gKSB7XG4gICAgICAgIGlmICggdHlwZW9mIGNvbSA9PSBcImZ1bmN0aW9uXCIgJiYgY29tLnByb3RvdHlwZSAhPSBudWxsICkge1xuICAgICAgICAgICAgLy8gQ2xhc3NUeXBl7Jy866GcIOyCreygnOulvCDsi5zrj4TtlZjripQg6rK97JqwXG4gICAgICAgICAgICAvLyDtlbTri7kg7YOA7J6F7J2YIOy7tO2PrOuEjO2KuOulvCDrqqjrkZAg7IKt7KCc7ZWc64ukXG4gICAgICAgICAgICBmb3IgKCBjb25zdCBrZXkgaW4gdGhpcy5fX2NvbXBvbmVudHMgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBjb20uZ2V0TmFtZSgpID09IGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb21wb25lbnQoIHRoaXMuX19jb21wb25lbnRzW2tleV0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21OYW1lID0gY29tLmdldE5hbWUoKTtcblxuICAgICAgICBpZiAoIGNvbS5vblJlbW92ZWQgKSB7XG4gICAgICAgICAgICBjb20ub25SZW1vdmVkLmNhbGwoIGNvbSwgY29tLmhvbGRlciApO1xuICAgICAgICB9IGVsc2UgaWYgKCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoIGNvbSApLm9uUmVtb3ZlZCApIHtcbiAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiggY29tICkub25SZW1vdmVkLmNhbGwoIGNvbSwgY29tLmhvbGRlciApO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9fY29tcG9uZW50c1tjb21OYW1lXTtcblxuICAgICAgICBpZiAoIGNvbS5fX3NhdmVkSGFuZGxlcnMgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyggYCR7Y29tTmFtZX3snZgg7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsoJXrpqztlZzri6RgICk7XG4gICAgICAgICAgICBmb3IgKCBjb25zdCBldmVudE5hbWUgaW4gY29tLl9fc2F2ZWRIYW5kbGVycyApIHtcbiAgICAgICAgICAgICAgICBmb3IgKCBjb25zdCBbZnVuYyxjb250ZXh0XSBvZiBjb20uX19zYXZlZEhhbmRsZXJzW2V2ZW50TmFtZV0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBgJHtldmVudE5hbWV9IOydtOuypO2KuCDtlbjrk6Trn6wg7IKt7KCcYCApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSxmdW5jLGNvbnRleHQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcnIgPSBzZWFyY2hNYXAuZ2V0KCBjb20uY29uc3RydWN0b3IgKTtcblxuICAgICAgICBjb25zb2xlLmFzc2VydCggQXJyYXkuaXNBcnJheSggYXJyICkgKTtcbiAgICAgICAgY29uc3QgaSA9IGFyci5pbmRleE9mKCBjb20gKTtcblxuICAgICAgICBpZiAoIGkgPj0gMCApIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoIGksMSApO1xuICAgICAgICAgICAgaWYgKCBhcnIubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hNYXAuc2V0KCBjb20uY29uc3RydWN0b3IsYXJyICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlYXJjaE1hcC5kZWxldGUoIGNvbS5jb25zdHJ1Y3RvciApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzQ29tcG9uZW50KCBjb21UeXBlICkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvbXBvbmVudHNbY29tVHlwZS5uYW1lXSAhPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBjb21wb25lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvbXBvbmVudHM7XG4gICAgfVxuXG4gICAgZ2V0Q29tcG9uZW50KCBjb21UeXBlICkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvbXBvbmVudHNbdHlwZW9mIGNvbVR5cGUgPT0gXCJzdHJpbmdcIiA/IGNvbVR5cGUgOiBjb21UeXBlLm5hbWVdO1xuICAgIH1cblxuICAgIGdldENvbXBhdGlibGVDb21wb25lbnRzKCBjb21UeXBlICkge1xuICAgICAgICBjb25zdCByID0gW107XG5cbiAgICAgICAgZm9yICggY29uc3QgY29tTmFtZSBpbiB0aGlzLl9fY29tcG9uZW50cyApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbSA9IHRoaXMuX19jb21wb25lbnRzW2NvbU5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoIGNvbSBpbnN0YW5jZW9mIGNvbVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgci5wdXNoKCBjb20gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBbGxDb21wb25lbnRzKCBjb21UeXBlICkge1xuICAgICAgICByZXR1cm4gc2VhcmNoTWFwLmdldCggY29tVHlwZSApO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBbGxDb21wb25lbnRIb2xkZXJzKCAuLi5jb21UeXBlcyApIHtcbiAgICAgICAgbGV0IGFycjtcblxuICAgICAgICBhcnIgPSB0aGlzLmdldEFsbENvbXBvbmVudHMoIGNvbVR5cGVzWzBdICk7XG4gICAgICAgIGZvciAoIGxldCBpID0gMTsgaSA8IGNvbVR5cGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgY29uc3QgYXJyMiA9IHRoaXMuZ2V0QWxsQ29tcG9uZW50cyggY29tVHlwZXNbaV0gKTtcblxuICAgICAgICAgICAgYXJyID0gYXJyMi5maWx0ZXIoICggdixpLGEgKSA9PiBhcnIuaW5jbHVkZXMoIHYgKSApO1xuICAgICAgICB9XG4gXG4gICAgICAgIGNvbnN0IHIgPSBbXTtcblxuICAgICAgICBmb3IgKCBjb25zdCBuIG9mIGFyciApIHtcbiAgICAgICAgICAgIHIucHVzaCggbi5ob2xkZXIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGhhc0FsbENvbXBvbmVudHMoIC4uLmNvbVR5cGVzICkge1xuICAgICAgICBmb3IgKCBjb25zdCBjb21UeXBlIG9mIGNvbVR5cGVzICkge1xuICAgICAgICAgICAgaWYgKCAhdGhpcy5oYXNDb21wb25lbnQoIGNvbVR5cGUgKSApIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbkNvbXBvbmVudEhvbGRlci5yZWdpc3RlcmVkSG9sZGVycyA9IHt9O1xuXG4iLCJcclxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL0NvbXBvbmVudFwiKS5Db21wb25lbnR9IENvbXBvbmVudCAqL1xyXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4vU3ByaXRlXCIpLlNwcml0ZX0gU3ByaXRlICovXHJcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9FdmVudERpc3BhdGNoZXJcIikuRXZlbnREaXNwYXRjaGVyfSBFdmVudERpc3BhdGNoZXIgKi9cclxuXHJcbi8qKlxyXG4gKiBcclxuICogQGNsYXNzIEV2ZW50XHJcbiAgKi9cclxuZXhwb3J0IGNsYXNzIEV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICpDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEV2ZW50LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD19IGV4dGVuZGVkVmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50RGlzcGF0Y2hlcj19IG93bmVyXHJcbiAgICAgKiBAbWVtYmVyb2YgRXZlbnRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoIG5hbWUgPSBcIkBFVkVOVFwiICsgKCArK0V2ZW50Lm5leHRJZCApLCBleHRlbmRlZFZhbHVlcyxvd25lciApIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7RXZlbnREaXNwYXRjaGVyfSAqL1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7Q29tcG9uZW50fSAqL1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7RXZlbnREaXNwYXRjaGVyfSAqL1xyXG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuICAgICAgICB0aGlzLmZvcndhcmRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIGV4dGVuZGVkVmFsdWVzICkge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKCB0aGlzLCBleHRlbmRlZFZhbHVlcyApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgRXZlbnRcclxuICAgICAqL1xyXG4gICAgb24oIGZ1bmMsIGNvbnRleHQgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLm93bmVyID09IG51bGwgKSB0aGlzLm93bmVyID0gbmV3IEV2ZW50LkV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgICAgIHRoaXMub3duZXIub24oIHRoaXMubmFtZSwgZnVuYywgY29udGV4dCApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgRXZlbnRcclxuICAgICAqL1xyXG4gICAgb25jZSggZnVuYywgY29udGV4dCApIHtcclxuICAgICAgICBpZiAoIHRoaXMub3duZXIgPT0gbnVsbCApIHRoaXMub3duZXIgPSBuZXcgRXZlbnQuRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgICAgICAgdGhpcy5vd25lci5vbmNlKCB0aGlzLm5hbWUsIGZ1bmMsIGNvbnRleHQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gY29udGV4dFxyXG4gICAgICogQHBhcmFtIHtTcHJpdGU9fSByZWZTcHJpdGVcclxuICAgICAqIEByZXR1cm5zIHtFdmVudH1cclxuICAgICAqIEBtZW1iZXJvZiBFdmVudFxyXG4gICAgICovXHJcbiAgICBvblN0YWdlKCBmdW5jLCBjb250ZXh0LHJlZlNwcml0ZSApIHtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICBjb25zb2xlLmFzc2VydCggdGhpcy5vd25lciAmJiB0aGlzLm93bmVyLmFkZENoaWxkLCBcIlNwcml0ZeqwgCDslYTri4jrqbQgb25TdGFnZeulvCDtlaAg7IiYIOyXhuyKteuLiOuLpC5cIiApO1xyXG4gICAgICAgIHRoaXMub3duZXIub25TdGFnZSggdGhpcy5uYW1lLCBmdW5jLCBjb250ZXh0LCByZWZTcHJpdGUgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gY29udGV4dFxyXG4gICAgICogQHJldHVybnMge0V2ZW50fVxyXG4gICAgICogQG1lbWJlcm9mIEV2ZW50XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZSggZnVuYywgY29udGV4dCApIHtcclxuICAgICAgICBpZiAoIHRoaXMub3duZXIgPT0gbnVsbCApIHRoaXMub3duZXIgPSBuZXcgRXZlbnQuRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgICAgICAgdGhpcy5vd25lci5yZW1vdmVFdmVudExpc3RlbmVyKCB0aGlzLm5hbWUsIGZ1bmMsIGNvbnRleHQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gZXh0ZW5kZWRWYWx1ZXNcclxuICAgICAqIEByZXR1cm5zIHtFdmVudH1cclxuICAgICAqIEBtZW1iZXJvZiBFdmVudFxyXG4gICAgICovXHJcbiAgICBkaXNwYXRjaCggZXh0ZW5kZWRWYWx1ZXMgKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLm93bmVyID09IG51bGwgKSB0aGlzLm93bmVyID0gbmV3IEV2ZW50LkV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIHRoaXMsIGV4dGVuZGVkVmFsdWVzICk7XHJcbiAgICAgICAgdGhpcy5vd25lci5kaXNwYXRjaEV2ZW50KCB0aGlzICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaXNJbnB1dEV2ZW50KCBldmVudE5hbWUgKSB7XHJcbiAgICAgICAgY29uc3QgYXR0ID0gRXZlbnQuZXZlbnRBdHRyaWJzW2V2ZW50TmFtZV07XHJcblxyXG4gICAgICAgIGlmICggYXR0ICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdHQuaXNJbnB1dCA9PSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuRXZlbnQuU1RBR0VfVklTSUJMRSA9IFwic3RhZ2VWaXNpYmxlXCI7XHJcbkV2ZW50LlNUQUdFX0ZPQ1VTID0gXCJzdGFnZUZvY3VzXCI7XHJcbkV2ZW50LkVOVEVSX0ZSQU1FID0gXCJlbnRlckZyYW1lXCI7XHJcbkV2ZW50LlJFTkRFUiA9IFwicmVuZGVyXCI7XHJcbkV2ZW50LkFEREVEX1RPX1NUQUdFID0gXCJhZGRlZFRvU3RhZ2VcIjtcclxuRXZlbnQuUkVNT1ZFRF9GUk9NX1NUQUdFID0gXCJyZW1vdmVkRnJvbVN0YWdlXCI7XHJcbkV2ZW50LlBPSU5URVJfRE9XTiA9IFwicG9pbnRlckRvd25cIjtcclxuRXZlbnQuUE9JTlRFUl9VUCA9IFwicG9pbnRlclVwXCI7XHJcbkV2ZW50LlBPSU5URVJfTU9WRSA9IFwicG9pbnRlck1vdmVcIjtcclxuRXZlbnQuTU9VU0VfRE9XTiA9IFwibW91c2VEb3duXCI7XHJcbkV2ZW50Lk1PVVNFX1VQID0gXCJtb3VzZVVwXCI7XHJcbkV2ZW50Lk1PVVNFX01PVkUgPSBcIm1vdXNlTW92ZVwiO1xyXG5FdmVudC5NT1VTRV9XSEVFTCA9IFwibW91c2VXaGVlbFwiO1xyXG5FdmVudC5UT1VDSEVTX0JFR0lOID0gXCJ0b3VjaGVzQmVnaW5cIjtcclxuRXZlbnQuVE9VQ0hFU19NT1ZFID0gXCJ0b3VjaGVzTW92ZVwiO1xyXG5FdmVudC5UT1VDSEVTX0VORCA9IFwidG91Y2hlc0VuZFwiO1xyXG5FdmVudC5UT1VDSEVTX0NBTkNFTCA9IFwidG91Y2hlc0NhbmNlbFwiO1xyXG5FdmVudC5LRVlfVVAgPSBcImtleVVwXCI7XHJcbkV2ZW50LktFWV9ET1dOID0gXCJrZXlEb3duXCI7XHJcbkV2ZW50LlRJTUVSID0gXCJ0aW1lclwiO1xyXG5FdmVudC5URVhUVVJFX1VQREFURSA9IFwidGV4dHVyZVVwZGF0ZVwiO1xyXG5FdmVudC5SRVNJWkUgPSBcInJlc2l6ZVwiO1xyXG5FdmVudC5SRUFEWSA9IFwicmVhZHlcIjtcclxuRXZlbnQuQ09NUExFVEUgPSBcImNvbXBsZXRlXCI7XHJcbkV2ZW50LkVSUk9SID0gXCJlcnJvclwiO1xyXG5FdmVudC5CRUZPUkVfVVBEQVRFID0gXCJiZWZvcmVVcGRhdGVcIjtcclxuRXZlbnQuQUZURVJfVVBEQVRFID0gXCJhZnRlclVwZGF0ZVwiO1xyXG5FdmVudC5MT0FERUQgPSBcImxvYWRlZFwiO1xyXG5FdmVudC5BTEwgPSBcIipcIjtcclxuRXZlbnQuQVBQTElDQVRJT05fSU5JVCA9IFwiQVBQTElDQVRJT05fSU5JVFwiO1xyXG5FdmVudC5BUFBMSUNBVElPTl9TVEFSVCA9IFwiQVBQTElDQVRJT05fU1RBUlRcIjtcclxuXHJcbkV2ZW50LmV2ZW50QXR0cmlicyA9IHtcclxuICAgIFtFdmVudC5QT0lOVEVSX0RPV05dOiAgIHsgaXNJbnB1dDogdHJ1ZSB9LFxyXG4gICAgW0V2ZW50LlBPSU5URVJfVVBdOiAgICAgeyBpc0lucHV0OiB0cnVlIH0sXHJcbiAgICBbRXZlbnQuUE9JTlRFUl9NT1ZFXTogICB7IGlzSW5wdXQ6IHRydWUgfSxcclxuICAgIFtFdmVudC5NT1VTRV9ET1dOXTogICAgIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcIm1vdXNlXCIgfSxcclxuICAgIFtFdmVudC5NT1VTRV9VUF06ICAgICAgIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcIm1vdXNlXCIgfSxcclxuICAgIFtFdmVudC5NT1VTRV9NT1ZFXTogICAgIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcIm1vdXNlXCIgfSxcclxuICAgIFtFdmVudC5NT1VTRV9XSEVFTF06ICAgIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcIm1vdXNlXCIgfSxcclxuICAgIFtFdmVudC5UT1VDSEVTX0JFR0lOXTogIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcInRvdWNoXCIgfSxcclxuICAgIFtFdmVudC5UT1VDSEVTX0VORF06ICAgIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcInRvdWNoXCIgfSxcclxuICAgIFtFdmVudC5UT1VDSEVTX01PVkVdOiAgIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcInRvdWNoXCIgfSxcclxuICAgIFtFdmVudC5UT1VDSEVTX0NBTkNFTF06IHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcInRvdWNoXCIgfSxcclxuICAgIFtFdmVudC5LRVlfVVBdOiAgICAgICAgIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcImtleWJvYXJkXCIgfSxcclxuICAgIFtFdmVudC5LRVlfRE9XTl06ICAgICAgIHsgaXNJbnB1dDogdHJ1ZSwgZGV2aWNlOiBcImtleWJvYXJkXCIgfSxcclxufTtcclxuXHJcbkV2ZW50LkV2ZW50RGlzcGF0Y2hlciA9IHVuZGVmaW5lZDtcclxuRXZlbnQubmV4dElkID0gMDtcclxuXHJcblxyXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudGVtaXR0ZXIzXCI7XHJcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi9FdmVudCc7XHJcblxyXG4vLyBldmVudGVtaXR0ZXIz7JeQ7IScIF9ldmVudHMg7Y+0642U7JeQIOydtOuypO2KuOulvCDrs7TqtIDtlZzri6Tqs6Ag6rCA7KCV7ZWY6rOgIOyTsOyXrOynhCDsvZTrk5zsnoRcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog7J20IOqwnOyytOyXkCDtirjrpqzqsbDrpbwg7LaU6rCA7ZWgIOyImCDsnojrj4TroZ0gVHJpZ2dlcmFibGUgUHJveHnrpbwg67CY7ZmY7ZWc64ukXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm5zIHtFdmVudERpc3BhdGNoZXJ9IC0gRXZlbnREaXNwYXRjaGVy7J2YIFByb3h566W8IOumrO2EtO2VnOuLpFxyXG4gICAgICogQG1lbWJlcm9mIEV2ZW50RGlzcGF0Y2hlclxyXG4gICAgICovXHJcbiAgICB0cmlnZ2VyYWJsZSgpIHtcclxuICAgICAgICB0aGlzLl9fdHJpZ2dlcnMgPSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSggdGhpcywge1xyXG4gICAgICAgICAgICBzZXQoIHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIgKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gUmVmbGVjdC5zZXQoIHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJzID0gdGFyZ2V0Ll9fdHJpZ2dlcnNba2V5XTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHRyaWdnZXJzICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGNvbnN0IFtldmVudE5hbWUsIGZ1bmNdIG9mIHRyaWdnZXJzICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGZ1bmMgPT0gbnVsbCB8fCBmdW5jKCB0YXJnZXQsIGtleSApICkgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoIGV2ZW50TmFtZSwgeyBrZXkgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOydtCDqsJzssrTqsIAg7IaM7Jyg7ZWcIOydtOuypO2KuOulvCDsg53shLHtlZzri6QuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gZXh0ZW5lZFZhbHVlcyBcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZXZlbnROYW1lIFxyXG4gICAgICogQHJldHVybnMge0V2ZW50fVxyXG4gICAgICovXHJcbiAgICBuZXdFdmVudCggZXh0ZW5lZFZhbHVlcyxldmVudE5hbWUgKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudCggZXZlbnROYW1lLCBleHRlbmVkVmFsdWVzLCB0aGlzICk7XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICog7J20IOqwnOyytOqwgCDshozsnKDtlZwg7Yq466as6rGw66W8IOyDneyEse2VnOuLpC5cclxuICAgICAqIO2KuOumrOqxsOuKlCDsnbQg6rCc7LK07J2YIO2KueyglSDtlITroZztjbzti7DqsJLsnbQg67CU64CUIOuVjCDsnpDrj5nsnLzroZwg7J2067Kk7Yq46rCAIOuwnOyDneuQmOuPhOuhnSDtlaAg7IiYIOyeiOuLpC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0g7Yq466as6rGw66W8IOqxuCDtlITroZztjbzti7DsnZgg66qp66GdLiB7IGE6dHJ1ZSwgYjpmYWxzZSB9IOuhnCDtlZjrqbQgYeyXkOuKlCDqsbjqs6AgYuyXkOuKlCDsp4DsmrTri6QuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gZmlsdGVyRnVuY3Rpb24gLSB0cnVl66W8IOumrO2EtO2VnCDqsr3smrDsl5Drp4wg7J2067Kk7Yq46rCAIOyLpO2WieuQnOuLpFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBldmVudE5hbWUgLSDsg53rnrXtlZjrqbQg7J6Q64+Z7Jy866GcIOydtOuypO2KuCDsnbTrpoTsnbQg67aA7Jes65Cc64ukXHJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIG5ld1RyaWdnZXIoIHByb3BzLCBmaWx0ZXJGdW5jdGlvbiwgZXZlbnROYW1lICkge1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KCB0aGlzLl9fdHJpZ2dlcnMgIT0gbnVsbCwgXCLsnbQg6rCc7LK064qUIHRyaWdnZXJhYmxl7J20IOyVhOuLmeuLiOuLpC5cIiApO1xyXG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRXZlbnQoIGV2ZW50TmFtZSApO1xyXG5cclxuICAgICAgICBmb3IgKCBjb25zdCBwcm9wIGluIHByb3BzICkge1xyXG4gICAgICAgICAgICBpZiAoIHByb3BzW3Byb3BdICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3RyaWdnZXJzW3Byb3BdID0gdGhpcy5fX3RyaWdnZXJzW3Byb3BdICE9IG51bGwgPyB0aGlzLl9fdHJpZ2dlcnNbcHJvcF0gOiBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX190cmlnZ2Vyc1twcm9wXS5wdXNoKCBbZS5uYW1lLCBmaWx0ZXJGdW5jdGlvbl0gKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fdHJpZ2dlcnNbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc0V2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuZXJzKCBldmVudE5hbWUgKS5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXHJcbiAgICAgKiBAcGFyYW0ge2FueT19IGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzT25jZT1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtFdmVudERpc3BhdGNoZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgRXZlbnREaXNwYXRjaGVyXHJcbiAgICAgKi9cclxuICAgIGFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgZnVuYywgY29udGV4dCA9IG51bGwsIGlzT25jZSA9IGZhbHNlICkge1xyXG4gICAgICAgIGlmICggaXNPbmNlICkge1xyXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIub25jZSggZXZlbnROYW1lLCBmdW5jLCBjb250ZXh0IHx8IHRoaXMgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIub24oIGV2ZW50TmFtZSwgZnVuYywgY29udGV4dCB8fCB0aGlzICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGV2ZW50TmFtZSA9PSBFdmVudC5FTlRFUl9GUkFNRSB8fCBldmVudE5hbWUgPT0gRXZlbnQuUkVOREVSICkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIEV2ZW50LkFEREVEX1RPX1NUQUdFLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIEV2ZW50RGlzcGF0Y2hlci5lbnRlckZyYW1lTGlzdC5zZXQoIHRoaXMsdGhpcy5ldmVudEVtaXR0ZXIuX2V2ZW50c1tldmVudE5hbWVdICE9IG51bGwgPyB0aGlzLmV2ZW50RW1pdHRlci5fZXZlbnRzW2V2ZW50TmFtZV0ubGVuZ3RoIDogMSApO1xyXG4gICAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggRXZlbnQuUkVNT1ZFRF9GUk9NX1NUQUdFLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBFdmVudERpc3BhdGNoZXIuZW50ZXJGcmFtZUxpc3QuZGVsZXRlKCB0aGlzICk7XHJcbiAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgICB0aGlz6rCAIHNwcml0ZeuhnCDqsIDsoJVcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmlzT25TdGFnZSgpICkge1xyXG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICBFdmVudERpc3BhdGNoZXIuZW50ZXJGcmFtZUxpc3Quc2V0KCB0aGlzLHRoaXMuZXZlbnRFbWl0dGVyLl9ldmVudHNbZXZlbnROYW1lXSAhPSBudWxsID8gdGhpcy5ldmVudEVtaXR0ZXIuX2V2ZW50c1tldmVudE5hbWVdLmxlbmd0aCA6IDEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICggRXZlbnQuaXNJbnB1dEV2ZW50KCBldmVudE5hbWUgKSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzSW5wdXRFdmVudHMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHBhcmFtIHthbnk9fSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc09uY2U9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnREaXNwYXRjaGVyfVxyXG4gICAgICogQG1lbWJlcm9mIEV2ZW50RGlzcGF0Y2hlclxyXG4gICAgICovXHJcbiAgICBhZGRVbmlxdWVFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIGZ1bmMsIGNvbnRleHQsIGlzT25jZSA9IGZhbHNlICkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBmdW5jLCBjb250ZXh0ICk7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIGZ1bmMsIGNvbnRleHQsIGlzT25jZSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnR8c3RyaW5nfSBldmVudE9yTmFtZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBleHRlbmRlZFZhbHVlc1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0g7J2067Kk7Yq4IO2VuOuTpOufrOqwgCDsnojsnLzrqbQgdHJ1ZVxyXG4gICAgICogQG1lbWJlcm9mIEV2ZW50RGlzcGF0Y2hlclxyXG4gICAgICovXHJcbiAgICBkaXNwYXRjaEV2ZW50KCBldmVudE9yTmFtZSxleHRlbmRlZFZhbHVlcyApIHtcclxuICAgICAgICBsZXQgZXZlbnQ7XHJcblxyXG4gICAgICAgIGlmICggdHlwZW9mIGV2ZW50T3JOYW1lID09IFwic3RyaW5nXCIgKSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50KCBldmVudE9yTmFtZSApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRPck5hbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIGV2ZW50LGV4dGVuZGVkVmFsdWVzICk7XHJcblxyXG4gICAgICAgIGlmICggIWV2ZW50LmZvcndhcmRlZCApIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoIFwiKlwiLGV2ZW50ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCBldmVudC5uYW1lLCBldmVudCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXHJcbiAgICAgKiBAcGFyYW0ge2FueT19IGNvbnRleHRcclxuICAgICAqIEBtZW1iZXJvZiBFdmVudERpc3BhdGNoZXJcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBmdW5jLCBjb250ZXh0ICkge1xyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCBldmVudE5hbWUsIGZ1bmMsIGNvbnRleHQgfHwgdGhpcyApO1xyXG5cclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICBpZiAoICggZXZlbnROYW1lID09IEV2ZW50LkVOVEVSX0ZSQU1FIHx8IGV2ZW50TmFtZSA9PSBFdmVudC5SRU5ERVIgKSAmJiAoIHRoaXMuZXZlbnRFbWl0dGVyLl9ldmVudHNbZXZlbnROYW1lXSA9PSBudWxsIHx8IHRoaXMuZXZlbnRFbWl0dGVyLl9ldmVudHNbZXZlbnROYW1lXS5sZW5ndGggPT0gMCApICkge1xyXG4gICAgICAgICAgICBFdmVudERpc3BhdGNoZXIuZW50ZXJGcmFtZUxpc3QuZGVsZXRlKCB0aGlzICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIEV2ZW50LmlzSW5wdXRFdmVudCggZXZlbnROYW1lICkgKSB7XHJcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBmb3IgKCBjb25zdCBpIGluIHRoaXMuZXZlbnRFbWl0dGVyLl9ldmVudHMgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIEV2ZW50LmlzSW5wdXRFdmVudCggaSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzSW5wdXRFdmVudHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGV2ZW50TmFtZVxyXG4gICAgICogQG1lbWJlcm9mIEV2ZW50RGlzcGF0Y2hlclxyXG4gICAgICovXHJcbiAgICByZW1vdmVBbGxFdmVudExpc3RlbmVycyggZXZlbnROYW1lICkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyggZXZlbnROYW1lICk7XHJcblxyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIGlmICggKCBldmVudE5hbWUgPT0gRXZlbnQuRU5URVJfRlJBTUUgfHwgZXZlbnROYW1lID09IEV2ZW50LlJFTkRFUiApICYmICggZXZlbnROYW1lICYmIHRoaXMuZXZlbnRFbWl0dGVyLl9ldmVudHNbZXZlbnROYW1lXSA9PSBudWxsIHx8IHRoaXMuZXZlbnRFbWl0dGVyLl9ldmVudHNbZXZlbnROYW1lXS5sZW5ndGggPT0gMCApICkge1xyXG4gICAgICAgICAgICBFdmVudERpc3BhdGNoZXIuZW50ZXJGcmFtZUxpc3QuZGVsZXRlKCB0aGlzICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIGV2ZW50TmFtZSAmJiBFdmVudC5pc0lucHV0RXZlbnQoIGV2ZW50TmFtZSApICkge1xyXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgZm9yICggY29uc3QgaSBpbiB0aGlzLmV2ZW50RW1pdHRlci5fZXZlbnRzICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBFdmVudC5pc0lucHV0RXZlbnQoIGkgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc0lucHV0RXZlbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHBhcmFtIHthbnk9fSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50RGlzcGF0Y2hlcn0gW3JlZlNwcml0ZT10aGlzXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNPbmNlPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0V2ZW50RGlzcGF0Y2hlcn1cclxuICAgICAqIEBtZW1iZXJvZiBFdmVudERpc3BhdGNoZXJcclxuICAgICAqL1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lck9uU3RhZ2UoIGV2ZW50LCBmdW5jLCBjb250ZXh0LCByZWZTcHJpdGUgPSB0aGlzLCBpc09uY2UgPSBmYWxzZSApIHtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgY29uc3Qgb25BZGRlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCBldmVudCwgZnVuYywgY29udGV4dCwgaXNPbmNlICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgb25SZW1vdmVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2ZW50LCBmdW5jLCBjb250ZXh0ICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmVmU3ByaXRlLmFkZEV2ZW50TGlzdGVuZXIoIEV2ZW50LkFEREVEX1RPX1NUQUdFLCBvbkFkZGVkLCB0aGlzICk7XHJcbiAgICAgICAgcmVmU3ByaXRlLmFkZEV2ZW50TGlzdGVuZXIoIEV2ZW50LlJFTU9WRURfRlJPTV9TVEFHRSwgb25SZW1vdmVkLCB0aGlzICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXHJcbiAgICAgKiBAcGFyYW0ge2FueT19IGNvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHtFdmVudERpc3BhdGNoZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgRXZlbnREaXNwYXRjaGVyXHJcbiAgICAgKi9cclxuICAgIG9uKCBldmVudE5hbWUsIGZ1bmMsIGNvbnRleHQgKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBmdW5jLCBjb250ZXh0ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcclxuICAgICAqIEBwYXJhbSB7YW55PX0gY29udGV4dFxyXG4gICAgICogQHJldHVybnMge0V2ZW50RGlzcGF0Y2hlcn1cclxuICAgICAqIEBtZW1iZXJvZiBFdmVudERpc3BhdGNoZXJcclxuICAgICAqL1xyXG4gICAgb25jZSggZXZlbnROYW1lLCBmdW5jLCBjb250ZXh0ICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgZnVuYywgY29udGV4dCwgdHJ1ZSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcclxuICAgICAqIEBwYXJhbSB7YW55PX0gY29udGV4dFxyXG4gICAgICogQHBhcmFtIHtFdmVudERpc3BhdGNoZXJ9IFtyZWZTcHJpdGU9dGhpc11cclxuICAgICAqIEByZXR1cm5zIHtFdmVudERpc3BhdGNoZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgRXZlbnREaXNwYXRjaGVyXHJcbiAgICAgKi9cclxuICAgIG9uU3RhZ2UoIGV2ZW50LCBmdW5jLCBjb250ZXh0LCByZWZTcHJpdGUgPSB0aGlzICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXJPblN0YWdlKCBldmVudCwgZnVuYywgY29udGV4dCwgcmVmU3ByaXRlICk7XHJcbiAgICB9XHJcblxyXG4gICAgYmVmb3JlUmVuZGVyKCBmdW5jLCBjb250ZXh0LCBpc1VuaXF1ZSA9IHRydWUgKSB7XHJcbiAgICAgICAgaWYgKCBpc1VuaXF1ZSApIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCBFdmVudC5SRU5ERVIsIGZ1bmMsIGNvbnRleHQgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggRXZlbnQuUkVOREVSLCBmdW5jLCBjb250ZXh0LCB0cnVlICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRGb3J3YXJkRXZlbnRzKCBldmVudExpc3QsZHN0RXZlbnREaXNwYXRjaGVyICkge1xyXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudExpc3RbaV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50LGRzdEV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50LmJpbmQoIGRzdEV2ZW50RGlzcGF0Y2hlcixbZXZlbnRdICkgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcEZvcndhcmRFdmVudHMoIGV2ZW50TGlzdCxkc3RFdmVudERpc3BhdGNoZXIgKSB7XHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGV2ZW50TGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZlbnQsZHN0RXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQuYmluZCggZHN0RXZlbnREaXNwYXRjaGVyLFtldmVudF0gKSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDsnbTrsqTtirjrpbwg66qo65GQIOq4sOuLpOugpOyEnCDrlLHtlZzrsoggZnVuY+ulvCDsi6TtlontlZzri6QuXHJcbiAgICAgKiDsnbTrsqTtirgg66qp66Gd7J2AIDzsnbTrsqTtirjsnbTrpoQ+IO2YueydgCBb7J2067Kk7Yq47J2066aELCDrjIDsg4EgRXZlbnREaXNwYXRjaGVyXVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YW55W119IGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHBhcmFtIHthbnk9fSBjb250ZXh0XHJcbiAgICAgKiBAbWVtYmVyb2YgRXZlbnREaXNwYXRjaGVyXHJcbiAgICAgKi9cclxuICAgIHdhaXRFdmVudHMoIGV2ZW50cywgZnVuYywgY29udGV4dCApIHtcclxuICAgICAgICBjb25zdCBjb3VudHMgPSBbXTtcclxuICAgICAgICBsZXQgd2FpdEhhbmRsZXI7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlbW92ZUFsbCA9ICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGNvbnN0IGkgaW4gZXZlbnRzICkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50TmFtZTtcclxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggZXZlbnRzW2ldICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgW2V2ZW50TmFtZSwgdGFyZ2V0XSA9IGV2ZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBldmVudE5hbWUgPSBldmVudHNbaV07XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCB3YWl0SGFuZGxlciwgY291bnQgKTtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB3YWl0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyB0aGlz66GcIOuwm+yVmOydjFxyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGNvdW50c1t0aGlzIC0gMV0rKztcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGxldCBqID0gMDsgaiA8IGNvdW50cy5sZW5ndGg7IGorKyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggY291bnRzW2pdID09IDAgKSByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICBmdW5jLmNhbGwoIGNvbnRleHQgKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKCBjb25zdCBpIGluIGV2ZW50cyApIHtcclxuICAgICAgICAgICAgbGV0IGV2ZW50TmFtZTtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGV2ZW50c1tpXSApICkge1xyXG4gICAgICAgICAgICAgICAgW2V2ZW50TmFtZSwgdGFyZ2V0XSA9IGV2ZW50c1tpXTtcclxuICAgICAgICAgICAgfSBlbHNlIGV2ZW50TmFtZSA9IGV2ZW50c1tpXTtcclxuICAgICAgICAgICAgLy8gMOydtOuptCBFdmVudEVtaXR0ZXIzIOuCtOu2gOyXkOyEnCB8fCDroZwg6rG465+s7KeA6riwIOuVjOusuOyXkCArMSDtlbTspIDri6RcclxuICAgICAgICAgICAgY29uc3QgY291bnRJbmRleCA9IGNvdW50cy5sZW5ndGggKyAxO1xyXG5cclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgd2FpdEhhbmRsZXIsIGNvdW50SW5kZXggKTtcclxuICAgICAgICAgICAgY291bnRzLnB1c2goIDAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7YW55W119IGV2ZW50c1xyXG4gICAgICogQHJldHVybnMge0V2ZW50RGlzcGF0Y2hlcn1cclxuICAgICAqIEBtZW1iZXJvZiBFdmVudERpc3BhdGNoZXJcclxuICAgICAqL1xyXG4gICAgYWRkQ29tYmluZWRFdmVudHMoIGV2ZW50TmFtZSwgZXZlbnRzICkge1xyXG4gICAgICAgIHRoaXMud2FpdEV2ZW50cyggZXZlbnRzLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZXZlbnROYW1lICk7XHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcblxyXG4gICAgZXZlbnRUb1Byb21pc2UoIGV2ZW50TmFtZSApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgcmVzb2x2ZSApO1xyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZG9FbnRlckZyYW1lKCkge1xyXG4gICAgICAgIGlmICggRXZlbnREaXNwYXRjaGVyLmVudGVyRnJhbWVQYXVzZWQgKSByZXR1cm4gMDtcclxuICAgICAgICBsZXQgdG90YWxFdmVudENvdW50ID0gMDtcclxuXHJcbiAgICAgICAgZm9yICggY29uc3QgW3NwciwgY291bnRdIG9mIEV2ZW50RGlzcGF0Y2hlci5lbnRlckZyYW1lTGlzdC5lbnRyaWVzKCkgKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIChzcHIuaXNWaXNpYmxlRGVlcGx5KCkpIHtcclxuICAgICAgICAgICAgc3ByLmRpc3BhdGNoRXZlbnQoIEV2ZW50LkVOVEVSX0ZSQU1FICk7XHJcbiAgICAgICAgICAgIHNwci5kaXNwYXRjaEV2ZW50KCBFdmVudC5SRU5ERVIgKTtcclxuICAgICAgICAgICAgdG90YWxFdmVudENvdW50ICs9IGNvdW50O1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG90YWxFdmVudENvdW50O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayB0d2VlblxyXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cclxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlc1xyXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxpbXBvcnQoXCIuL3R3ZWVuLmpzXCIpLlByb3A9fSBwcm9wc1xyXG4gKiBAcmV0dXJucyB7aW1wb3J0KFwiLi90d2Vlbi5qc1wiKS5wcm90b3R5cGV9XHJcbiAqIEBtZW1iZXJvZiBFdmVudERpc3BhdGNoZXJcclxuICogQHR5cGUge3R3ZWVufVxyXG4gKi9cclxuXHJcbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudHdlZW4gPSB1bmRlZmluZWQ7XHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIG1vdmVcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0wXVxyXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxpbXBvcnQoXCIuL3R3ZWVuLmpzXCIpLlByb3A9fSBwcm9wc1xyXG4gKiBAcmV0dXJucyB7VHdlZW59XHJcbiAqIEBtZW1iZXJvZiBFdmVudERpc3BhdGNoZXJcclxuICogQHR5cGUge21vdmV9XHJcbiAqL1xyXG5cclxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5tb3ZlID0gdW5kZWZpbmVkO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayB3YWl0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MF1cclxuICogQHBhcmFtIHtmdW5jdGlvbj19IGZ1bmNcclxuICogQHBhcmFtIHtvYmplY3Q9fSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHtpbXBvcnQoXCIuL3R3ZWVuLmpzXCIpLnByb3RvdHlwZX1cclxuICogQG1lbWJlcm9mIEV2ZW50RGlzcGF0Y2hlclxyXG4gKiBAdHlwZSB7d2FpdH1cclxuICovXHJcblxyXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLndhaXQgPSB1bmRlZmluZWQ7XHJcblxyXG5cclxuLyoqIFxyXG4gKiBAY2FsbGJhY2sgZ2V0VHdlZW5zXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHBsYXlpbmdPbmx5XHJcbiAqIEByZXR1cm5zIHtpbXBvcnQoXCIuL3R3ZWVuLmpzXCIpLnByb3RvdHlwZVtdfVxyXG4gKiBAbWVtYmVyb2YgRXZlbnREaXNwYXRjaGVyXHJcbiAqIFxyXG4gKi9cclxuXHJcbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZ2V0VHdlZW5zID0gdW5kZWZpbmVkO1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBzdG9wQWxsVHdlZW5zXHJcbiAqIEBtZW1iZXJvZiBFdmVudERpc3BhdGNoZXJcclxuICovXHJcbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuc3RvcEFsbFR3ZWVucyA9IHVuZGVmaW5lZDtcclxuXHJcbkV2ZW50RGlzcGF0Y2hlci5lbnRlckZyYW1lUGF1c2VkID0gZmFsc2U7XHJcblxyXG5cclxuRXZlbnQuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xyXG5FdmVudERpc3BhdGNoZXIuZW50ZXJGcmFtZUxpc3QgPSBuZXcgTWFwKCk7XHJcblxyXG5cclxuIiwiXHJcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi9VdGlscyc7XHJcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUnO1xyXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vRXZlbnQnO1xyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IEFzc2V0IH0gZnJvbSAnLi9Bc3NldCc7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEZvbnRCYXNlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCBuYW1lLCByZWZlcmVuY2VTaXplLCBzdHlsZXMgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZVNpemUgfHwgMTtcclxuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcclxuICAgICAgICAvKiogQHR5cGUge0Fzc2V0fSAqL1xyXG4gICAgICAgIHRoaXMuYXNzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcclxuICAgICAqIEBwYXJhbSB7YW55PX0gY29udGV4dFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNPbmNlPWZhbHNlXVxyXG4gICAgICogQHJldHVybnMge0ZvbnRCYXNlfVxyXG4gICAgICogQG1lbWJlcm9mIEZvbnRCYXNlXHJcbiAgICAgKi9cclxuICAgIGFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgZnVuYywgY29udGV4dCA9IG51bGwsIGlzT25jZSA9IGZhbHNlICkge1xyXG4gICAgICAgIGlmICggZXZlbnROYW1lID09IEV2ZW50LkxPQURFRCApIHtcclxuICAgICAgICAgICAgdGhpcy5hc3NldC5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMuZGlzcGF0Y2hFdmVudC5iaW5kKCB0aGlzLEV2ZW50LkxPQURFRCApLCBudWxsLCBpc09uY2UgKTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiBzdXBlci5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIGZ1bmMsIGNvbnRleHQsIGlzT25jZSApO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEFzY2VuZGVyKCBzaXplICkge1xyXG4gICAgICAgIGlmICggIXRoaXMuYXNzZXQubG9hZGVkICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyggYOuhnOuUqeydtCDslYjrkJwg7IOB7YOc66GcIOyCrOydtOymiOulvCDqtaztlZjroKTqs6Ag7ZWc64ukLiAke3RoaXMuYXNzZXQubmFtZX1gICk7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmb250SW5mbyA9IHRoaXMuYXNzZXQuZm9udEluZm87XHJcblxyXG4gICAgICAgIHJldHVybiBmb250SW5mby5hc2NlbmRlciAvIGZvbnRJbmZvLnVuaXRzUGVyRW0gKiAoIHNpemUgfHwgdGhpcy5yZWZlcmVuY2VTaXplICk7IFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBtZWFzdXJlVGV4dFdpZHRoKCBzdHIsc2l6ZSApIHtcclxuICAgICAgICBpZiAoICF0aGlzLmFzc2V0LmxvYWRlZCApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coIGDroZzrlKnsnbQg7JWI65CcIOyDge2DnOuhnCDsgqzsnbTspojrpbwg6rWs7ZWY66Ck6rOgIO2VnOuLpC4gJHt0aGlzLmFzc2V0Lm5hbWV9YCApO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g7IOB7IaNIOuwm+ydgCDtgbTrnpjsiqTsl5DshJwg6rWs7ZiEXHJcbiAgICB9XHJcbn1cclxuXHJcbiIsIlxyXG5leHBvcnQgY29uc3QgS2V5Q29kZSA9IHtcclxuICAgIEVTQzogICAgXCJFc2NhcGVcIixcclxuICAgIEVOVEVSOiAgXCJFbnRlclwiLFxyXG4gICAgU1BBQ0U6ICBcIlNwYWNlXCIsXHJcbiAgICBMRUZUOiAgIFwiQXJyb3dMZWZ0XCIsXHJcbiAgICBSSUdIVDogIFwiQXJyb3dSaWdodFwiLFxyXG4gICAgVVA6ICAgICBcIkFycm93VXBcIixcclxuICAgIERPV046ICAgXCJBcnJvd0Rvd25cIixcclxuICAgIENUUkw6ICAgXCJDb250cm9sTGVmdFwiLFxyXG4gICAgQTogICAgICBcIktleUFcIixcclxuICAgIEI6ICAgICAgXCJLZXlCXCIsXHJcbiAgICBDOiAgICAgIFwiS2V5Q1wiLFxyXG4gICAgRDogICAgICBcIktleURcIixcclxuICAgIEU6ICAgICAgXCJLZXlFXCIsXHJcbiAgICBGOiAgICAgIFwiS2V5RlwiLFxyXG4gICAgRzogICAgICBcIktleUdcIixcclxuICAgIEg6ICAgICAgXCJLZXlIXCIsXHJcbiAgICBJOiAgICAgIFwiS2V5SVwiLFxyXG4gICAgSjogICAgICBcIktleUpcIixcclxuICAgIEs6ICAgICAgXCJLZXlLXCIsXHJcbiAgICBMOiAgICAgIFwiS2V5TFwiLFxyXG4gICAgTTogICAgICBcIktleU1cIixcclxuICAgIE46ICAgICAgXCJLZXlOXCIsXHJcbiAgICBPOiAgICAgIFwiS2V5T1wiLFxyXG4gICAgUDogICAgICBcIktleVBcIixcclxuICAgIFE6ICAgICAgXCJLZXlRXCIsXHJcbiAgICBSOiAgICAgIFwiS2V5UlwiLFxyXG4gICAgUzogICAgICBcIktleVNcIixcclxuICAgIFQ6ICAgICAgXCJLZXlUXCIsXHJcbiAgICBVOiAgICAgIFwiS2V5VVwiLFxyXG4gICAgVjogICAgICBcIktleVZcIixcclxuICAgIFc6ICAgICAgXCJLZXlXXCIsXHJcbiAgICBYOiAgICAgIFwiS2V5WFwiLFxyXG4gICAgWTogICAgICBcIktleVlcIixcclxuICAgIFo6ICAgICAgXCJLZXlaXCIsXHJcbiAgICBEaWdpdDA6IFwiRGlnaXQwXCIsXHJcbiAgICBEaWdpdDE6IFwiRGlnaXQxXCIsXHJcbiAgICBEaWdpdDI6IFwiRGlnaXQyXCIsXHJcbiAgICBEaWdpdDM6IFwiRGlnaXQzXCIsXHJcbiAgICBEaWdpdDQ6IFwiRGlnaXQ0XCIsXHJcbiAgICBEaWdpdDU6IFwiRGlnaXQ1XCIsXHJcbiAgICBEaWdpdDY6IFwiRGlnaXQ2XCIsXHJcbiAgICBEaWdpdDc6IFwiRGlnaXQ3XCIsXHJcbiAgICBEaWdpdDg6IFwiRGlnaXQ4XCIsXHJcbiAgICBEaWdpdDk6IFwiRGlnaXQ5XCIsXHJcbn07XHJcblxyXG5cclxuXHJcbiIsIlxyXG5cclxuXHJcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlJztcclxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcclxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL1R5cGVzJztcclxuaW1wb3J0IHsgYXBwbGljYXRpb24gfSBmcm9tICcuL0FwcGxpY2F0aW9uJztcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTGF5b3V0IGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCB4ID0gMCx5ID0gMCx3ID0gMCxoID0gMCApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX19sb2NhdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLl9fd2lkdGggPSB3O1xyXG4gICAgICAgIHRoaXMuX19oZWlnaHQgPSBoO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgIH1cclxuXHJcbiAgICByZXNpemUoIHcsIGggKSB7XHJcbiAgICAgICAgdGhpcy5fX3dpZHRoID0gdztcclxuICAgICAgICB0aGlzLl9faGVpZ2h0ID0gaDtcclxuICAgICAgICB0aGlzLl9vblJlc2l6ZUV2ZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UmVjdCggeCwgeSwgdywgaCApIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5yZXNpemUoIHcsIGggKTtcclxuICAgIH1cclxuXHJcbiAgICBfb25SZXNpemVFdmVudCgpIHtcclxuICAgICAgICBmb3IgKCBjb25zdCBrZXkgaW4gdGhpcy5fX2xvY2F0aW9ucyApIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jU3ByID0gdGhpcy5fX2xvY2F0aW9uc1trZXldO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBrZXkgPT0gXCJvcmlnaW5cIiApIHtcclxuICAgICAgICAgICAgICAgIGxvY1Nwci54ID0gLXRoaXMueDtcclxuICAgICAgICAgICAgICAgIGxvY1Nwci55ID0gLXRoaXMueTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGtleS5zcGxpdCggXCIsXCIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2NTcHIueCA9IHRoaXMuX193aWR0aCAqIHBhcnNlRmxvYXQoIHggKTtcclxuICAgICAgICAgICAgICAgIGxvY1Nwci55ID0gdGhpcy5fX2hlaWdodCAqIHBhcnNlRmxvYXQoIHkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBuZXcgRXZlbnQoIEV2ZW50LlJFU0laRSwgeyB3aWR0aDogdGhpcy5fX3dpZHRoLCBoZWlnaHQ6IHRoaXMuX19oZWlnaHQgfSApICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG9yaWdpbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbiggXCJvcmlnaW5cIiApO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB0b3BMZWZ0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uKCAwLCAwICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHRvcE1pZGRsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbiggMC41LCAwICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHRvcFJpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uKCAxLCAwICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGJvdHRvbUxlZnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24oIDAsIDEgKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYm90dG9tTWlkZGxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uKCAwLjUsIDEgKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYm90dG9tUmlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24oIDEsIDEgKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbGVmdE1pZGRsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbiggMCwgMC41ICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHJpZ2h0TWlkZGxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uKCAxLCAwLjUgKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uKCAwLjUsIDAuNSApO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9bnVsbF1cclxuICAgICAqIEByZXR1cm5zIHtMYXlvdXR9XHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5b3V0XHJcbiAgICAgKi9cclxuICAgIGxvY2F0aW9uKCB4LCB5ID0gbnVsbCApIHtcclxuICAgICAgICBjb25zdCBpZCA9IHkgIT0gbnVsbCA/IHggKyBcIixcIiArIHkgOiB4O1xyXG4gICAgICAgIGxldCBsb2NTcHIgPSB0aGlzLl9fbG9jYXRpb25zW2lkXTtcclxuXHJcbiAgICAgICAgaWYgKCBsb2NTcHIgIT0gbnVsbCApIHJldHVybiBsb2NTcHI7XHJcbiAgICAgICAgbG9jU3ByID0gKCB0aGlzLl9fbG9jYXRpb25zW2lkXSA9IG5ldyBMYXlvdXQoKSApO1xyXG5cclxuICAgICAgICBpZiAoIHkgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgaWYgKCBpZCA9PSBcIm9yaWdpblwiICkge1xyXG4gICAgICAgICAgICAgICAgbG9jU3ByLnggPSAtdGhpcy54O1xyXG4gICAgICAgICAgICAgICAgbG9jU3ByLnkgPSAtdGhpcy55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBsb2NTcHIueCA9IHRoaXMuX193aWR0aCAqIHg7XHJcbiAgICAgICAgICAgIGxvY1Nwci55ID0gdGhpcy5fX2hlaWdodCAqIHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFkZENoaWxkKCBsb2NTcHIgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxvY1NwcjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX193aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgd2lkdGgoIHYgKSB7XHJcbiAgICAgICAgdGhpcy5fX3dpZHRoID0gdjtcclxuICAgICAgICB0aGlzLl9vblJlc2l6ZUV2ZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2hlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgaGVpZ2h0KCB2ICkge1xyXG4gICAgICAgIHRoaXMuX19oZWlnaHQgPSB2O1xyXG4gICAgICAgIHRoaXMuX29uUmVzaXplRXZlbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHJldHVybnMge1BvaW50fVxyXG4gICAgICogQG1lbWJlcm9mIExheW91dFxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCB0aGlzLl9fd2lkdGgsIHRoaXMuX19oZWlnaHQgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHZcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5b3V0XHJcbiAgICAgKi9cclxuICAgIHNldCBzaXplKCB2ICkge1xyXG4gICAgICAgIHRoaXMuX193aWR0aCA9IHYueDtcclxuICAgICAgICB0aGlzLl9faGVpZ2h0ID0gdi55O1xyXG4gICAgICAgIHRoaXMuX29uUmVzaXplRXZlbnQoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIGZyb21SZW5kZXJWaWV3cG9ydCgpIHtcclxuICAgICAgICBjb25zdCBsYXlvdXQgPSBuZXcgTGF5b3V0KCBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLngsIGFwcGxpY2F0aW9uLmxvZ2ljYWxSZW5kZXJCb3VuZHMueSxhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLndpZHRoLCBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLmhlaWdodCApO1xyXG5cclxuICAgICAgICBhcHBsaWNhdGlvbi5hZGRFdmVudExpc3RlbmVyKCBFdmVudC5SRVNJWkUsICgpID0+IHtcclxuICAgICAgICAgICAgbGF5b3V0LnggPSBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLng7XHJcbiAgICAgICAgICAgIGxheW91dC55ID0gYXBwbGljYXRpb24ubG9naWNhbFJlbmRlckJvdW5kcy55O1xyXG4gICAgICAgICAgICBsYXlvdXQucmVzaXplKCBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLndpZHRoLCBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLmhlaWdodCApO1xyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxheW91dDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnJvbUxvZ2ljYWxWaWV3cG9lcigpIHtcclxuICAgICAgICBjb25zdCBsYXlvdXQgPSBuZXcgTGF5b3V0KCAwLDAsYXBwbGljYXRpb24ubG9naWNhbFZpZXdwb3J0LndpZHRoLCBhcHBsaWNhdGlvbi5sb2dpY2FsVmlld3BvcnQuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgIGFwcGxpY2F0aW9uLmFkZEV2ZW50TGlzdGVuZXIoIEV2ZW50LlJFU0laRSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBsYXlvdXQucmVzaXplKCBhcHBsaWNhdGlvbi5sb2dpY2FsVmlld3BvcnQud2lkdGgsIGFwcGxpY2F0aW9uLmxvZ2ljYWxWaWV3cG9ydC5oZWlnaHQgKTtcclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIHJldHVybiBsYXlvdXQ7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4iLCJcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTWF0cml4IHtcclxuICAgIGNvbnN0cnVjdG9yKCBtMTEgPSAxLCBtMTIgPSAwLCBtMjEgPSAwLCBtMjIgPSAxLCB0eCA9IDAsIHR5ID0gMCApIHtcclxuICAgICAgICB0aGlzLl9fcGl4aSA9IG5ldyBQSVhJLk1hdHJpeCggbTExLCBtMTIsIG0yMSwgbTIyLCB0eCwgdHkgKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL1Nwcml0ZSc7XHJcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUnO1xyXG5pbXBvcnQgeyBQb2ludCwgVHlwZWRBcnJheUhlbHBlciB9IGZyb20gJy4vVHlwZXMnO1xyXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4vVXRpbHMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1lc2ggZXh0ZW5kcyBTcHJpdGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1lc2guXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVzaFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuXyQkc3ByaXRlVHlwZSA9IFNwcml0ZS5TcHJpdGVUeXBlcy5NRVNIO1xyXG4gICAgICAgIHRoaXMuXyQkdXBkYXRlQ29kZSA9IFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfTk9USElORztcclxuICAgICAgICB0aGlzLmRpcnR5ID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbk9mZnNldDogMCxcclxuICAgICAgICAgICAgcG9zaXRpb25MZW5ndGg6IDAsXHJcbiAgICAgICAgICAgIHRleENvb3JkT2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB0ZXhDb29yZExlbmd0aDogMCxcclxuICAgICAgICAgICAgY29sb3JPZmZzZXQ6ICAgIDAsXHJcbiAgICAgICAgICAgIGNvbG9yTGVuZ3RoOiAgICAwLFxyXG4gICAgICAgICAgICBpbmRleE9mZnNldDogICAgMCxcclxuICAgICAgICAgICAgaW5kZXhMZW5ndGg6ICAgIDAsXHJcbiAgICAgICAgICAgIHRleHR1cmVSZXNldDogICBmYWxzZSxcclxuICAgICAgICAgICAgcG9zaXRpb25SZXNldDogIGZhbHNlLFxyXG4gICAgICAgICAgICB0ZXhDb29yZFJlc2V0OiAgZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbG9yUmVzZXQ6ICAgICBmYWxzZSxcclxuICAgICAgICAgICAgaW5kZXhSZXNldDogICAgIGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuYV90ZXhDb29yZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmFfY29sb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuYV9nZW5lcmljQXJyYXkgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGV4dHVyZSggdGV4dHVyZSApIHtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgIHRoaXMuXyQkdXBkYXRlQ29kZSB8PSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgICAgIHRoaXMuZGlydHkudGV4dHVyZVJlc2V0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUZXh0dXJlQ29vcmRpbmF0ZUFycmF5KCBhcnIgKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eS50ZXhDb29yZFJlc2V0ID0gISggdGhpcy5hX3RleENvb3JkICYmIHRoaXMuYV90ZXhDb29yZC5sZW5ndGggPj0gYXJyLmxlbmd0aCApO1xyXG4gICAgICAgIHRoaXMuYV90ZXhDb29yZCA9IG5ldyBGbG9hdDMyQXJyYXkoIGFyciApO1xyXG4gICAgICAgIHRoaXMuXyQkdXBkYXRlQ29kZSB8PSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgICAgIHRoaXMuZGlydHkudGV4Q29vcmRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGlydHkudGV4Q29vcmRMZW5ndGggPSB0aGlzLmFfdGV4Q29vcmQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHsuLi5udW1iZXJ9IGFyZ3NcclxuICAgICAqIEBtZW1iZXJvZiBNZXNoXHJcbiAgICAgKi9cclxuICAgIHNldFRleHR1cmVDb29yZGluYXRlcyggLi4uYXJncyApIHtcclxuICAgICAgICBsZXQgbWluSW5kZXggPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgbWF4SW5kZXggPSAtSW5maW5pdHk7XHJcblxyXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDMgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYXJnc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGFyZ3NbaSArIDFdO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gYXJnc1tpICsgMl07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFfdGV4Q29vcmRbaW5kZXggKiAyXSA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMuYV90ZXhDb29yZFtpbmRleCAqIDIgKyAxXSA9IHk7XHJcbiAgICAgICAgICAgIG1pbkluZGV4ID0gTWF0aC5taW4oIG1pbkluZGV4LGluZGV4ICk7XHJcbiAgICAgICAgICAgIG1heEluZGV4ID0gTWF0aC5tYXgoIG1heEluZGV4LGluZGV4ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuXyQkdXBkYXRlQ29kZSB8PSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgICAgIHRoaXMuZGlydHkudGV4Q29vcmRPZmZzZXQgPSBNYXRoLm1pbiggdGhpcy5kaXJ0eS50ZXhDb29yZE9mZnNldCAvIDIsbWluSW5kZXggKSAqIDI7XHJcbiAgICAgICAgdGhpcy5kaXJ0eS50ZXhDb29yZExlbmd0aCA9IE1hdGgubWF4KCAoIHRoaXMuZGlydHkudGV4Q29vcmRPZmZzZXQgKyB0aGlzLmRpcnR5LnRleENvb3JkTGVuZ3RoICkgLyAyICxtYXhJbmRleCApICogMjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUZXh0dXJlQ29vcmRpbmF0ZSggaSx4LHkgKSB7XHJcbiAgICAgICAgdGhpcy5hX3RleENvb3JkW2kgKiAyXSA9IHg7XHJcbiAgICAgICAgdGhpcy5hX3RleENvb3JkW2kgKiAyICsgMV0gPSB5O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHR1cmVDb29yZGluYXRlKCBpICkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoIHRoaXMuYV90ZXhDb29yZFtpICogMl0sdGhpcy5hX3RleENvb3JkW2kgKiAyICsgMV0gKTtcclxuICAgIH1cclxuXHJcbiAgICBfY2FsY3VsYXRlTG9jYWxCb3VuZHMoIHN0YXJ0SW5kZXggPSAwLGVuZEluZGV4ID0gdGhpcy5hX3Bvc2l0aW9uLmxlbmd0aCAvIDIgKSB7XHJcbiAgICAgICAgbGV0IG1pblggPSBJbmZpbml0eSxtYXhYID0gLUluZmluaXR5LG1pblkgPSBJbmZpbml0eSAsbWF4WSA9IC1JbmZpbml0eTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXggKiAyOyBpICs9IDIgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmFfcG9zaXRpb25baV07XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmFfcG9zaXRpb25baSArIDFdO1xyXG5cclxuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKCB4LG1pblggKTtcclxuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KCB4LG1heFggKTtcclxuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKCB5LG1pblkgKTtcclxuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KCB5LG1heFkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fJCRsb2NhbEJvdW5kcy54ID0gbWluWDtcclxuICAgICAgICB0aGlzLl8kJGxvY2FsQm91bmRzLnkgPSBtaW5ZO1xyXG4gICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgICAgICB0aGlzLl8kJGxvY2FsQm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFZlcnRleEFycmF5KCBhcnIgKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eS5wb3NpdGlvblJlc2V0ID0gISggdGhpcy5hX3Bvc2l0aW9uICYmIHRoaXMuYV9wb3NpdGlvbi5sZW5ndGggPj0gYXJyLmxlbmd0aCApO1xyXG4gICAgICAgIHRoaXMuYV9wb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoIGFyciApO1xyXG4gICAgICAgIHRoaXMuXyQkdXBkYXRlQ29kZSB8PSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgICAgIGlmICggIXRoaXMudXNlQ3VzdG9tTG9jYWxCb3VuZHMgKSB0aGlzLl9jYWxjdWxhdGVMb2NhbEJvdW5kcygpO1xyXG4gICAgICAgIHRoaXMuZGlydHkucG9zaXRpb25PZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGlydHkucG9zaXRpb25MZW5ndGggPSB0aGlzLmFfcG9zaXRpb24ubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHsuLi5udW1iZXJ9IGFyZ3NcclxuICAgICAqIEBtZW1iZXJvZiBNZXNoXHJcbiAgICAgKi9cclxuICAgIHNldFZlcnRpY2VzKCAuLi5hcmdzICkge1xyXG4gICAgICAgIGxldCBtaW5JbmRleCA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBtYXhJbmRleCA9IC1JbmZpbml0eTtcclxuXHJcbiAgICAgICAgbGV0IG1pblggPSB0aGlzLl8kJGxvY2FsQm91bmRzLmxlZnQ7XHJcbiAgICAgICAgbGV0IG1heFggPSB0aGlzLl8kJGxvY2FsQm91bmRzLnJpZ2h0O1xyXG4gICAgICAgIGxldCBtaW5ZID0gdGhpcy5fJCRsb2NhbEJvdW5kcy50b3A7XHJcbiAgICAgICAgbGV0IG1heFkgPSB0aGlzLl8kJGxvY2FsQm91bmRzLmJvdHRvbTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMyApIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhcmdzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gYXJnc1tpICsgMV07XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBhcmdzW2kgKyAyXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYV9wb3NpdGlvbltpbmRleCAqIDJdID0geDtcclxuICAgICAgICAgICAgdGhpcy5hX3Bvc2l0aW9uW2luZGV4ICogMiArIDFdID0geTtcclxuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKCB4LG1pblggKTtcclxuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KCB4LG1heFggKTtcclxuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKCB5LG1pblkgKTtcclxuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWluKCB5LG1heFkgKTtcclxuICAgICAgICAgICAgbWluSW5kZXggPSBNYXRoLm1pbiggbWluSW5kZXgsaW5kZXggKTtcclxuICAgICAgICAgICAgbWF4SW5kZXggPSBNYXRoLm1heCggbWF4SW5kZXgsaW5kZXggKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fJCR1cGRhdGVDb2RlIHw9IFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfRVhUUkE7XHJcblxyXG4gICAgICAgIGlmICggIXRoaXMudXNlQ3VzdG9tTG9jYWxCb3VuZHMgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMueCA9IG1pblg7XHJcbiAgICAgICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMueSA9IG1pblk7XHJcbiAgICAgICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgICAgICAgICAgdGhpcy5fJCRsb2NhbEJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkucG9zaXRpb25PZmZzZXQgPSBNYXRoLm1pbiggdGhpcy5kaXJ0eS5wb3NpdGlvbk9mZnNldCAvIDIsbWluSW5kZXggKSAqIDI7XHJcbiAgICAgICAgdGhpcy5kaXJ0eS5wb3NpdGlvbkxlbmd0aCA9IE1hdGgubWF4KCAoIHRoaXMuZGlydHkucG9zaXRpb25PZmZzZXQgKyB0aGlzLmRpcnR5LnBvc2l0aW9uTGVuZ3RoICkgLyAyLG1heEluZGV4ICkgKiAyO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFZlcnRleCggaSx4LHkgKSB7XHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uW2kgKiAyXSA9IHg7XHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uW2kgKiAyICsgMV0gPSB5O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFZlcnRleCggaSApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCB0aGlzLmFfcG9zaXRpb25baSAqIDJdLHRoaXMuYV9wb3NpdGlvbltpICogMiArIDFdICk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHNldENvbG9yQXJyYXkoIGFyciApIHtcclxuICAgICAgICB0aGlzLmRpcnR5LmNvbG9yUmVzZXQgPSAhKCB0aGlzLmFfY29sb3IgJiYgdGhpcy5hX2NvbG9yLmxlbmd0aCA+PSBhcnIubGVuZ3RoICogMiApO1xyXG4gICAgICAgIHRoaXMuYV9jb2xvciA9IG5ldyBVaW50OEFycmF5KCBhcnIubGVuZ3RoICogMiApO1xyXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMiApIHtcclxuICAgICAgICAgICAgdGhpcy5hX2NvbG9yW2kgKiAyICsgMF0gPSAoIGFycltpXSA+PiAxNiApICYgMHhmZjtcclxuICAgICAgICAgICAgdGhpcy5hX2NvbG9yW2kgKiAyICsgMV0gPSAoIGFycltpXSA+PiA4ICkgJiAweGZmO1xyXG4gICAgICAgICAgICB0aGlzLmFfY29sb3JbaSAqIDIgKyAyXSA9ICggYXJyW2ldICkgJiAweGZmO1xyXG4gICAgICAgICAgICB0aGlzLmFfY29sb3JbaSAqIDIgKyAzXSA9ICBhcnJbaSArIDFdICogMjU1O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl8kJHVwZGF0ZUNvZGUgfD0gU3ByaXRlLlVwZGF0ZUNvZGVzLlVQREFURV9FWFRSQTtcclxuICAgICAgICB0aGlzLmRpcnR5LmNvbG9yT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmRpcnR5LmNvbG9yTGVuZ3RoID0gdGhpcy5hX2NvbG9yLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Li4ubnVtYmVyfSBhcmdzXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVzaFxyXG4gICAgICovXHJcbiAgICBzZXRDb2xvcnMoIC4uLmFyZ3MgKSB7XHJcbiAgICAgICAgbGV0IG1pbkluZGV4ID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IG1heEluZGV4ID0gLUluZmluaXR5O1xyXG5cclxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAzICkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGFyZ3NbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBhcmdzW2kgKyAxXTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IGFyZ3NbaSArIDJdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hX2NvbG9yW2luZGV4ICogNF0gPSAoIGMgPj4gMTYgKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIHRoaXMuYV9jb2xvcltpbmRleCAqIDQgKyAxXSA9ICggYyA+PiA4ICkgJiAweGZmO1xyXG4gICAgICAgICAgICB0aGlzLmFfY29sb3JbaW5kZXggKiA0ICsgMl0gPSBjICYgMHhmZjtcclxuICAgICAgICAgICAgdGhpcy5hX2NvbG9yW2luZGV4ICogNCArIDNdID0gYSAqIDI1NTtcclxuICAgICAgICAgICAgbWluSW5kZXggPSBNYXRoLm1pbiggbWluSW5kZXgsaW5kZXggKTtcclxuICAgICAgICAgICAgbWF4SW5kZXggPSBNYXRoLm1heCggbWF4SW5kZXgsaW5kZXggKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fJCR1cGRhdGVDb2RlIHw9IFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfRVhUUkE7XHJcbiAgICAgICAgdGhpcy5kaXJ0eS5jb2xvck9mZnNldCA9IE1hdGgubWluKCB0aGlzLmRpcnR5LmNvbG9yT2Zmc2V0IC8gNCxtaW5JbmRleCApICogNDtcclxuICAgICAgICB0aGlzLmRpcnR5LmNvbG9yTGVuZ3RoID0gTWF0aC5tYXgoICggdGhpcy5kaXJ0eS5jb2xvck9mZnNldCArIHRoaXMuZGlydHkuY29sb3JMZW5ndGggKSAvIDQsbWF4SW5kZXggKSAqIDQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldENvbG9yQXJyYXlTaXplKCkge1xyXG4gICAgICAgIC8vIFV0aWxzLmxlZ2FjeSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFfY29sb3IubGVuZ3RoIC8gNDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRSZ2JhQ29sb3JBcnJheSggYXJyICkge1xyXG4gICAgICAgIHRoaXMuZGlydHkuY29sb3JSZXNldCA9ICEoIHRoaXMuYV9jb2xvciAmJiB0aGlzLmFfY29sb3IubGVuZ3RoID49IGFyci5sZW5ndGggKTtcclxuICAgICAgICB0aGlzLmFfY29sb3IgPSBuZXcgVWludDhBcnJheSggYXJyLm1hcCggdj0+diAqIDI1NSApICk7XHJcbiAgICAgICAgdGhpcy5fJCR1cGRhdGVDb2RlIHw9IFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfRVhUUkE7XHJcbiAgICAgICAgdGhpcy5kaXJ0eS5jb2xvck9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5kaXJ0eS5jb2xvckxlbmd0aCA9IHRoaXMuYV9jb2xvci5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q29sb3IoIGksYyxhICkge1xyXG4gICAgICAgIGNvbnN0IGFyciA9IFV0aWxzLmhleDJyZ2JhKCBjLGEgKTtcclxuXHJcbiAgICAgICAgdGhpcy5hX2NvbG9yW2kgKiA0XSA9IGFyclswXTtcclxuICAgICAgICB0aGlzLmFfY29sb3JbaSAqIDQgKyAxXSA9IGFyclsxXTtcclxuICAgICAgICB0aGlzLmFfY29sb3JbaSAqIDQgKyAyXSA9IGFyclsyXTtcclxuICAgICAgICB0aGlzLmFfY29sb3JbaSAqIDQgKyAzXSA9IGFyclszXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDb2xvciggaSApIHtcclxuICAgICAgICBjb25zdCBjID0gVXRpbHMucmdiYTJoZXgoIHRoaXMuYV9jb2xvcixpICogNCApO1xyXG5cclxuICAgICAgICByZXR1cm4geyBjb2xvcjogYyAmIDB4ZmZmZmZmLGFscGhhOiB0aGlzLmFfY29sb3JbaSAqIDQgKyAzXSB9O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzZXRJbmRleEFycmF5KCBhcnIgKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eS5pbmRleFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIE1hdGguY2VpbCggYXJyLmxlbmd0aCAvIDIgKSAqIDIgKTsgLy8gZmxvYXQzMuuhnCDrsJTqv5Tslbwg7ZWY6riwIOuVjOusuOyXkCDsoJXroKxcclxuICAgICAgICB0aGlzLmluZGljZXMuc2V0KCBhcnIgKTtcclxuICAgICAgICB0aGlzLl8kJHVwZGF0ZUNvZGUgfD0gU3ByaXRlLlVwZGF0ZUNvZGVzLlVQREFURV9FWFRSQTtcclxuICAgICAgICB0aGlzLmRpcnR5LmluZGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmRpcnR5LmluZGV4TGVuZ3RoID0gdGhpcy5pbmRpY2VzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Li4ubnVtYmVyfSBhcmdzXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVzaFxyXG4gICAgICovXHJcbiAgICBzZXRJbmRpY2VzKCAuLi5hcmdzICkge1xyXG4gICAgICAgIGxldCBtaW5JbmRleCA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBtYXhJbmRleCA9IC1JbmZpbml0eTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMiApIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhcmdzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCB2aSA9IGFyZ3NbaSArIDFdO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pbmRpY2VzW2luZGV4XSA9IHZpO1xyXG4gICAgICAgICAgICBtaW5JbmRleCA9IE1hdGgubWluKCBtaW5JbmRleCxpbmRleCApO1xyXG4gICAgICAgICAgICBtYXhJbmRleCA9IE1hdGgubWF4KCBtYXhJbmRleCxpbmRleCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl8kJHVwZGF0ZUNvZGUgfD0gU3ByaXRlLlVwZGF0ZUNvZGVzLlVQREFURV9FWFRSQTtcclxuICAgICAgICB0aGlzLmRpcnR5LmluZGV4T2Zmc2V0ID0gTWF0aC5taW4oIHRoaXMuZGlydHkuaW5kZXhPZmZzZXQsbWluSW5kZXggKTtcclxuICAgICAgICB0aGlzLmRpcnR5LmluZGV4TGVuZ3RoID0gTWF0aC5tYXgoIHRoaXMuZGlydHkuaW5kZXhPZmZzZXQgKyB0aGlzLmRpcnR5LmluZGV4TGVuZ3RoLG1heEluZGV4ICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SW5kZXgoIGkgKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kaWNlc1tpXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRJbmRleCggaSx2ICkge1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1tpXSA9IHY7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJOYW1lXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJcclxuICAgICAqIEBwYXJhbSB7TWVzaC5BcnJheVR5cGVzfSBhcnJheVR5cGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbm9ybWFsaXplID0gZmFsc2VdXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVzaFxyXG4gICAgICovXHJcbiAgICBzZXRHZW5lcmljQXJyYXkoIGF0dHJpYk5hbWUsIGFyciwgYXJyYXlUeXBlID0gTWVzaC5BcnJheVR5cGVzLkZMT0FUMzIsIHNpemUgPSAxLCBub3JtYWxpemUgPSBmYWxzZSApIHtcclxuICAgICAgICB0aGlzLmFfZ2VuZXJpY0FycmF5ID0gdGhpcy5hX2dlbmVyaWNBcnJheSB8fCB7fTtcclxuICAgICAgICB0aGlzLmFfZ2VuZXJpY0FycmF5W2F0dHJpYk5hbWVdID0geyBcclxuICAgICAgICAgICAgZGF0YTogICAgICAgICAgbmV3IGFycmF5VHlwZSggYXJyICksXHJcbiAgICAgICAgICAgIG51bUNvbXBvbmVudHM6IHNpemUsXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZTogICAgIG5vcm1hbGl6ZSBcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuXyQkdXBkYXRlQ29kZSB8PSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBjcmVhdGVCb3goIHgsIHksIHcsIGgsIGNvbG9yID0gMHhmZmZmZmYsIGFscGhhID0gMSApIHtcclxuICAgICAgICBjb25zdCBtID0gbmV3IE1lc2goKTtcclxuXHJcbiAgICAgICAgbS5zZXRWZXJ0ZXhBcnJheSggW3gsIHksIHggKyB3LCB5LCB4LCB5ICsgaCwgeCArIHcsIHkgKyBoXSApO1xyXG4gICAgICAgIG0uc2V0Q29sb3JBcnJheSggW2NvbG9yLCBhbHBoYSwgY29sb3IsIGFscGhhLCBjb2xvciwgYWxwaGEsIGNvbG9yLCBhbHBoYV0gKTtcclxuICAgICAgICBtLnNldEluZGV4QXJyYXkoIFswLCAxLCAyLCAxLCAzLCAyXSApO1xyXG5cclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZW5jb2RlRXh0cmFSZW5kZXJpbmdJbmZvKCkge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZWRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCBcclxuICAgICAgICAgICAgMTQgKyBcclxuICAgICAgICAgICAgIHRoaXMuZGlydHkucG9zaXRpb25MZW5ndGggKyBcclxuICAgICAgICAgICAgIHRoaXMuZGlydHkudGV4Q29vcmRMZW5ndGggKyBcclxuICAgICAgICAgICAgIE1hdGguY2VpbCggdGhpcy5kaXJ0eS5jb2xvckxlbmd0aCAvIDQgKSArIFxyXG4gICAgICAgICAgICAgTWF0aC5jZWlsKCB0aGlzLmRpcnR5LmluZGV4TGVuZ3RoIC8gMiApICk7XHJcblxyXG4gICAgICAgIGVuY29kZWRCdWZmZXIuc2V0KCBbXHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSAhPSBudWxsID8gdGhpcy50ZXh0dXJlLmFzc2V0LmlkIDogMCxcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eS5wb3NpdGlvbk9mZnNldCxcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eS5wb3NpdGlvbkxlbmd0aCxcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eS50ZXhDb29yZE9mZnNldCxcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eS50ZXhDb29yZExlbmd0aCxcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eS5jb2xvck9mZnNldCxcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eS5jb2xvckxlbmd0aCxcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eS5pbmRleE9mZnNldCxcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eS5pbmRleExlbmd0aCxcclxuICAgICAgICAgICAgK3RoaXMuZGlydHkudGV4dHVyZVJlc2V0LFxyXG4gICAgICAgICAgICArdGhpcy5kaXJ0eS5wb3NpdGlvblJlc2V0LFxyXG4gICAgICAgICAgICArdGhpcy5kaXJ0eS50ZXhDb29yZFJlc2V0LFxyXG4gICAgICAgICAgICArdGhpcy5kaXJ0eS5jb2xvclJlc2V0LFxyXG4gICAgICAgICAgICArdGhpcy5kaXJ0eS5pbmRleFJlc2V0LFxyXG4gICAgICAgIF0gKTtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMTQ7XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5kaXJ0eS5wb3NpdGlvbkxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgIGVuY29kZWRCdWZmZXIuc2V0KCBUeXBlZEFycmF5SGVscGVyLnN1YmFycmF5KCB0aGlzLmFfcG9zaXRpb24sdGhpcy5kaXJ0eS5wb3NpdGlvbk9mZnNldCwgdGhpcy5kaXJ0eS5wb3NpdGlvbkxlbmd0aCApLG9mZnNldCApO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gIHRoaXMuZGlydHkucG9zaXRpb25MZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggdGhpcy5kaXJ0eS50ZXhDb29yZExlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgIGVuY29kZWRCdWZmZXIuc2V0KCBUeXBlZEFycmF5SGVscGVyLnN1YmFycmF5KCB0aGlzLmFfdGV4Q29vcmQsdGhpcy5kaXJ0eS50ZXhDb29yZE9mZnNldCwgdGhpcy5kaXJ0eS50ZXhDb29yZExlbmd0aCApLG9mZnNldCApO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gIHRoaXMuZGlydHkudGV4Q29vcmRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggdGhpcy5kaXJ0eS5jb2xvckxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgIGVuY29kZWRCdWZmZXIuc2V0KCBUeXBlZEFycmF5SGVscGVyLlVpbnQ4VG9GbG9hdDMyKCB0aGlzLmFfY29sb3IsdGhpcy5kaXJ0eS5jb2xvck9mZnNldCwgdGhpcy5kaXJ0eS5jb2xvckxlbmd0aCApLG9mZnNldCApO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gIHRoaXMuZGlydHkuY29sb3JMZW5ndGggLyA0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMuZGlydHkuaW5kZXhMZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICBlbmNvZGVkQnVmZmVyLnNldCggVHlwZWRBcnJheUhlbHBlci5VaW50MTZUb0Zsb2F0MzIoIHRoaXMuaW5kaWNlcyx0aGlzLmRpcnR5LmluZGV4T2Zmc2V0LCB0aGlzLmRpcnR5LmluZGV4TGVuZ3RoICksb2Zmc2V0ICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRpcnR5LnRleHR1cmVSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGlydHkucG9zaXRpb25SZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGlydHkudGV4Q29vcmRSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGlydHkuY29sb3JSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGlydHkuaW5kZXhSZXNldCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgZ2VuZXJpY0RhdGE7XHJcbiAgICAgICAgbGV0IHRyYW5zZmVyO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYV9nZW5lcmljQXJyYXkgKSB7XHJcbiAgICAgICAgICAgIGdlbmVyaWNEYXRhID0gdGhpcy5hX2dlbmVyaWNBcnJheTtcclxuICAgICAgICAgICAgdHJhbnNmZXIgPSBbXTtcclxuICAgICAgICAgICAgZm9yICggbGV0IG5hbWUgaW4gdGhpcy5hX2dlbmVyaWNBcnJheSApIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZmVyLnB1c2goIHRoaXMuYV9nZW5lcmljQXJyYXlbbmFtZV0uZGF0YS5idWZmZXIgKTtcclxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFtlbmNvZGVkQnVmZmVyLG51bGwsZ2VuZXJpY0RhdGEsdHJhbnNmZXJdO1xyXG4gICAgfVxyXG59XHJcbi8qKiBcclxuICogXHJcbiAqIEBlbnVtIHtvYmplY3R9IFxyXG4gKi9cclxuTWVzaC5BcnJheVR5cGVzID0ge1xyXG4gICAgVUlOVDMyOiAgVWludDMyQXJyYXksXHJcbiAgICBVSU5UMTY6ICBVaW50MTZBcnJheSxcclxuICAgIFVJTlQ4OiAgIFVpbnQ4QXJyYXksXHJcbiAgICBGTE9BVDMyOiBGbG9hdDMyQXJyYXksXHJcbn07XHJcblxyXG4iLCJpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL1Nwcml0ZSc7XG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vRXZlbnQnO1xuaW1wb3J0IHsgZWFzaW5nIH0gZnJvbSAnLi9lYXNpbmcnO1xuXG5jb25zdCBFTVBUWV9LRVkgPSBcIiRcIjtcbmNvbnN0IFNUT1BfTUFSSyA9IC0xO1xuXG4vKiogXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBPcHRpb25zIFxuICogQHBhcmFtIHtib29sZWFufSBhdXRvUGxheVxuKi9cblxuLyoqIEB0eXBlIHtPcHRpb25zfSAqL1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgYXV0b1BsYXk6IHRydWVcbn07XG5cbi8vIFxuLypcbiAgICDsiqTthYzsnbTsp4Dsl5Ag67aZ7Ja0IOyeiOydhCDrlYzrp4wg7J6R64+Z7ZWc64ukLlxuICAgIOydvOuwmCDqsJzssrTsnZgg6rCS7J2EIOyhsOygle2VoCDrlYzrj4Qg7IKs7Jqp7ZWgIOyImCDsnojri6QuXG5cbiAgICBcImVhc2VcIixcbiAgICBbMCwxMCx0YXJnZXQse3g6WzAsMTAwLGVhc2VdfV1cbiAgICBbMCxcImdvdG9cIixcImV2ZW50XCJdXG4gICAgWzAsXCJzdG9wXCJdXG5cbiovXG5cbi8vICAqIEB0eXBlZGVmIHtPYmplY3QuPHN0cmluZyxSYW5nZT59IFByb3BzXG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlcnwqW119IFJhbmdlXG4gKiBAdHlwZWRlZiB7T2JqZWN0LjxzdHJpbmcsUmFuZ2U+fSBQcm9wc1xuICogQHR5cGVkZWYge1tudW1iZXIsbnVtYmVyLG9iamVjdHxzdHJpbmddfFtudW1iZXIsbnVtYmVyLG9iamVjdHxzdHJpbmcsUHJvcHNdfFtudW1iZXIsc3RyaW5nLHN0cmluZ3xudW1iZXJdfFtudW1iZXIsc3RyaW5nXX0gTGluZVxuICogQHR5cGVkZWYge0xpbmVbXX0gVGltZWxpbmVcbiAqIEB0eXBlZGVmIHtPYmplY3QuPHN0cmluZyxUaW1lbGluZT59IFRpbWVsaW5lR3JvdXBcbiAqL1xuXG4vKipcbiAqXG4gKiBAdGhpcyBNb3ZpZUNsaXBcbiAqIEBwYXJhbSB7RXZlbnR9IGVcbiAqL1xuZnVuY3Rpb24gb25FbnRlckZyYW1lKCBlICkge1xuICAgIC8qKiBAdHlwZSB7e3RpbWVsaW5lOm9iamVjdCxhY3Rpb246b2JqZWN0LGxhc3RGcmFtZTpudW1iZXJ9fSAqL1xuICAgIGNvbnN0IGFuaSA9IHRoaXMuX19tYy5hbmltYXRpb25zW3RoaXMuX19tYy5jdXJyZW50QW5pbWF0aW9uXTtcblxuICAgIGlmICggYW5pID09IG51bGwgKSByZXR1cm47XG4gICAgZm9yICggbGV0IFt0YXJnZXQsIHRpbWVsaW5lXSBvZiBhbmkudGltZWxpbmUuZW50cmllcygpICkge1xuICAgICAgICBsZXQgbm9LZXkgPSB0cnVlO1xuXG4gICAgICAgIC8vY29uc29sZS5hc3NlcnQodGFyZ2V0U3ByaXRlIGluc3RhbmNlb2YgU3ByaXRlKTtcbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9fbWMudGFyZ2V0c1t0YXJnZXRdO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIHRhcmdldCAhPSBudWxsLCBgTW92aWVDbGlw7J2YIO2DgOqyn+ydhCDssL7snYQg7IiYIOyXhuyKteuLiOuLpC5gICk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBjb25zdCBwYXJhbSBpbiB0aW1lbGluZSApIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGltZWxpbmVbcGFyYW1dW3RoaXMuX19tYy5jdXJyZW50RnJhbWVdO1xuXG4gICAgICAgICAgICBpZiAoIHBhcmFtID09IEVNUFRZX0tFWSApIHtcbiAgICAgICAgICAgICAgICBub0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggdmFsdWUgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcGFyYW1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgbm9LZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGFyZ2V0IGluc3RhbmNlb2YgU3ByaXRlICkge1xuICAgICAgICAgICAgaWYgKCBub0tleSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY29udGFpbnMoIHRhcmdldCApICkgdGhpcy5yZW1vdmVDaGlsZCggdGFyZ2V0ICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICggIXRoaXMuY29udGFpbnMoIHRhcmdldCApICkgdGhpcy5hZGRDaGlsZCggdGFyZ2V0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb24gPSBhbmkuYWN0aW9uW3RoaXMuX19tYy5jdXJyZW50RnJhbWVdO1xuXG4gICAgaWYgKCBhY3Rpb24gIT0gbnVsbCApIHtcbiAgICAgICAgaWYgKCBhY3Rpb24gPT0gU1RPUF9NQVJLICkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBhY3Rpb24gPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIGNvbnN0IFtoZWFkZXIsIHZhbHVlLCBleHRyYV0gPSBhY3Rpb24uc3BsaXQoIFwiOlwiICk7XG5cbiAgICAgICAgICAgIGlmICggaGVhZGVyID09IFwiYW5pXCIgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nb3RvQW5kUGxheSggZXh0cmEgIT0gbnVsbCA/IHZhbHVlICsgXCI6XCIgKyBleHRyYSA6IHZhbHVlICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBoZWFkZXIgPT0gXCJzb3VuZFwiICkge1xuICAgICAgICAgICAgICAgIC8vVE9ETzpcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGhlYWRlciA9PSBcImV2ZW50XCIgKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPOlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX21jLmN1cnJlbnRGcmFtZSA9IHBhcnNlSW50KCBhY3Rpb24gKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggdGhpcy5fX21jLnBsYXlpbmcgPT0gZmFsc2UgfHwgdGhpcy5fX21jLmN1cnJlbnRGcmFtZSA+PSBhbmkubGFzdEZyYW1lICkgdGhpcy5zdG9wKCk7XG4gICAgICAgIGVsc2UgdGhpcy5fX21jLmN1cnJlbnRGcmFtZSsrO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAdGhpcyBNb3ZpZUNsaXBcbiAqIEBwYXJhbSB7VGltZWxpbmV9IHRsXG4gKiBAcmV0dXJucyB7e3RpbWVsaW5lOm9iamVjdCxhY3Rpb246b2JqZWN0LGxhc3RGcmFtZTpudW1iZXJ9fVxuICovXG5mdW5jdGlvbiBwYXJzZVRpbWVsaW5lKCB0bCApIHtcbiAgICBjb25zdCB0aW1lbGluZSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhY3Rpb24gPSB7fTtcbiAgICBsZXQgcGFyYW1UaW1lbGluZTtcbiAgICBsZXQgbGFzdEZyYW1lID0gMDtcblxuICAgIGZvciAoIGNvbnN0IGkgaW4gdGwgKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0bFtpXTtcblxuICAgICAgICBpZiAoIHR5cGVvZiBsaW5lWzFdID09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICBjb25zdCBbZnJhbWUsIGNvbW1hbmQsIGxhYmVsXSA9IGxpbmU7XG5cbiAgICAgICAgICAgIGlmICggY29tbWFuZCA9PSBcInN0b3BcIiApIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25bZnJhbWVdID0gU1RPUF9NQVJLO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggY29tbWFuZCA9PSBcImdvdG9cIiApIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25bZnJhbWVdID0gdHlwZW9mIGxhYmVsID09IFwibnVtYmVyXCIgPyBsYWJlbCA6IFwiYW5pOlwiICsgbGFiZWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjb21tYW5kID09IFwiZXZlbnRcIiApIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25bZnJhbWVdID0gXCJldmVudDpcIiArIGxhYmVsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggY29tbWFuZCA9PSBcInNvdW5kXCIgKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uW2ZyYW1lXSA9IFwic291bmQ6XCIgKyBsYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFtzdGFydEZyYW1lLCBlbmRGcmFtZSwgdGFyZ2V0T2JqZWN0LCBwcm9wc10gPSBsaW5lO1xuXG4gICAgICAgICAgICBwYXJhbVRpbWVsaW5lID0gdGltZWxpbmUuZ2V0KCB0YXJnZXRPYmplY3QgKSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCBwcm9wcyA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHBhcmFtVGltZWxpbmVbRU1QVFlfS0VZXSA9IHBhcmFtVGltZWxpbmVbRU1QVFlfS0VZXSB8fCB7fTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGZvciAoIGxldCBmcmFtZSA9IHN0YXJ0RnJhbWU7IGZyYW1lIDw9IGVuZEZyYW1lOyBmcmFtZSsrICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVRpbWVsaW5lW0VNUFRZX0tFWV1bZnJhbWVdID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZm9yICggY29uc3Qga2V5IGluIHByb3BzICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVRpbWVsaW5lW2tleV0gPSBwYXJhbVRpbWVsaW5lW2tleV0gfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBwcm9wc1trZXldICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGVhc2VdID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVhc2luZ0Z1bmMgPSAoIHR5cGVvZiBlYXNlID09IFwiZnVuY3Rpb25cIiA/IGVhc2UgOiBlYXNpbmdbZWFzZV0gKSB8fCBlYXNpbmcubGluZWFyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBsZXQgZnJhbWUgPSBzdGFydEZyYW1lOyBmcmFtZSA8PSBlbmRGcmFtZTsgZnJhbWUrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVGltZWxpbmVba2V5XVtmcmFtZV0gPSBlYXNpbmdGdW5jKCAoIGZyYW1lIC0gc3RhcnRGcmFtZSApIC8gKCBlbmRGcmFtZSAtIHN0YXJ0RnJhbWUgKSApICogKCBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUgKSArIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGxldCBmcmFtZSA9IHN0YXJ0RnJhbWU7IGZyYW1lIDw9IGVuZEZyYW1lOyBmcmFtZSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVGltZWxpbmVba2V5XVtmcmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGltZWxpbmUuc2V0KCB0YXJnZXRPYmplY3QsIHBhcmFtVGltZWxpbmUgKTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgbGFzdEZyYW1lID0gTWF0aC5tYXgoIGxhc3RGcmFtZSwgZW5kRnJhbWUgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGFjdGlvbix0aW1lbGluZSxsYXN0RnJhbWUgfTtcbn1cblxuXG5leHBvcnQgY2xhc3MgTW92aWVDbGlwIGV4dGVuZHMgU3ByaXRlIHtcbiAgICAvKipcbiAgICAgKiDsnpDrj5nsnLzroZwg7JWg64uI66mU7J207IWY7J2EIO2VmOuKlCBNb3ZpZUNsaXAg6rCc7LK066W8IOunjOuToOuLpC5cbiAgICAgKiBNb3ZpZUNsaXDsnYAgVHdlZW7snbTrgpggc2hvdyxoaWRl66W8IOyLnOqwhOyInOyXkCDrp57qsowg67O07Jes7KSEIOyImCDsnojri6QuXG4gICAgICogXG4gICAgICog7JiI7KCcMSkgQXJyYXnrpbwg7IKs7Jqp7ZWcIOqyveyasFxuICAgICAqIFxuICAgICAqIG5ldyBNb3ZpZUNsaXAoW1xuICAgICAqICAgICBbMCwxMCx0YXJnZXRTcHIseyB4OlswLDEwMCxcIm91dEN1YmljXCJdLCB5OjIwLCBhbHBoYTpbMC41LDFdIH1dLFxuICAgICAqICAgICBbMTEsMjAsdGFyZ2V0U3ByLHsgeDpbMTAwLDAsZWFzaW5nLmluQm91bmNlXSB9XVxuICAgICAqICAgICBbMjAsXCJnb3RvXCIsMF0gLy8g7J2066CH6rKMIOujqO2UhOulvCDsi5ztgqwg7IiY64+EIOyeiOuLpC4g7JeG7Jy866m0IOuniOyngOuniSDtlITroIjsnoTsl5DshJwg66mI7LakLiBcInN0b3BcIiwgXCJldmVudFwiLCBcInNvdW5kXCIg65Ox7J2EIOyTuCDsiJgg7J6I64ukLlxuICAgICAqIF0pXG4gICAgICogXG4gICAgICog7JiI7KCcMikgT2JqZWN066W8IOyCrOyaqe2VnCDqsr3smrBcbiAgICAgKiBcbiAgICAgKiBuZXcgTW92aWVDbGlwKHtcbiAgICAgKiAgICAgIGRlZmF1bHQ6IFtcbiAgICAgKiAgICAgICAgICBbMCwxMCx0YXJnZXRTcHIsIHsgeTogMTAgfV1cbiAgICAgKiAgICAgICAgICA6XG4gICAgICogICAgICBdLFxuICAgICAqICAgICAgc2hvdzogW1xuICAgICAqICAgICAgICAgIFswLDIwLHRhcmdldFNwciwgeyB4OiA1IH1dXG4gICAgICogICAgICAgICAgWzIwLFwiZ290b1wiLFwiZGVmYXVsdFwiXVxuICAgICAqICAgICAgXVxuICAgICAqIH0pO1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7VGltZWxpbmV8VGltZWxpbmVHcm91cD19IHRpbWVsaW5lRGF0YSAtIO2VmOuCmOydmCDtg4DsnoTrnbzsnbgg7JWg64uI66mU7J207IWY7J2EIEFycmF566GcIOuEo+qxsOuCmCDri6TsiJjsnZgg7JWg64uI66mU7J207IWY7J2EIE9iamVjdOuhnCDrhKPsnYQg7IiYIOyeiOuLpFxuICAgICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdGlvbnNcbiAgICAgKiBAbWVtYmVyb2YgTW92aWVDbGlwXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoIHRpbWVsaW5lRGF0YSwgb3B0aW9ucyAgKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX19tYyA9IHt9O1xuICAgICAgICB0aGlzLl9fbWMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5fX21jLmN1cnJlbnRBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19tYy5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19tYy50YXJnZXRzID0ge307XG4gICAgICAgIHRoaXMuX19tYy5hbmltYXRpb25zID0ge307XG4gICAgICAgIHRoaXMuX19tYy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbiggZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgKTtcbiAgICAgICAgaWYgKCB0aW1lbGluZURhdGEgKSB0aGlzLmFkZEFuaW1hdGlvbnMoIHRpbWVsaW5lRGF0YSApO1xuICAgICAgICBpZiAoIHRoaXMuX19tYy5vcHRpb25zLmF1dG9QbGF5ICkge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZpZUNsaXDsl5AgYW5pbWF0aW9u7J2EIOy2lOqwgO2VnOuLpC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1RpbWVsaW5lfFRpbWVsaW5lR3JvdXB9IHRpbWVsaW5lRGF0YSAtIO2VmOuCmOydmCDtg4DsnoTrnbzsnbgg7JWg64uI66mU7J207IWY7J2EIEFycmF566GcIOuEo+qxsOuCmCDri6TsiJjsnZgg7JWg64uI66mU7J207IWY7J2EIE9iamVjdOuhnCDrhKPsnYQg7IiYIOyeiOuLpFxuICAgICAqIEBtZW1iZXJvZiBNb3ZpZUNsaXBcbiAgICAgKi9cbiAgICBhZGRBbmltYXRpb25zKCB0aW1lbGluZURhdGEgKSB7XG4gICAgICAgIGlmICggdGltZWxpbmVEYXRhICE9IG51bGwgKSB7XG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHRpbWVsaW5lRGF0YSApICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19tYy5hbmltYXRpb25zW1wiZGVmYXVsdFwiXSA9IHBhcnNlVGltZWxpbmUuY2FsbCggdGhpcywgdGltZWxpbmVEYXRhICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX21jLmN1cnJlbnRBbmltYXRpb24gPSBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICggY29uc3QgbGFiZWwgaW4gdGltZWxpbmVEYXRhICkge1xuICAgICAgICAgICAgICAgICAgICAvLyDssqvrsojsp7gg7JWg64uI66mU7J207IWY7J2EIOuUlO2PtO2KuOuhnFxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuX19tYy5jdXJyZW50QW5pbWF0aW9uID09IG51bGwgKSB0aGlzLl9fbWMuY3VycmVudEFuaW1hdGlvbiA9IGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbWMuYW5pbWF0aW9uc1tsYWJlbF0gPSBwYXJzZVRpbWVsaW5lLmNhbGwoIHRoaXMsIHRpbWVsaW5lRGF0YVtsYWJlbF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDrkZAg6rCc7J2YIE1vdmllQ2xpcOydhCDrs5HtlantlZzri6RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TW92aWVDbGlwfSBtY1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZVxuICAgICAqIEBtZW1iZXJvZiBNb3ZpZUNsaXBcbiAgICAgKi9cbiAgICBtZXJnZSggbWMscmVwbGFjZSApIHtcbiAgICAgICAgZm9yICggY29uc3QgbGFiZWwgaW4gbWMuX19tYy5hbmltYXRpb25zICkge1xuICAgICAgICAgICAgY29uc3QgYW5pID0gbWMuX19tYy5hbmltYXRpb25zW2xhYmVsXTtcblxuICAgICAgICAgICAgaWYgKCByZXBsYWNlIHx8IHRoaXMuX19tYy5hbmltYXRpb25zW2xhYmVsXSA9PSBudWxsICkgdGhpcy5fX21jLmFuaW1hdGlvbnNbbGFiZWxdID0gYW5pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBzZXRUYXJnZXQoIG5hbWUsIHRhcmdldCApIHtcbiAgICAgICAgdGhpcy5fX21jLnRhcmdldHNbbmFtZV0gPSB0YXJnZXQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBmXG4gICAgICogQG1lbWJlcm9mIE1vdmllQ2xpcFxuICAgICAqL1xuICAgIGdvdG9BbmRQbGF5KCBmICkge1xuICAgICAgICBpZiAoIHR5cGVvZiBmID09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFthbmltYXRpb25OYW1lLCBmcmFtZV0gPSBmLnNwbGl0KCBcIjpcIiApO1xuXG4gICAgICAgICAgICB0aGlzLl9fbWMuY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGlvbk5hbWU7XG4gICAgICAgICAgICB0aGlzLl9fbWMuY3VycmVudEZyYW1lID0gZnJhbWUgIT0gbnVsbCA/IHBhcnNlSW50KCBmcmFtZSApIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCB0eXBlb2YgZiA9PSBcIm51bWJlclwiICk7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX19tYy5jdXJyZW50RnJhbWUgPSBwYXJzZUludCggZiApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmXG4gICAgICogQG1lbWJlcm9mIE1vdmllQ2xpcFxuICAgICAqL1xuICAgIGdvdG9BbmRTdG9wKCBmICkge1xuICAgICAgICBpZiAoIHR5cGVvZiBmID09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFthbmltYXRpb25OYW1lLCBmcmFtZV0gPSBmLnNwbGl0KCBcIjpcIiApO1xuXG4gICAgICAgICAgICB0aGlzLl9fbWMuY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGlvbk5hbWU7XG4gICAgICAgICAgICB0aGlzLl9fbWMuY3VycmVudEZyYW1lID0gZnJhbWUgIT0gbnVsbCA/IHBhcnNlSW50KCBmcmFtZSApIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCB0eXBlb2YgZiA9PSBcIm51bWJlclwiICk7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX19tYy5jdXJyZW50RnJhbWUgPSBwYXJzZUludCggZiApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuXG4gICAgcGxheSggYW5pTmFtZSApIHtcbiAgICAgICAgaWYgKCBhbmlOYW1lICE9IG51bGwgKSB7XG4gICAgICAgICAgICB0aGlzLmdvdG9BbmRQbGF5KCBhbmlOYW1lICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICF0aGlzLl9fbWMucGxheWluZyApIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggRXZlbnQuRU5URVJfRlJBTUUsb25FbnRlckZyYW1lLHRoaXMgKTtcbiAgICAgICAgICAgIHRoaXMuX19tYy5wbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICggdGhpcy5fX21jLnBsYXlpbmcgKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIEV2ZW50LkVOVEVSX0ZSQU1FLG9uRW50ZXJGcmFtZSx0aGlzICk7XG4gICAgICAgICAgICB0aGlzLl9fbWMucGxheWluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkZXN0aW5hdGlvblxuICAgICAqIEBtZW1iZXJvZiBNb3ZpZUNsaXBcbiAgICAgKi9cbiAgICBzZXRHb3RvQWN0aW9uKCBmLCBkZXN0aW5hdGlvbiApIHtcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGlmICggcGFyc2VJbnQoIGRlc3RpbmF0aW9uICkgPT0gZGVzdGluYXRpb24gKSBkZXN0aW5hdGlvbiA9IHBhcnNlSW50KCBkZXN0aW5hdGlvbiApO1xuICAgICAgICB0aGlzLl9fbWMuYW5pbWF0aW9uc1t0aGlzLl9fbWMuY3VycmVudEFuaW1hdGlvbl0uYWN0aW9uW2ZdID0gZGVzdGluYXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmXG4gICAgICogQG1lbWJlcm9mIE1vdmllQ2xpcFxuICAgICAqL1xuICAgIHNldFN0b3BBY3Rpb24oIGYgKSB7XG4gICAgICAgIHRoaXMuX19tYy5hbmltYXRpb25zW3RoaXMuX19tYy5jdXJyZW50QW5pbWF0aW9uXS5hY3Rpb25bZl0gPSBTVE9QX01BUks7IC8vIHN0b3BcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIHRhcmdldOydhCDsoJzsmbjtlZjqs6Ag66qo65OgIOuCtOyaqeydtCDrj5nsnbztlZwgTW92aWVDbGlw7J2EIOunjOuToOuLpC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtNb3ZpZUNsaXB9XG4gICAgICogQG1lbWJlcm9mIE1vdmllQ2xpcFxuICAgICAqL1xuICAgIGluc3RhbmNlKCkge1xuICAgICAgICBjb25zdCBuZXdPYmogPSBuZXcgTW92aWVDbGlwKCBudWxsICk7XG5cbiAgICAgICAgbmV3T2JqLl9fbWMuYW5pbWF0aW9ucyA9IHRoaXMuX19tYy5hbmltYXRpb25zO1xuICAgICAgICBuZXdPYmouX19tYy5jdXJyZW50QW5pbWF0aW9uID0gT2JqZWN0LmtleXMoIHRoaXMuX19tYy5hbmltYXRpb25zIClbMF07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oIG5ld09iai5fX21jLnRhcmdldHMsIHRoaXMuX19tYy50YXJnZXRzICk7XG4gICAgICAgIG5ld09iai5wbGF5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG59XG5cbi8vIGxldCBiID0gbmV3IFNwcml0ZSgpO1xuLy8gbmV3IE1vdmllQ2xpcChbXG4vLyAgICAgWzAsIDAsIGIsIHsgeDogWzAsMSxlYXNpbmcub3V0Q3ViaWNdLHk6IFsxLDFdIH1dLFxuLy8gXSk7XG5cblxuIiwiaW1wb3J0IHsgQXNzZXQgfSBmcm9tICcuL0Fzc2V0JztcbmltcG9ydCB7IEZvbnRCYXNlIH0gZnJvbSAnLi9Gb250QmFzZSc7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4vVXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgTXNkZkZvbnQgZXh0ZW5kcyBGb250QmFzZSB7XG4gICAgY29uc3RydWN0b3IoIE1zZGZGb250TmFtZSxyZWZlcmVuY2VTaXplLCBzdHlsZXMgKSB7XG4gICAgICAgIHN1cGVyKCBNc2RmRm9udE5hbWUsIHJlZmVyZW5jZVNpemUsIHN0eWxlcyApO1xuICAgICAgICAvLyBCaXRtYXBcbiAgICAgICAgdGhpcy5hc3NldCA9IG5ldyBBc3NldCggTXNkZkZvbnROYW1lLEFzc2V0LkFzc2V0VHlwZXMuTXNkZkZvbnQgKTtcbiAgICAgICAgLy8g7Y6Y7J207KeA6rCAIOyXrOufrOqwnCDsnojripQg7Y+w7Yq464qUIOyVhOyngSDsspjrpqwg66q77ZWoXG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLmFzc2V0LmZvbnRJbmZvLnBhZ2VzWzBdO1xuICAgICAgICBjb25zdCBwbmdTaXplID0gVXRpbHMuZ2V0SW1hZ2VTaXplKCBwYWdlLmZpbGUgKTtcblxuICAgICAgICB0aGlzLmFzc2V0LmxvYWQoIHsgXG4gICAgICAgICAgICBiaXRtYXA6ICAgICAgICBwYWdlLmZpbGUsIFxuICAgICAgICAgICAgd2lkdGg6ICAgICAgICAgcG5nU2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgIHBuZ1NpemUuaGVpZ2h0LFxuICAgICAgICAgICAgcmVmZXJlbmNlU2l6ZTogdGhpcy5yZWZlcmVuY2VTaXplLFxuICAgICAgICAgICAgc3R5bGVzOiAgICAgICAgdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBmb250SW5mbzogICAgICB0aGlzLmFzc2V0LmZvbnRJbmZvIFxuICAgICAgICB9ICk7XG4gICAgICAgIHRoaXMuZm9udExvYWRlZCA9IGZhbHNlO1xuICAgIH0gICAgXG5cbiAgICBtZWFzdXJlVGV4dFdpZHRoKCBzdHIsc2l6ZSApIHtcbiAgICAgICAgc3VwZXIubWVhc3VyZVRleHRXaWR0aCggc3RyLHNpemUgKTtcblxuICAgICAgICBjb25zdCBmb250SW5mbyA9IHRoaXMuYXNzZXQuZm9udEluZm87XG4gICAgICAgIGNvbnN0IHNjYWxlID0gc2l6ZSA/IHNpemUgLyBmb250SW5mby5pbmZvLnNpemUgOiAxO1xuXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQ29kZUF0KCBpICk7XG4gICAgICAgICAgICBjb25zdCBjaGFySW5mbyA9IGZvbnRJbmZvLmNoYXJzW2NoYXJdO1xuXG4gICAgICAgICAgICB3aWR0aCArPSBjaGFySW5mby54YWR2YW5jZSAqIHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWR0aDsgICAgICAgIFxuICAgIH1cbn1cblxuXG4iLCJcclxuaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAnLi9TcHJpdGUnOyBcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFBhcnRpY2xlcyBleHRlbmRzIFNwcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFBhcnRpY2xlcyggLi4uYXJncyApIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGV4dHVyZSggLi4uYXJncyApIHtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlJztcclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL1V0aWxzJztcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFBpeGVsIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCBjb2xvciA9IDB4ZmZmZmZmLCBhbHBoYSA9IDEsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuXyQkc3ByaXRlVHlwZSA9IFNwcml0ZS5TcHJpdGVUeXBlcy5QSVhFTDtcclxuICAgICAgICB0aGlzLl8kJHVwZGF0ZUNvZGUgPSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgICAgIHRoaXMucGl4ZWxDb2xvciA9IFV0aWxzLmhleDJyZ2JhKCBjb2xvcixhbHBoYSApO1xyXG4gICAgICAgIHRoaXMucGl4ZWxXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMucGl4ZWxIZWlnaHQgPSBoZWlnaHQ7ICAgIFxyXG4gICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMueCA9IDA7XHJcbiAgICAgICAgdGhpcy5fJCRsb2NhbEJvdW5kcy55ID0gMDtcclxuICAgICAgICB0aGlzLl8kJGxvY2FsQm91bmRzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fJCRsb2NhbEJvdW5kcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q29sb3IoIGNvbG9yID0gMHhmZmZmZmYsIGFscGhhID0gMSApIHtcclxuICAgICAgICB0aGlzLnBpeGVsQ29sb3IgPSBVdGlscy5oZXgycmdiYSggY29sb3IsYWxwaGEgKTtcclxuICAgICAgICB0aGlzLl8kJHVwZGF0ZUNvZGUgPSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgfVxyXG5cclxuICAgIGVuY29kZUV4dHJhUmVuZGVyaW5nSW5mbygpIHtcclxuICAgICAgICBsZXQgZW5jb2RlZEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoIDYgKTtcclxuXHJcbiAgICAgICAgZW5jb2RlZEJ1ZmZlclswXSA9IHRoaXMucGl4ZWxXaWR0aDtcclxuICAgICAgICBlbmNvZGVkQnVmZmVyWzFdID0gdGhpcy5waXhlbEhlaWdodDtcclxuICAgICAgICBlbmNvZGVkQnVmZmVyLnNldCggdGhpcy5waXhlbENvbG9yLDIgKTtcclxuICAgICAgICByZXR1cm4gW2VuY29kZWRCdWZmZXJdO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCIvL1xyXG4vLyDroIzrjZTrp4Hqs7wg66Gc7KeBIOyTsOugiOuTnOqwgCDrtoTrpqzrkJjslrQg7J6I6riwIOuVjOusuOyXkCBSVOqwgCDqsIDsnqUg66eM65Ok6riwIOyWtOugteuLpC5cclxuLy8gUlTrpbwg7JqU7LKt7ZWY64qUIOyLnOygkOyXkOyEnCDrqZTsnbjsk7DroIjrk5zsl5Ag7IOd7ISxXHJcbi8vIGRyYXftlaAg65WMIOq3uOumtCDsiqTtlITrnbzsnbTtirgg7Yq466as7J2YIOyKpOuDheyDt+ydhCDsoITshqFcclxuLy8gbWFpbuyXkOyEnOuKlCDrsJvsnYAg7Iqk64OF7IO37J2EIOqwgOyngOqzoCBkcmF366W8IOymieyLnCDsiJjtlolcclxuLy8gUlTripQg7IiY64+Z7Jy866GcIO2MjOq4sCDtlbTso7zslrTslbwg7ZWoXHJcblxyXG5cclxuaW1wb3J0IHsgYXBwbGljYXRpb24sIEFwcGxpY2F0aW9uIH0gZnJvbSAnLi9BcHBsaWNhdGlvbic7XHJcbmltcG9ydCB7IFRleHR1cmVCYXNlIH0gZnJvbSAnLi9UZXh0dXJlQmFzZSc7XHJcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlJztcclxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL1V0aWxzJztcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vVHlwZXMnO1xyXG5pbXBvcnQgeyBBc3NldCB9IGZyb20gJy4vQXNzZXQnO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgUmVuZGVyVGFyZ2V0IGV4dGVuZHMgVGV4dHVyZUJhc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKkNyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVuZGVyVGFyZ2V0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlclxyXG4gICAgICogQG1lbWJlcm9mIFJlbmRlclRhcmdldFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvciggd2lkdGgsIGhlaWdodCwgZmlsdGVyID0gZmFsc2UgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmFzc2V0ID0gbmV3IEFzc2V0KCBcIjxSVDoqPlwiLEFzc2V0LkFzc2V0VHlwZXMuUmVuZGVyVGFyZ2V0ICk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudXZSZWN0ID0gbmV3IFJlY3QoIDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgIHRoaXMuYXNzZXQubG9hZCggeyB3aWR0aDogdGhpcy53aWR0aCxoZWlnaHQ6IHRoaXMuaGVpZ2h0LGZpbHRlcjogZmlsdGVyIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2xvcj0wXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbHBoYT0wXVxyXG4gICAgICogQG1lbWJlcm9mIFJlbmRlclRhcmdldFxyXG4gICAgICovXHJcbiAgICBjbGVhciggY29sb3IgPSAwICwgYWxwaGEgPSAwICkge1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLnBvc3RNZXNzYWdlVG9SZW5kZXIoIHsgbXNnOiBcImFkZENvbW1hbmRcIiwgY2xhc3M6IFwiUmVuZGVyVGFyZ2V0XCIsIG1ldGhvZDogXCJjbGVhclwiLGFyZ3M6IFt0aGlzLmFzc2V0LmlkLCBVdGlscy5oZXgycmdiYSggY29sb3IsYWxwaGEgKV0gfSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Nwcml0ZX0gc3ByXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVuZGVyVGFyZ2V0XHJcbiAgICAgKi9cclxuICAgIGRyYXcoIHNwciApIHtcclxuICAgICAgICBsZXQgW2J1Zix0cmFuc2Zlckxpc3RdID0gc3ByLmVuY29kZVJlbmRlcmluZ0luZm9XaXRoQ2hpbGRyZW4oKTtcclxuXHJcbiAgICAgICAgYXBwbGljYXRpb24ucG9zdE1lc3NhZ2VUb1JlbmRlciggeyBtc2c6IFwiYWRkQ29tbWFuZFwiLCBjbGFzczogXCJSZW5kZXJUYXJnZXRcIiwgbWV0aG9kOiBcImRyYXdcIixhcmdzOiBbdGhpcy5hc3NldC5pZCwgYnVmXSB9LCB0cmFuc2Zlckxpc3QgKTtcclxuICAgIH1cclxufVxyXG4iLCJcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlJztcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi9FdmVudCc7XG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4vVXRpbHMnO1xuaW1wb3J0IHsgVGltZXIgfSBmcm9tICcuL1RpbWVyJztcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuL01lc2gnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9SZW5kZXJUYXJnZXQnO1xuLy8gY29uc3QgU3ByaXRlID0gcmVxdWlyZShcIi4vc3ByaXRlXCIpO1xuLy8gY29uc3QgTWVzaCA9IHJlcXVpcmUoXCIuL21lc2hcIik7XG4vLyBjb25zdCBSZW5kZXJUYXJnZXQgPSByZXF1aXJlKFwiLi9yZW5kZXJUYXJnZXRcIik7XG4vLyBjb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLy8gY29uc3QgRXZlbnQgPSByZXF1aXJlKFwiLi9ldmVudFwiKTtcblxuZnVuY3Rpb24gcmFkKCBkICkge1xuICAgIHJldHVybiBkICogTWF0aC5QSSAvIDE4MDtcbn1cblxubGV0IF9uZWVkUlQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRFYXNlKCByYXRpbyApIHtcbiAgICByZXR1cm4gcmF0aW87XG59XG5cblxuXG5leHBvcnQgY2xhc3MgU2NlbmVNYW5hZ2VyIGV4dGVuZHMgU3ByaXRlIHtcbiAgICBjb25zdHJ1Y3RvciggYXBwbGljYXRpb24sIHgsIHksIHcsIGgsIGx3LCBsaCApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgICAgICB0aGlzLnN0YWdlID0gYXBwbGljYXRpb24uc3RhZ2U7XG4gICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgdGhpcy54MiA9IHggKyB3O1xuICAgICAgICB0aGlzLnkyID0geSArIGg7XG4gICAgICAgIHRoaXMubHcgPSBsdztcbiAgICAgICAgdGhpcy5saCA9IGxoO1xuICAgICAgICB0aGlzLnR3ZWVuaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkV2ZW50Q2F0Y2hlciA9IG5ldyBTcHJpdGUoKTtcbiAgICAgICAgLyoqIEB0eXBlIHtNZXNofSAqL1xuICAgICAgICB0aGlzLl9ibGFja01lc2ggPSBudWxsO1xuICAgICAgICAvKiogQHR5cGUge1JlbmRlclRhcmdldH0gKi9cbiAgICAgICAgdGhpcy5fUlQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBbVHJhbnNpdGlvbnNdXG5cdFxuICAgIC8vIHNjZW5lMiA9PSBuZXdTY2VuZTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIO2KuOuenOyngOyFmOuTpFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgIHN0YXRpYyBhY2NvcmRpb25MZWZ0KCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3QgdyA9IHNlbGYubHc7XG4gICAgICAgIC8vbGV0IGggPSBzZWxmLmxoO1xuICAgICAgICBjb25zdCBzY2FsZTEgPSAoIDEgLSB0ICk7XG4gICAgICAgIGNvbnN0IHNjYWxlMiA9IHQ7XG5cbiAgICAgICAgc2NlbmUxLnNldFNjYWxlWCggc2NhbGUxICk7XG4gICAgICAgIHNjZW5lMi5zZXRYKCB3ICogc2NhbGUxICk7XG4gICAgICAgIHNjZW5lMi5zZXRTY2FsZVgoIHNjYWxlMiApO1xuICAgIH1cblxuICAgIHN0YXRpYyBhY2NvcmRpb25SaWdodCggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLmx3O1xuICAgICAgICAvL2xldCBoID0gc2VsZi5saDtcbiAgICAgICAgY29uc3Qgc2NhbGUxID0gKCAxIC0gdCApO1xuICAgICAgICBjb25zdCBzY2FsZTIgPSB0O1xuXG4gICAgICAgIHNjZW5lMS5zZXRYKCB3ICogc2NhbGUyICk7XG4gICAgICAgIHNjZW5lMS5zZXRTY2FsZVgoIHNjYWxlMSApO1xuICAgICAgICBzY2VuZTIuc2V0U2NhbGVYKCBzY2FsZTIgKTtcbiAgICB9XG5cblxuICAgIHN0YXRpYyB6b29tT3V0KCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3QgdyA9IHNlbGYubHc7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLmxoO1xuICAgICAgICBjb25zdCBzY2FsZTEgPSB0ICsgMTtcbiAgICAgICAgY29uc3Qgc2NhbGUyID0gdDtcbiAgICAgICAgY29uc3QgYWxwaGEgPSAxIC0gdCAqIDEuMjtcblxuICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIGFscGhhICk7XG4gICAgICAgIGlmICggYWxwaGEgPD0gMCApIHNjZW5lMS5zZXRWaXNpYmxlKCBmYWxzZSApO1xuXG4gICAgICAgIHNjZW5lMS5zZXRTY2FsZSggc2NhbGUxICk7XG4gICAgICAgIHNjZW5lMS5zZXRQb3NpdGlvbiggLSggdyAqIHNjYWxlMSAtIHcgKSAvIDIsIC0oIGggKiBzY2FsZTEgLSBoICkgLyAyICk7XG4gICAgICAgIHNjZW5lMi5zZXRBbHBoYSggdCApO1xuICAgICAgICBzY2VuZTIuc2V0U2NhbGUoIHNjYWxlMiApO1xuICAgICAgICBzY2VuZTIuc2V0UG9zaXRpb24oIC0oIHcgKiBzY2FsZTIgLSB3ICkgLyAyLCAtKCBoICogc2NhbGUyIC0gaCApIC8gMiApO1xuICAgIH1cblxuICAgIHN0YXRpYyB6b29tSW4oIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3ID0gc2VsZi5sdztcbiAgICAgICAgY29uc3QgaCA9IHNlbGYubGg7XG4gICAgICAgIGNvbnN0IHNjYWxlMSA9IHQgKyAxO1xuICAgICAgICBjb25zdCBzY2FsZTIgPSB0O1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUxLnNldFNjYWxlKCBzY2FsZTEgKTtcbiAgICAgICAgc2NlbmUxLnNldFBvc2l0aW9uKCAtKCB3ICogc2NhbGUxIC0gdyApIC8gMiwgLSggaCAqIHNjYWxlMSAtIGggKSAvIDIgKTtcbiAgICAgICAgc2NlbmUyLnNldEFscGhhKCB0ICk7XG4gICAgICAgIHNjZW5lMi5zZXRTY2FsZSggc2NhbGUyICk7XG4gICAgICAgIHNjZW5lMi5zZXRQb3NpdGlvbiggLSggdyAqIHNjYWxlMiAtIHcgKSAvIDIsIC0oIGggKiBzY2FsZTIgLSBoICkgLyAyICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHpvb21PdXRDcm9zcyggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLmx3O1xuICAgICAgICBjb25zdCBoID0gc2VsZi5saDtcbiAgICAgICAgY29uc3Qgc2NhbGUxID0gdCArIDE7XG4gICAgICAgIGNvbnN0IHNjYWxlMiA9ICggMSAtIHQgKSArIDE7XG4gICAgICAgIGNvbnN0IGFscGhhID0gMSAtIHQgKiAxLjI7XG5cbiAgICAgICAgc2NlbmUxLnNldEFscGhhKCBhbHBoYSApO1xuICAgICAgICBpZiAoIGFscGhhIDw9IDAgKSBzY2VuZTEuc2V0VmlzaWJsZSggZmFsc2UgKTtcblxuICAgICAgICBzY2VuZTEuc2V0U2NhbGUoIHNjYWxlMSApO1xuICAgICAgICBzY2VuZTEuc2V0UG9zaXRpb24oIC0oIHcgKiBzY2FsZTEgLSB3ICkgLyAyLCAtKCBoICogc2NhbGUxIC0gaCApIC8gMiApO1xuICAgICAgICBzY2VuZTIuc2V0QWxwaGEoIHQgKTtcbiAgICAgICAgc2NlbmUyLnNldFNjYWxlKCBzY2FsZTIgKTtcbiAgICAgICAgc2NlbmUyLnNldFBvc2l0aW9uKCAtKCB3ICogc2NhbGUyIC0gdyApIC8gMiwgLSggaCAqIHNjYWxlMiAtIGggKSAvIDIgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgem9vbUluQ3Jvc3MoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3ID0gc2VsZi5sdztcbiAgICAgICAgY29uc3QgaCA9IHNlbGYubGg7XG4gICAgICAgIGNvbnN0IHNjYWxlMSA9ICggMSAtIHQgKTtcbiAgICAgICAgY29uc3Qgc2NhbGUyID0gdDtcblxuICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDEgLSB0ICk7XG4gICAgICAgIHNjZW5lMS5zZXRTY2FsZSggc2NhbGUxICk7XG4gICAgICAgIHNjZW5lMS5zZXRQb3NpdGlvbiggLSggdyAqIHNjYWxlMSAtIHcgKSAvIDIsIC0oIGggKiBzY2FsZTEgLSBoICkgLyAyICk7XG4gICAgICAgIHNjZW5lMi5zZXRBbHBoYSggdCApO1xuICAgICAgICBzY2VuZTIuc2V0U2NhbGUoIHNjYWxlMiApO1xuICAgICAgICBzY2VuZTIuc2V0UG9zaXRpb24oIC0oIHcgKiBzY2FsZTIgLSB3ICkgLyAyLCAtKCBoICogc2NhbGUyIC0gaCApIC8gMiApO1xuICAgIH1cblxuXG4gICAgc3RhdGljIHNwaW5DVyggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLmx3O1xuICAgICAgICBjb25zdCBoID0gc2VsZi5saDtcbiAgICAgICAgLy9cdGxldCBhMSA9ICgxLXQpICogMzYwO1xuICAgICAgICBjb25zdCBhMSA9IHQgKiAxODA7XG4gICAgICAgIGNvbnN0IGEyID0gMTgwICsgdCAqIDE4MDtcbiAgICAgICAgLy9sZXQgbCA9IE1hdGguc3FydCgodyAvIDIpICoqIDIsIChoIC8gMikgKiogMik7XG4gICAgICAgIGNvbnN0IFt4MSwgeTFdID0gW01hdGguY29zKCByYWQoIGExICkgKSAqIHcgLyAyIC0gTWF0aC5zaW4oIHJhZCggYTEgKSApICogaCAvIDIgLSB3IC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oIHJhZCggYTEgKSApICogdyAvIDIgKyBNYXRoLmNvcyggcmFkKCBhMSApICkgKiBoIC8gMiAtIGggLyAyXTtcbiAgICAgICAgY29uc3QgW3gyLCB5Ml0gPSBbTWF0aC5jb3MoIHJhZCggYTIgKSApICogdyAvIDIgLSBNYXRoLnNpbiggcmFkKCBhMiApICkgKiBoIC8gMiAtIHcgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbiggcmFkKCBhMiApICkgKiB3IC8gMiArIE1hdGguY29zKCByYWQoIGEyICkgKSAqIGggLyAyIC0gaCAvIDJdO1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUyLnNldEFscGhhKCB0ICk7XG4gICAgICAgIHNjZW5lMS5zZXRSb3RhdGlvbiggYTEgKTtcbiAgICAgICAgc2NlbmUyLnNldFJvdGF0aW9uKCBhMiApO1xuICAgICAgICBzY2VuZTEuc2V0UG9zaXRpb24oIC14MSwgLXkxICk7XG4gICAgICAgIHNjZW5lMi5zZXRQb3NpdGlvbiggLXgyLCAteTIgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc3BpbkNDVyggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLmx3O1xuICAgICAgICBjb25zdCBoID0gc2VsZi5saDtcbiAgICAgICAgLy9cdGxldCBhMSA9ICgxLXQpICogMzYwO1xuICAgICAgICBjb25zdCBhMSA9IDE4MCArICggMSAtIHQgKSAqIDE4MDtcbiAgICAgICAgY29uc3QgYTIgPSAoIDEgLSB0ICkgKiAxODA7XG4gICAgICAgIC8vbGV0IGwgPSBNYXRoLnNxcnQoKHcgLyAyKSAqKiAyLCAoaCAvIDIpICoqIDIpO1xuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IFtNYXRoLmNvcyggcmFkKCBhMSApICkgKiB3IC8gMiAtIE1hdGguc2luKCByYWQoIGExICkgKSAqIGggLyAyIC0gdyAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKCByYWQoIGExICkgKSAqIHcgLyAyICsgTWF0aC5jb3MoIHJhZCggYTEgKSApICogaCAvIDIgLSBoIC8gMl07XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gW01hdGguY29zKCByYWQoIGEyICkgKSAqIHcgLyAyIC0gTWF0aC5zaW4oIHJhZCggYTIgKSApICogaCAvIDIgLSB3IC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oIHJhZCggYTIgKSApICogdyAvIDIgKyBNYXRoLmNvcyggcmFkKCBhMiApICkgKiBoIC8gMiAtIGggLyAyXTtcblxuICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDEgLSB0ICk7XG4gICAgICAgIHNjZW5lMi5zZXRBbHBoYSggdCApO1xuICAgICAgICBzY2VuZTEuc2V0Um90YXRpb24oIGExICk7XG4gICAgICAgIHNjZW5lMi5zZXRSb3RhdGlvbiggYTIgKTtcbiAgICAgICAgc2NlbmUxLnNldFBvc2l0aW9uKCAteDEsIC15MSApO1xuICAgICAgICBzY2VuZTIuc2V0UG9zaXRpb24oIC14MiwgLXkyICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNwaW5Dcm9zc0NXKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3QgdyA9IHNlbGYubHc7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLmxoO1xuICAgICAgICBjb25zdCBhMSA9IC10ICogMTgwO1xuICAgICAgICBjb25zdCBhMiA9IDE4MCArIHQgKiAxODA7XG4gICAgICAgIC8vbGV0IGwgPSBNYXRoLnNxcnQoKHcgLyAyKSAqKiAyLCAoaCAvIDIpICoqIDIpO1xuICAgICAgICBjb25zdCBbeDEsIHkxXSA9IFtNYXRoLmNvcyggcmFkKCBhMSApICkgKiB3IC8gMiAtIE1hdGguc2luKCByYWQoIGExICkgKSAqIGggLyAyIC0gdyAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKCByYWQoIGExICkgKSAqIHcgLyAyICsgTWF0aC5jb3MoIHJhZCggYTEgKSApICogaCAvIDIgLSBoIC8gMl07XG4gICAgICAgIGNvbnN0IFt4MiwgeTJdID0gW01hdGguY29zKCByYWQoIGEyICkgKSAqIHcgLyAyIC0gTWF0aC5zaW4oIHJhZCggYTIgKSApICogaCAvIDIgLSB3IC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oIHJhZCggYTIgKSApICogdyAvIDIgKyBNYXRoLmNvcyggcmFkKCBhMiApICkgKiBoIC8gMiAtIGggLyAyXTtcblxuICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDEgLSB0ICk7XG4gICAgICAgIHNjZW5lMi5zZXRBbHBoYSggdCApO1xuICAgICAgICBzY2VuZTEuc2V0Um90YXRpb24oIGExICk7XG4gICAgICAgIHNjZW5lMi5zZXRSb3RhdGlvbiggYTIgKTtcbiAgICAgICAgc2NlbmUxLnNldFBvc2l0aW9uKCAteDEsIC15MSApO1xuICAgICAgICBzY2VuZTIuc2V0UG9zaXRpb24oIC14MiwgLXkyICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNwaW5Dcm9zc0NDVyggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLmx3O1xuICAgICAgICBjb25zdCBoID0gc2VsZi5saDtcbiAgICAgICAgY29uc3QgYTEgPSB0ICogMTgwO1xuICAgICAgICBjb25zdCBhMiA9IDE4MCArIC10ICogMTgwO1xuICAgICAgICAvL2xldCBsID0gTWF0aC5zcXJ0KCh3IC8gMikgKiogMiwgKGggLyAyKSAqKiAyKTtcbiAgICAgICAgY29uc3QgW3gxLCB5MV0gPSBbTWF0aC5jb3MoIHJhZCggYTEgKSApICogdyAvIDIgLSBNYXRoLnNpbiggcmFkKCBhMSApICkgKiBoIC8gMiAtIHcgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbiggcmFkKCBhMSApICkgKiB3IC8gMiArIE1hdGguY29zKCByYWQoIGExICkgKSAqIGggLyAyIC0gaCAvIDJdO1xuICAgICAgICBjb25zdCBbeDIsIHkyXSA9IFtNYXRoLmNvcyggcmFkKCBhMiApICkgKiB3IC8gMiAtIE1hdGguc2luKCByYWQoIGEyICkgKSAqIGggLyAyIC0gdyAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKCByYWQoIGEyICkgKSAqIHcgLyAyICsgTWF0aC5jb3MoIHJhZCggYTIgKSApICogaCAvIDIgLSBoIC8gMl07XG5cbiAgICAgICAgc2NlbmUxLnNldEFscGhhKCAxIC0gdCApO1xuICAgICAgICBzY2VuZTIuc2V0QWxwaGEoIHQgKTtcbiAgICAgICAgc2NlbmUxLnNldFJvdGF0aW9uKCBhMSApO1xuICAgICAgICBzY2VuZTIuc2V0Um90YXRpb24oIGEyICk7XG4gICAgICAgIHNjZW5lMS5zZXRQb3NpdGlvbiggLXgxLCAteTEgKTtcbiAgICAgICAgc2NlbmUyLnNldFBvc2l0aW9uKCAteDIsIC15MiApO1xuICAgIH1cblxuXG4gICAgc3RhdGljIGJhbGxvb24oIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3ID0gc2VsZi5sdztcbiAgICAgICAgY29uc3QgaCA9IHNlbGYubGg7XG4gICAgICAgIGNvbnN0IHNjYWxlMXggPSB0ICsgMTtcbiAgICAgICAgY29uc3Qgc2NhbGUyeCA9ICggMSAtIHQgKSArIDE7XG4gICAgICAgIGNvbnN0IHNjYWxlMXkgPSAoIDEgLSB0ICk7XG4gICAgICAgIGNvbnN0IHNjYWxlMnkgPSB0O1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUxLnNldFNjYWxlKCBzY2FsZTF4LCBzY2FsZTF5ICk7XG4gICAgICAgIHNjZW5lMS5zZXRQb3NpdGlvbiggLSggdyAqIHNjYWxlMXggLSB3ICkgLyAyLCAtKCBoICogc2NhbGUxeSAtIGggKSAvIDIgKTtcbiAgICAgICAgc2NlbmUyLnNldEFscGhhKCB0ICk7XG4gICAgICAgIHNjZW5lMi5zZXRTY2FsZSggc2NhbGUyeCwgc2NhbGUyeSApO1xuICAgICAgICBzY2VuZTIuc2V0UG9zaXRpb24oIC0oIHcgKiBzY2FsZTJ4IC0gdyApIC8gMiwgLSggaCAqIHNjYWxlMnkgLSBoICkgLyAyICk7XG4gICAgfVxuXG5cbiAgICBzdGF0aWMgdHYoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3ID0gc2VsZi5sdztcbiAgICAgICAgY29uc3QgaCA9IHNlbGYubGg7XG4gICAgICAgIGNvbnN0IHNjYWxlMXggPSB0ICogMyArIDE7XG4gICAgICAgIGNvbnN0IHNjYWxlMnggPSB0ICogMC4yICsgMC44Oy8vMS0tKDEtdCkqMysxO1xuICAgICAgICBjb25zdCBzY2FsZTF5ID0gKCAxIC0gdCApO1xuICAgICAgICBjb25zdCBzY2FsZTJ5ID0gdDtcblxuICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDEgLSB0ICk7XG4gICAgICAgIC8vbGV0IGNvbG9yID0gTWF0aC5tYXgoMS10KjIsMCk7XG4gICAgICAgIC8vc2NlbmUxLnNldENvbG9yTXVsdGlwbGllcihjb2xvcixjb2xvcixjb2xvcik7XG4gICAgICAgIHNjZW5lMS5zZXRTY2FsZSggc2NhbGUxeCwgc2NhbGUxeSApO1xuICAgICAgICBzY2VuZTEuc2V0UG9zaXRpb24oIC0oIHcgKiBzY2FsZTF4IC0gdyApIC8gMiwgLSggaCAqIHNjYWxlMXkgLSBoICkgLyAyICk7XG4gICAgICAgIHNjZW5lMi5zZXRBbHBoYSggdCApO1xuICAgICAgICBzY2VuZTIuc2V0U2NhbGUoIHNjYWxlMngsIHNjYWxlMnkgKTtcbiAgICAgICAgc2NlbmUyLnNldFBvc2l0aW9uKCAtKCB3ICogc2NhbGUyeCAtIHcgKSAvIDIsIC0oIGggKiBzY2FsZTJ5IC0gaCApIC8gMiApO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRXaXBlclYyKCBzZWxmLCB3LCBoICkge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1lc2goKTtcblxuICAgICAgICBtLnNldFZlcnRleEFycmF5KCBbMCwgMCwgdywgMCwgMCwgaCAqIDEuMiwgdywgaCwgMCwgaCAqIDEuNCwgdywgaCAqIDEuMl0gKTtcbiAgICAgICAgbS5zZXRDb2xvckFycmF5KCBbMHgwMDAwMDAsIDEsIDB4MDAwMDAwLCAxLCAweDAwMDAwMCwgMSwgMHgwMDAwMDAsIDEsIDB4MDAwMDAwLCAwLCAweDAwMDAwMCwgMF0gKTtcbiAgICAgICAgbS5zZXRJbmRleEFycmF5KCBbMCwgMSwgMiwgMSwgMywgMiwgMiwgMywgNCwgMywgNCwgNV0gKTtcbiAgICAgICAgbS5zZXRDb2xvck11bHRpcGxpZXIoIDAsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0V2lwZXJWKCBzZWxmLCB3LCBoICkge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1lc2goKTtcblxuICAgICAgICBtLnNldFZlcnRleEFycmF5KCBbMCwgMCwgdywgMCwgMCwgaCwgdywgaCwgMCwgaCAqIDEuMiwgdywgaCAqIDEuMl0gKTtcbiAgICAgICAgbS5zZXRDb2xvckFycmF5KCBbMHgwMDAwMDAsIDEsIDB4MDAwMDAwLCAxLCAweDAwMDAwMCwgMSwgMHgwMDAwMDAsIDEsIDB4MDAwMDAwLCAwLCAweDAwMDAwMCwgMF0gKTtcbiAgICAgICAgbS5zZXRJbmRleEFycmF5KCBbMCwgMSwgMiwgMSwgMywgMiwgMiwgMywgNCwgMywgNCwgNV0gKTtcbiAgICAgICAgbS5zZXRDb2xvck11bHRpcGxpZXIoIDAsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0V2lwZXJIKCBzZWxmLCB3LCBoICkge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1lc2goKTtcblxuICAgICAgICBtLnNldFZlcnRleEFycmF5KCBbMCwgMCwgdywgMCwgMCwgaCwgdywgaCwgdyAqIDEuMiwgMCwgdyAqIDEuMiwgaF0gKTtcbiAgICAgICAgbS5zZXRDb2xvckFycmF5KCBbMHgwMDAwMDAsIDEsIDB4MDAwMDAwLCAxLCAweDAwMDAwMCwgMSwgMHgwMDAwMDAsIDEsIDB4MDAwMDAwLCAwLCAweDAwMDAwMCwgMF0gKTtcbiAgICAgICAgbS5zZXRJbmRleEFycmF5KCBbMCwgMSwgMiwgMSwgMywgMiwgMSwgNCwgMywgNCwgNSwgM10gKTtcbiAgICAgICAgbS5zZXRDb2xvck11bHRpcGxpZXIoIDAsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBzdGF0aWMgd2lwZVVwMiggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHBoeXNpY2FsTWFyZ2luWCA9IC1zZWxmLngxO1xuICAgICAgICBjb25zdCBwaHlzaWNhbE1hcmdpblkgPSAtc2VsZi55MTtcbiAgICAgICAgY29uc3QgdyA9IHNlbGYueDIgLSBzZWxmLngxO1xuICAgICAgICBjb25zdCBoID0gc2VsZi55MiAtIHNlbGYueTE7XG5cbiAgICAgICAgaWYgKCBzZWxmLl9ibGFja01lc2ggKSB7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0IDwgMC41ICkge1xuICAgICAgICAgICAgLy9sZXQgdDIgPSB0ICogMjtcbiAgICAgICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCB0cnVlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggZmFsc2UgKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0V2lwZXJWMiggc2VsZix3LCBoICk7XG5cbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaCA9IG07XG4gICAgICAgICAgICBzZWxmLmFkZENoaWxkKCBtICk7XG4gICAgICAgICAgICBtLnNldFNjYWxlWSggLTEgKTtcbiAgICAgICAgICAgIG0uc2V0WCggLXBoeXNpY2FsTWFyZ2luWCApO1xuICAgICAgICAgICAgbS5zZXRZKCBoICogKCAxICsgKCAxIC0gdCAqIDIgKSAqIDEuNCApIC0gcGh5c2ljYWxNYXJnaW5ZICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0MiA9ICggdCAtIDAuNSApICogMjtcblxuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIGZhbHNlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggdHJ1ZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRXaXBlclYyKCBzZWxmLHcsIGggKTtcblxuICAgICAgICAgICAgc2VsZi5fYmxhY2tNZXNoID0gbTtcbiAgICAgICAgICAgIG0uc2V0U2NhbGVYKCAtMSApO1xuICAgICAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICAgICAgbS5zZXRYKCB3IC0gcGh5c2ljYWxNYXJnaW5YICk7XG4gICAgICAgICAgICBtLnNldFkoIGggKiAoIC10MiAqIDEuNCApIC0gcGh5c2ljYWxNYXJnaW5ZICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHN0YXRpYyB3aXBlRG93biggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHBoeXNpY2FsTWFyZ2luWCA9IC1zZWxmLngxO1xuICAgICAgICBjb25zdCBwaHlzaWNhbE1hcmdpblkgPSAtc2VsZi55MTtcbiAgICAgICAgY29uc3QgdyA9IHNlbGYueDIgLSBzZWxmLngxO1xuICAgICAgICBjb25zdCBoID0gc2VsZi55MiAtIHNlbGYueTE7XG5cbiAgICAgICAgaWYgKCBzZWxmLl9ibGFja01lc2ggKSB7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0IDwgMC41ICkge1xuICAgICAgICAgICAgY29uc3QgdDIgPSB0ICogMjtcblxuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRWaXNpYmxlKCBmYWxzZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRXaXBlclYoIHNlbGYsdywgaCApO1xuXG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICAgICAgbS5zZXRYKCAtcGh5c2ljYWxNYXJnaW5YICk7XG4gICAgICAgICAgICBtLnNldFkoIC1oICogKCAxIC0gdDIgKSAqIDEuMiAtIHBoeXNpY2FsTWFyZ2luWSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdDIgPSAoIHQgLSAwLjUgKSAqIDI7XG5cbiAgICAgICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCBmYWxzZSApO1xuICAgICAgICAgICAgc2NlbmUyLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0V2lwZXJWKCBzZWxmLHcsIGggKTtcblxuICAgICAgICAgICAgc2VsZi5fYmxhY2tNZXNoID0gbTtcbiAgICAgICAgICAgIHNlbGYuYWRkQ2hpbGQoIG0gKTtcbiAgICAgICAgICAgIG0uc2V0U2NhbGVZKCAtMSApO1xuICAgICAgICAgICAgbS5zZXRYKCAtcGh5c2ljYWxNYXJnaW5YICk7XG4gICAgICAgICAgICBtLnNldFkoIGggKiAoIDEgKyB0MiAqIDEuMiApIC0gcGh5c2ljYWxNYXJnaW5ZICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgd2lwZVVwKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3QgcGh5c2ljYWxNYXJnaW5YID0gLXNlbGYueDE7XG4gICAgICAgIGNvbnN0IHBoeXNpY2FsTWFyZ2luWSA9IC1zZWxmLnkxO1xuICAgICAgICBjb25zdCB3ID0gc2VsZi54MiAtIHNlbGYueDE7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLnkyIC0gc2VsZi55MTtcblxuICAgICAgICBpZiAoIHNlbGYuX2JsYWNrTWVzaCApIHtcbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaC5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHQgPCAwLjUgKSB7XG4gICAgICAgICAgICAvL2xldCB0MiA9IHQgKiAyO1xuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRWaXNpYmxlKCBmYWxzZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRXaXBlclYoIHNlbGYsdywgaCApO1xuXG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICAgICAgbS5zZXRTY2FsZVkoIC0xICk7XG4gICAgICAgICAgICBtLnNldFgoIC1waHlzaWNhbE1hcmdpblggKTtcbiAgICAgICAgICAgIG0uc2V0WSggaCAqICggMSArICggMSAtIHQgKiAyICkgKiAxLjIgKSAtIHBoeXNpY2FsTWFyZ2luWSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdDIgPSAoIHQgLSAwLjUgKSAqIDI7XG5cbiAgICAgICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCBmYWxzZSApO1xuICAgICAgICAgICAgc2NlbmUyLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0V2lwZXJWKCBzZWxmLHcsIGggKTtcblxuICAgICAgICAgICAgc2VsZi5fYmxhY2tNZXNoID0gbTtcbiAgICAgICAgICAgIHNlbGYuYWRkQ2hpbGQoIG0gKTtcbiAgICAgICAgICAgIG0uc2V0WCggLXBoeXNpY2FsTWFyZ2luWCApO1xuICAgICAgICAgICAgbS5zZXRZKCBoICogKCAtdDIgKiAxLjIgKSAtIHBoeXNpY2FsTWFyZ2luWSApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHdpcGVSaWdodCggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHBoeXNpY2FsTWFyZ2luWCA9IC1zZWxmLngxO1xuICAgICAgICBjb25zdCBwaHlzaWNhbE1hcmdpblkgPSAtc2VsZi55MTtcbiAgICAgICAgY29uc3QgdyA9IHNlbGYueDIgLSBzZWxmLngxO1xuICAgICAgICBjb25zdCBoID0gc2VsZi55MiAtIHNlbGYueTE7XG5cbiAgICAgICAgaWYgKCBzZWxmLl9ibGFja01lc2ggKSB7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0IDwgMC41ICkge1xuICAgICAgICAgICAgY29uc3QgdDIgPSB0ICogMjtcblxuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRWaXNpYmxlKCBmYWxzZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRXaXBlckgoIHNlbGYsdywgaCApO1xuXG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICAgICAgbS5zZXRYKCAtdyAqICggMSAtIHQyICkgKiAxLjIgLSBwaHlzaWNhbE1hcmdpblggKTtcbiAgICAgICAgICAgIG0uc2V0WSggLXBoeXNpY2FsTWFyZ2luWSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdDIgPSAoIHQgLSAwLjUgKSAqIDI7XG5cbiAgICAgICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCBmYWxzZSApO1xuICAgICAgICAgICAgc2NlbmUyLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0V2lwZXJIKCBzZWxmLHcsIGggKTtcblxuICAgICAgICAgICAgc2VsZi5fYmxhY2tNZXNoID0gbTtcbiAgICAgICAgICAgIHNlbGYuYWRkQ2hpbGQoIG0gKTtcbiAgICAgICAgICAgIG0uc2V0U2NhbGVYKCAtMSApO1xuICAgICAgICAgICAgbS5zZXRYKCB3ICogKCAxICsgdDIgKiAxLjIgKSAtIHBoeXNpY2FsTWFyZ2luWCApO1xuICAgICAgICAgICAgbS5zZXRZKCAtcGh5c2ljYWxNYXJnaW5ZICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgd2lwZUxlZnQoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCBwaHlzaWNhbE1hcmdpblggPSAtc2VsZi54MTtcbiAgICAgICAgY29uc3QgcGh5c2ljYWxNYXJnaW5ZID0gLXNlbGYueTE7XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLngyIC0gc2VsZi54MTtcbiAgICAgICAgY29uc3QgaCA9IHNlbGYueTIgLSBzZWxmLnkxO1xuXG4gICAgICAgIGlmICggc2VsZi5fYmxhY2tNZXNoICkge1xuICAgICAgICAgICAgc2VsZi5fYmxhY2tNZXNoLnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdCA8IDAuNSApIHtcbiAgICAgICAgICAgIC8vbGV0IHQyID0gdCAqIDI7XG4gICAgICAgICAgICBzY2VuZTEuc2V0VmlzaWJsZSggdHJ1ZSApO1xuICAgICAgICAgICAgc2NlbmUyLnNldFZpc2libGUoIGZhbHNlICk7XG4gICAgICAgICAgICBjb25zdCBtID0gU2NlbmVNYW5hZ2VyLmdldFdpcGVySCggc2VsZix3LCBoICk7XG5cbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaCA9IG07XG4gICAgICAgICAgICBzZWxmLmFkZENoaWxkKCBtICk7XG4gICAgICAgICAgICBtLnNldFNjYWxlWCggLTEgKTtcbiAgICAgICAgICAgIG0uc2V0WCggdyAqICggMSArICggMSAtIHQgKiAyICkgKiAxLjIgKSAtIHBoeXNpY2FsTWFyZ2luWCApO1xuICAgICAgICAgICAgbS5zZXRZKCAtcGh5c2ljYWxNYXJnaW5ZICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0MiA9ICggdCAtIDAuNSApICogMjtcblxuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIGZhbHNlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggdHJ1ZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRXaXBlckgoIHNlbGYsdywgaCApO1xuXG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICAgICAgbS5zZXRYKCB3ICogKCAtdDIgKiAxLjIgKSAtIHBoeXNpY2FsTWFyZ2luWCApO1xuICAgICAgICAgICAgbS5zZXRZKCAtcGh5c2ljYWxNYXJnaW5ZICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHN0YXRpYyBnZXRDbG9ja01lc2goIHNlbGYsIHcsIGgsIHJhdGlvICkge1xuICAgICAgICBpZiAoIHJhdGlvIDwgMCApIHtcbiAgICAgICAgICAgIHJhdGlvID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcmF0aW8gPiAxICkge1xuICAgICAgICAgICAgcmF0aW8gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYW5nbGUgPSByYXRpbyAqIDM2MDtcbiAgICAgICAgY29uc3QgYW5nbGVab25lID0gTWF0aC5mbG9vciggcmF0aW8gKiA4ICkgKyAxO1xuICAgICAgICBjb25zdCBhbmdsZTIgPSAoIGFuZ2xlICUgNDUgKTtcbiAgICAgICAgY29uc3QgdHJpV2lkdGggPSBNYXRoLnNpbiggcmFkKCBhbmdsZTIgKSApO1xuICAgICAgICBsZXQgdiA9IFtdO1xuICAgICAgICBsZXQgaWR4ID0gW107XG5cbiAgICAgICAgaWYgKCByYXRpbyA9PSAxICkge1xuICAgICAgICAgICAgdiA9IFswICogdywgMCAqIGgsIDEgKiB3LCAwICogaCwgMSAqIHcsIDEgKiBoLCAwICogdywgMSAqIGhdO1xuICAgICAgICAgICAgaWR4ID0gWzAsIDEsIDIsIDIsIDMsIDBdO1xuICAgICAgICB9IGVsc2UgaWYgKCBhbmdsZVpvbmUgPT0gMSApIHtcbiAgICAgICAgICAgIHYgPSBbMC41ICogdywgMCAqIGgsICggMC41ICsgdHJpV2lkdGggKSAqIHcsIDAgKiBoLCAwLjUgKiB3LCAwLjUgKiBoXTtcbiAgICAgICAgICAgIGlkeCA9IFswLCAxLCAyXTtcbiAgICAgICAgfSBlbHNlIGlmICggYW5nbGVab25lID09IDIgKSB7XG4gICAgICAgICAgICB2ID0gWzEgKiB3LCAwICogaCwgMSAqIHcsIHRyaVdpZHRoICogaCwgMC41ICogdywgMC41ICogaCwgMC41ICogdywgMCAqIGhdO1xuICAgICAgICAgICAgaWR4ID0gWzAsIDEsIDIsIDMsIDAsIDJdO1xuICAgICAgICB9IGVsc2UgaWYgKCBhbmdsZVpvbmUgPT0gMyApIHtcbiAgICAgICAgICAgIHYgPSBbMSAqIHcsIDAuNSAqIGgsIDEgKiB3LCAoIDAuNSArIHRyaVdpZHRoICkgKiBoLCAwLjUgKiB3LCAwLjUgKiBoLCAwLjUgKiB3LCAwICogaCwgMSAqIHcsIDAgKiBoXTtcbiAgICAgICAgICAgIGlkeCA9IFswLCAxLCAyLCAzLCA0LCAyLCA0LCAwLCAyXTtcbiAgICAgICAgfSBlbHNlIGlmICggYW5nbGVab25lID09IDQgKSB7XG4gICAgICAgICAgICB2ID0gWzEgKiB3LCAxICogaCwgKCAxIC0gdHJpV2lkdGggKSAqIHcsIDEgKiBoLCAwLjUgKiB3LCAwLjUgKiBoLCAwLjUgKiB3LCAwICogaCwgMSAqIHcsIDAgKiBoXTtcbiAgICAgICAgICAgIGlkeCA9IFswLCAxLCAyLCAzLCA0LCAyLCA0LCAwLCAyXTtcbiAgICAgICAgfSBlbHNlIGlmICggYW5nbGVab25lID09IDUgKSB7XG4gICAgICAgICAgICB2ID0gWzAuNSAqIHcsIDEgKiBoLCAoIDAuNSAtIHRyaVdpZHRoICkgKiB3LCAxICogaCwgMC41ICogdywgMC41ICogaCwgMC41ICogdywgMCAqIGgsIDEgKiB3LCAwICogaCwgMSAqIHcsIDEgKiBoXTtcbiAgICAgICAgICAgIGlkeCA9IFswLCAxLCAyLCAzLCA0LCAwLCA0LCA1LCAwXTtcbiAgICAgICAgfSBlbHNlIGlmICggYW5nbGVab25lID09IDYgKSB7XG4gICAgICAgICAgICB2ID0gWzAgKiB3LCAxICogaCwgMCAqIHcsICggMSAtIHRyaVdpZHRoICkgKiBoLCAwLjUgKiB3LCAwLjUgKiBoLCAwLjUgKiB3LCAwICogaCwgMSAqIHcsIDAgKiBoLCAxICogdywgMSAqIGhdO1xuICAgICAgICAgICAgaWR4ID0gWzAsIDEsIDIsIDMsIDQsIDIsIDQsIDUsIDBdO1xuICAgICAgICB9IGVsc2UgaWYgKCBhbmdsZVpvbmUgPT0gNyApIHtcbiAgICAgICAgICAgIHYgPSBbMCAqIHcsIDAuNSAqIGgsIDAgKiB3LCAoIDAuNSAtIHRyaVdpZHRoICkgKiBoLCAwLjUgKiB3LCAwLjUgKiBoLCAwLjUgKiB3LCAwICogaCwgMSAqIHcsIDAgKiBoLCAxICogdywgMSAqIGgsIDAgKiB3LCAxICogaF07XG4gICAgICAgICAgICBpZHggPSBbMCwgMSwgMiwgMywgNCwgMiwgNCwgNSwgNiwgMCwgMiwgNl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gWzAgKiB3LCAwICogaCwgdHJpV2lkdGggKiB3LCAwICogaCwgMC41ICogdywgMC41ICogaCwgMC41ICogdywgMCAqIGgsIDEgKiB3LCAwICogaCwgMSAqIHcsIDEgKiBoLCAwICogdywgMSAqIGhdO1xuICAgICAgICAgICAgaWR4ID0gWzAsIDEsIDIsIDMsIDQsIDIsIDQsIDUsIDYsIDAsIDIsIDZdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbSA9IG5ldyBNZXNoKCk7XG5cbiAgICAgICAgLy9tLnNldFRleHR1cmUodGV4KTtcbiAgICAgICAgLy9tLnNldFRleHR1cmVDb29yZGluYXRlQXJyYXkodik7XG4gICAgICAgIG0uc2V0VmVydGV4QXJyYXkoIHYgKTtcbiAgICAgICAgbS5zZXRJbmRleEFycmF5KCBpZHggKTtcbiAgICAgICAgbS5zZXRDb2xvck11bHRpcGxpZXIoIDAsIDAsIDAgKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cblxuXG4gICAgc3RhdGljIGdldENpcmNsZU1lc2goIHNlbGYsIHJhZGl1cyApIHtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSA2NDtcbiAgICAgICAgY29uc3QgdiA9IFswLCAwXTtcbiAgICAgICAgY29uc3QgaWR4ID0gW107XG4gICAgICAgIGNvbnN0IGMgPSBbMHgwMDAwMDAsIDFdO1xuXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKysgKSB7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9ICggaSAvIHNpZGVzICkgKiAyICogTWF0aC5QSTtcblxuICAgICAgICAgICAgdlsyICsgaSAqIDRdID0gTWF0aC5jb3MoIGFuZ2xlICkgKiByYWRpdXM7XG4gICAgICAgICAgICB2WzIgKyBpICogNCArIDFdID0gTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXM7XG4gICAgICAgICAgICB2WzIgKyBpICogNCArIDJdID0gTWF0aC5jb3MoIGFuZ2xlICkgKiByYWRpdXMgKiAxLjI7XG4gICAgICAgICAgICB2WzIgKyBpICogNCArIDNdID0gTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXMgKiAxLjI7XG4gICAgICAgICAgICBjWzIgKyBpICogNF0gPSAweDAwMDAwMDtcbiAgICAgICAgICAgIGNbMiArIGkgKiA0ICsgMV0gPSAxO1xuICAgICAgICAgICAgY1syICsgaSAqIDQgKyAyXSA9IDB4MDAwMDAwO1xuICAgICAgICAgICAgY1syICsgaSAqIDQgKyAzXSA9IDA7XG4gICAgICAgICAgICBpZHhbIGkgKiA5XSA9IDA7XHQvL29yaWdpbjtcbiAgICAgICAgICAgIGlkeFsgaSAqIDkgKyAxXSA9ICggaSAqIDIgKSArIDE7XG4gICAgICAgICAgICBpZHhbIGkgKiA5ICsgMl0gPSAoIGkgKiAyICkgKyAzO1xuICAgICAgICAgICAgaWR4WyBpICogOSArIDNdID0gKCBpICogMiApICsgMTtcbiAgICAgICAgICAgIGlkeFsgaSAqIDkgKyA0XSA9ICggaSAqIDIgKSArIDI7XG4gICAgICAgICAgICBpZHhbIGkgKiA5ICsgNV0gPSAoIGkgKiAyICkgKyA0O1xuICAgICAgICAgICAgaWR4WyBpICogOSArIDZdID0gKCBpICogMiApICsgMTtcbiAgICAgICAgICAgIGlkeFsgaSAqIDkgKyA3XSA9ICggaSAqIDIgKSArIDQ7XG4gICAgICAgICAgICBpZHhbIGkgKiA5ICsgOF0gPSAoIGkgKiAyICkgKyAzO1xuXG4gICAgICAgICAgICBpZiAoIGkgPT0gc2lkZXMgLSAxICkge1xuICAgICAgICAgICAgICAgIGlkeFsgaSAqIDkgKyAyXSA9IDE7XG4gICAgICAgICAgICAgICAgaWR4WyBpICogOSArIDVdID0gMjtcbiAgICAgICAgICAgICAgICBpZHhbIGkgKiA5ICsgN10gPSAyO1xuICAgICAgICAgICAgICAgIGlkeFsgaSAqIDkgKyA4XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2xvZyhMb2cuVUksIHRhYmxlLmNvbmNhdChpZHgsXCIsXCIpKTtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNZXNoKCk7XG5cbiAgICAgICAgbS5zZXRWZXJ0ZXhBcnJheSggdiApO1xuICAgICAgICBtLnNldEluZGV4QXJyYXkoIGlkeCApO1xuICAgICAgICBtLnNldENvbG9yQXJyYXkoIGMgKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0Q2lyY2xlSG9sZU1lc2goIHNlbGYsIHJhZGl1czEsIHJhZGl1czIgKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gMzI7XG4gICAgICAgIGNvbnN0IHYgPSBbXTtcbiAgICAgICAgY29uc3QgaWR4ID0gW107XG4gICAgICAgIGNvbnN0IGMgPSBbXTtcblxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBzaWRlczsgaSsrICkge1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSAoIGkgLyBzaWRlcyApICogMiAqIE1hdGguUEk7XG5cbiAgICAgICAgICAgIHZbIGkgKiA2XSA9IE1hdGguY29zKCBhbmdsZSApICogcmFkaXVzMSAvIDEuMjtcbiAgICAgICAgICAgIHZbIGkgKiA2ICsgMV0gPSBNYXRoLnNpbiggYW5nbGUgKSAqIHJhZGl1czEgLyAxLjI7XG4gICAgICAgICAgICB2WyBpICogNiArIDJdID0gTWF0aC5jb3MoIGFuZ2xlICkgKiByYWRpdXMxO1xuICAgICAgICAgICAgdlsgaSAqIDYgKyAzXSA9IE1hdGguc2luKCBhbmdsZSApICogcmFkaXVzMTtcbiAgICAgICAgICAgIHZbIGkgKiA2ICsgNF0gPSBNYXRoLmNvcyggYW5nbGUgKSAqIHJhZGl1czI7XG4gICAgICAgICAgICB2WyBpICogNiArIDVdID0gTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXMyO1xuICAgICAgICAgICAgY1sgaSAqIDZdID0gMHgwMDAwMDA7XG4gICAgICAgICAgICBjWyBpICogNiArIDFdID0gMDtcbiAgICAgICAgICAgIGNbIGkgKiA2ICsgMl0gPSAweDAwMDAwMDtcbiAgICAgICAgICAgIGNbIGkgKiA2ICsgM10gPSAxO1xuICAgICAgICAgICAgY1sgaSAqIDYgKyA0XSA9IDB4MDAwMDAwO1xuICAgICAgICAgICAgY1sgaSAqIDYgKyA1XSA9IDE7XG4gICAgICAgICAgICBpZHhbIGkgKiAxMl0gPSAoIGkgKiAzICkgKyAwO1xuICAgICAgICAgICAgaWR4WyBpICogMTIgKyAxXSA9ICggaSAqIDMgKSArIDQ7XG4gICAgICAgICAgICBpZHhbIGkgKiAxMiArIDJdID0gKCBpICogMyApICsgMztcbiAgICAgICAgICAgIGlkeFsgaSAqIDEyICsgM10gPSAoIGkgKiAzICkgKyAwO1xuICAgICAgICAgICAgaWR4WyBpICogMTIgKyA0XSA9ICggaSAqIDMgKSArIDE7XG4gICAgICAgICAgICBpZHhbIGkgKiAxMiArIDVdID0gKCBpICogMyApICsgNDtcbiAgICAgICAgICAgIGlkeFsgaSAqIDEyICsgNl0gPSAoIGkgKiAzICkgKyAxO1xuICAgICAgICAgICAgaWR4WyBpICogMTIgKyA3XSA9ICggaSAqIDMgKSArIDI7XG4gICAgICAgICAgICBpZHhbIGkgKiAxMiArIDhdID0gKCBpICogMyApICsgNTtcbiAgICAgICAgICAgIGlkeFsgaSAqIDEyICsgOV0gPSAoIGkgKiAzICkgKyAxO1xuICAgICAgICAgICAgaWR4WyBpICogMTIgKyAxMF0gPSAoIGkgKiAzICkgKyA1O1xuICAgICAgICAgICAgaWR4WyBpICogMTIgKyAxMV0gPSAoIGkgKiAzICkgKyA0O1xuXG4gICAgICAgICAgICBpZiAoIGkgPT0gc2lkZXMgLSAxICkge1xuICAgICAgICAgICAgICAgIGlkeFsgaSAqIDEyICsgMV0gPSAxO1xuICAgICAgICAgICAgICAgIGlkeFsgaSAqIDEyICsgMl0gPSAwO1xuICAgICAgICAgICAgICAgIGlkeFsgaSAqIDEyICsgNV0gPSAxO1xuICAgICAgICAgICAgICAgIGlkeFsgaSAqIDEyICsgOF0gPSAyO1xuICAgICAgICAgICAgICAgIGlkeFsgaSAqIDEyICsgMTBdID0gMjtcbiAgICAgICAgICAgICAgICBpZHhbIGkgKiAxMiArIDExXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2xvZyhMb2cuVUksIHRhYmxlLmNvbmNhdChpZHgsXCIsXCIpKTtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNZXNoKCk7XG5cbiAgICAgICAgbS5zZXRWZXJ0ZXhBcnJheSggdiApO1xuICAgICAgICBtLnNldEluZGV4QXJyYXkoIGlkeCApO1xuICAgICAgICBtLnNldENvbG9yQXJyYXkoIGMgKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2lyY2xlSW5PdXQoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3ID0gc2VsZi54MiAtIHNlbGYueDE7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLnkyIC0gc2VsZi55MTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KCAoIHcgLyAyICkgKiogMiArICggaCAvIDIgKSAqKiAyICk7XG5cbiAgICAgICAgaWYgKCBzZWxmLl9ibGFja01lc2ggKSB7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAoIHQgPCAwLjUgKSApIHtcbiAgICAgICAgICAgIGNvbnN0IHQyID0gdCAqIDI7XG5cbiAgICAgICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCB0cnVlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggZmFsc2UgKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0Q2lyY2xlSG9sZU1lc2goIHNlbGYscmFkaXVzICogKCAxIC0gdDIgKSAqIDEuMiwgcmFkaXVzICogMS4yICk7XG5cbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaCA9IG07XG4gICAgICAgICAgICBzZWxmLmFkZENoaWxkKCBtICk7XG4gICAgICAgICAgICAvL20uc2V0U2NhbGUodCk7XG4gICAgICAgICAgICBtLnNldFgoIHNlbGYubHcgLyAyICk7XG4gICAgICAgICAgICBtLnNldFkoIHNlbGYubGggLyAyICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0MiA9ICggdCAtIDAuNSApICogMjtcblxuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIGZhbHNlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggdHJ1ZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRDaXJjbGVIb2xlTWVzaCggc2VsZixyYWRpdXMgKiB0MiAqIDEuMiwgcmFkaXVzICogMS4yICk7XG5cbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaCA9IG07XG4gICAgICAgICAgICBzZWxmLmFkZENoaWxkKCBtICk7XG4gICAgICAgICAgICAvL20uc2V0U2NhbGUodCk7XG4gICAgICAgICAgICBtLnNldFgoIHNlbGYubHcgLyAyICk7XG4gICAgICAgICAgICBtLnNldFkoIHNlbGYubGggLyAyICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHN0YXRpYyBjaXJjbGVPdXQoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3ID0gc2VsZi54MiAtIHNlbGYueDE7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLnkyIC0gc2VsZi55MTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KCAoIHcgLyAyICkgKiogMiArICggaCAvIDIgKSAqKiAyICk7XG5cbiAgICAgICAgaWYgKCBzZWxmLl9ibGFja01lc2ggKSB7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAoIHQgPCAwLjUgKSApIHtcbiAgICAgICAgICAgIGNvbnN0IHQyID0gdCAqIDI7XG5cbiAgICAgICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCB0cnVlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggZmFsc2UgKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0Q2lyY2xlTWVzaCggc2VsZixyYWRpdXMgKiAxLjIgKTtcblxuICAgICAgICAgICAgc2VsZi5fYmxhY2tNZXNoID0gbTtcbiAgICAgICAgICAgIHNlbGYuYWRkQ2hpbGQoIG0gKTtcbiAgICAgICAgICAgIG0uc2V0U2NhbGUoIHQyICk7XG4gICAgICAgICAgICBtLnNldFgoIHNlbGYubHcgLyAyICk7XG4gICAgICAgICAgICBtLnNldFkoIHNlbGYubGggLyAyICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0MiA9ICggdCAtIDAuNSApICogMjtcblxuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIGZhbHNlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggdHJ1ZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRDaXJjbGVIb2xlTWVzaCggc2VsZixyYWRpdXMgKiB0MiAqIDEuMiwgcmFkaXVzICogMS4yICk7XG5cbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaCA9IG07XG4gICAgICAgICAgICBzZWxmLmFkZENoaWxkKCBtICk7XG4gICAgICAgICAgICAvL20uc2V0U2NhbGUodCk7XG4gICAgICAgICAgICBtLnNldFgoIHNlbGYubHcgLyAyICk7XG4gICAgICAgICAgICBtLnNldFkoIHNlbGYubGggLyAyICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY2lyY2xlSW4oIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3ID0gc2VsZi54MiAtIHNlbGYueDE7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLnkyIC0gc2VsZi55MTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KCAoIHcgLyAyICkgKiogMiArICggaCAvIDIgKSAqKiAyICk7XG5cbiAgICAgICAgaWYgKCBzZWxmLl9ibGFja01lc2ggKSB7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAoIHQgPCAwLjUgKSApIHtcbiAgICAgICAgICAgIGNvbnN0IHQyID0gdCAqIDI7XG5cbiAgICAgICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCB0cnVlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggZmFsc2UgKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0Q2lyY2xlSG9sZU1lc2goIHNlbGYscmFkaXVzICogKCAxIC0gdDIgKSAqIDEuMiwgcmFkaXVzICogMS4yICk7XG5cbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaCA9IG07XG4gICAgICAgICAgICBzZWxmLmFkZENoaWxkKCBtICk7XG4gICAgICAgICAgICAvL20uc2V0U2NhbGUodCk7XG4gICAgICAgICAgICBtLnNldFgoIHNlbGYubHcgLyAyICk7XG4gICAgICAgICAgICBtLnNldFkoIHNlbGYubGggLyAyICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0MiA9ICggdCAtIDAuNSApICogMjtcblxuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIGZhbHNlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggdHJ1ZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRDaXJjbGVNZXNoKCBzZWxmLHJhZGl1cyAqIDEuMiApO1xuXG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICAgICAgbS5zZXRTY2FsZSggMSAtIHQyICk7XG4gICAgICAgICAgICBtLnNldFgoIHNlbGYubHcgLyAyICk7XG4gICAgICAgICAgICBtLnNldFkoIHNlbGYubGggLyAyICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHN0YXRpYyBjbG9jayggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHBoeXNpY2FsTWFyZ2luWCA9IC1zZWxmLngxO1xuICAgICAgICBjb25zdCBwaHlzaWNhbE1hcmdpblkgPSAtc2VsZi55MTtcbiAgICAgICAgY29uc3QgdyA9IHNlbGYueDIgLSBzZWxmLngxO1xuICAgICAgICBjb25zdCBoID0gc2VsZi55MiAtIHNlbGYueTE7XG5cbiAgICAgICAgaWYgKCBzZWxmLl9ibGFja01lc2ggKSB7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAoIHQgPCAwLjUgKSApIHtcbiAgICAgICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCB0cnVlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggZmFsc2UgKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0Q2xvY2tNZXNoKCBzZWxmLHcsIGgsIHQgKiAyICk7XG5cbiAgICAgICAgICAgIG0uc2V0WCggLXBoeXNpY2FsTWFyZ2luWCApO1xuICAgICAgICAgICAgbS5zZXRZKCAtcGh5c2ljYWxNYXJnaW5ZICk7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIGZhbHNlICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggdHJ1ZSApO1xuICAgICAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRDbG9ja01lc2goIHNlbGYsdywgaCwgMSAtICggdCAtIDAuNSApICogMiApO1xuXG4gICAgICAgICAgICBtLnNldFNjYWxlWCggLTEgKTtcbiAgICAgICAgICAgIG0uc2V0WCggdyAtIHBoeXNpY2FsTWFyZ2luWCApO1xuICAgICAgICAgICAgbS5zZXRZKCAtcGh5c2ljYWxNYXJnaW5ZICk7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSVCB0cmFuc2l0aW9uO1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHN0YXRpYyBnZXRDaXJjbGVNZXNoUlQoIHNlbGYsIHJhZGl1cyApIHtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSA2NDtcbiAgICAgICAgY29uc3QgdiA9IFswLCAwXTtcbiAgICAgICAgY29uc3QgdCA9IFsoIHNlbGYueDIgLSBzZWxmLngxICkgLyAyLCAoIHNlbGYueTIgLSBzZWxmLnkxICkgLyAyXTtcbiAgICAgICAgY29uc3QgaWR4ID0gW107XG4gICAgICAgIGNvbnN0IGMgPSBbMHhmZmZmZmYsIDFdO1xuXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKysgKSB7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9ICggaSAvIHNpZGVzICkgKiAyICogTWF0aC5QSTtcblxuICAgICAgICAgICAgdlsyICsgaSAqIDRdID0gTWF0aC5jb3MoIGFuZ2xlICkgKiByYWRpdXM7XG4gICAgICAgICAgICB2WzIgKyBpICogNCArIDFdID0gTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXM7XG4gICAgICAgICAgICB2WzIgKyBpICogNCArIDJdID0gTWF0aC5jb3MoIGFuZ2xlICkgKiByYWRpdXMgKiAxLjI7XG4gICAgICAgICAgICB2WzIgKyBpICogNCArIDNdID0gTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXMgKiAxLjI7XG4gICAgICAgICAgICB0WzIgKyBpICogNF0gPSB0WzFdICsgdlsyICsgaSAqIDRdO1xuICAgICAgICAgICAgdFsyICsgaSAqIDQgKyAxXSA9IHRbMl0gKyB2WzIgKyBpICogNCArIDFdO1xuICAgICAgICAgICAgdFsyICsgaSAqIDQgKyAyXSA9IHRbMV0gKyB2WzIgKyBpICogNCArIDJdO1xuICAgICAgICAgICAgdFsyICsgaSAqIDQgKyAzXSA9IHRbMl0gKyB2WzIgKyBpICogNCArIDNdO1xuICAgICAgICAgICAgY1syICsgaSAqIDRdID0gMHhmZmZmZmY7XG4gICAgICAgICAgICBjWzIgKyBpICogNCArIDFdID0gMTtcbiAgICAgICAgICAgIGNbMiArIGkgKiA0ICsgMl0gPSAweGZmZmZmZjtcbiAgICAgICAgICAgIGNbMiArIGkgKiA0ICsgM10gPSAwO1xuICAgICAgICAgICAgaWR4W2kgKiA5XSA9IDA7XHQvL29yaWdpbjtcbiAgICAgICAgICAgIGlkeFtpICogOSArIDFdID0gKCBpICogMiApICsgMTtcbiAgICAgICAgICAgIGlkeFtpICogOSArIDJdID0gKCBpICogMiApICsgMztcbiAgICAgICAgICAgIGlkeFtpICogOSArIDNdID0gKCBpICogMiApICsgMTtcbiAgICAgICAgICAgIGlkeFtpICogOSArIDRdID0gKCBpICogMiApICsgMjtcbiAgICAgICAgICAgIGlkeFtpICogOSArIDVdID0gKCBpICogMiApICsgNDtcbiAgICAgICAgICAgIGlkeFtpICogOSArIDZdID0gKCBpICogMiApICsgMTtcbiAgICAgICAgICAgIGlkeFtpICogOSArIDddID0gKCBpICogMiApICsgNDtcbiAgICAgICAgICAgIGlkeFtpICogOSArIDhdID0gKCBpICogMiApICsgMztcblxuICAgICAgICAgICAgaWYgKCBpID09IHNpZGVzIC0gMSApIHtcbiAgICAgICAgICAgICAgICBpZHhbaSAqIDkgKyAyXSA9IDE7XG4gICAgICAgICAgICAgICAgaWR4W2kgKiA5ICsgNV0gPSAyO1xuICAgICAgICAgICAgICAgIGlkeFtpICogOSArIDddID0gMjtcbiAgICAgICAgICAgICAgICBpZHhbaSAqIDkgKyA4XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2xvZyhMb2cuVUksIHRhYmxlLmNvbmNhdChpZHgsXCIsXCIpKTtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNZXNoKCk7XG5cbiAgICAgICAgbS5zZXRWZXJ0ZXhBcnJheSggdiApO1xuICAgICAgICBtLnNldEluZGV4QXJyYXkoIGlkeCApO1xuICAgICAgICBtLnNldENvbG9yQXJyYXkoIGMgKTtcbiAgICAgICAgbS5zZXRUZXh0dXJlQ29vcmRpbmF0ZUFycmF5KCB0ICk7XG4gICAgICAgIG0uc2V0VGV4dHVyZSggc2VsZi5fUlQgKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0Q2lyY2xlSG9sZU1lc2hSVCggc2VsZiwgcmFkaXVzMSwgcmFkaXVzMiApIHtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSAzMjtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSBbKCBzZWxmLngyIC0gc2VsZi54MSApIC8gMiwgKCBzZWxmLnkyIC0gc2VsZi55MSApIC8gMl07XG4gICAgICAgIGNvbnN0IHYgPSBbXTtcbiAgICAgICAgY29uc3QgdCA9IFtdO1xuICAgICAgICBjb25zdCBpZHggPSBbXTtcbiAgICAgICAgY29uc3QgYyA9IFtdO1xuXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKysgKSB7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9ICggaSAvIHNpZGVzICkgKiAyICogTWF0aC5QSTtcblxuICAgICAgICAgICAgdi5wdXNoKFxuICAgICAgICAgICAgICAgIE1hdGguY29zKCBhbmdsZSApICogcmFkaXVzMSAvIDEuMiwgTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXMxIC8gMS4yLFxuICAgICAgICAgICAgICAgIE1hdGguY29zKCBhbmdsZSApICogcmFkaXVzMSwgTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXMxLFxuICAgICAgICAgICAgICAgIE1hdGguY29zKCBhbmdsZSApICogcmFkaXVzMiwgTWF0aC5zaW4oIGFuZ2xlICkgKiByYWRpdXMyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdC5wdXNoKFxuICAgICAgICAgICAgICAgIGN4ICsgdltpICogNl0sIGN5ICsgdltpICogNiArIDFdLFxuICAgICAgICAgICAgICAgIGN4ICsgdltpICogNiArIDJdLCBjeSArIHZbaSAqIDYgKyAzXSxcbiAgICAgICAgICAgICAgICBjeCArIHZbaSAqIDYgKyA0XSwgY3kgKyB2W2kgKiA2ICsgNV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjLnB1c2goXG4gICAgICAgICAgICAgICAgMHhmZmZmZmYsIDAsXG4gICAgICAgICAgICAgICAgMHhmZmZmZmYsIDEsXG4gICAgICAgICAgICAgICAgMHhmZmZmZmYsIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZHgucHVzaChcbiAgICAgICAgICAgICAgICAoIGkgKiAzICkgKyAwLCAoIGkgKiAzICkgKyA0LCAoIGkgKiAzICkgKyAzLFxuICAgICAgICAgICAgICAgICggaSAqIDMgKSArIDAsICggaSAqIDMgKSArIDEsICggaSAqIDMgKSArIDQsXG4gICAgICAgICAgICAgICAgKCBpICogMyApICsgMSwgKCBpICogMyApICsgMiwgKCBpICogMyApICsgNSxcbiAgICAgICAgICAgICAgICAoIGkgKiAzICkgKyAxLCAoIGkgKiAzICkgKyA1LCAoIGkgKiAzICkgKyA0XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIGkgPT0gc2lkZXMgLSAxICkge1xuICAgICAgICAgICAgICAgIGlkeFtpICogMTIgKyAxXSA9IDE7XG4gICAgICAgICAgICAgICAgaWR4W2kgKiAxMiArIDJdID0gMDtcbiAgICAgICAgICAgICAgICBpZHhbaSAqIDEyICsgNV0gPSAxO1xuICAgICAgICAgICAgICAgIGlkeFtpICogMTIgKyA4XSA9IDI7XG4gICAgICAgICAgICAgICAgaWR4W2kgKiAxMiArIDEwXSA9IDI7XG4gICAgICAgICAgICAgICAgaWR4W2kgKiAxMiArIDExXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2xvZyhMb2cuVUksIHRhYmxlLmNvbmNhdChpZHgsXCIsXCIpKTtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNZXNoKCk7XG5cbiAgICAgICAgbS5zZXRWZXJ0ZXhBcnJheSggdiApO1xuICAgICAgICBtLnNldEluZGV4QXJyYXkoIGlkeCApO1xuICAgICAgICBtLnNldENvbG9yQXJyYXkoIGMgKTtcbiAgICAgICAgbS5zZXRUZXh0dXJlQ29vcmRpbmF0ZUFycmF5KCB0ICk7XG4gICAgICAgIG0uc2V0VGV4dHVyZSggc2VsZi5fUlQgKTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cblxuICAgIHN0YXRpYyBjaXJjbGVPdXRSVCggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHcgPSBzZWxmLngyIC0gc2VsZi54MTtcbiAgICAgICAgY29uc3QgaCA9IHNlbGYueTIgLSBzZWxmLnkxO1xuXG4gICAgICAgIGlmICggc2VsZi5fYmxhY2tNZXNoICE9IG51bGwgKSB7XG4gICAgICAgICAgICBzZWxmLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KCAoIHcgLyAyICkgKiogMiArICggaCAvIDIgKSAqKiAyICk7XG5cbiAgICAgICAgc2NlbmUxLnNldFZpc2libGUoIGZhbHNlICk7XG4gICAgICAgIHNjZW5lMi5zZXRWaXNpYmxlKCB0cnVlICk7XG4gICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0Q2lyY2xlSG9sZU1lc2hSVCggc2VsZixyYWRpdXMgKiB0ICogMS4yLCByYWRpdXMgKiAxLjIgKTtcblxuICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICBzZWxmLmFkZENoaWxkKCBtICk7XG4gICAgICAgIC8vbS5zZXRTY2FsZSh0KTtcbiAgICAgICAgbS5zZXRYKCBzZWxmLmx3IC8gMiApO1xuICAgICAgICBtLnNldFkoIHNlbGYubGggLyAyICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNpcmNsZUluUlQoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3ID0gc2VsZi54MiAtIHNlbGYueDE7XG4gICAgICAgIGNvbnN0IGggPSBzZWxmLnkyIC0gc2VsZi55MTtcblxuICAgICAgICBpZiAoIHNlbGYuX2JsYWNrTWVzaCApIHtcbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaC5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoICggdyAvIDIgKSAqKiAyICsgKCBoIC8gMiApICoqIDIgKTtcblxuICAgICAgICBzY2VuZTEuc2V0VmlzaWJsZSggZmFsc2UgKTtcbiAgICAgICAgc2NlbmUyLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRDaXJjbGVNZXNoUlQoIHNlbGYscmFkaXVzICogKCAxIC0gdCApICogMS4yICk7XG5cbiAgICAgICAgc2VsZi5fYmxhY2tNZXNoID0gbTtcbiAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgICAgICBtLnNldFgoIHNlbGYubHcgLyAyICk7XG4gICAgICAgIG0uc2V0WSggc2VsZi5saCAvIDIgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UGFwZXJNZXNoUlQoIHNlbGYsIGNsaXAxLCBjbGlwMiApIHtcbiAgICAgICAgLy9sZXQgc2lkZXMgPSAzMjtcbiAgICAgICAgY29uc3QgdiA9IFtcbiAgICAgICAgICAgIHNlbGYueDEsIHNlbGYueTEsXG4gICAgICAgICAgICBzZWxmLngyIC0gY2xpcDEgLSBjbGlwMiwgc2VsZi55MSxcbiAgICAgICAgICAgIHNlbGYueDEsIHNlbGYueTIsXG4gICAgICAgICAgICBzZWxmLngyIC0gY2xpcDEgLSBjbGlwMiwgc2VsZi55MlxuICAgICAgICBdO1xuICAgICAgICBjb25zdCB0ID0gWzAgKyBjbGlwMSwgMCwgKCBzZWxmLngyIC0gc2VsZi54MSApIC0gY2xpcDIsIDAsIDAgKyBjbGlwMSwgKCBzZWxmLnkyIC0gc2VsZi55MSApLCAoIHNlbGYueDIgLSBzZWxmLngxICkgLSBjbGlwMiwgKCBzZWxmLnkyIC0gc2VsZi55MSApXTtcbiAgICAgICAgY29uc3QgaWR4ID0gWzAsIDEsIDIsIDEsIDMsIDJdO1xuICAgICAgICBjb25zdCBtID0gbmV3IE1lc2goKTtcblxuICAgICAgICBtLnNldFZlcnRleEFycmF5KCB2ICk7XG4gICAgICAgIG0uc2V0SW5kZXhBcnJheSggaWR4ICk7XG4gICAgICAgIG0uc2V0VGV4dHVyZUNvb3JkaW5hdGVBcnJheSggdCApO1xuICAgICAgICBtLnNldFRleHR1cmUoIHNlbGYuX1JUICk7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG5cbiAgICBzdGF0aWMgcGFwZXJEb3duUlQoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBpZiAoIHNlbGYuX2JsYWNrTWVzaCApIHtcbiAgICAgICAgICAgIHNlbGYuX2JsYWNrTWVzaC5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2VuZTEuc2V0VmlzaWJsZSggZmFsc2UgKTtcbiAgICAgICAgc2NlbmUyLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgY29uc3QgY2xpcDEgPSBNYXRoLnNpbiggcmFkKCB0ICogMTgwICkgKSAqICggc2VsZi54MiAtIHNlbGYueDEgKSAvIDI7XG4gICAgICAgIGNvbnN0IGNsaXAyID0gKCB0IDwgMC41ICkgPyAwIDogKCAxIC0gTWF0aC5jb3MoIHJhZCggKCB0IC0gMC41ICkgKiAxODAgKSApICkgKiAoIHNlbGYueDIgLSBzZWxmLngxICk7XG4gICAgICAgIGNvbnN0IG0gPSBTY2VuZU1hbmFnZXIuZ2V0UGFwZXJNZXNoUlQoIHNlbGYsY2xpcDEsIGNsaXAyICk7XG5cbiAgICAgICAgc2NlbmUyLnNldFgoIE1hdGguc2luKCByYWQoIHQgKiAxODAgKSApICogKCBzZWxmLngyIC0gc2VsZi54MSApIC8gMiApO1xuICAgICAgICBtLnNldFgoIDAgKTtcbiAgICAgICAgY29uc3QgYjEgPSAxIC0gdCAqIDAuNTtcbiAgICAgICAgY29uc3QgYjIgPSBNYXRoLm1heCggMCwgdCAqIDIgLSAxICk7XG5cbiAgICAgICAgc2NlbmUyLnNldENvbG9yTXVsdGlwbGllciggYjIsIGIyLCBiMiApO1xuICAgICAgICBtLnNldENvbG9yTXVsdGlwbGllciggYjEsIGIxLCBiMSApO1xuICAgICAgICBzZWxmLl9ibGFja01lc2ggPSBtO1xuICAgICAgICBzZWxmLmFkZENoaWxkKCBtICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcGVyVXBSVCggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGlmICggc2VsZi5fYmxhY2tNZXNoICkge1xuICAgICAgICAgICAgc2VsZi5fYmxhY2tNZXNoLnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjZW5lMS5zZXRWaXNpYmxlKCBmYWxzZSApO1xuICAgICAgICBzY2VuZTIuc2V0VmlzaWJsZSggdHJ1ZSApO1xuICAgICAgICBzY2VuZTIuc2V0WCggLU1hdGguc2luKCByYWQoIHQgKiAxODAgKSApICogKCBzZWxmLngyIC0gc2VsZi54MSApIC8gMiApO1xuICAgICAgICBjb25zdCB4MiA9ICggdCA8IDAuNSApID8gTWF0aC5zaW4oIHJhZCggdCAqIDE4MCApICkgKiAoIHNlbGYueDIgLSBzZWxmLngxICkgLyAyIDogc2NlbmUyLmdldFgoKSArICggc2VsZi54MiAtIHNlbGYueDEgKTtcbiAgICAgICAgY29uc3QgY2xpcDEgPSAoIHQgPCAwLjUgKSA/IDAgOiB4MiAtICggc2VsZi54MiAtIHNlbGYueDEgKSAvIDIgLSBNYXRoLmNvcyggcmFkKCAoIHQgLSA5MCApICogMTgwICkgKSAqICggc2VsZi54MiAtIHNlbGYueDEgKSAvIDI7XG4gICAgICAgIGNvbnN0IGNsaXAyID0geDIgLSBjbGlwMTtcbiAgICAgICAgY29uc3QgbSA9IFNjZW5lTWFuYWdlci5nZXRQYXBlck1lc2hSVCggc2VsZixjbGlwMSwgY2xpcDIgKTtcblxuICAgICAgICBtLnNldFgoIHgyICk7XG4gICAgICAgIGNvbnN0IGIxID0gMSAtIHQgKiAwLjU7XG4gICAgICAgIGNvbnN0IGIyID0gTWF0aC5tYXgoIDAsIHQgKiAyIC0gMSApO1xuXG4gICAgICAgIHNjZW5lMi5zZXRDb2xvck11bHRpcGxpZXIoIGIyLCBiMiwgYjIgKTtcbiAgICAgICAgbS5zZXRDb2xvck11bHRpcGxpZXIoIGIxLCBiMSwgYjEgKTtcbiAgICAgICAgc2VsZi5fYmxhY2tNZXNoID0gbTtcbiAgICAgICAgc2VsZi5hZGRDaGlsZCggbSApO1xuICAgIH1cblxuXG5cbiAgICBzdGF0aWMgbW92ZUZyb21SaWdodCggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gc2VsZi5sdyArIC1zZWxmLngxICogMjtcblxuICAgICAgICBzY2VuZTEuc2V0WCggLXQgKiB3aWR0aCApO1xuICAgICAgICBzY2VuZTIuc2V0WCggKCAxIC0gdCApICogd2lkdGggKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbW92ZUZyb21MZWZ0KCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLmx3ICsgLXNlbGYueDEgKiAyO1xuXG4gICAgICAgIHNjZW5lMS5zZXRYKCB0ICogd2lkdGggKTtcbiAgICAgICAgc2NlbmUyLnNldFgoICggdCAtIDEgKSAqIHdpZHRoICk7XG4gICAgfVxuXG4gICAgc3RhdGljIG92ZXJGcm9tUmlnaHQoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHNlbGYubHcgKyAtc2VsZi54MSAqIDI7XG5cbiAgICAgICAgc2NlbmUyLnNldFgoICggMSAtIHQgKSAqIHdpZHRoICk7XG4gICAgfVxuXG4gICAgc3RhdGljIG92ZXJGcm9tTGVmdCggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gc2VsZi5sdyArIC1zZWxmLngxICogMjtcblxuICAgICAgICBzY2VuZTIuc2V0WCggKCB0IC0gMSApICogd2lkdGggKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbW92ZUZyb21SaWdodFdpdGhGYWRlKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLmx3ICsgLXNlbGYueDEgKiAyO1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUxLnNldFgoIC10ICogd2lkdGggKTtcbiAgICAgICAgc2NlbmUyLnNldFgoICggMSAtIHQgKSAqIHdpZHRoICk7XG4gICAgfVxuXG4gICAgc3RhdGljIG1vdmVGcm9tTGVmdFdpdGhGYWRlKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLmx3ICsgLXNlbGYueDEgKiAyO1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUxLnNldFgoIHQgKiB3aWR0aCApO1xuICAgICAgICBzY2VuZTIuc2V0WCggKCB0IC0gMSApICogd2lkdGggKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgb3ZlckZyb21SaWdodFdpdGhGYWRlKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLmx3ICsgLXNlbGYueDEgKiAyO1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUyLnNldFgoICggMSAtIHQgKSAqIHdpZHRoICk7XG4gICAgfVxuXG4gICAgc3RhdGljIG92ZXJGcm9tTGVmdFdpdGhGYWRlKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLmx3ICsgLXNlbGYueDEgKiAyO1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUyLnNldFgoICggdCAtIDEgKSAqIHdpZHRoICk7XG4gICAgfVxuXG4gICAgc3RhdGljIG1vdmVGcm9tQm90dG9tKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2VsZi5saDtcblxuICAgICAgICBzY2VuZTEuc2V0WSggLXQgKiBoZWlnaHQgKTtcbiAgICAgICAgc2NlbmUyLnNldFkoICggMSAtIHQgKSAqIGhlaWdodCApO1xuICAgIH1cblxuICAgIHN0YXRpYyBtb3ZlRnJvbVRvcCggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHNlbGYubGg7XG5cbiAgICAgICAgc2NlbmUxLnNldFkoIHQgKiBoZWlnaHQgKTtcbiAgICAgICAgc2NlbmUyLnNldFkoICggdCAtIDEgKSAqIGhlaWdodCApO1xuICAgIH1cblxuICAgIHN0YXRpYyBvdmVyRnJvbUJvdHRvbSggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHNlbGYubGg7XG5cbiAgICAgICAgc2NlbmUyLnNldFkoICggMSAtIHQgKSAqIGhlaWdodCApO1xuICAgIH1cblxuICAgIHN0YXRpYyBvdmVyRnJvbVRvcCggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHNlbGYubGg7XG5cbiAgICAgICAgc2NlbmUyLnNldFkoICggdCAtIDEgKSAqIGhlaWdodCApO1xuICAgIH1cblxuICAgIHN0YXRpYyBtb3ZlRnJvbUJvdHRvbVdpdGhGYWRlKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2VsZi5saDtcblxuICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDEgLSB0ICk7XG4gICAgICAgIHNjZW5lMS5zZXRZKCAtdCAqIGhlaWdodCApO1xuICAgICAgICBzY2VuZTIuc2V0WSggKCAxIC0gdCApICogaGVpZ2h0ICk7XG4gICAgfVxuXG4gICAgc3RhdGljIG1vdmVGcm9tVG9wV2l0aEZhZGUoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBzZWxmLmxoO1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUxLnNldFkoIHQgKiBoZWlnaHQgKTtcbiAgICAgICAgc2NlbmUyLnNldFkoICggdCAtIDEgKSAqIGhlaWdodCApO1xuICAgIH1cblxuXG4gICAgc3RhdGljIG92ZXJGcm9tQm90dG9tV2l0aEZhZGUoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBzZWxmLmxoO1xuXG4gICAgICAgIHNjZW5lMS5zZXRBbHBoYSggMSAtIHQgKTtcbiAgICAgICAgc2NlbmUyLnNldFkoICggMSAtIHQgKSAqIGhlaWdodCApO1xuICAgIH1cblxuICAgIHN0YXRpYyBvdmVyRnJvbVRvcFdpdGhGYWRlKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2VsZi5saDtcblxuICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDEgLSB0ICk7XG4gICAgICAgIHNjZW5lMi5zZXRZKCAoIHQgLSAxICkgKiBoZWlnaHQgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZmFkZSggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGlmICggdCA8IDAuNSApIHtcbiAgICAgICAgICAgIHNjZW5lMS5zZXRBbHBoYSggKCAwLjUgLSB0ICkgKiAyICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdCA8IDAuNSApIHtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRBbHBoYSggMCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NlbmUyLnNldEFscGhhKCAoIHQgLSAwLjUgKSAqIDIgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjcm9zc2ZhZGUoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDEgLSB0ICk7XG4gICAgICAgIHNjZW5lMi5zZXRBbHBoYSggdCApO1xuICAgIH1cblxuICAgIHN0YXRpYyBmbGlwKCBzZWxmLCBzY2VuZTEsIHNjZW5lMiwgdCwgcmF3VCApIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzZWxmLmx3O1xuXG4gICAgICAgIGlmICggdCA8IDAuNSApIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSAoIDAuNSAtIHQgKSAqIDI7XG5cbiAgICAgICAgICAgIHNjZW5lMS5zZXRTY2FsZVgoIHMgKTtcbiAgICAgICAgICAgIHNjZW5lMS5zZXRYKCAoIDEgLSBzICkgKiB3aWR0aCAqIDAuNSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NlbmUxLnNldFNjYWxlWCggMCApO1xuICAgICAgICAgICAgc2NlbmUxLnNldFgoIHdpZHRoICogMC41ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHQgPCAwLjUgKSB7XG4gICAgICAgICAgICBzY2VuZTIuc2V0U2NhbGVYKCAwICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0WCggd2lkdGggKiAwLjUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSAoIHQgLSAwLjUgKSAqIDI7XG5cbiAgICAgICAgICAgIHNjZW5lMi5zZXRTY2FsZVgoIHMgKTtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRYKCAoIDEgLSBzICkgKiB3aWR0aCAqIDAuNSApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGZsaXBXaXRoRmFkZSggc2VsZiwgc2NlbmUxLCBzY2VuZTIsIHQsIHJhd1QgKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gc2VsZi5sdztcblxuICAgICAgICBpZiAoIHQgPCAwLjUgKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gKCAwLjUgLSB0ICkgKiAyO1xuXG4gICAgICAgICAgICBzY2VuZTEuc2V0U2NhbGVYKCBzICk7XG4gICAgICAgICAgICBzY2VuZTEuc2V0WCggKCAxIC0gcyApICogd2lkdGggKiAwLjUgKTtcbiAgICAgICAgICAgIHNjZW5lMS5zZXRBbHBoYSggcyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NlbmUxLnNldFNjYWxlWCggMCApO1xuICAgICAgICAgICAgc2NlbmUxLnNldFgoIHdpZHRoICogMC41ICk7XG4gICAgICAgICAgICBzY2VuZTEuc2V0QWxwaGEoIDAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdCA8IDAuNSApIHtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRTY2FsZVgoIDAgKTtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRYKCB3aWR0aCAqIDAuNSApO1xuICAgICAgICAgICAgc2NlbmUyLnNldEFscGhhKCAwICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzID0gKCB0IC0gMC41ICkgKiAyO1xuXG4gICAgICAgICAgICBzY2VuZTIuc2V0U2NhbGVYKCBzICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0WCggKCAxIC0gcyApICogd2lkdGggKiAwLjUgKTtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRBbHBoYSggcyApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGZsaXBXaXRoU2hhZGUoIHNlbGYsIHNjZW5lMSwgc2NlbmUyLCB0LCByYXdUICkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHNlbGYubHc7XG5cbiAgICAgICAgaWYgKCB0IDwgMC41ICkge1xuICAgICAgICAgICAgY29uc3QgcyA9ICggMC41IC0gdCApICogMjtcblxuICAgICAgICAgICAgc2NlbmUxLnNldFNjYWxlWCggcyApO1xuICAgICAgICAgICAgc2NlbmUxLnNldFgoICggMSAtIHMgKSAqIHdpZHRoICogMC41ICk7XG4gICAgICAgICAgICBzY2VuZTEuc2V0Q29sb3JNdWx0aXBsaWVyKCAxIC0gdCwgMSAtIHQsIDEgLSB0LCAxICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2VuZTEuc2V0U2NhbGVYKCAwICk7XG4gICAgICAgICAgICBzY2VuZTEuc2V0WCggd2lkdGggKiAwLjUgKTtcbiAgICAgICAgICAgIHNjZW5lMS5zZXRDb2xvck11bHRpcGxpZXIoIDAuNSwgMC41LCAwLjUsIDEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdCA8IDAuNSApIHtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRTY2FsZVgoIDAgKTtcbiAgICAgICAgICAgIHNjZW5lMi5zZXRYKCB3aWR0aCAqIDAuNSApO1xuICAgICAgICAgICAgc2NlbmUyLnNldENvbG9yTXVsdGlwbGllciggMC41LCAwLjUsIDAuNSwgMSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcyA9ICggdCAtIDAuNSApICogMjtcblxuICAgICAgICAgICAgc2NlbmUyLnNldFNjYWxlWCggcyApO1xuICAgICAgICAgICAgc2NlbmUyLnNldFgoICggMSAtIHMgKSAqIHdpZHRoICogMC41ICk7XG4gICAgICAgICAgICBzY2VuZTIuc2V0Q29sb3JNdWx0aXBsaWVyKCB0LCB0LCB0LCAxICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIOuplOyduCDsvZTrk5xcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgIGdldEN1cnJlbnRTY2VuZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50U2NlbmUoKSB7XG4gICAgICAgIGlmICggdGhpcy5zY2VuZTIgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2VuZTI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZTE7XG4gICAgfVxuXG4gICAgaXNDaGFuZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdpbmdTY2VuZTtcbiAgICB9XG5cbiAgICBjaGFuZ2VTY2VuZSggc3ByT3JGdW5jLCBkdXJhdGlvbiwgdHJhbnNpdGlvbiwgZWFzZSwgb3B0aW9ucyApIHtcbiAgICAgICAgbGV0IHNwcjtcblxuICAgICAgICBpZiAoIHR5cGVvZiBzcHJPckZ1bmMgPT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgc3ByID0gc3ByT3JGdW5jKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcHIgPSBzcHJPckZ1bmM7XG4gICAgICAgIH1cblxuICAgICAgICAvL2xvZyhMb2cuU0NFTkUsIFwiY2hhbmdlU2NlbmU6IFwiIC4uICh0aGlzLmN1cnJlbnRTY2VuZSB+PSBudWxsIGFuZCB0aGlzLmN1cnJlbnRTY2VuZSBvciBcIm51bGxcIikgLi4gXCIgdG8gXCIgLi4gKHNjZW5lIH49IG51bGwgYW5kIHNjZW5lIG9yIFwibnVsbFwiKSk7XG4gICAgICAgIGlmICggIXRoaXMuYWN0aXZlICkge1xuICAgICAgICAgICAgLy9pZiAoR0xPQkFMLmxheWVyU2hpZWxkRm9yU2NlbmVDaGFuZ2UpIHsgR0xPQkFMLmxheWVyU2hpZWxkRm9yU2NlbmVDaGFuZ2Uuc2hvdygpIH1cbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggRXZlbnQuRU5URVJfRlJBTUUsIHRoaXMub25FbnRlckZyYW1lLCB0aGlzICk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoYW5naW5nU2NlbmUgPSB0cnVlO1x0IC8vIOyLoCDsoITtmZjsi5wg7J6F66Cl7J2EIOunieqxsOuCmCDtlaAg65WMIOyTsOugpOqzoC4gdHdlZW5pbmftlZjqs6DripQg7Iuc7KCQ7J20IOyigCDri6TrpbTri6RcbiAgICAgICAgdGhpcy5ldmVudEZpbHRlciA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuZXZlbnRGaWx0ZXIgOiBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9IHNwcjtcblxuICAgICAgICAvLyBoZW5qZW9uLCAyMDE0LjEyLjAxO1xuICAgICAgICAvLyDtlZwg7ZSE66CI7J6E7JeQIG9uRW50ZXJGcmFtZSgpIOyghOyXkCBjaGFuZ2VTY2VuZSgpIOyXsOyGjeycvOuhnCDtmLjstpzrkJjrqbQgYmVnaW7snbTrsqTtirgg7JeG7J20IH0g7J2067Kk7Yq46rCAIO2YuOy2nOuQmOuKlCDrrLjsoJzqsIAg7J6I64ukLlxuICAgICAgICAvLyBjaGFuZ2VTY2VuZSgp7JeQ7IScIHRyYW5zaXRpb25CZWdpbiDsnbTrsqTtirjrpbwg67CU66GcIO2YuOy2nO2VoCDqsr3smrAg7L2U65OcIO2dkOumhOydtCDsoITqs7wg64us65287KC47IScIOyXrOufrCDqsIDsp4Ag66y47KCc6rCAIOuwnOyDne2VmOyXrCxcbiAgICAgICAgLy8g7Zi47LacIOyInOyEnOuKlCDqt7jrjIDroZwg7Jyg7KeA7ZWY64+E66GdIOyXrOq4sOyEnCB0aGlzLnRpbWXsnbQgMOydtCDslYTri5DrlYzrp4wg7J2067Kk7Yq466W8IO2YuOy2nO2VmOuPhOuhnSDsspjrpqztlahcbiAgICAgICAgLy9cdFx0XG4gICAgICAgIGlmICggdGhpcy50d2VlbmluZyApIHtcbiAgICAgICAgICAgIGlmICggdGhpcy50aW1lICE9IDAgKSB7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBcInRyYW5zaXRpb25FbmRcIiApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUxLmRpc3BhdGNoRXZlbnQoIFwiZXhpdEVuZFwiICk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZTIuZGlzcGF0Y2hFdmVudCggXCJlbnRlckVuZFwiICk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lMS5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZTEgPSB0aGlzLnNjZW5lMjtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lMiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy50d2VlbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdTY2VuZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc2NlbmUyICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lMi5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuc2NlbmUxID09IG51bGwgKSB7XG4gICAgICAgICAgICAvL+ydtOyghCDslKzsnbQg7JeG64qUIOqyveyasOydtOuLpC5cbiAgICAgICAgICAgIHRoaXMuc2NlbmUxID0gbmV3IFNwcml0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICB0aGlzLmVhc2UgPSBlYXNlIHx8IGRlZmF1bHRFYXNlO1xuICAgICAgICB0aGlzLnNjZW5lMiA9IHNwcjsgLy90aGlzLnNjZW5lc1tzY2VuZV0ubmV3KG9wdGlvbnMgYW5kIG9wdGlvbnMudXNlckRhdGEpO1xuICAgICAgICB0aGlzLnNjZW5lMi5zZXRWaXNpYmxlKCBmYWxzZSApO1xuICAgICAgICB0aGlzLmFkZENoaWxkKCB0aGlzLnNjZW5lMiApO1xuICAgICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lciA9IFRpbWVyLm5vdygpO1xuICAgICAgICB0aGlzLnR3ZWVuaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIF9uZWVkUlQuZ2V0KCB0cmFuc2l0aW9uICkgKSB7XG4gICAgICAgICAgICBjb25zdCBzcyA9IHRoaXMuc3RhZ2UuZ2V0U2NhbGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHcgPSAoIHRoaXMueDIgLSB0aGlzLngxICk7IC8vKiBzcztcbiAgICAgICAgICAgIGNvbnN0IGggPSAoIHRoaXMueTIgLSB0aGlzLnkxICk7IC8vKiBzcztcbiAgICAgICAgICAgIGNvbnN0IHN4ID0gdGhpcy5zdGFnZS5nZXRYKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhZ2Uuc2V0U2NhbGUoIDEgKTtcbiAgICAgICAgICAgIGNvbnN0IHJ0ID0gbmV3IFJlbmRlclRhcmdldCggdywgaCwgdHJ1ZSApO1xuXG4gICAgICAgICAgICBydC5jbGVhciggMHgwMDAwMDAsIDEgKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2Uuc2V0UG9zaXRpb24oIC10aGlzLngxLCAtdGhpcy55MSApO1xuICAgICAgICAgICAgcnQuZHJhdyggdGhpcy5zdGFnZSApO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5zZXRYKCBzeCApO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5zZXRTY2FsZSggc3MueCxzcy55ICk7XG4gICAgICAgICAgICB0aGlzLl9SVCA9IHJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmUyO1xuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudFNjZW5lKCBjdXJyZW50U2NlbmUgKSB7XG4gICAgICAgIHRoaXMuc2NlbmUxID0gY3VycmVudFNjZW5lO1xuICAgICAgICB0aGlzLmFkZENoaWxkKCB0aGlzLnNjZW5lMSApO1xuICAgIH1cblxuICAgIGZpbHRlclRyYW5zaXRpb25FdmVudHMoIGV2ZW50ICkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBvblRyYW5zaXRpb25CZWdpbigpIHtcbiAgICAgICAgaWYgKCB0aGlzLmV2ZW50RmlsdGVyICkge1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCggdGhpcy50cmFuc2l0aW9uRXZlbnRDYXRjaGVyICk7XG5cbiAgICAgICAgICAgIGZvciAoIGNvbnN0IGkgaW4gdGhpcy5ldmVudEZpbHRlciApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRGaWx0ZXJbaV07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25FdmVudENhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lciggZXZlbnQsIHRoaXMuZmlsdGVyVHJhbnNpdGlvbkV2ZW50cywgdGhpcyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25UcmFuc2l0aW9uRW5kKCkge1xuICAgICAgICBpZiAoIHRoaXMuZXZlbnRGaWx0ZXIgKSB7XG4gICAgICAgICAgICBmb3IgKCBjb25zdCBpIGluIHRoaXMuZXZlbnRGaWx0ZXIgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmV2ZW50RmlsdGVyW2ldO1xuXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uRXZlbnRDYXRjaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2ZW50LCB0aGlzLmZpbHRlclRyYW5zaXRpb25FdmVudHMsIHRoaXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uRXZlbnRDYXRjaGVyLnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRW50ZXJGcmFtZSggZXZlbnQgKSB7XG4gICAgICAgIC8vIOydtOuypO2KuO2VhO2EsOungeqwnOyytOulvCBhbHdheXMgb24gdG9wIOyLnO2CqOuLpFxuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKCB0aGlzLnRyYW5zaXRpb25FdmVudENhdGNoZXIgKTtcblxuICAgICAgICAvLyDtirjrnpzsp4DshZgg7KKF66OM7IucIOydtOqzs+yXkOyEnCDsnbzqtIQg7LKY66asXG4gICAgICAgIGlmICggIXRoaXMudHdlZW5pbmcgKSB7XG4gICAgICAgICAgICAvL2lmIChHTE9CQUwubGF5ZXJTaGllbGRGb3JTY2VuZUNoYW5nZSkgeyBHTE9CQUwubGF5ZXJTaGllbGRGb3JTY2VuZUNoYW5nZS5oaWRlKCkgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCBFdmVudC5FTlRFUl9GUkFNRSwgdGhpcy5vbkVudGVyRnJhbWUsIHRoaXMgKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUxLnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUxID0gdGhpcy5zY2VuZTI7XG4gICAgICAgICAgICB0aGlzLnNjZW5lMiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoYW5naW5nU2NlbmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy93aXBlciByZW1vdmU7XG4gICAgICAgICAgICBpZiAoIHRoaXMuX2JsYWNrTWVzaCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ibGFja01lc2gucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JsYWNrTWVzaCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cdFx0XG4gICAgICAgICAgICBpZiAoIHRoaXMuX1JUICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX1JUID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0aGlzLnRpbWUgPT0gMCApIHtcbiAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uQmVnaW4oKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUyLnNldFZpc2libGUoIHRydWUgKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggXCJ0cmFuc2l0aW9uQmVnaW5cIiApO1xuICAgICAgICAgICAgdGhpcy5zY2VuZTEuZGlzcGF0Y2hFdmVudCggXCJleGl0QmVnaW5cIiApO1xuICAgICAgICAgICAgdGhpcy5zY2VuZTIuZGlzcGF0Y2hFdmVudCggXCJlbnRlckJlZ2luXCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVyID0gVGltZXIubm93KCk7XG4gICAgICAgIGNvbnN0IGRlbHRhVGltZSA9IDEwMDAgLyA2MDsgLy8gdGltZXIgLSB0aGlzLmN1cnJlbnRUaW1lcjtcblxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lciA9IHRpbWVyO1xuICAgICAgICBjb25zdCB0ID0gKCB0aGlzLmR1cmF0aW9uID09IDAgKSA/IDEgOiAoIHRoaXMudGltZSAvIHRoaXMuZHVyYXRpb24gKTtcblxuICAgICAgICB0aGlzLnRyYW5zaXRpb24oIHRoaXMsIHRoaXMuc2NlbmUxLCB0aGlzLnNjZW5lMiwgdGhpcy5lYXNlKCB0ICksIHQgKTtcblxuICAgICAgICBpZiAoIHRoaXMudGltZSA9PSB0aGlzLmR1cmF0aW9uICkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBcInRyYW5zaXRpb25FbmRcIiApO1xuICAgICAgICAgICAgdGhpcy5zY2VuZTEuZGlzcGF0Y2hFdmVudCggXCJleGl0RW5kXCIgKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUyLmRpc3BhdGNoRXZlbnQoIFwiZW50ZXJFbmRcIiApO1xuICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgICAgIHRoaXMudHdlZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZSA9IHRoaXMudGltZSArIGRlbHRhVGltZTtcblxuICAgICAgICBpZiAoIHRoaXMuZHVyYXRpb24gPCB0aGlzLnRpbWUgKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWUgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5fbmVlZFJUID0gbmV3IE1hcCggW1xuICAgIFtTY2VuZU1hbmFnZXIuY2lyY2xlSW5SVCwgdHJ1ZV0sXG4gICAgW1NjZW5lTWFuYWdlci5jaXJjbGVPdXRSVCwgdHJ1ZV0sXG4gICAgW1NjZW5lTWFuYWdlci5wYXBlckRvd25SVCwgdHJ1ZV0sXG4gICAgW1NjZW5lTWFuYWdlci5wYXBlclVwUlQsIHRydWVdLFxuXSApO1xuXG4iLCJcclxuLy9pbXBvcnQgRXZlbnREaXNwYXRjaGVyIGZyb20gXCIuL2V2ZW50RGlzcGF0Y2hlclwiO1xyXG5cclxuXHJcbi8qKiBcclxuICogQHR5cGVkZWYge29iamVjdH0gQ2xhc3NEZWZPcHRpb25zXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb249fSBjb25zdHJ1Y3RcclxuICogQHBhcmFtIHtib29sZWFuPX0gZmlsbFxyXG4gKiBAcGFyYW0ge3N0cmluZ1tdPX0gd2hpdGVcclxuICogQHBhcmFtIHtzdHJpbmdbXT19IGJsYWNrXHJcbiAqIEBwYXJhbSB7c3RyaW5nW109fSBrZWVwXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGRhdGFPbmx5XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtbb2JqZWN0LENsYXNzRGVmT3B0aW9uc119IF9DbGFzc0RlZlxyXG4gKiBcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdHxfQ2xhc3NEZWZ9IENsYXNzRGVmXHJcbiAqIFxyXG4gKi9cclxuXHJcbmNvbnN0IFMgPSB7XHJcbiAgICB1bmRlZmluZWQ6ICAgICBcIiQkVURGXCIsXHJcbiAgICBmdW5jdGlvbjogICAgICBcIiQkRk5DXCIsXHJcbiAgICB1bmtub3duOiAgICAgICBcIiQkVUtOXCIsXHJcbiAgICBOYU46ICAgICAgICAgICBcIiQkTkFOXCIsXHJcbiAgICBJbmZpbml0eTogICAgICBcIiQkSU5GXCIsXHJcbiAgICBNaW51c0luZmluaXR5OiBcIiQkTUlGXCIsXHJcbiAgICBEYXRlOiAgICAgICAgICBcIiQkREFUXCIsXHJcbiAgICBSZWdFeHA6ICAgICAgICBcIiQkUkdYXCIsXHJcbiAgICBSZWZlcmVuY2U6ICAgICBcIiQkUkVGXCJcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgaWdub3JlUHJlZml4OiAgICAgXCJfX1wiLFxyXG4gICAgaWdub3JlTGlzdDogICAgICAgW1wiX19waXhpXCJdLFxyXG4gICAgc2tpcFVuZGVmaW5lZDogICAgdHJ1ZSxcclxuICAgIHNraXBVbmtub3duQ2xhc3M6IHRydWVcclxufTtcclxuXHJcbi8qKiBcclxuICogQHR5cGVkZWYge29iamVjdH0gU2VyaWFsaXplck9wdGlvbnNcclxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBpZ25vcmVQcmVmaXhcclxuICogQHByb3BlcnR5IHtzdHJpbmdbXT19IGlnbm9yZUxpc3RcclxuICogQHByb3BlcnR5IHtib29sZWFuPX0gc2tpcFVuZGVmaW5lZFxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW49fSBza2lwVW5rbm93bkNsYXNzXHJcbiAqIFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiBjb3B5T2JqZWN0KCBkc3QsIHNyYywga2VlcCApIHtcclxuICAgIGlmICgga2VlcCA9PSBudWxsICkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIGRzdCwgc3JjICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoIGNvbnN0IGsgaW4gc3JjICkge1xyXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzcmNba10gPT0gXCJvYmplY3RcIiAmJiBkc3Rba10gJiYga2VlcC5pbmNsdWRlcyggayApICkge1xyXG4gICAgICAgICAgICAgICAgLy8g64yA7IOB7J20IO2UhOuhneyLnOydvCDqsr3smrAg6re464OlIOuzteyCrO2VmOuptCDtlITroZ3si5wg7ZW465Ok65+s66W8IOyeg+yWtOuyhOumrOq4sCDrlYzrrLjsl5AgXHJcbiAgICAgICAgICAgICAgICAvLyBrZWVwIOumrOyKpO2KuOydmCDqsoPrk6TsnYAg7KO87IaM66W8IOuztOyhtOyLnOy8nOyVvO2VnOuLpC5cclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oIGRzdFtrXSwgc3JjW2tdICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkc3Rba10gPSBzcmNba107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDqsozsnoQg7Jik67iM7KCd7Yq466W8IOyngeugrO2ZlO2VmOqzoCDri6Tsi5wg6rKM7J6E7Jik67iM7KCd7Yq466GcIOunjOuTpCDsiJgg7J6I64+E66GdIO2VnOuLpC5cclxuICog7KeB66Cs7ZmU7ZWcIOyYpOu4jOygne2KuOuKlCDrhKTtirjsm43snLzroZwg67O064K06rGw64KYIO2MjOydvOyXkCDsoIDsnqXtlaAg7IiYIOyeiOuLpC5cclxuICogXHJcbiAqIOyngeugrO2ZlO2VoCDsmKTruIzsoJ3tirjqsIAg7IOd7ISx7J6Q7JeQ7IScIFByb3h566W8IOunjOuTnOuKlCDqsr3smrAg7KO87J2Y6rCAIO2VhOyalO2VqFxyXG4gKiBQcm94eeqwgCDri6TsuLXsnLzroZwg6rWs7ISx65CgIOqyveyasCBQcm94eeydmCBoYW5kbGVy66W8IOyeg+yWtOuyhOumtCDsiJgg7J6I64ukLlxyXG4gKiDqt7jrn7Ag6rKD65Ok7J2AIGtlZXAg7Ji17IWY7J2EIOyCrOyaqe2VtOyEnCDtg4Dqsp8g6rCc7LK07J2YIO2UhOuhnO2GoO2DgOyeheydhCDsnKDsp4DtlZjrj4TroZ0g7ZWgIOqyg1xyXG4gKlxyXG4gKiBAY2xhc3MgU2VyaWFsaXplclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNlcmlhbGl6ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKkNyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU2VyaWFsaXplci5cclxuICAgICAqIEBwYXJhbSB7Q2xhc3NEZWZbXX0gY2xhc3NMaXN0XHJcbiAgICAgKiBAcGFyYW0ge1NlcmlhbGl6ZXJPcHRpb25zfSBbb3B0aW9ucz17fV1cclxuICAgICAqIEBtZW1iZXJvZiBTZXJpYWxpemVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCBjbGFzc0xpc3QsIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyApIHtcclxuICAgICAgICAvL3N1cGVyKCk7XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsX0NsYXNzRGVmPn0gKi9cclxuICAgICAgICB0aGlzLmNsYXNzTGlzdCA9IHt9O1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgZm9yICggY29uc3QgY2xhc3NEZWYgb2YgY2xhc3NMaXN0ICkge1xyXG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGNsYXNzRGVmICkgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdFtjbGFzc0RlZlswXS5uYW1lXSA9IFtjbGFzc0RlZixjbGFzc0RlZlsxXV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdFtjbGFzc0RlZi5uYW1lXSA9IFtjbGFzc0RlZixudWxsXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9fb2JqZWN0VG9JZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9faWRUb09iamVjdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9fcmVmQ291bnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyggdGhpcy5jbGFzc0xpc3QgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBvYmpcclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAgICAgKiBAbWVtYmVyb2YgU2VyaWFsaXplclxyXG4gICAgICovXHJcbiAgICBfZ2V0U2VyaWFsaXphYmxlT2JqZWN0KCBvYmogKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLl9fb2JqZWN0VG9JZC5oYXMoIG9iaiApICkge1xyXG4gICAgICAgICAgICB0aGlzLl9fcmVmQ291bnRbdGhpcy5fX29iamVjdFRvSWQuZ2V0KCBvYmogKV0gPSAoIHRoaXMuX19yZWZDb3VudFt0aGlzLl9fb2JqZWN0VG9JZC5nZXQoIG9iaiApXSB8fCAwICkgKyAxO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFMuUmVmZXJlbmNlICsgXCI6XCIgKyB0aGlzLl9fb2JqZWN0VG9JZC5nZXQoIG9iaiApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHR5cGVvZiBvYmogPT0gXCJ1bmRlZmluZWRcIiApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFMudW5kZWZpbmVkO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9iaiA9PT0gbnVsbCApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmICggb2JqIGluc3RhbmNlb2YgUmVnRXhwICkge1xyXG4gICAgICAgICAgICByZXR1cm4gUy5SZWdFeHAgKyBcIjpcIiArIG9iai50b1N0cmluZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIG9iaiBpbnN0YW5jZW9mIERhdGUgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTLkRhdGUgKyBcIjpcIiArIG9iai5nZXRUaW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIG9iaiA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBvYmogPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygb2JqID09IFwiYm9vbGVhblwiICkge1xyXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgaWYgKCBOdW1iZXIuaXNOYU4oIG9iaiApICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFMuTmFOO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBvYmogPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTLkluZmluaXR5O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBvYmogPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTLk1pbnVzSW5maW5pdHk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIG9iaiA9PSBcImZ1bmN0aW9uXCIgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTLmZ1bmN0aW9uO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBvYmogPT0gXCJvYmplY3RcIiApICB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLnNraXBVbmtub3duQ2xhc3MgJiYgb2JqLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgJiYgb2JqLmNvbnN0cnVjdG9yICE9PSBBcnJheSAmJiB0aGlzLmNsYXNzTGlzdFtvYmouY29uc3RydWN0b3IubmFtZV0gPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTLnVua25vd247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5fX29iamVjdFRvSWQuc2l6ZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX19vYmplY3RUb0lkLnNldCggb2JqLCBpZCApO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZE9iaiA9IHRoaXMuX2dldFNlcmlhbGl6YWJsZU9iamVjdCggb2JqW2ldICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLnNraXBVbmRlZmluZWQgJiYgY29udmVydGVkT2JqID09IFMudW5kZWZpbmVkICkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ZXJ0ZWRPYmogIT0gUy5mdW5jdGlvbiAmJiBjb252ZXJ0ZWRPYmogIT0gUy51bmtub3duICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjb252ZXJ0ZWRPYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtDbGFzc0RlZk9wdGlvbnN9ICovXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc09wdGlvbnMgPSBvYmouY29uc3RydWN0b3IgIT09IE9iamVjdCA/IHRoaXMuY2xhc3NMaXN0W29iai5jb25zdHJ1Y3Rvci5uYW1lXVsxXSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gISggY2xhc3NPcHRpb25zICYmIGNsYXNzT3B0aW9ucy5kYXRhT25seSApICYmIG9iai5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ID8geyBfX2NsYXNzOiBvYmouY29uc3RydWN0b3IubmFtZSB9IDoge307XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEtleSA9IE9iamVjdC5rZXlzKCBvYmogKS5zb3J0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggY29uc3QgayBvZiBzb3J0ZWRLZXkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5hc3NlcnQoIGsgIT0gXCJlbnRpdHlNYW5hZ2VyXCIgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICF0aGlzLm9wdGlvbnMuaWdub3JlTGlzdC5pbmNsdWRlcyggayApICYmICFrLnN0YXJ0c1dpdGgoIHRoaXMub3B0aW9ucy5pZ25vcmVQcmVmaXggKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjbGFzc09wdGlvbnMgJiYgY2xhc3NPcHRpb25zLmJsYWNrICYmIGNsYXNzT3B0aW9ucy5ibGFjay5pbmNsdWRlcyggayApICkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2xhc3NPcHRpb25zICYmIGNsYXNzT3B0aW9ucy53aGl0ZSAmJiAhY2xhc3NPcHRpb25zLndoaXRlLmluY2x1ZGVzKCBrICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRPYmogPSB0aGlzLl9nZXRTZXJpYWxpemFibGVPYmplY3QoIG9ialtrXSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbnMuc2tpcFVuZGVmaW5lZCAmJiBjb252ZXJ0ZWRPYmogPT0gUy51bmRlZmluZWQgKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ZXJ0ZWRPYmogIT0gUy5mdW5jdGlvbiAmJiBjb252ZXJ0ZWRPYmogIT0gUy51bmtub3duICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gY29udmVydGVkT2JqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX19pZFRvT2JqZWN0W2lkXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHJlc3VsdC5fX3JlZklkID0gaWQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIGDslYwg7IiYIOyXhuuKlCDtg4DsnoUg67Cc6rKsICR7b2JqfWAgKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTZXJpYWxpemFibGVPYmplY3QoIG9iaiApIHtcclxuICAgICAgICB0aGlzLl9fb2JqZWN0VG9JZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9faWRUb09iamVjdCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX19yZWZDb3VudCA9IHt9O1xyXG5cclxuICAgICAgICBjb25zdCByID0gdGhpcy5fZ2V0U2VyaWFsaXphYmxlT2JqZWN0KCBvYmogKTtcclxuXHJcbiAgICAgICAgLy8g66as7Y2865+w7IqkIOygleumrFxyXG5cclxuICAgICAgICBmb3IgKCBjb25zdCBpZCBpbiB0aGlzLl9faWRUb09iamVjdCApIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLl9fcmVmQ291bnRbaWRdID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fX2lkVG9PYmplY3RbaWRdLl9fcmVmSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX19vYmplY3RUb0lkO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9faWRUb09iamVjdDtcclxuICAgICAgICBkZWxldGUgdGhpcy5fX3JlZkNvdW50O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIFNlcmlhbGl6ZXJcclxuICAgICAqL1xyXG4gICAgc3RyaW5naWZ5KCBvYmogKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCB0aGlzLmdldFNlcmlhbGl6YWJsZU9iamVjdCggb2JqICkgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOyngeugrO2ZlOuQnCDqsJzssrTrpbwg67O16rWs7ZWc64ukLlxyXG4gICAgICogXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzIC0g66y47J6Q7Je0IO2YueydgCDsp4HroKztmZQg7LKY66as65CcIOqwnOyytFxyXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBwYXJzZU9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAgICAgKiBAbWVtYmVyb2YgU2VyaWFsaXplclxyXG4gICAgICovXHJcbiAgICBwYXJzZSggcyAsIHBhcnNlT3B0aW9ucyApIHtcclxuICAgICAgICAvKiogQHR5cGUge1NlcmlhbGl6ZXJ9ICovXHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBmdW5jdGlvbiAoIGssIHYgKSB7XHJcbiAgICAgICAgICAgIGlmICggdiA9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2ID09IFwib2JqZWN0XCIgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHYgKSB8fCB2Ll8kJGNsYXNzID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCAhc2VsZi5fX29iamVjdFRvSWQuaGFzKCB2ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld09iajtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCggc2VsZi5jbGFzc0xpc3Rbdi5fJCRjbGFzc10gKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY2xhc3NPYmosIGNsYXNzRGVmT3B0aW9uc10gPSBzZWxmLmNsYXNzTGlzdFt2Ll8kJGNsYXNzXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjbGFzc0RlZk9wdGlvbnMgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIGNsYXNzT2JqLmxlbmd0aCA9PSAwLGAke3YuXyQkY2xhc3N97J2YIOyDneyEseyekOydmCDsnbjsiJjripQgJHtjbGFzc09iai5sZW5ndGh97J24642wIOyduOyImCDsl4bsnbQg7IOd7ISx7J2EIOyLnOuPhO2VmOqzoCDsnojri6QuIGNvbnN0cnVjdCDsmLXshZjsnbQg7ZWE7JqU7ZWoYCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmogPSBuZXcgY2xhc3NPYmooKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbiggbmV3T2JqLCB2ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjbGFzc0RlZk9wdGlvbnMuY29uc3RydWN0ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqID0gY2xhc3NEZWZPcHRpb25zLmNvbnN0cnVjdC5jYWxsKCBzZWxmLCB2LCBwYXJzZU9wdGlvbnMgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNsYXNzRGVmT3B0aW9ucy5maWxsICE9PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5T2JqZWN0KCBuZXdPYmosIHYsY2xhc3NEZWZPcHRpb25zLmtlZXAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlPYmplY3QoIG5ld09iaiwgdiwgY2xhc3NEZWZPcHRpb25zLmtlZXAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHYuX19yZWZJZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpZCAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fb2JqZWN0VG9JZC5zZXQoIHYsIGlkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19pZFRvT2JqZWN0W2lkXSA9IG5ld09iajtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5ld09iai5fX3JlZklkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5ld09iai5fJCRjbGFzcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iajtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHYgPT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgICAgIGlmICggT2JqZWN0LnZhbHVlcyggUyApLmluY2x1ZGVzKCB2LnN1YnN0ciggMCwgNSApICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g64K067aA7YOA7J6FIOuwnOqyrFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB2LnN1YnN0ciggMCwgNSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT0gUy5OYU4gKSByZXR1cm4gTnVtYmVyLk5hTjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggdHlwZSA9PSBTLkluZmluaXR5ICkgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggdHlwZSA9PSBTLk1pbnVzSW5maW5pdHkgKSByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCB0eXBlID09IFMuUmVnRXhwICkgcmV0dXJuIG5ldyBSZWdFeHAoIHYuc3Vic3RyKCA2ICkgKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggdHlwZSA9PSBTLkRhdGUgKSByZXR1cm4gbmV3IERhdGUoIHYuc3Vic3RyKCA2ICkgKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggdHlwZSA9PSBTLlJlZmVyZW5jZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSB2LnN1YnN0ciggNiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzZWxmLl9faWRUb09iamVjdFtpZF0gKSByZXR1cm4gc2VsZi5fX2lkVG9PYmplY3RbaWRdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIuumrO2NvOufsOyKpCDqsJzssrTqsIAg66eM65Ok7Ja07KeA6riwIOyghOyXkCDrpqztjbzrn7DsiqTrpbwg7Jew6rKw7ZWY66Ck6rOgIO2VqFwiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBgcGFyc2Ug7ZWgIOyImCDsl4bripQg6rCc7LK0ICR7dn1gICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fX29iamVjdFRvSWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fX2lkVG9PYmplY3QgPSB7fTtcclxuICAgICAgICBjb25zb2xlLmxvZyggcyApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCByO1xyXG5cclxuICAgICAgICBpZiAoIHR5cGVvZiBzID09IFwib2JqZWN0XCIgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKCBvICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBvID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbyA9PSBcIm9iamVjdFwiICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBBcnJheS5pc0FycmF5KCBvICkgPyBbXSA6IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBjb25zdCBrIGluIG8gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJba10gPSByZWNlaXZlci5jYWxsKCByLCBrLCBwYXJzZU9iamVjdCggb1trXSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByID0gcGFyc2VPYmplY3QoIHMgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgcyA9PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICByID0gSlNPTi5wYXJzZSggcywgcmVjZWl2ZXIgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9faWRUb09iamVjdDtcclxuICAgICAgICBkZWxldGUgdGhpcy5fX29iamVjdFRvSWQ7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCByICk7XHJcblxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuIiwiaW1wb3J0IHsgYXBwbGljYXRpb24gfSBmcm9tICcuL0FwcGxpY2F0aW9uJztcclxuaW1wb3J0IHsgQXNzZXQgfSBmcm9tICcuL0Fzc2V0JztcclxuaW1wb3J0IHsgVGV4dHVyZUJhc2UgfSBmcm9tICcuL1RleHR1cmVCYXNlJztcclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL1V0aWxzJztcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgU2hhZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICpDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFNoYWRlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJ0ZXhTcmNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcmFnbWVudFNyY1xyXG4gICAgICogQHBhcmFtIHtUZXh0dXJlQmFzZVtdPX0gdGV4dHVyZXNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gY29uc3RhbnRzXHJcbiAgICAgKiBAbWVtYmVyb2YgU2hhZGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCB0ZXh0dXJlcywgY29uc3RhbnRzICkge1xyXG4gICAgICAgIHRoaXMuYXNzZXQgPSBuZXcgQXNzZXQoIFwiPFNoYWRlcjoqPlwiLEFzc2V0LkFzc2V0VHlwZXMuU2hhZGVyICk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzICE9IG51bGwgPyB0ZXh0dXJlcyA6IHt9O1xyXG4gICAgICAgIHRoaXMuY29uc3RhbnRzID0gY29uc3RhbnRzICE9IG51bGwgPyBjb25zdGFudHMgOiB7fTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hc3NldC5sb2FkKCB7IHZlcnRleFNyYzogdmVydGV4U3JjLGZyYWdtZW50U3JjOiBmcmFnbWVudFNyYyx0ZXh0dXJlczogdGhpcy5fZ2V0VGV4dHVyZUlkcygpLGNvbnN0YW50czogdGhpcy5jb25zdGFudHMgfSApO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRUZXh0dXJlSWRzKCkge1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVJZHMgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IG5hbWUgaW4gdGhpcy50ZXh0dXJlcyApIHtcclxuICAgICAgICAgICAgdGV4dHVyZUlkc1tuYW1lXSA9IHRoaXMudGV4dHVyZXNbbmFtZV0uYXNzZXQuaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlSWRzO1xyXG4gICAgfVxyXG5cclxuICAgIF91cGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yY2VVcGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmRpcnR5ICkge1xyXG4gICAgICAgICAgICB0aGlzLmFzc2V0LnVwZGF0ZSggeyB0ZXh0dXJlczogdGhpcy5fZ2V0VGV4dHVyZUlkcygpLGNvbnN0YW50czogdGhpcy5jb25zdGFudHMgfSApO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbGVhc2UoKSB7XHJcbiAgICAgICAgdGhpcy5hc3NldC5yZWxlYXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q29uc3RhbnQoIG5hbWUsIHZhbHVlICkge1xyXG4gICAgICAgIHRoaXMuY29uc3RhbnRzW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldENvbnN0YW50cyggY29uc3RhbnRzICkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIHRoaXMuY29uc3RhbnRzLGNvbnN0YW50cyApO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOyFsOydtOuNlOyXkCDthY3siqTss5Drpbwg67CU7J2465Sp7ZWc64ukXHJcbiAgICAgKiBuYW1l7J2EIOyngOygle2VmOuptCDshbDsnbTrjZTslYjsl5AgbmFtZVNhbXBsZXLroZwg7J297J2EIOyImCDsnojri6QuXHJcbiAgICAgKiBTYW1wbGVy6rCAIOu2meuKlCDqsoPsl5Ag7KO87J2Y7ZWgIOqyg1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcGFyYW0ge1RleHR1cmVCYXNlfSB0ZXh0dXJlXHJcbiAgICAgKiBAcmV0dXJucyB7U2hhZGVyfVxyXG4gICAgICogQG1lbWJlcm9mIFNoYWRlclxyXG4gICAgICovXHJcbiAgICBzZXRUZXh0dXJlKCBuYW1lLCB0ZXh0dXJlICkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZXNbbmFtZV0gPSB0ZXh0dXJlO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1NoYWRlcn0gXHJcbiAgICAgKiBAbWVtYmVyb2YgU2hhZGVyXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1NoYWRlciA9IHsgdGV4dHVyZXM6IHt9LGNvbnN0YW50czoge30gfTtcclxuXHJcbiAgICAgICAgbmV3U2hhZGVyLmFzc2V0ID0gbmV3IEFzc2V0KCBcIjxTaGFkZXI6Kj5cIixBc3NldC5Bc3NldFR5cGVzLlNoYWRlciApO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIG5ld1NoYWRlci50ZXh0dXJlcyx0aGlzLnRleHR1cmVzICk7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbiggbmV3U2hhZGVyLmNvbnN0YW50cyx0aGlzLmNvbnN0YW50cyApO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiggbmV3U2hhZGVyLFNoYWRlci5wcm90b3R5cGUgKTtcclxuICAgICAgICBuZXdTaGFkZXIuYXNzZXQubG9hZCggeyBjb3B5RnJvbTogdGhpcy5hc3NldC5pZCwgdGV4dHVyZXM6IG5ld1NoYWRlci5fZ2V0VGV4dHVyZUlkcygpLGNvbnN0YW50czogbmV3U2hhZGVyLmNvbnN0YW50cyB9ICk7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgcmV0dXJuIG5ld1NoYWRlcjtcclxuICAgIH1cclxufVxyXG5TaGFkZXIubGFzdElkID0gMDtcclxuIiwiXHJcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlJztcclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL1V0aWxzJztcclxuXHJcbi8vIGdpZGVyb3PsmYAg7JmE7KCE7Z6IIO2YuO2ZmOydgCDslYjrkKguIFxyXG4vLyDrjIDstqkg66eM65OgIOuLpOydjOyXkCBBUEnrpbwg67CU6r+AIOqyg1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBTaGFwZSBleHRlbmRzIFNwcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvciggdGV4dHVyZSApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuXyQkc3ByaXRlVHlwZSA9IFNwcml0ZS5TcHJpdGVUeXBlcy5TSEFQRTtcclxuICAgICAgICB0aGlzLl8kJHVwZGF0ZUNvZGUgPSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5zZXRMaW5lU3R5bGUoIDAsMHgwMDAwMDAsMCApO1xyXG4gICAgICAgIHRoaXMuc2V0RmlsbFN0eWxlKCBTaGFwZS5TT0xJRCwweDAwMDAwMCwwICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGN1cnJlbnRTdWJQYXRoUG9pbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YlBhdGhzW3RoaXMuc3ViUGF0aHMubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TGluZVN0eWxlKCB3aWR0aCwgY29sb3IsIGFscGhhICkge1xyXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5saW5lQ29sb3IgPSBVdGlscy5oZXgycmdiYSggY29sb3IsYWxwaGEgKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRGaWxsU3R5bGUoIHR5cGUsIC4uLmFyZ3MgKSB7XHJcbiAgICAgICAgaWYgKCB0eXBlID09IFNoYXBlLlNPTElEICkge1xyXG4gICAgICAgICAgICBjb25zdCBbY29sb3IsIGFscGhhXSA9IGFyZ3M7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZpbGxDb2xvciA9IFV0aWxzLmhleDJyZ2JhKCBjb2xvcixhbHBoYSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBiZWdpblBhdGgoIHdpbmRpbmcgKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFggPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnRZID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RYID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RZID0gMDtcclxuICAgICAgICB0aGlzLnN1YlBhdGhzID0gW1tdXTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnN1YlBhdGhzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgbW92ZVRvKCB4LHkgKSB7XHJcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XHJcbiAgICAgICAgaWYgKCB0aGlzLmN1cnJlbnRTdWJQYXRoUG9pbnRzLmxlbmd0aCA9PSAwICkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0WCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRZID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViUGF0aFBvaW50cy5wdXNoKCB4LHkgKTtcclxuICAgICAgICB0aGlzLmxhc3RYID0geDtcclxuICAgICAgICB0aGlzLmxhc3RZID0geTtcclxuICAgICAgICB0aGlzLl8kJGxvY2FsQm91bmRzLmV4dGVuZFBvaW50KCB4LHkgKTtcclxuICAgIH1cclxuXHJcbiAgICBsaW5lVG8oIHgseSApIHtcclxuICAgICAgICBpZiAoIHRoaXMuY3VycmVudFN1YlBhdGhQb2ludHMubGVuZ3RoID09IDAgKSByZXR1cm4gdGhpcy5tb3ZlVG8oIHgseSApO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YlBhdGhQb2ludHMucHVzaCggeCwgeSApO1xyXG4gICAgICAgIHRoaXMubGFzdFggPSB4O1xyXG4gICAgICAgIHRoaXMubGFzdFkgPSB5O1xyXG4gICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMuZXh0ZW5kUG9pbnQoIHgseSApO1xyXG4gICAgfVxyXG5cclxuICAgIGVuZFBhdGgoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgY2xvc2VQYXRoKCkge1xyXG4gICAgICAgIGlmICggdGhpcy5jdXJyZW50U3ViUGF0aFBvaW50cy5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdWJQYXRoUG9pbnRzLnB1c2goIHRoaXMuc3RhcnRYLHRoaXMuc3RhcnRZICk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViUGF0aHMucHVzaCggW10gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fJCR1cGRhdGVDb2RlIHw9IFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfRVhUUkE7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIG1ha2VCb3goIHgsIHksIHcsIGgsIGMsIGEgKSB7XHJcbiAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLnNldEZpbGxTdHlsZSggU2hhcGUuU09MSUQsIGMsIGEgKTtcclxuICAgICAgICB0aGlzLm1vdmVUbyggeCx5ICk7XHJcbiAgICAgICAgdGhpcy5saW5lVG8oIHggKyB3LHkgKTtcclxuICAgICAgICB0aGlzLmxpbmVUbyggeCArIHcseSArIGggKTtcclxuICAgICAgICB0aGlzLmxpbmVUbyggeCx5ICsgaCApO1xyXG4gICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIG1ha2VCb3goIHgsIHksIHcsIGgsIGMsIGEgKSB7XHJcbiAgICAgICAgY29uc3Qgc2ggPSBuZXcgU2hhcGUoKTtcclxuXHJcbiAgICAgICAgc2gubWFrZUJveCggeCwgeSwgdywgaCwgYywgYSApO1xyXG4gICAgICAgIHJldHVybiBzaDtcclxuICAgIH1cclxuXHJcbiAgICBlbmNvZGVFeHRyYVJlbmRlcmluZ0luZm8oKSB7XHJcbiAgICAgICAgY29uc3QgZ2V0QXJyYXkgPSAoKT0+IHtcclxuICAgICAgICAgICAgY29uc3QgYXJyID0gW107XHJcblxyXG4gICAgICAgICAgICBhcnIucHVzaCggdGhpcy5zdWJQYXRocy5sZW5ndGggLSAoIHRoaXMuY3VycmVudFN1YlBhdGhQb2ludHMubGVuZ3RoID09IDAgPyAxIDogMCApICk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViUGF0aHMuZm9yRWFjaCggcGF0aCA9PiB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCggcGF0aC5sZW5ndGggKTtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKCAuLi5wYXRoICk7XHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsZXQgYXJyMiA9IGdldEFycmF5KCk7XHJcbiAgICAgICAgbGV0IGVuY29kZWRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCA5ICsgYXJyMi5sZW5ndGggKTtcclxuXHJcbiAgICAgICAgZW5jb2RlZEJ1ZmZlclswXSA9IHRoaXMubGluZVdpZHRoO1xyXG4gICAgICAgIGVuY29kZWRCdWZmZXIuc2V0KCB0aGlzLmxpbmVDb2xvciwxICk7XHJcbiAgICAgICAgZW5jb2RlZEJ1ZmZlci5zZXQoIHRoaXMuZmlsbENvbG9yLDUgKTtcclxuICAgICAgICBlbmNvZGVkQnVmZmVyLnNldCggYXJyMiw5ICk7XHJcblxyXG4gICAgICAgIHJldHVybiBbZW5jb2RlZEJ1ZmZlcl07XHJcbiAgICB9XHJcbn1cclxuXHJcblNoYXBlLk5PTkUgPSBcIm5vbmVcIjtcclxuU2hhcGUuU09MSUQgPSBcInNvbGlkXCI7XHJcblNoYXBlLlRFWFRVUkUgPSBcInRleHR1cmVcIjtcclxuU2hhcGUuTElORUFSX0dSQURJRU5UID0gXCJsaW5lYXJHcmFkaWVudFwiO1xyXG5TaGFwZS5SQURJQUxfR1JBRElFTlQgPSBcInJhZGlhbEdyYWRpZW50XCI7XHJcblNoYXBlLk5PTl9aRVJPID0gXCJub25lWmVyb1wiO1xyXG5cclxuIiwiaW1wb3J0IHsgYXBwbGljYXRpb24gfSBmcm9tIFwiLi9BcHBsaWNhdGlvblwiO1xyXG5pbXBvcnQgeyBBc3NldCB9IGZyb20gXCIuL0Fzc2V0XCI7XHJcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi9FdmVudCc7XHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCIuL0V2ZW50RGlzcGF0Y2hlclwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgU291bmQgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoIG5hbWUgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmFzc2V0ID0gbmV3IEFzc2V0KCBuYW1lLEFzc2V0LkFzc2V0VHlwZXMuU291bmQgKTtcclxuICAgICAgICB0aGlzLmFzc2V0LmxvYWQoKTtcclxuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHBhcmFtIHthbnk9fSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc09uY2U9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7U291bmR9XHJcbiAgICAgKiBAbWVtYmVyb2YgU291bmRcclxuICAgICAqL1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBmdW5jLCBjb250ZXh0ID0gbnVsbCwgaXNPbmNlID0gZmFsc2UgKSB7XHJcbiAgICAgICAgaWYgKCBldmVudE5hbWUgPT0gRXZlbnQuTE9BREVEICkge1xyXG4gICAgICAgICAgICB0aGlzLmFzc2V0LmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgdGhpcy5kaXNwYXRjaEV2ZW50LmJpbmQoIHRoaXMsRXZlbnQuTE9BREVEICksIG51bGwsIGlzT25jZSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICByZXR1cm4gc3VwZXIuYWRkRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBmdW5jLCBjb250ZXh0LCBpc09uY2UgKTtcclxuICAgIH1cclxuXHJcbiAgICBwbGF5KCBzdGFydFRpbWUsbG9vcGluZyxwYXVzZWQgKSB7XHJcbiAgICAgICAgYXBwbGljYXRpb24ucG9zdE1lc3NhZ2VUb1JlbmRlciggeyBtc2c6IFwiYWRkQ29tbWFuZFwiLGNsYXNzOiBcIlNvdW5kXCIsIG1ldGhvZDogXCJwbGF5XCIsYXJnczogW3RoaXMuYXNzZXQuaWQsIHN0YXJ0VGltZSxsb29waW5nLHBhdXNlZF0gfSApO1xyXG4gICAgICAgIHRoaXMucGxheWluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Vm9sdW1lKCB2ICkge1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLnBvc3RNZXNzYWdlVG9SZW5kZXIoIHsgbXNnOiBcImFkZENvbW1hbmRcIixjbGFzczogXCJTb3VuZFwiLG1ldGhvZDogXCJzZXRWb2x1bWVcIixhcmdzOiBbdGhpcy5hc3NldC5pZCwgdl0gfSApO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBpdGNoKCB2ICkge1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLnBvc3RNZXNzYWdlVG9SZW5kZXIoIHsgbXNnOiBcImFkZENvbW1hbmRcIixjbGFzczogXCJTb3VuZFwiLG1ldGhvZDogXCJzZXRQaXRjaFwiLGFyZ3M6IFt0aGlzLmFzc2V0LmlkLCB2XSB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQbGF5aW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBsYXlpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGF1c2VkKCB2ICkge1xyXG4gICAgICAgIGlmICggdiApIHtcclxuICAgICAgICAgICAgYXBwbGljYXRpb24ucG9zdE1lc3NhZ2VUb1JlbmRlciggeyBtc2c6IFwiYWRkQ29tbWFuZFwiLGNsYXNzOiBcIlNvdW5kXCIsbWV0aG9kOiBcInNldFBhdXNlZFwiLGFyZ3M6IFt0aGlzLmFzc2V0LmlkLCB2XSB9ICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGxheWluZyA9ICF2O1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBvc2l0aW9uKCB2ICkge1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLnBvc3RNZXNzYWdlVG9SZW5kZXIoIHsgbXNnOiBcImFkZENvbW1hbmRcIixjbGFzczogXCJTb3VuZFwiLG1ldGhvZDogXCJzZXRQb3NpdGlvblwiLGFyZ3M6IFt0aGlzLmFzc2V0LmlkLCB2XSB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBhcHBsaWNhdGlvbi5wb3N0TWVzc2FnZVRvUmVuZGVyKCB7IG1zZzogXCJhZGRDb21tYW5kXCIsY2xhc3M6IFwiU291bmRcIixtZXRob2Q6IFwic3RvcFwiLGFyZ3M6IFt0aGlzLmFzc2V0LmlkXSB9ICk7XHJcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TGVuZ3RoKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvciggXCJOb3QgaW1wbGVtZW50ZWRcIiApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwbGF5U291bmQoIG5hbWUgKSB7XHJcbiAgICAgICAgcmV0dXJuICggbmV3IFNvdW5kKCBuYW1lICkgKS5wbGF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDqsJnsnYAga2V566W8IOyCrOyaqe2eiOuptCDtla3sg4Eg7ZWY64KY7J2YIOyCrOyatOuTnOunjCDrgpjsmKTqsowg7ZWc64ukLlxyXG4gICAgICog66eM7JW9IOqwmeydgCBrZXnsnbjrjbAgbmFtZeydtCDri6Trpbwg6rK97JqwIOydtOyghCDsgqzsmrTrk5zripQg7KSR7KeA7Iuc7YKk6rOgIOyDiOuhnCDsl7Dso7xcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0geyp9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7Kn0gdm9sXHJcbiAgICAgKiBAcGFyYW0geyp9IGxvb3BcclxuICAgICAqIEBwYXJhbSB7Kn0gW2tleT1uYW1lXVxyXG4gICAgICogQG1lbWJlcm9mIFNvdW5kXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwbGF5U2luZ2xlU291bmQoIG5hbWUsdm9sLGxvb3Asa2V5ID0gbmFtZSApIHtcclxuICAgICAgICBhcHBsaWNhdGlvbi5wb3N0TWVzc2FnZVRvUmVuZGVyKCB7IG1zZzogXCJhZGRDb21tYW5kXCIsY2xhc3M6IFwiU291bmRcIixtZXRob2Q6IFwicGxheVNpbmdsZVNvdW5kXCIsYXJnczogW25hbWUsdm9sLGxvb3Asa2V5XSB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHN0b3BBbGxTaW5nbGVTb3VuZCgpIHtcclxuICAgICAgICBhcHBsaWNhdGlvbi5wb3N0TWVzc2FnZVRvUmVuZGVyKCB7IG1zZzogXCJhZGRDb21tYW5kXCIsY2xhc3M6IFwiU291bmRcIixtZXRob2Q6IFwic3RvcEFsbFNpbmdsZVNvdW5kXCIsYXJnczogW10gfSApO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuIiwiXHJcbi8vIGltcG9ydCB7U3BpbmVQaXhpIGZyb20gXCIuL2V4dC9zcGluZS1waXhpXCI7XHJcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlJztcclxuaW1wb3J0IHsgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xyXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vRXZlbnQnO1xyXG5pbXBvcnQgeyBTdG9yYWdlIH0gZnJvbSAnLi9TdG9yYWdlJztcclxuXHJcblxyXG4vL3BpeGktc3BpbmUgZG9jc1xyXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS1zcGluZS9ibG9iL25leHQvZXhhbXBsZXMvaW5kZXgubWRcclxuXHJcbmV4cG9ydCBjbGFzcyBTcGluZSBleHRlbmRzIFNwcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvciggc3BpbmVGaWxlbmFtZSApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gXHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgU3BpbmVQaXhpLkFzc2V0TWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWRUZXh0KCBzcGluZUZpbGVuYW1lICsgXCIuanNvblwiICk7XHJcbiAgICAgICAgLy8gdGhpcy5sb2FkZXIubG9hZFRleHQoIHNwaW5lRmlsZW5hbWUgKyBcIi5hdGxhc1wiICk7XHJcbiAgICAgICAgLy8gdGhpcy5sb2FkZXIubG9hZFRleHR1cmUoIHNwaW5lRmlsZW5hbWUgKyBcIi5wbmdcIiApO1xyXG4gICAgICAgIC8vIHRoaXMubG9hZGVyLmxvYWRUZXh0dXJlKCBzcGluZUZpbGVuYW1lICsgXCIyLnBuZ1wiICk7XHJcbiAgICAgICAgLy8gdGhpcy5sb2FkZXIubG9hZFRleHR1cmUoIHNwaW5lRmlsZW5hbWUgKyBcIjMucG5nXCIgKTtcclxuICAgICAgICAvLyB0aGlzLmxvYWRlci5sb2FkVGV4dHVyZSggc3BpbmVGaWxlbmFtZSArIFwiNC5wbmdcIiApO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWRUZXh0KCBcIlNwaW5lcy9TcGluZV9QbGF5ZXJfMy5hdGxhc1wiICk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZFRleHR1cmUoIFwiU3BpbmVzL1NwaW5lX1BsYXllcl8zLnBuZ1wiICk7XHJcblxyXG4gICAgICAgIC8vIFN0b3JhZ2UubG9hZEZpbGUoIHNwaW5lRmlsZW5hbWUgKS5vbiggRXZlbnQuQ09NUExFVEUsKCBlICk9PntcclxuXHJcbiAgICAgICAgLy8gICAgIHRoaXMuc3BpbmUgPSBuZXcgU3BpbmVQaXhpKCBlLmRhdGEgKTtcclxuICAgICAgICAvLyAgICAgdGhpcy5vbiggRXZlbnQuUkVBRFksKCk9PntcclxuXHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLm9uU3RhZ2UoIEV2ZW50LkVOVEVSX0ZSQU1FLCgpPT57XHJcblxyXG4gICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuc3BpbmUudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAvLyAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gICAgIH0gKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyB9ICk7XHJcbiAgICAgICAgdGhpcy5zcGluZUZpbGVuYW1lID0gc3BpbmVGaWxlbmFtZTtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoICgpPT50aGlzLmxvYWQoKSApO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmxvYWRlci5pc0xvYWRpbmdDb21wbGV0ZSgpICkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyggXCLsmYTro4xcIiApO1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMubG9hZFNrZWxldG9uKCB0aGlzLnNwaW5lRmlsZW5hbWUgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2tlbGV0b24gPSBkYXRhLnNrZWxldG9uO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5zdGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZHMgPSBkYXRhLmJvdW5kcztcclxuICAgICAgICAgICAgdGhpcy5za2VsZXRvbkRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAvLyB0aGlzLm9uU3RhZ2UoIEV2ZW50LkVOVEVSX0ZSQU1FLCgpPT57XHJcblxyXG4gICAgICAgICAgICAvLyAgICAgcy51cGRhdGUoIDEwMDAgLyA2MCApO1xyXG4gICAgICAgICAgICAvLyB9ICk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgU3BpbmVQaXhpLlNrZWxldG9uUmVuZGVyZXIoIHRoaXMuX19waXhpICk7XHJcbiAgICAgICAgICAgIHRoaXMub25TdGFnZSggRXZlbnQuRU5URVJfRlJBTUUsKCk9PntcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlKCAxIC8gNjAgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuYXBwbHkoIHRoaXMuc2tlbGV0b24gKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZHJhdyggdGhpcy5za2VsZXRvbiApO1xyXG4gICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9fcGl4aS5lbWl0KCBFdmVudC5SRUFEWSApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSggKCk9PnRoaXMubG9hZCgpICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxvYWRTa2VsZXRvbiggbmFtZSApIHtcclxuICAgICAgICBsZXQgYmFzZVBhdGggPSBuYW1lLnN1YnN0ciggMCxuYW1lLmxhc3RJbmRleE9mKCBcIi9cIiApICk7XHJcbiAgICAgICAgLy8gICAgICAgIGxldCBhdGxhcyA9IG5ldyBTcGluZVBpeGkuY29yZS5UZXh0dXJlQXRsYXMoIHRoaXMubG9hZGVyLmdldCggbmFtZS5yZXBsYWNlKCBcIi1wcm9cIiwgXCJcIiApLnJlcGxhY2UoIFwiLWVzc1wiLCBcIlwiICkgKyBcIi5hdGxhc1wiICksICggcGF0aCApID0+IHtcclxuICAgICAgICBsZXQgYXRsYXMgPSBuZXcgU3BpbmVQaXhpLmNvcmUuVGV4dHVyZUF0bGFzKCB0aGlzLmxvYWRlci5nZXQoIFwiU3BpbmVzL1NwaW5lX1BsYXllcl8zLmF0bGFzXCIgKSwgKCBwYXRoICkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuZ2V0KCBiYXNlUGF0aCArIFwiL1wiICsgcGF0aCApO1xyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgQXRsYXNBdHRhY2htZW50TG9hZGVyLCB3aGljaCBpcyBzcGVjaWZpYyB0byB0aGUgV2ViR0wgYmFja2VuZC5cclxuICAgICAgICBsZXQgYXRsYXNMb2FkZXIgPSBuZXcgU3BpbmVQaXhpLmNvcmUuQXRsYXNBdHRhY2htZW50TG9hZGVyKCBhdGxhcyApO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIFNrZWxldG9uSnNvbiBpbnN0YW5jZSBmb3IgcGFyc2luZyB0aGUgLmpzb24gZmlsZS5cclxuICAgICAgICBsZXQgc2tlbGV0b25Kc29uID0gbmV3IFNwaW5lUGl4aS5jb3JlLlNrZWxldG9uSnNvbiggYXRsYXNMb2FkZXIgKTtcclxuXHJcbiAgICAgICAgbGV0IHNrZWxldG9uRGF0YSA9IHNrZWxldG9uSnNvbi5yZWFkU2tlbGV0b25EYXRhKCB0aGlzLmxvYWRlci5nZXQoIG5hbWUgKyBcIi5qc29uXCIgKSApO1xyXG4gICAgICAgIGxldCBza2VsZXRvbiA9IG5ldyBTcGluZVBpeGkuY29yZS5Ta2VsZXRvbiggc2tlbGV0b25EYXRhICk7XHJcblxyXG4gICAgICAgIHNrZWxldG9uLmZsaXBZID0gdHJ1ZTtcclxuICAgICAgICBsZXQgYm91bmRzID0gdGhpcy5jYWxjdWxhdGVCb3VuZHMoIHNrZWxldG9uICk7XHJcblxyXG4gICAgICAgIHNrZWxldG9uLnNldFNraW5CeU5hbWUoIFwicnVubmVyXCIgKTtcclxuICAgICAgICAvLyBDcmVhdGUgYW4gQW5pbWF0aW9uU3RhdGUsIGFuZCBzZXQgdGhlIGluaXRpYWwgYW5pbWF0aW9uIGluIGxvb3BpbmcgbW9kZS5cclxuICAgICAgICB2YXIgYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3BpbmVQaXhpLmNvcmUuQW5pbWF0aW9uU3RhdGUoIG5ldyBTcGluZVBpeGkuY29yZS5BbmltYXRpb25TdGF0ZURhdGEoIHNrZWxldG9uLmRhdGEgKSApO1xyXG5cclxuICAgICAgICBhbmltYXRpb25TdGF0ZS5zZXRBbmltYXRpb24oIDAsIFwic3RhbmRpbmdcIiwgdHJ1ZSApO1xyXG5cclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICBhbmltYXRpb25TdGF0ZS5hZGRMaXN0ZW5lcigge1xyXG4gICAgICAgICAgICBldmVudDogZnVuY3Rpb24oIHRyYWNrSW5kZXgsIGV2ZW50ICkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJFdmVudCBvbiB0cmFjayBcIiArIHRyYWNrSW5kZXggKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShldmVudCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIHRyYWNrSW5kZXgsIGxvb3BDb3VudCApIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQW5pbWF0aW9uIG9uIHRyYWNrIFwiICsgdHJhY2tJbmRleCArIFwiIGNvbXBsZXRlZCwgbG9vcCBjb3VudDogXCIgKyBsb29wQ291bnQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdGFydDogZnVuY3Rpb24oIHRyYWNrSW5kZXggKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkFuaW1hdGlvbiBvbiB0cmFjayBcIiArIHRyYWNrSW5kZXggKyBcIiBzdGFydGVkXCIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbmQ6IGZ1bmN0aW9uKCB0cmFja0luZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJBbmltYXRpb24gb24gdHJhY2sgXCIgKyB0cmFja0luZGV4ICsgXCIgZW5kZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIC8vIFBhY2sgZXZlcnl0aGluZyB1cCBhbmQgcmV0dXJuIHRvIGNhbGxlci5cclxuICAgICAgICByZXR1cm4geyBza2VsZXRvbjogc2tlbGV0b24sIHN0YXRlOiBhbmltYXRpb25TdGF0ZSwgYm91bmRzOiBib3VuZHMgfTtcclxuICAgIH1cclxuXHJcbiAgICBjYWxjdWxhdGVCb3VuZHMoIHNrZWxldG9uICkge1xyXG4gICAgICAgIHZhciBkYXRhID0gc2tlbGV0b24uZGF0YTtcclxuXHJcbiAgICAgICAgc2tlbGV0b24uc2V0VG9TZXR1cFBvc2UoKTtcclxuICAgICAgICBza2VsZXRvbi51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSBuZXcgU3BpbmVQaXhpLmNvcmUuVmVjdG9yMigpO1xyXG4gICAgICAgIHZhciBzaXplID0gbmV3IFNwaW5lUGl4aS5jb3JlLlZlY3RvcjIoKTtcclxuXHJcbiAgICAgICAgc2tlbGV0b24uZ2V0Qm91bmRzKCBvZmZzZXQsIHNpemUsIFtdICk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IG9mZnNldDogb2Zmc2V0LCBzaXplOiBzaXplIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIFNwaW5l7J2AIOyekOyytOyggeycvOuhnCDssKjsnbzrk5zrpbwg7IOd7ISx7ZWY6riwIOuVjOusuOyXkCDssKjsnbzrk5wg7IiY6rCAIOq8rOydvCDsiJgg7J6I7J2MXHJcbi8vIOqwmeydgCDsspjrpqzrpbwg7ZWY6rOgIOyeiOuKlCBUZXh0RmllbGTsnZgg6rKD7J2EIOyTsOyekFxyXG5TcGluZS5wcm90b3R5cGUuZ2V0Q2hpbGRBdCA9IFRleHRGaWVsZC5wcm90b3R5cGUuZ2V0Q2hpbGRBdDtcclxuU3BpbmUucHJvdG90eXBlLmdldE51bUNoaWxkcmVuID0gVGV4dEZpZWxkLnByb3RvdHlwZS5nZXROdW1DaGlsZHJlbjtcclxuU3BpbmUucHJvdG90eXBlLnNvcnRDaGlsZHJlbiA9IFRleHRGaWVsZC5wcm90b3R5cGUuc29ydENoaWxkcmVuO1xyXG5TcGluZS5wcm90b3R5cGUucmVmcmVzaENvbG9yID0gVGV4dEZpZWxkLnByb3RvdHlwZS5yZWZyZXNoQ29sb3I7XHJcblxyXG4iLCJpbXBvcnQgeyBtNCwgdjMgfSBmcm9tICd0d2dsLmpzJztcclxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vRXZlbnQnO1xyXG5pbXBvcnQgeyBDb21wb25lbnRIb2xkZXIgfSBmcm9tICcuL0NvbXBvbmVudEhvbGRlcic7XHJcbmltcG9ydCB7IFBvaW50LCBSZWN0LCBUeXBlZEFycmF5SGVscGVyIH0gZnJvbSAnLi9UeXBlcyc7XHJcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi9VdGlscyc7XHJcbmltcG9ydCB7IEFzc2V0IH0gZnJvbSAnLi9Bc3NldCc7XHJcbmltcG9ydCB7IGFwcGxpY2F0aW9uIH0gZnJvbSAnLi9BcHBsaWNhdGlvbic7XHJcbmltcG9ydCB7IGVhc2luZyB9IGZyb20gJy4vZWFzaW5nJztcclxuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnLi9UcmFuc2Zvcm0nO1xyXG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuL1NoYWRlcic7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFNwcml0ZSBleHRlbmRzIENvbXBvbmVudEhvbGRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuXyQkaWQgPSBTcHJpdGUubGFzdElkKys7XHJcbiAgICAgICAgU3ByaXRlLmZpbmFsaXphdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKCB0aGlzLHsgdGhpc09iaklkOiB0aGlzLl8kJGlkIH0gKTtcclxuICAgICAgICB0aGlzLl8kJHNwcml0ZVR5cGUgPSBTcHJpdGUuU3ByaXRlVHlwZXMuU1BSSVRFO1xyXG4gICAgICAgIHRoaXMuXyQkdXBkYXRlQ29kZSA9IFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfTk9USElORztcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5pbnZhbGlkYXRlQ2FsbGJhY2sgPSB0aGlzLm9uSW52YWxpZGF0ZVRyYW5zZm9ybS5iaW5kKCB0aGlzICk7XHJcbiAgICAgICAgdGhpcy5fJCRsb2NhbEJvdW5kcyA9IG5ldyBSZWN0KCAwLDAsMCwwICk7XHJcbiAgICAgICAgdGhpcy5fJCRib3VuZHNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fJCRib3VuZHMgPSBuZXcgUmVjdCggMCwwLDAsMCApO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7UmVjdH0gKi9cclxuICAgICAgICB0aGlzLmN1c3RvbUJvdW5kcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyB0aGlzLmJvdW5kc0RpcnR5XHJcbiAgICAgICAgdGhpcy51c2VDdXN0b21Mb2NhbEJvdW5kcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMud29ybGRNYXRyaXggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jb2xvck92ZXJyaWRlID0gWzEsMSwxLDFdO1xyXG4gICAgICAgIHRoaXMuY29sb3JBZGQgPSBbMCwwLDAsMF07XHJcbiAgICAgICAgdGhpcy5jbGlwUmVnaW9uID0gbnVsbDtcclxuICAgICAgICAvKiogQHR5cGUge1Nwcml0ZVtdfSAqL1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fJCR2aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmN1c3RvbVByZXY7XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7QXNzZXR9ICovXHJcbiAgICAgICAgdGhpcy5hc3NldDtcclxuXHJcbiAgICAgICAgdGhpcy5jYWNoZUJpdG1hcE1vZGUgPSBTcHJpdGUuQ2FjaGVCaXRtYXBNb2Rlcy5OT19DQUNIRTtcclxuICAgICAgICB0aGlzLmNhY2hlQml0bWFwRHN0SWQgPSAwO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7QXNzZXR9ICovXHJcbiAgICAgICAgdGhpcy5jYWNoZUJpdG1hcEFzc2V0O1xyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gU3ByaXRlLkJsZW5kTW9kZXMuTk9STUFMO1xyXG4gICAgICAgIHRoaXMubW90aW9uQmx1ciA9IHRydWU7XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7U2hhZGVyfSAqL1xyXG4gICAgICAgIHRoaXMuc2hhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmaW5hbGl6ZUhhbmRsZXIoIG9iaiApIHtcclxuICAgICAgICAvLyBHQ+yXkCDsnZjtlbQg7IiY6rGw65CY7JeI7Jy866m0IOumtOumrOymiOulvCDrs7Trgrjri6QuXHJcbiAgICAgICAgYXBwbGljYXRpb24ucG9zdE1lc3NhZ2VUb1JlbmRlciggeyBtc2c6IFwiYWRkQ29tbWFuZFwiLGNsYXNzOiBcIlNwcml0ZVwiLCBtZXRob2Q6IFwicmVsZWFzZVwiLGFyZ3M6IFtvYmoudGhpc09iaklkXSB9ICk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJlbGVhc2UoKSB7XHJcbiAgICAgICAgLy8g6rCV7KCc66GcIOyCreygnFxyXG4gICAgICAgIGlmICggdGhpcy5hc3NldCAhPSBudWxsICkgIHtcclxuICAgICAgICAgICAgdGhpcy5hc3NldC5yZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOyKpO2UhOudvOydtO2KuCDsp4DsmrDrnbzripQg66mU7Iuc7KeAIOuztOuCtOyVvO2VqFxyXG4gICAgICAgIGZvciAoIGxldCBrZXkgaW4gdGhpcyApIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXBwbGljYXRpb24ucG9zdE1lc3NhZ2VUb1JlbmRlciggeyBtc2c6IFwiYWRkQ29tbWFuZFwiLGV4ZWN1dGlvblRpbWluZzogMixjbGFzczogXCJTcHJpdGVcIixtZXRob2Q6IFwicmVsZWFzZVwiLGFyZ3M6IFt0aGlzLl8kJGlkXSB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDsiqTtlITrnbzsnbTtirjsnZgg67O17IKs67O47J2EIOunjOuToOuLpFxyXG4gICAgICog7JaV7J2AIOuzteyCrOulvCDtlZjquLAg65WM66y47JeQIOyKpO2UhOudvOydtO2KuOulvCDsg4Hsho3tlZwg6rCc7LK07J24IOqyveyasCDqsJLsnbQg7JWE64uI6528IOywuOyhsOqwgCDrs7XsgqzrkJjripQg6rKD7JeQIOyjvOydmCDtlaAg6rKDXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Nwcml0ZX0gXHJcbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIC8qKiBAdHlwZSB7U3ByaXRlfSAqL1xyXG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHt9O1xyXG5cclxuICAgICAgICBPYmplY3QuYXNzaWduKCBuZXdPYmosdGhpcyApO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZiggbmV3T2JqLE9iamVjdC5nZXRQcm90b3R5cGVPZiggdGhpcyApICk7XHJcbiAgICAgICAgbmV3T2JqLl8kJGlkID0gU3ByaXRlLmxhc3RJZCsrO1xyXG4gICAgICAgIC8vIOqwnOyytOulvCDqs7XsnKDtlZjqsowg65CY6riwIOuVjOusuOyXkCBjbG9uZeydhCDri6Tsi5wg7ZW07KO87Ja07JW8IO2VnOuLpFxyXG4gICAgICAgIG5ld09iai50cmFuc2Zvcm0gPSBuZXdPYmoudHJhbnNmb3JtLmNsb25lKCk7XHJcbiAgICAgICAgbmV3T2JqLnRyYW5zZm9ybS5pbnZhbGlkYXRlQ2FsbGJhY2sgPSBuZXdPYmoub25JbnZhbGlkYXRlVHJhbnNmb3JtLmJpbmQoIG5ld09iaiApO1xyXG4gICAgICAgIG5ld09iai5fJCRsb2NhbEJvdW5kcyA9IG5ld09iai5fJCRsb2NhbEJvdW5kcy5jbG9uZSgpO1xyXG4gICAgICAgIG5ld09iai5fJCRib3VuZHMgPSBuZXdPYmouXyQkYm91bmRzLmNsb25lKCk7XHJcbiAgICAgICAgbmV3T2JqLndvcmxkTWF0cml4ID0gKCBuZXdPYmoud29ybGRNYXRyaXggIT0gbnVsbCApID8gbTQuY29weSggbmV3T2JqLndvcmxkTWF0cml4ICkgOiBudWxsO1xyXG4gICAgICAgIG5ld09iai5jb2xvck92ZXJyaWRlID0gWy4uLm5ld09iai5jb2xvck92ZXJyaWRlXTtcclxuICAgICAgICBuZXdPYmouY29sb3JBZGQgPSBbLi4ubmV3T2JqLmNvbG9yQWRkXTtcclxuICAgICAgICBuZXdPYmouY2xpcFJlZ2lvbiA9ICggbmV3T2JqLmNsaXBSZWdpb24gIT0gbnVsbCApID8gbmV3T2JqLmNsaXBSZWdpb24uY2xvbmUoKSA6IG51bGw7XHJcbiAgICAgICAgbmV3T2JqLmNoaWxkcmVuID0gWy4uLm5ld09iai5jaGlsZHJlbl07XHJcbiAgICAgICAgbmV3T2JqLmN1c3RvbVByZXYgPSAoIG5ld09iai5jdXN0b21QcmV2ICE9IG51bGwgKSA/ICggT2JqZWN0LmFzc2lnbigge30sbmV3T2JqLmN1c3RvbVByZXYgKSApIDogbnVsbDtcclxuICAgICAgICBuZXdPYmouXyQkdXBkYXRlQ29kZSB8PSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0VYVFJBO1xyXG4gICAgICAgIHJldHVybiBuZXdPYmo7XHJcbiAgICB9XHJcblxyXG4gICAgb25JbnZhbGlkYXRlVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIGxldCBzcHIgPSB0aGlzO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHNwci5fJCRib3VuZHNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwciA9IHNwci5wYXJlbnQ7XHJcbiAgICAgICAgfSB3aGlsZSAoIHNwciAhPSBudWxsICk7XHJcbiAgICAgICAgcmV0dXJuIHNwcjtcclxuICAgIH1cclxuXHJcbiAgICBnZXRQYXRoKCBkZXRhaWxJbmZvICkge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBbXTtcclxuICAgICAgICBsZXQgc3ByID0gdGhpcztcclxuXHJcbiAgICAgICAgd2hpbGUgKCBzcHIucGFyZW50ICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgIGlmICggZGV0YWlsSW5mbyApIHtcclxuICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdCggc3ByLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKCBzcHIgKSArIFwiOlwiICsgc3ByLmNvbnN0cnVjdG9yLm5hbWUgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdCggc3ByLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKCBzcHIgKSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNwciA9IHNwci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIGlmICggc3ByLmlzU3RhZ2UgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIi8vXCIgKyBwYXRoLmpvaW4oIFwiL1wiICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiPy9cIiArIHBhdGguam9pbiggXCIvXCIgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMge1BvaW50fSBcclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcclxuICAgICAqL1xyXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoIHRoaXMudHJhbnNmb3JtLngsdGhpcy50cmFuc2Zvcm0ueSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gdlxyXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxyXG4gICAgICovXHJcbiAgICBzZXQgcG9zaXRpb24oIHYgKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ueCA9IHYueDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS55ID0gdi55O1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBvc2l0aW9uKCB4LHkgKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ueCA9IHg7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ueSA9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldCB4KCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0ueDsgfVxyXG5cclxuICAgIHNldCB4KCB2ICkgeyB0aGlzLnRyYW5zZm9ybS54ID0gdjsgfVxyXG5cclxuICAgIGdldFgoKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS54OyB9XHJcblxyXG4gICAgc2V0WCggdiApIHsgdGhpcy50cmFuc2Zvcm0ueCA9IHY7IH0gXHJcblxyXG4gICAgZ2V0IHkoKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS55OyB9XHJcblxyXG4gICAgc2V0IHkoIHYgKSB7IHRoaXMudHJhbnNmb3JtLnkgPSB2OyB9XHJcblxyXG4gICAgZ2V0WSgpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnk7IH1cclxuXHJcbiAgICBzZXRZKCB2ICkgeyB0aGlzLnRyYW5zZm9ybS55ID0gdjsgfSBcclxuXHJcbiAgICAvKipcclxuICAgICAqIFt4LHldIO2Yle2DnOuhnCDrsJjtmZjtlZzri6QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1tudW1iZXIsbnVtYmVyXX1cclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcclxuICAgICAqL1xyXG4gICAgZ2V0IHh5KCkgeyByZXR1cm4gW3RoaXMueCwgdGhpcy55XTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogW3gseV0g7ZiV7YOc66Gc66eMIOuwm+uKlOuLpC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxQb2ludH0gdlxyXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxyXG4gICAgICovXHJcbiAgICBzZXQgeHkoIHYgKSB7XHJcbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCB2ICkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZbMF07XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHZbMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHRoaXMueCA9IHYueDtcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHRoaXMueSA9IHYueTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxyXG4gICAgICovXHJcbiAgICBnZXRSb3RhdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdlxyXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxyXG4gICAgICovXHJcbiAgICBzZXRSb3RhdGlvbiggdiApIHsgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gPSB2OyB9XHJcblxyXG4gICAgZ2V0IGFuY2hvclgoKSB7IFxyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5hbmNob3JYIC8gKCB0aGlzLmJvdW5kcy53aWR0aCB8fCAxICk7IFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMge1BvaW50fVxyXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxyXG4gICAgICovXHJcbiAgICBnZXQgYW5jaG9yUG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCggdGhpcy50cmFuc2Zvcm0uYW5jaG9yWCx0aGlzLnRyYW5zZm9ybS5hbmNob3JZICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSB2XHJcbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIHNldCBhbmNob3JQb3NpdGlvbiggdiApIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5hbmNob3JYID0gdi54O1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmFuY2hvclkgPSB2Lnk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGFuY2hvclBvc2l0aW9uWCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uYW5jaG9yWDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgYW5jaG9yUG9zaXRpb25YKCB2ICkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmFuY2hvclggPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBhbmNob3JQb3NpdGlvblkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmFuY2hvclk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGFuY2hvclBvc2l0aW9uWSggdiApIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5hbmNob3JZID0gdjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc2V0IGFuY2hvclgoIHYgKSB7IFxyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmFuY2hvclggPSB2ICogdGhpcy5ib3VuZHMud2lkdGg7IFxyXG4gICAgfVxyXG5cclxuICAgIGdldCBhbmNob3JZKCkgeyBcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uYW5jaG9yWSAvICggdGhpcy5ib3VuZHMuaGVpZ2h0IHx8IDEgKTsgXHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGFuY2hvclkoIHYgKSB7IFxyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmFuY2hvclkgPSB2ICogdGhpcy5ib3VuZHMuaGVpZ2h0OyBcclxuICAgIH1cclxuXHJcbiAgICBnZXRBbmNob3JQb2ludCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCB0aGlzLmFuY2hvclgsdGhpcy5hbmNob3JZICk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QW5jaG9yUG9pbnQoIGF4LGF5ICkge1xyXG4gICAgICAgIHRoaXMuYW5jaG9yWCA9IGF4O1xyXG4gICAgICAgIHRoaXMuYW5jaG9yWSA9IGF5O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBzY2FsZVgoKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5zY2FsZVg7IH1cclxuXHJcbiAgICBzZXQgc2NhbGVYKCB2ICkgeyB0aGlzLnRyYW5zZm9ybS5zY2FsZVggPSB2OyB9XHJcblxyXG4gICAgZ2V0U2NhbGVYKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2NhbGVYOyB9XHJcblxyXG4gICAgc2V0U2NhbGVYKCB2ICkgeyB0aGlzLnRyYW5zZm9ybS5zY2FsZVggPSB2OyB9XHJcbiAgICBcclxuXHJcbiAgICBnZXQgc2NhbGVZKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2NhbGVZOyB9XHJcblxyXG4gICAgc2V0IHNjYWxlWSggdiApIHsgdGhpcy50cmFuc2Zvcm0uc2NhbGVZID0gdjsgfVxyXG5cclxuICAgIGdldFNjYWxlWSgpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNjYWxlWTsgfVxyXG5cclxuICAgIHNldFNjYWxlWSggdiApIHsgdGhpcy50cmFuc2Zvcm0uc2NhbGVZID0gdjsgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGdldCBzY2FsZSgpIHsgcmV0dXJuIG5ldyBQb2ludCggdGhpcy50cmFuc2Zvcm0uc2NhbGVYLHRoaXMudHJhbnNmb3JtLnNjYWxlWSApOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxQb2ludH0gdlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtbbnVtYmVyLG51bWJlcl18RmxvYXQzMkFycmF5fG51bWJlcnxQb2ludH0gdlxyXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxyXG4gICAgICovXHJcbiAgICBzZXQgc2NhbGUoIHYgKSB7XHJcbiAgICAgICAgaWYgKCB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiApIHtcclxuICAgICAgICAgICAgLy8g7Iqk7LyA7J287J2AIOuPmeyLnOyXkCDrhKPsnYQg7IiYIOyeiOycvOuptCDtjrjrpqxcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2NhbGVYID0gdjtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2NhbGVZID0gdjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFBvaW50KCB2ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZVggPSBwLng7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlWSA9IHAueTtcclxuICAgICAgICB9XHJcbiAgICB9IFxyXG5cclxuICAgIGdldFNjYWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFNjYWxlKCB4LHkgKSB7XHJcbiAgICAgICAgdGhpcy5zY2FsZVggPSB4O1xyXG4gICAgICAgIHRoaXMuc2NhbGVZID0geSA9PSBudWxsID8geCA6IHk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgcm90YXRpb24oIHYgKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog7J6Q7IudIOyKpO2UhOudvOydtO2KuOulvCDsoJzsmbjtlZjqs6Ag7Iic7IiY7ZWY6rKMIOyekOq4sCDsnpDsi6DsnZgg7YGs6riwXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICBjb25zdCByID0gbmV3IFJlY3QoIHRoaXMuXyQkbG9jYWxCb3VuZHMgKTtcclxuXHJcbiAgICAgICAgci54IC09IHRoaXMudHJhbnNmb3JtLmFuY2hvclg7XHJcbiAgICAgICAgci55IC09IHRoaXMudHJhbnNmb3JtLmFuY2hvclk7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDsnpDsi6Dqs7wg7J6Q7IudIOuqqOuRkOulvCDtj6ztlajtlZwg6rK96rOEIOyCrOqwge2YleydhCDqtaztlZzri6QuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGdldCBib3VuZHMoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmN1c3RvbUJvdW5kcyApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tQm91bmRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoICF0aGlzLl8kJGJvdW5kc0RpcnR5ICkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fJCRib3VuZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOyXrOq4sCDripDrpqzri6QuIOuCmOykkeyXkCDstZzsoIHtmZQg7ZWgIOqyg1xyXG4gICAgICAgIC8vIO2VmOychCDqsJzssrTqsIAg7LaU6rCAL+yCreygnOuQmOqxsOuCmCDsnbTrj5ntlZjrqbQg64uk7IucIOqzhOyCsO2VmOuPhOuhnSDtlbTslbwg7ZWc64ukLlxyXG4gICAgICAgIC8vIOuLpOyLnCDqs4TsgrDsnbQg7ZWE7JqU7ZWcIOqyveyasCDsg4HsnITroZwg7KCE7YyM7Iuc7Lyc7KSY7JW87ZWgIOqygyDqsJnsnYxcclxuICAgICAgICBsZXQgbWF0RnJvbSA9IG00LmlkZW50aXR5KCk7XHJcbiAgICAgICAgbGV0IGJvdW5kcyA9IG5ldyBSZWN0KCk7XHJcbiAgICAgICAgbGV0IGJvdW5kc1BvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICBjb25zdCBzZWFyY2ggPSAoIHNwcixtYXQgKT0+e1xyXG4gICAgICAgICAgICBpZiAoICFzcHIuXyQkYm91bmRzRGlydHkgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDsnpDsi50g7Iqk7ZSE65287J207Yq46rCAIOuwlOuAkOqyjCDsl4bsnLzrqbQg67O06rSA65CcIOygkOuTpOydhCDsgqzsmqntlZzri6QuXHJcbiAgICAgICAgICAgICAgICBib3VuZHNQb2ludHMucHVzaCggLi4uIHNwci5fJCRib3VuZHNQb2ludHMgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICggc3ByLnNwcml0ZVR5cGUgIT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbeDEseTEseDIseTIseDMseTMseDQseTRdID0gc3ByLmxvY2FsQm91bmRzLmdldENvcm5lclBvaW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4LHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFt4LHldID0gbTQudHJhbnNmb3JtUG9pbnQoIG1hdCxbeDEseTEsMF0gKTtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHNQb2ludHMucHVzaCggeCx5ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgW3gseV0gPSBtNC50cmFuc2Zvcm1Qb2ludCggbWF0LFt4Mix5MiwwXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kc1BvaW50cy5wdXNoKCB4LHkgKTtcclxuICAgICAgICAgICAgICAgICAgICBbeCx5XSA9IG00LnRyYW5zZm9ybVBvaW50KCBtYXQsW3gzLHkzLDBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzUG9pbnRzLnB1c2goIHgseSApO1xyXG4gICAgICAgICAgICAgICAgICAgIFt4LHldID0gbTQudHJhbnNmb3JtUG9pbnQoIG1hdCxbeDQseTQsMF0gKTtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHNQb2ludHMucHVzaCggeCx5ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBsZXQgY2hpbGQgb2Ygc3ByLmNoaWxkcmVuICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggY2hpbGQudmlzaWJsZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoKCBjaGlsZCxtNC5tdWx0aXBseSggbWF0LGNoaWxkLnRyYW5zZm9ybS5tYXRyaXggKSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNlYXJjaCggdGhpcyxtYXRGcm9tICk7XHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgYm91bmRzUG9pbnRzLmxlbmd0aDsgaSArPSAyICkge1xyXG4gICAgICAgICAgICBib3VuZHMuZXh0ZW5kUG9pbnQoIGJvdW5kc1BvaW50c1tpXSxib3VuZHNQb2ludHNbaSArIDFdICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl8kJGJvdW5kcyA9IGJvdW5kcztcclxuICAgICAgICB0aGlzLl8kJGJvdW5kc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fJCRib3VuZHNQb2ludHMgPSBib3VuZHNQb2ludHM7XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kczsgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBnZXRCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUxvY2FsQm91bmRzKCkge1xyXG5cclxuICAgIH0gICAgXHJcblxyXG4gICAgZ2V0IHZpc2libGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuXyQkdmlzaWJsZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgdmlzaWJsZSggdiApIHtcclxuICAgICAgICBpZiAoICF0aGlzLl8kJHZpc2libGUgJiYgdiApIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4oIFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfQ0xFQVJfUFJFViApOyBcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fJCR2aXNpYmxlID0gdjtcclxuICAgIH1cclxuXHJcbiAgICBpc1Zpc2libGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRWaXNpYmxlKCB2ICkge1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHY7XHJcbiAgICB9XHJcblxyXG4gICAgaXNWaXNpYmxlRGVlcGx5KCkge1xyXG4gICAgICAgIGxldCBzcHI7XHJcblxyXG4gICAgICAgIGZvciAoIHNwciA9IHRoaXM7IHNwciAhPSBudWxsICYmICFzcHIuaXNTdGFnZTsgc3ByID0gc3ByLnBhcmVudCApIHtcclxuICAgICAgICAgICAgaWYgKCAhc3ByLnZpc2libGUgKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc3ByID09IG51bGwgKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCByZWRNdWx0aXBsaWVyKCkgeyByZXR1cm4gdGhpcy5jb2xvck92ZXJyaWRlWzBdOyB9XHJcblxyXG4gICAgc2V0IHJlZE11bHRpcGxpZXIoIHYgKSB7IHRoaXMuY29sb3JPdmVycmlkZVswXSA9IHY7IH1cclxuXHJcbiAgICBnZXQgZ3JlZW5NdWx0aXBsaWVyKCkgeyByZXR1cm4gdGhpcy5jb2xvck92ZXJyaWRlWzFdOyB9XHJcblxyXG4gICAgc2V0IGdyZWVuTXVsdGlwbGllciggdiApIHsgdGhpcy5jb2xvck92ZXJyaWRlWzFdID0gdjsgfVxyXG5cclxuICAgIGdldCBibHVlTXVsdGlwbGllcigpIHsgcmV0dXJuIHRoaXMuY29sb3JPdmVycmlkZVsyXTsgfVxyXG5cclxuICAgIHNldCBibHVlTXVsdGlwbGllciggdiApIHsgdGhpcy5jb2xvck92ZXJyaWRlWzJdID0gdjsgfVxyXG5cclxuICAgIGdldCBhbHBoYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvck92ZXJyaWRlWzNdO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBhbHBoYSggdiApIHtcclxuICAgICAgICB0aGlzLmNvbG9yT3ZlcnJpZGVbM10gPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIHNldEFscGhhKCB2ICkge1xyXG4gICAgICAgIHRoaXMuY29sb3JPdmVycmlkZVszXSA9IHY7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0QWxwaGEoIHYgKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JPdmVycmlkZVszXTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDb2xvck11bHRpcGxpZXIoIHIsZyxiLGEgKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvck92ZXJyaWRlWzBdID0gcjtcclxuICAgICAgICB0aGlzLmNvbG9yT3ZlcnJpZGVbMV0gPSBnO1xyXG4gICAgICAgIHRoaXMuY29sb3JPdmVycmlkZVsyXSA9IGI7XHJcbiAgICAgICAgaWYgKCBhICE9IG51bGwgKSB0aGlzLmNvbG9yT3ZlcnJpZGVbM10gPSBhOyBcclxuICAgIH1cclxuXHJcbiAgICBzZXRPdmVycmlkZUNvbG9yKCBjLGEgKSB7XHJcbiAgICAgICAgY29uc3QgYXJyID0gVXRpbHMuaGV4MnJnYmEoIGMsYSApO1xyXG5cclxuICAgICAgICB0aGlzLmNvbG9yT3ZlcnJpZGVbMF0gPSBhcnJbMF07XHJcbiAgICAgICAgdGhpcy5jb2xvck92ZXJyaWRlWzFdID0gYXJyWzFdO1xyXG4gICAgICAgIHRoaXMuY29sb3JPdmVycmlkZVsyXSA9IGFyclsyXTtcclxuICAgICAgICBpZiAoIGEgIT0gbnVsbCApIHRoaXMuY29sb3JPdmVycmlkZVszXSA9IGFyclszXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzLndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB3aWR0aCggdiApIHtcclxuICAgICAgICB0aGlzLmN1c3RvbUJvdW5kcyA9IHRoaXMuY3VzdG9tQm91bmRzIHx8IHRoaXMuYm91bmRzO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tQm91bmRzLndpZHRoID0gdjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kcy5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGhlaWdodCggdiApIHtcclxuICAgICAgICB0aGlzLmN1c3RvbUJvdW5kcyA9IHRoaXMuY3VzdG9tQm91bmRzIHx8IHRoaXMuYm91bmRzO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tQm91bmRzLmhlaWdodCA9IHY7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q3VzdG9tQm91bmRzKCB4LHksdyxoICkge1xyXG4gICAgICAgIHRoaXMuY3VzdG9tQm91bmRzLnggPSB4O1xyXG4gICAgICAgIHRoaXMuY3VzdG9tQm91bmRzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMuY3VzdG9tQm91bmRzLndpZHRoID0gdztcclxuICAgICAgICB0aGlzLmN1c3RvbUJvdW5kcy5oZWlnaHQgPSBoO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGxvY2FsVG9HbG9iYWwoIHgseSApIHtcclxuICAgICAgICBsZXQgbWF0QXJyID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIGxldCBzcHIgPSB0aGlzOyA7IHNwciA9IHNwci5wYXJlbnQgKSB7XHJcbiAgICAgICAgICAgIG1hdEFyci51bnNoaWZ0KCBzcHIudHJhbnNmb3JtLm1hdHJpeCApO1xyXG4gICAgICAgICAgICBpZiAoIHNwci5wYXJlbnQgPT0gbnVsbCApIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWF0ID0gbTQuaWRlbnRpdHkoKTtcclxuXHJcbiAgICAgICAgbWF0QXJyLmZvckVhY2goIHY9PntcclxuICAgICAgICAgICAgbTQubXVsdGlwbHkoIG1hdCx2LG1hdCApO1xyXG4gICAgICAgIH0gKTtcclxuICAgICAgICBsZXQgcCA9IG00LnRyYW5zZm9ybVBvaW50KCBtYXQsW3gseSwwXSApO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCBwWzBdLHBbMV0gKTtcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxUb0xvY2FsKCB4LHkgKSB7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgaWYgKCB0aGlzLnBhcmVudCA9PSBudWxsIHx8IHRoaXMuaXNTdGFnZSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCggeCx5ICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOyngOuCnCDtlITroIjsnoTsl5Ag6rWs7ZW064aT7J2AIHdvcmxkTWF0cml466W8IOyCrOyaqe2VmOuptCDruaDrpbTqsowg7ZWgIOyImCDsnojri6QuXHJcbiAgICAgICAgLy8g7KeA6riI7J2AIOq3uOuDpSDrkZTri6RcclxuICAgICAgICBsZXQgbWF0QXJyID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIGxldCBzcHIgPSB0aGlzOyA7IHNwciA9IHNwci5wYXJlbnQgKSB7XHJcbiAgICAgICAgICAgIG1hdEFyci5wdXNoKCBtNC5pbnZlcnNlKCBzcHIudHJhbnNmb3JtLm1hdHJpeCApICk7XHJcbiAgICAgICAgICAgIGlmICggc3ByLnBhcmVudCA9PSBudWxsICkgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtYXQgPSBtNC5pZGVudGl0eSgpO1xyXG5cclxuICAgICAgICBtYXRBcnIuZm9yRWFjaCggdj0+e1xyXG4gICAgICAgICAgICBtNC5tdWx0aXBseSggbWF0LHYsbWF0ICk7XHJcbiAgICAgICAgfSApO1xyXG4gICAgICAgIGxldCBwID0gbTQudHJhbnNmb3JtUG9pbnQoIG1hdCxbeCx5LDBdICk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoIHBbMF0scFsxXSApO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEJsZW5kTW9kZSggdiApIHtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IHY7ICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIGFkZENoaWxkICYgcmVtb3ZlQ2hpbGRcclxuXHJcbiAgICBfdXBkYXRlQ2hpbGRyZW4oIHVwZGF0ZUNvZGVUb09OICkge1xyXG4gICAgICAgIGZvciAoIGNvbnN0IHMgb2YgdGhpcy5zZWFyY2hDaGlsZHJlbigpICkge1xyXG4gICAgICAgICAgICBzLnVwZGF0ZUNvZGUgfD0gdXBkYXRlQ29kZVRvT047XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Nwcml0ZX0gc3ByXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGlcclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcclxuICAgICAqL1xyXG4gICAgYWRkQ2hpbGRBdCggc3ByLCBpICkge1xyXG4gICAgICAgIGlmICggaSA9PSBudWxsICkge1xyXG4gICAgICAgICAgICBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBzcHIgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoIGksMCwgc3ByICk7XHJcbiAgICAgICAgaWYgKCBvbGRJbmRleCA+PSAwICkge1xyXG4gICAgICAgICAgICAvLyDsm5Drnpgg7J6I642YIOqyveyasCDsnITsuZgg7J2064+ZXHJcbiAgICAgICAgICAgIGlmICggb2xkSW5kZXggPiBpICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoIG9sZEluZGV4ICsgMSwxICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9sZEluZGV4IDwgaSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBvbGRJbmRleCwxICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3ByLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCB0aGlzLmlzT25TdGFnZSgpICkge1xyXG4gICAgICAgICAgICBzcHIuX3VwZGF0ZUNoaWxkcmVuKCBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0NMRUFSX1BSRVYgKTsgXHJcbiAgICAgICAgICAgIHNwci5kaXNwYXRjaEV2ZW50V2l0aENoaWxkcmVuKCBuZXcgRXZlbnQoIEV2ZW50LkFEREVEX1RPX1NUQUdFICkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vbkludmFsaWRhdGVUcmFuc2Zvcm0oKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Li4uU3ByaXRlfSBzcHJzXHJcbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGFkZENoaWxkKCAuLi5zcHJzICkge1xyXG4gICAgICAgIGZvciAoIGNvbnN0IHNwciBvZiBzcHJzICkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkQXQoIHNwciApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcmVtb3ZlQ2hpbGRBdCggaSApIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcblxyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoIGksMSApO1xyXG4gICAgICAgIGlmICggdGhpcy5pc09uU3RhZ2UoKSApIHtcclxuICAgICAgICAgICAgY2hpbGQuZGlzcGF0Y2hFdmVudFdpdGhDaGlsZHJlbiggbmV3IEV2ZW50KCBFdmVudC5SRU1PVkVEX0ZST01fU1RBR0UgKSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uSW52YWxpZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Nwcml0ZX0gc3ByXHJcbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNoaWxkKCBzcHIgKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBzcHIgKTtcclxuXHJcbiAgICAgICAgaWYgKCBpbmRleCAhPSAtMSApIHRoaXMucmVtb3ZlQ2hpbGRBdCggaW5kZXggKTtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVGcm9tUGFyZW50KCkge1xyXG4gICAgICAgIGlmICggdGhpcy5wYXJlbnQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKCB0aGlzICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgZm9yICggbGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkQXQoIGkgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q2hpbGRJbmRleCggc3ByICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIHNwciApO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENoaWxkQXQoIGkgKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgZ2V0U3RhZ2UoKSB7XHJcbiAgICAgICAgbGV0IHNwcjtcclxuXHJcbiAgICAgICAgZm9yICggc3ByID0gdGhpczsgc3ByICE9IG51bGwgJiYgIXNwci5pc1N0YWdlOyBzcHIgPSBzcHIucGFyZW50ICk7XHJcbiAgICAgICAgcmV0dXJuIHNwcjtcclxuICAgIH1cclxuXHJcbiAgICBpc09uU3RhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhZ2UoKSAhPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fHN0cmluZ30gZXZlbnRPck5hbWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gZXh0ZW5kZWRWYWx1ZXNcclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcclxuICAgICAqL1xyXG4gICAgZGlzcGF0Y2hFdmVudFdpdGhDaGlsZHJlbiggZXZlbnRPck5hbWUsZXh0ZW5kZWRWYWx1ZXMgKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50O1xyXG5cclxuICAgICAgICBpZiAoIHR5cGVvZiBldmVudE9yTmFtZSA9PSBcInN0cmluZ1wiICkge1xyXG4gICAgICAgICAgICBldmVudCA9IG5ldyBFdmVudCggZXZlbnRPck5hbWUgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudCA9IGV2ZW50T3JOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuYXNzaWduKCBldmVudCxleHRlbmRlZFZhbHVlcyApO1xyXG4gICAgICAgIC8vIGNvbnN0IGlucHV0T25seSA9IEV2ZW50LmlzSW5wdXRFdmVudCggZXZlbnQubmFtZSApO1xyXG5cclxuICAgICAgICBmb3IgKCBjb25zdCBzcHIgb2YgdGhpcy5zZWFyY2hDaGlsZHJlbiggdHJ1ZSApICkge1xyXG4gICAgICAgICAgICBpZiAoIGV2ZW50LnN0b3BwZWQgKSByZXR1cm47XHJcbiAgICAgICAgICAgIHNwci5kaXNwYXRjaEV2ZW50KCBldmVudCApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYm90dG9tVXA9ZmFsc2VdXHJcbiAgICAgKi9cclxuICAgICpzZWFyY2hDaGlsZHJlbiggYm90dG9tVXAgKSB7XHJcbiAgICAgICAgeWllbGQqIFNwcml0ZS5zZWFyY2hDaGlsZHJlbiggdGhpcywgYm90dG9tVXAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtTcHJpdGV9IHN0YXJ0T2JqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21VcD1mYWxzZV1cclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljICpzZWFyY2hDaGlsZHJlbiggc3RhcnRPYmosIGJvdHRvbVVwID0gZmFsc2UgKSB7XHJcbiAgICAgICAgY29uc3Qgc2VhcmNoUmVjdXJzaXZlID0gZnVuY3Rpb24qICggY3VyICkge1xyXG4gICAgICAgICAgICBpZiAoIGJvdHRvbVVwICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBjdXIuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBsZXQgaSA9IGN1ci5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjdXIuY2hpbGRyZW5baV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNoaWxkICkgeWllbGQqIHNlYXJjaFJlY3Vyc2l2ZSggY2hpbGQgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBjdXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBjdXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGN1ci5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGN1ci5jaGlsZHJlbi5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjdXIuY2hpbGRyZW5baV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNoaWxkICkgeWllbGQqIHNlYXJjaFJlY3Vyc2l2ZSggY2hpbGQgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB5aWVsZCogc2VhcmNoUmVjdXJzaXZlKCBzdGFydE9iaiApO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRDaGlsZEJ5SWQoIGlkICkge1xyXG4gICAgICAgIGZvciAoIGxldCBzcHIgb2YgdGhpcy5zZWFyY2hDaGlsZHJlbiggKSApIHtcclxuICAgICAgICAgICAgaWYgKCBzcHIuaWQgPT0gaWQgKSByZXR1cm4gc3ByO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0TnVtQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7U3ByaXRlfVxyXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxyXG4gICAgICovXHJcbiAgICBnZXRQYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Nwcml0ZX0gc3ByXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoIHNwciApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5pbmNsdWRlcyggc3ByICk7XHJcbiAgICB9XHJcblxyXG4gICAgaGl0VGVzdFBvaW50KCB4LCB5ICkge1xyXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmdsb2JhbFRvTG9jYWwoIHgseSApO1xyXG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmJvdW5kcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlY3QuY29udGFpbnMoIHAueCxwLnkgKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDbGlwKCB4LHksd2lkdGgsaGVpZ2h0ICkge1xyXG4gICAgICAgIHRoaXMuY2xpcFJlZ2lvbiA9IG5ldyBSZWN0KCB4LHksd2lkdGgsaGVpZ2h0ICk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2hhZGVyKCBzaGFkZXIgKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2hhZGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlcjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIHNldEludGVyYWN0aXZlKCkgXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQGNhbGxiYWNrIEFuaW1hdGlvbkhhbmRsZXJcclxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLHk6bnVtYmVyLGJ1dHRvbjoqLHRhcmdldDpTcHJpdGV9fSBldmVudFxyXG4gICAgICogQHBhcmFtIHt7ZG93blBvaW50ZXJQb3NpdGlvbjpQb2ludCxkb3duVGhpc1Bvc2l0aW9uOlBvaW50LGRvd25PZmZzZXQ6UG9pbnQsZG93bkJ1dHRvbjoqLHB1c2hlZDpib29sZWFuLGNsaWNrQ2FuY2xlZDpib29sZWFuLHN0YXRlOnN0cmluZyxtb3ZlRGVsdGFQb3NpdGlvbjpQb2ludCxtb3ZlVGhpc1Bvc2l0aW9uOlBvaW50fX0gaW5mb1xyXG4gICAgICogQHJldHVybiB7VHdlZW59XHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogQGNhbGxiYWNrIEludGVyYWN0aXZlSGFuZGxlclxyXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIseTpudW1iZXIsYnV0dG9uOiosdGFyZ2V0OlNwcml0ZX19IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge3tkb3duUG9pbnRlclBvc2l0aW9uOlBvaW50LGRvd25UaGlzUG9zaXRpb246UG9pbnQsZG93bk9mZnNldDpQb2ludCxkb3duQnV0dG9uOioscHVzaGVkOmJvb2xlYW4sY2xpY2tDYW5jbGVkOmJvb2xlYW4sc3RhdGU6c3RyaW5nLG1vdmVEZWx0YVBvc2l0aW9uOlBvaW50LG1vdmVUaGlzUG9zaXRpb246UG9pbnR9fSBpbmZvXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbkhhbmRsZXI9fSBvcHRpb25zLnByZXNzQW5pbWF0aW9uIC0g64iM65+s7KeA64qUIOyVoOuLiOuplOydtOyFmOydhCDti4DquLAuIHR3ZWVu66W8IOumrO2EtO2VtOyVvO2VnOuLpC5cclxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uSGFuZGxlcj19IG9wdGlvbnMucmVsZWFzZUFuaW1hdGlvbiAtIOyYrOudvOyYpOuKlCDslaDri4jrqZTsnbTshZjsnYQg7YuA6riwLiB0d2VlbuydhCDrpqzthLTtlbTslbztlZzri6QuXHJcbiAgICAgKiBAcGFyYW0ge0ludGVyYWN0aXZlSGFuZGxlcj19IG9wdGlvbnMuZG93biAtIOyYgeyXreyViOyXkOyEnCBkb3du7ZWcIOqyveyasFxyXG4gICAgICogQHBhcmFtIHtJbnRlcmFjdGl2ZUhhbmRsZXI9fSBvcHRpb25zLm1vdmUgLSBkb3duIO2bhCBtb3Zl7ZWgIOqyveyasFxyXG4gICAgICogQHBhcmFtIHtJbnRlcmFjdGl2ZUhhbmRsZXI9fSBvcHRpb25zLnVwIC0gZG93biDtm4QgdXDtlaAg6rK97JqwXHJcbiAgICAgKiBAcGFyYW0ge0ludGVyYWN0aXZlSGFuZGxlcj19IG9wdGlvbnMuY2xpY2sgLSBkb3du7JeQ7IScIOupgOumrCDrlqjslrTsp4Dsp4Ag7JWK7J2AIOychOy5mOyXkOyEnCB1cFxyXG4gICAgICogQHBhcmFtIHtJbnRlcmFjdGl2ZUhhbmRsZXI9fSBvcHRpb25zLnByZXNzIC0gZG93biDtm4QgdXDtlaAg65WMIOyYgeyXrSDslYhcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbnMucHJldmVudFJlbGVhc2UgLSBjbGlja+ydtOuCmCBwcmVzc+yXkOyEnCByZWxlYXNlQW5pbWF0aW9u7ZWY7KeAIOyViuuPhOuhnVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0aW9ucy5kaXNhYmxlQmFzaWNBbmltYXRpb24gLSDquLDrs7gg7JWg64uI66mU7J207IWYIOuBhOq4sFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLnByZXNzT2Zmc2V0WSAtIOq4sOuzuCBwcmVzc0FuaW1hdGlvbuyXkOyEnCDslrzrp4jrgpgg7JWE656Y66GcIOuCtOugpOqwgOuKlOqwgFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmNsaWNrUmFkaXVzIC0gY2xpY2vsnLzroZwg7YyQ7KCV7ZWY64qUIOuwmOyngOumhFxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0aW9ucy5kcmFnWCAtIOqwgOuhnOy2leycvOuhnCDrk5zrnpjqt7hcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbnMuZHJhZ1kgLSDshLjroZzstpXsnLzroZwg65Oc656Y6re4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMuZHJhZ1JlbGVhc2VEaXN0YW5jZSAtIOydtCDqsbDrpqzrpbwg67KX7Ja064KY66m0IGRyYWfqsIAg7Leo7IaM65Cc64ukLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0aW9ucy5hbGxvd0RyYWdPdXRzaWRlIC0g7ZmU66m0IOuwluycvOuhnCDrqrsg64GM6rOgIOuCmOqwgOuPhOuhnSDtlZzri6RcclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcclxuICAgICAqL1xyXG4gICAgc2V0SW50ZXJhY3RpdmUoIG9wdGlvbnMgPSBudWxsICkge1xyXG4gICAgICAgIHRoaXMuX19pbnRlcmFjdGl2ZSA9IHRoaXMuX19pbnRlcmFjdGl2ZSB8fCB7fTtcclxuICAgICAgICBjb25zdCBfaSA9IHRoaXMuX19pbnRlcmFjdGl2ZTtcclxuICAgICAgICBjb25zdCBjbGlja0NhbmNlbERpc3RhbmNlID0gKCBvcHRpb25zICYmIG9wdGlvbnMuY2xpY2tSYWRpdXMgIT0gbnVsbCApID8gb3B0aW9ucy5jbGlja1JhZGl1cyA6IDEwO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcmVzc09mZnNldFkgPSAzOy8vIOyLpOygnCDtlL3shYDquLDspIDsnLzroZwg7ZW07JW87ZWoXHJcbiAgICAgICAgY29uc3QgcG9pbnRlckRvd24gPSAoIGUgKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5oaXRUZXN0UG9pbnQoIGUueCwgZS55ICkgKSB7XHJcbiAgICAgICAgICAgICAgICBfaS5kb3duUG9pbnRlclBvc2l0aW9uID0gbmV3IFBvaW50KCBlLngsIGUueSApO1xyXG4gICAgICAgICAgICAgICAgX2kuZG93blRoaXNQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgX2kuZG93bk9mZnNldCA9IG5ldyBQb2ludCggZS54IC0gdGhpcy54LCBlLnkgLSB0aGlzLnkgKTtcclxuICAgICAgICAgICAgICAgIF9pLmRvd25CdXR0b24gPSBlLmJ1dHRvbjtcclxuICAgICAgICAgICAgICAgIF9pLnB1c2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfaS5jbGlja0NhbmNlbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfaS5zdGF0ZSA9IFwiZG93blwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5kaXNhYmxlQmFzaWNBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBfaS50d2VlbiApIF9pLnR3ZWVuLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfaS50d2VlbiA9IHRoaXMubW92ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2kuZG93blRoaXNQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaS5kb3duVGhpc1Bvc2l0aW9uLnkgKyAoIG9wdGlvbnMucHJlc3NPZmZzZXRZICE9IG51bGwgPyBvcHRpb25zLnByZXNzT2Zmc2V0WSA6IGRlZmF1bHRQcmVzc09mZnNldFkgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMzAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmcub3V0QmFjayApO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBvcHRpb25zLnByZXNzQW5pbWF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggX2kudHdlZW4gKSBfaS50d2Vlbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2kudHdlZW4gPSBvcHRpb25zLnByZXNzQW5pbWF0aW9uLmNhbGwoIHRoaXMsIGUsIF9pICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5kb3duICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kb3duLmNhbGwoIHRoaXMsIGUsIF9pICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHBvaW50ZXJNb3ZlID0gKCBlICkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIF9pLnN0YXRlID09IFwiZG93blwiIHx8IF9pLnN0YXRlID09IFwibW92ZVwiICkge1xyXG4gICAgICAgICAgICAgICAgX2kuc3RhdGUgPSBcIm1vdmVcIjtcclxuICAgICAgICAgICAgICAgIF9pLm1vdmVEZWx0YVBvc2l0aW9uID0gbmV3IFBvaW50KCBlLnggLSBfaS5kb3duUG9pbnRlclBvc2l0aW9uLnggLCBlLnkgLSBfaS5kb3duUG9pbnRlclBvc2l0aW9uLnkgKTtcclxuICAgICAgICAgICAgICAgIF9pLm1vdmVUaGlzUG9zaXRpb24gPSBuZXcgUG9pbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kcmFnWCA/IF9pLmRvd25UaGlzUG9zaXRpb24ueCArIF9pLm1vdmVEZWx0YVBvc2l0aW9uLnggOiBfaS5kb3duVGhpc1Bvc2l0aW9uLngsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kcmFnWSA/IF9pLmRvd25UaGlzUG9zaXRpb24ueSArIF9pLm1vdmVEZWx0YVBvc2l0aW9uLnkgOiBfaS5kb3duVGhpc1Bvc2l0aW9uLnksXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5hbGxvd0RyYWdPdXRzaWRlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9pLm1vdmVUaGlzUG9zaXRpb24ueCA9IFV0aWxzLmNsYW1wKCBfaS5tb3ZlVGhpc1Bvc2l0aW9uLngsIGFwcGxpY2F0aW9uLmxvZ2ljYWxSZW5kZXJCb3VuZHMubGVmdCAtIF9pLmRvd25PZmZzZXQueCwgYXBwbGljYXRpb24ubG9naWNhbFJlbmRlckJvdW5kcy5yaWdodCAtIF9pLmRvd25PZmZzZXQueCApO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pLm1vdmVUaGlzUG9zaXRpb24ueSA9IFV0aWxzLmNsYW1wKCBfaS5tb3ZlVGhpc1Bvc2l0aW9uLnksIGFwcGxpY2F0aW9uLmxvZ2ljYWxSZW5kZXJCb3VuZHMudG9wIC0gX2kuZG93bk9mZnNldC55LCBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLmJvdHRvbSAtIF9pLmRvd25PZmZzZXQueSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmRyYWdYIHx8IG9wdGlvbnMuZHJhZ1kgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBfaS50d2VlbiApIF9pLnR3ZWVuLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmRyYWdYICkgdGhpcy54ID0gX2kubW92ZVRoaXNQb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLmRyYWdZICkgdGhpcy55ID0gX2kubW92ZVRoaXNQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgaWYgKCBfaS5jbGlja0NhbmNlbGVkID09IGZhbHNlICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggTWF0aC5zcXJ0KCBfaS5tb3ZlRGVsdGFQb3NpdGlvbi54ICoqIDIgKyBfaS5tb3ZlRGVsdGFQb3NpdGlvbi55ICoqIDIgKSA+IGNsaWNrQ2FuY2VsRGlzdGFuY2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pLmNsaWNrQ2FuY2VsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMubW92ZSAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubW92ZS5jYWxsKCB0aGlzLGUsIF9pICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIF9pLnB1c2hlZCAmJiAhdGhpcy5oaXRUZXN0UG9pbnQoIGUueCwgZS55ICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2kucHVzaGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5kaXNhYmxlQmFzaWNBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggX2kudHdlZW4gKSBfaS50d2Vlbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pLnR3ZWVuID0gdGhpcy5tb3ZlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kubW92ZVRoaXNQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kubW92ZVRoaXNQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMjAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nLm91dEN1YmljICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggb3B0aW9ucy5yZWxlYXNlQW5pbWF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIF9pLnR3ZWVuICkgX2kudHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaS50d2VlbiA9IG9wdGlvbnMucmVsZWFzZUFuaW1hdGlvbi5jYWxsKCB0aGlzLCBlLCBfaSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICFfaS5wdXNoZWQgJiYgdGhpcy5oaXRUZXN0UG9pbnQoIGUueCwgZS55ICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2kucHVzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFvcHRpb25zLmRpc2FibGVCYXNpY0FuaW1hdGlvbiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBfaS50d2VlbiApIF9pLnR3ZWVuLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2kudHdlZW4gPSB0aGlzLm1vdmUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaS5tb3ZlVGhpc1Bvc2l0aW9uLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaS5tb3ZlVGhpc1Bvc2l0aW9uLnkgKyAoIG9wdGlvbnMucHJlc3NPZmZzZXRZICE9IG51bGwgPyBvcHRpb25zLnByZXNzT2Zmc2V0WSA6IGRlZmF1bHRQcmVzc09mZnNldFkgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZy5vdXRDdWJpYyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9wdGlvbnMucHJlc3NBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggX2kudHdlZW4gKSBfaS50d2Vlbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pLnR3ZWVuID0gb3B0aW9ucy5wcmVzc0FuaW1hdGlvbi5jYWxsKCB0aGlzLCBlLCBfaSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcG9pbnRlclVwID0gKCBlICkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIF9pLnN0YXRlID09IFwiZG93blwiIHx8IF9pLnN0YXRlID09IFwibW92ZVwiICkge1xyXG4gICAgICAgICAgICAgICAgX2kuc3RhdGUgPSBcInVwXCI7XHJcbiAgICAgICAgICAgICAgICBfaS5tb3ZlRGVsdGFQb3NpdGlvbiA9IG5ldyBQb2ludCggZS54IC0gX2kuZG93blBvaW50ZXJQb3NpdGlvbi54ICwgZS55IC0gX2kuZG93blBvaW50ZXJQb3NpdGlvbi55ICk7XHJcbiAgICAgICAgICAgICAgICBfaS5tb3ZlVGhpc1Bvc2l0aW9uID0gbmV3IFBvaW50KFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZHJhZ1ggPyBfaS5kb3duVGhpc1Bvc2l0aW9uLnggKyBfaS5tb3ZlRGVsdGFQb3NpdGlvbi54IDogX2kuZG93blRoaXNQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZHJhZ1kgPyBfaS5kb3duVGhpc1Bvc2l0aW9uLnkgKyBfaS5tb3ZlRGVsdGFQb3NpdGlvbi55IDogX2kuZG93blRoaXNQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5kcmFnWCApIHRoaXMueCA9IF9pLm1vdmVUaGlzUG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy5kcmFnWSApIHRoaXMueSA9IF9pLm1vdmVUaGlzUG9zaXRpb24ueTtcclxuICAgICAgICAgICAgICAgIGlmICggIW9wdGlvbnMuYWxsb3dEcmFnT3V0c2lkZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBfaS5tb3ZlVGhpc1Bvc2l0aW9uLnggPSBVdGlscy5jbGFtcCggX2kubW92ZVRoaXNQb3NpdGlvbi54LCBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLmxlZnQgLSBfaS5kb3duT2Zmc2V0LngsIGFwcGxpY2F0aW9uLmxvZ2ljYWxSZW5kZXJCb3VuZHMucmlnaHQgLSBfaS5kb3duT2Zmc2V0LnggKTtcclxuICAgICAgICAgICAgICAgICAgICBfaS5tb3ZlVGhpc1Bvc2l0aW9uLnkgPSBVdGlscy5jbGFtcCggX2kubW92ZVRoaXNQb3NpdGlvbi55LCBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLnRvcCAtIF9pLmRvd25PZmZzZXQueSwgYXBwbGljYXRpb24ubG9naWNhbFJlbmRlckJvdW5kcy5ib3R0b20gLSBfaS5kb3duT2Zmc2V0LnkgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggX2kuY2xpY2tDYW5jZWxlZCA9PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIE1hdGguc3FydCggX2kubW92ZURlbHRhUG9zaXRpb24ueCAqKiAyICsgX2kubW92ZURlbHRhUG9zaXRpb24ueSAqKiAyICkgPCBjbGlja0NhbmNlbERpc3RhbmNlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMuY2xpY2sgIT0gbnVsbCApIG9wdGlvbnMuY2xpY2suY2FsbCggdGhpcywgZSwgX2kgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuaGl0VGVzdFBvaW50KCBlLngsIGUueSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9pLnB1c2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLnByZXNzICE9IG51bGwgKSBvcHRpb25zLnByZXNzLmNhbGwoIHRoaXMsZSwgX2kgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggIW9wdGlvbnMucHJldmVudFJlbGVhc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5kaXNhYmxlQmFzaWNBbmltYXRpb24gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggX2kudHdlZW4gKSBfaS50d2Vlbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pLnR3ZWVuID0gdGhpcy5tb3ZlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kubW92ZVRoaXNQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kubW92ZVRoaXNQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMzAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nLm91dEJvdW5jZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG9wdGlvbnMucmVsZWFzZUFuaW1hdGlvbiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBfaS50d2VlbiApIF9pLnR3ZWVuLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2kudHdlZW4gPSBvcHRpb25zLnJlbGVhc2VBbmltYXRpb24uY2FsbCggdGhpcywgZSwgX2kgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbnMudXAgIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVwLmNhbGwoIHRoaXMsIGUsIF9pICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIG9wdGlvbnMgIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgdGhpcy5vbiggRXZlbnQuUE9JTlRFUl9ET1dOLCBwb2ludGVyRG93biApO1xyXG4gICAgICAgICAgICB0aGlzLm9uKCBFdmVudC5QT0lOVEVSX01PVkUsIHBvaW50ZXJNb3ZlICk7XHJcbiAgICAgICAgICAgIHRoaXMub24oIEV2ZW50LlBPSU5URVJfVVAsIHBvaW50ZXJVcCApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggRXZlbnQuUE9JTlRFUl9ET1dOLCBwb2ludGVyRG93biApO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIEV2ZW50LlBPSU5URVJfTU9WRSwgcG9pbnRlck1vdmUgKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCBFdmVudC5QT0lOVEVSX1VQLCBwb2ludGVyVXAgKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX19pbnRlcmFjdGl2ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uICAgIFxyXG5cclxuXHJcbiAgICBlbmNvZGVSZW5kZXJpbmdJbmZvKCkge1xyXG4gICAgICAgIC8vIGlkKDEpLHR5cGUoMSksdXBkYXRlQ29kZSgxKSxjb2xvck92ZXJyaWRlKDQpLGNvbG9yQWRkKDQpLGFuY2hvcigyKSxzaGFkZXJJZCgxKSxtYXRyaXgoMTYpLGNsaXBSZWdpb24oNClcclxuICAgICAgICBjb25zdCBlbmNvZGVkQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggMzggKTtcclxuXHJcbiAgICAgICAgLy8gZW5jb2RlZEJ1ZmZlclswXSA9IHRoaXMuaWQ7XHJcbiAgICAgICAgLy8gZW5jb2RlZEJ1ZmZlclsxXSA9IHRoaXMuc3ByaXRlVHlwZTtcclxuICAgICAgICAvLyBlbmNvZGVkQnVmZmVyWzJdID0gdGhpcy51cGRhdGVDb2RlOyBcclxuICAgICAgICAvLyAvLyBlbmNvZGVkQnVmZmVyLnNldCggdGhpcy5jb2xvck92ZXJyaWRlLDMgKTtcclxuICAgICAgICAvLyBlbmNvZGVkQnVmZmVyWzNdID0gdGhpcy5jb2xvck92ZXJyaWRlWzBdO1xyXG4gICAgICAgIC8vIGVuY29kZWRCdWZmZXJbNF0gPSB0aGlzLmNvbG9yT3ZlcnJpZGVbMV07XHJcbiAgICAgICAgLy8gZW5jb2RlZEJ1ZmZlcls1XSA9IHRoaXMuY29sb3JPdmVycmlkZVsyXTtcclxuICAgICAgICAvLyBlbmNvZGVkQnVmZmVyWzZdID0gdGhpcy5jb2xvck92ZXJyaWRlWzNdO1xyXG4gICAgICAgIC8vIC8vIGVuY29kZWRCdWZmZXIuc2V0KCB0aGlzLmNvbG9yQWRkLDcgKTtcclxuICAgICAgICAvLyBlbmNvZGVkQnVmZmVyWzddID0gdGhpcy5jb2xvckFkZFswXTtcclxuICAgICAgICAvLyBlbmNvZGVkQnVmZmVyWzhdID0gdGhpcy5jb2xvckFkZFsxXTtcclxuICAgICAgICAvLyBlbmNvZGVkQnVmZmVyWzldID0gdGhpcy5jb2xvckFkZFsyXTtcclxuICAgICAgICAvLyBlbmNvZGVkQnVmZmVyWzEwXSA9IHRoaXMuY29sb3JBZGRbM107XHJcbiAgICAgICAgLy8gZW5jb2RlZEJ1ZmZlclsxMV0gPSB0aGlzLnRyYW5zZm9ybS5hbmNob3JYO1xyXG4gICAgICAgIC8vIGVuY29kZWRCdWZmZXJbMTJdID0gdGhpcy50cmFuc2Zvcm0uYW5jaG9yWTtcclxuXHJcbiAgICAgICAgZW5jb2RlZEJ1ZmZlci5zZXQoIFt0aGlzLl8kJGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fJCRzcHJpdGVUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fJCR1cGRhdGVDb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvck92ZXJyaWRlWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvck92ZXJyaWRlWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvck92ZXJyaWRlWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvck92ZXJyaWRlWzNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvckFkZFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3JBZGRbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yQWRkWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvckFkZFszXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmFuY2hvclgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5hbmNob3JZXSApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuc2hhZGVyICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIGVuY29kZWRCdWZmZXJbMTNdID0gdGhpcy5zaGFkZXIuYXNzZXQuaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZW5jb2RlZEJ1ZmZlclsxM10gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3IgKCBsZXQgaSA9IDA7IGkgPCAxNjsgaSsrICkge1xyXG4gICAgICAgIC8vICAgICBlbmNvZGVkQnVmZmVyWzE0ICsgaV0gPSB0aGlzLnRyYW5zZm9ybS5tYXRyaXhbaV07IFxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBlbmNvZGVkQnVmZmVyLnNldCggdGhpcy50cmFuc2Zvcm0ubWF0cml4LDE0ICk7XHJcbiAgICAgICAgVHlwZWRBcnJheUhlbHBlci5tZW1jcHkoIGVuY29kZWRCdWZmZXIsMTQsdGhpcy50cmFuc2Zvcm0ubWF0cml4LDAsMTYgKTtcclxuXHJcbiAgICAgICAgZW5jb2RlZEJ1ZmZlci5zZXQoICggdGhpcy5jbGlwUmVnaW9uICE9IG51bGwgKSA/IHRoaXMuY2xpcFJlZ2lvbi54eXdoIDogW05hTixOYU4sTmFOLE5hTl0sMzAgKTtcclxuICAgICAgICBlbmNvZGVkQnVmZmVyWzM0XSA9IHRoaXMuY2FjaGVCaXRtYXBBc3NldCAhPSBudWxsID8gdGhpcy5jYWNoZUJpdG1hcEFzc2V0LmlkIDogMDtcclxuICAgICAgICBlbmNvZGVkQnVmZmVyWzM1XSA9IHRoaXMuY2FjaGVCaXRtYXBEc3RJZDtcclxuICAgICAgICBlbmNvZGVkQnVmZmVyWzM2XSA9IHRoaXMuYmxlbmRNb2RlO1xyXG4gICAgICAgIGVuY29kZWRCdWZmZXJbMzddID0gK3RoaXMubW90aW9uQmx1cjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVuY29kZWRCdWZmZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZW5jb2RlQ3VzdG9tUHJldigpIHtcclxuICAgICAgICBjb25zdCBlbmNvZGVkQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggMjIgKTtcclxuXHJcbiAgICAgICAgZW5jb2RlZEJ1ZmZlci5zZXQoIFtcclxuICAgICAgICAgICAgdGhpcy5jdXN0b21QcmV2LmNvbG9yT3ZlcnJpZGVbMF0sXHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tUHJldi5jb2xvck92ZXJyaWRlWzFdLFxyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVByZXYuY29sb3JPdmVycmlkZVsyXSxcclxuICAgICAgICAgICAgdGhpcy5jdXN0b21QcmV2LmNvbG9yT3ZlcnJpZGVbM10sXHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tUHJldi5hbmNob3JQb3NpdGlvblgsXHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tUHJldi5hbmNob3JQb3NpdGlvblldICk7XHJcbiAgICAgICAgLy8gZW5jb2RlZEJ1ZmZlci5zZXQoIHRoaXMuY3VzdG9tUHJldi53b3JsZE1hdHJpeCw2ICk7XHJcbiAgICAgICAgVHlwZWRBcnJheUhlbHBlci5tZW1jcHkoIGVuY29kZWRCdWZmZXIsNix0aGlzLmN1c3RvbVByZXYud29ybGRNYXRyaXgsMCwxNiApO1xyXG4gICAgICAgIHJldHVybiBlbmNvZGVkQnVmZmVyO1xyXG4gICAgfVxyXG5cclxuICAgIHNvcnRDaGlsZHJlbiggcHJvcCA9IFwieVwiICkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc29ydCggKCBhLCBiICkgPT4gYVtwcm9wXSAtIGJbcHJvcF0gKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc2V0Q3VzdG9tUHJldiggd29ybGRNYXRyaXgsY29sb3JPdmVycmlkZSxhbmNob3JQb3NpdGlvblgsYW5jaG9yUG9zaXRpb25ZICkge1xyXG4gICAgICAgIHRoaXMuY3VzdG9tUHJldiA9IHtcclxuICAgICAgICAgICAgd29ybGRNYXRyaXgsXHJcbiAgICAgICAgICAgIGNvbG9yT3ZlcnJpZGUsXHJcbiAgICAgICAgICAgIGFuY2hvclBvc2l0aW9uWCxcclxuICAgICAgICAgICAgYW5jaG9yUG9zaXRpb25ZLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fJCR1cGRhdGVDb2RlIHw9IFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfQ1VTVE9NX1BSRVY7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q2FjaGVNb2RlKCBtb2RlICkge1xyXG4gICAgICAgIGlmICggdGhpcy5jYWNoZUJpdG1hcE1vZGUgPT0gU3ByaXRlLkNhY2hlQml0bWFwTW9kZXMuU05BUFNIT1QgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKCBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0NMRUFSX1BSRVYgKTsgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB0aGlzLmNhY2hlQml0bWFwQXNzZXQgKSB7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVCaXRtYXBBc3NldC5yZWxlYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTcHJpdGV9IHNwclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgY2xlYXJEc3RJZCA9ICggc3ByICk9PntcclxuICAgICAgICAgICAgICAgIGlmICggc3ByLmNhY2hlQml0bWFwTW9kZSA9PSBTcHJpdGUuQ2FjaGVCaXRtYXBNb2Rlcy5OT19DQUNIRSApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlQml0bWFwQXNzZXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwci5jYWNoZUJpdG1hcERzdElkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBsZXQgc3ByMiBvZiBzcHIuY2hpbGRyZW4gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyRHN0SWQoIHNwcjIgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNhY2hlQml0bWFwTW9kZSA9IFNwcml0ZS5DYWNoZUJpdG1hcE1vZGVzLk5PX0NBQ0hFO1xyXG4gICAgICAgICAgICBjbGVhckRzdElkKCB0aGlzICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FjaGVCaXRtYXBNb2RlID0gbW9kZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZW5jb2RlUmVuZGVyaW5nSW5mb1dpdGhDaGlsZHJlbigpIHtcclxuICAgICAgICBjb25zdCBlbmNvZGVkQnVmZmVycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyTGlzdCA9IFtdO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtTcHJpdGV9IHNwclxyXG4gICAgICAgICAqIEBwYXJhbSB7bTQuTWF0NH0gd29ybGRNYXRyaXhcclxuICAgICAgICAgKiBAcGFyYW0ge1tudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXJdfEZsb2F0MzJBcnJheX0gY29sb3JPdmVycmlkZVxyXG4gICAgICAgICAqIEBwYXJhbSB7W251bWJlcixudW1iZXIsbnVtYmVyLG51bWJlcl18RmxvYXQzMkFycmF5fG51bGx9IGNsaXBSZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNhY2hlQml0bWFwRHN0SWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVDaGlsZHJlbiggc3ByLHdvcmxkTWF0cml4LGNvbG9yT3ZlcnJpZGUsIGNsaXBSZWN0LCBjYWNoZUJpdG1hcERzdElkICkge1xyXG4gICAgICAgICAgICBjb25zdCBidWYgPSBzcHIuZW5jb2RlUmVuZGVyaW5nSW5mbygpO1xyXG4gICAgICAgICAgICBjb25zdCBidWZNYXRyaXggPSBidWYuc3ViYXJyYXkoIDE0LDE0ICsgMTYgKTtcclxuICAgICAgICAgICAgY29uc3QgY3VyQ29sb3JPdmVycmlkZSA9IGJ1Zi5zdWJhcnJheSggMywzICsgNCApO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJDbGlwUmVjdCA9IGJ1Zi5zdWJhcnJheSggMzAsMzAgKyA0ICk7XHJcbiAgICAgICAgICAgIGxldCBhc3NldElkID0gMDtcclxuICAgICAgICAgICAgbGV0IGV4dHJhO1xyXG4gICAgICAgICAgICBsZXQgc3RycztcclxuICAgICAgICAgICAgbGV0IGdlbmVyaWNEYXRhO1xyXG4gICAgICAgICAgICBsZXQgY3VzdG9tUHJldjtcclxuICAgICAgICAgICAgbGV0IG5lZWRNYWtlUlQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNsaXBSZWdpb24g7Yq4656c7Iqk7Y+8XHJcbiAgICAgICAgICAgIGlmICggIU51bWJlci5pc05hTiggY3VyQ2xpcFJlY3RbMF0gKSApIHtcclxuICAgICAgICAgICAgICAgIGxldCBjbGlwUG9zID0gbTQudHJhbnNmb3JtUG9pbnQoIHdvcmxkTWF0cml4LFtjdXJDbGlwUmVjdFswXSxjdXJDbGlwUmVjdFsxXSwwXSApO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1ckNsaXBSZWN0WzBdID0gY2xpcFBvc1swXSArIHNwci54O1xyXG4gICAgICAgICAgICAgICAgY3VyQ2xpcFJlY3RbMV0gPSBjbGlwUG9zWzFdICsgc3ByLnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOunpO2KuOumreyKpOuKlCDtirjrpqwg7ZWY64uo7Jy866GcIOqwiCDsiJjroZ0g6rOx7ZWc64ukLlxyXG4gICAgICAgICAgICBtNC5tdWx0aXBseSggd29ybGRNYXRyaXgsYnVmTWF0cml4LGJ1Zk1hdHJpeCApO1xyXG4gICAgICAgICAgICAvLyDsm5Trk5wg66ek7Yq466at7Iqk66GcIOuztOq0gC4g7ZWcIO2UhOugiOyehCDriqbsnYAg6rCS7J2064ukLlxyXG4gICAgICAgICAgICAvLyBjb3B57ZWY64qUIOydtOycoOuKlCBwb3N0TWVzc2FnZeuhnCDsm5Drs7jsnbQg67O064K07KC47IScIOyCrOudvOyngOq4sCDrlYzrrLhcclxuICAgICAgICAgICAgc3ByLndvcmxkTWF0cml4ID0gbTQuY29weSggYnVmTWF0cml4ICk7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKCBzcHIuY2FjaGVCaXRtYXBNb2RlICE9IFNwcml0ZS5DYWNoZUJpdG1hcE1vZGVzLk5PX0NBQ0hFICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBzcHIuY2FjaGVCaXRtYXBBc3NldCA9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5lZWRNYWtlUlQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggc3ByLmNhY2hlQml0bWFwTW9kZSA9PSBTcHJpdGUuQ2FjaGVCaXRtYXBNb2Rlcy5GSUxURVIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g7ZWE7YSw66eBIOuqqOuTnFxyXG4gICAgICAgICAgICAgICAgICAgIHNwci5jYWNoZUJpdG1hcEFzc2V0LnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZWVkTWFrZVJUID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICggbmVlZE1ha2VSVCApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBzcHIuYm91bmRzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZXQgPSBuZXcgQXNzZXQoIFwiPFJUOio+XCIsQXNzZXQuQXNzZXRUeXBlcy5SZW5kZXJUYXJnZXQgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBhc3NldC5sb2FkKCB7IFxyXG4gICAgICAgICAgICAgICAgICAgIHg6ICAgICAgICAgICByZWN0LngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogICAgICAgICAgIHJlY3QueSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogICAgICAgTWF0aC5taW4oIDIwNDgsIHJlY3Qud2lkdGggKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICAgICAgTWF0aC5taW4oIDIwNDgscmVjdC5oZWlnaHQgKSwgXHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRNYXRyaXg6IHNwci53b3JsZE1hdHJpeCAgfSApO1xyXG4gICAgICAgICAgICAgICAgc3ByLmNhY2hlQml0bWFwQXNzZXQgPSBhc3NldDtcclxuICAgICAgICAgICAgICAgIGFzc2V0SWQgPSBhc3NldC5pZDtcclxuICAgICAgICAgICAgICAgIHNwci5jYWNoZUJpdG1hcERzdElkID0gYXNzZXRJZDtcclxuICAgICAgICAgICAgICAgIGNhY2hlQml0bWFwRHN0SWQgPSBhc3NldElkO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGBDYWNoZSAke2Fzc2V0SWR9IHNyYz0ke3Nwci5jYWNoZUJpdG1hcFNyY0lkfWAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNwci5jYWNoZUJpdG1hcERzdElkID0gY2FjaGVCaXRtYXBEc3RJZCB8fCBzcHIuY2FjaGVCaXRtYXBEc3RJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidWZbMzVdID0gc3ByLmNhY2hlQml0bWFwRHN0SWQ7XHJcblxyXG4gICAgICAgICAgICAvLyDsu6zrn6zripQgUkdCQeqwgeqwgeydhCDqs7HtlbTrgpjqsITri6QuIDB+MSDqsJJcclxuICAgICAgICAgICAgY3VyQ29sb3JPdmVycmlkZVswXSA9IGN1ckNvbG9yT3ZlcnJpZGVbMF0gKiBjb2xvck92ZXJyaWRlWzBdO1xyXG4gICAgICAgICAgICBjdXJDb2xvck92ZXJyaWRlWzFdID0gY3VyQ29sb3JPdmVycmlkZVsxXSAqIGNvbG9yT3ZlcnJpZGVbMV07XHJcbiAgICAgICAgICAgIGN1ckNvbG9yT3ZlcnJpZGVbMl0gPSBjdXJDb2xvck92ZXJyaWRlWzJdICogY29sb3JPdmVycmlkZVsyXTtcclxuICAgICAgICAgICAgY3VyQ29sb3JPdmVycmlkZVszXSA9IGN1ckNvbG9yT3ZlcnJpZGVbM10gKiBjb2xvck92ZXJyaWRlWzNdO1xyXG4gICAgICAgICAgICAvLyBjbGlwUmVjdOuKlCBOYU7snbTrqbQg67aA66qoIOqyg+ydhCDqsIDsoLjsmKjri6RcclxuICAgICAgICAgICAgaWYgKCBOdW1iZXIuaXNOYU4oIGN1ckNsaXBSZWN0WzBdICkgJiYgIU51bWJlci5pc05hTiggY2xpcFJlY3RbMF0gKSApIHtcclxuICAgICAgICAgICAgICAgIGN1ckNsaXBSZWN0LnNldCggY2xpcFJlY3QgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHNwci5fJCRzcHJpdGVUeXBlICE9IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIGlmICggKCBzcHIuXyQkdXBkYXRlQ29kZSAmIFNwcml0ZS5VcGRhdGVDb2Rlcy5VUERBVEVfRVhUUkEgKSAmJiBzcHIuZW5jb2RlRXh0cmFSZW5kZXJpbmdJbmZvICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zZmVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgICAgICBbZXh0cmEsc3RycyxnZW5lcmljRGF0YSx0cmFuc2Zlcl0gPSBzcHIuZW5jb2RlRXh0cmFSZW5kZXJpbmdJbmZvKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0cmFuc2ZlciApIHRyYW5zZmVyTGlzdC5wdXNoKCAuLi50cmFuc2ZlciApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCAoIHNwci5fJCR1cGRhdGVDb2RlICYgU3ByaXRlLlVwZGF0ZUNvZGVzLlVQREFURV9DVVNUT01fUFJFViApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVByZXYgPSBzcHIuZW5jb2RlQ3VzdG9tUHJldigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUlTsl5Ag6re466a0IOqyg+ydtOudvOyEnCBzcmNJZD0wXHJcbiAgICAgICAgICAgICAgICBidWZbMzRdID0gMDtcclxuICAgICAgICAgICAgICAgIGVuY29kZWRCdWZmZXJzLnB1c2goIFtidWYsZXh0cmEsc3RycyxjdXN0b21QcmV2LGdlbmVyaWNEYXRhXSApO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCBzcHIuY2FjaGVCaXRtYXBNb2RlID09IFNwcml0ZS5DYWNoZUJpdG1hcE1vZGVzLlNOQVBTSE9UICYmIHNwci5jYWNoZUJpdG1hcERzdElkID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDsupDsi5zrkJwg6rK97JqwXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDruYTtirjrp7Xsl5Ag7LqQ7Iuc7ZWcIOqyveyasOqwgCDslYTri4jrqbQg7LCo7J2865Oc66W8IOq3uOumsOuLpC5cclxuICAgICAgICAgICAgICAgIHNwci5jaGlsZHJlbi5mb3JFYWNoKCBjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGlsZC52aXNpYmxlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVDaGlsZHJlbiggY2hpbGQsIGJ1Zk1hdHJpeCxjdXJDb2xvck92ZXJyaWRlLCBjdXJDbGlwUmVjdCwgY2FjaGVCaXRtYXBEc3RJZCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNwci5jYWNoZUJpdG1hcE1vZGUgPT0gU3ByaXRlLkNhY2hlQml0bWFwTW9kZXMuU05BUFNIT1QgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5jYWNoZUJpdG1hcERzdElkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgIGlmICggc3ByLmNhY2hlQml0bWFwTW9kZSA9PSBTcHJpdGUuQ2FjaGVCaXRtYXBNb2Rlcy5TTkFQU0hPVCApIHtcclxuICAgICAgICAgICAgICAgICAgICBzcHIuY2FjaGVCaXRtYXBEc3RJZCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggc3ByLmNhY2hlQml0bWFwQXNzZXQgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDthY3siqTss5Drpbwg6re466Ck7JW8IO2VqFxyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmMiA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZiApO1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1ZjJbMzRdID0gYXNzZXRJZDtcclxuICAgICAgICAgICAgICAgIGJ1ZjJbMzVdID0gMDtcclxuICAgICAgICAgICAgICAgIGVuY29kZWRCdWZmZXJzLnB1c2goIFtidWYyLG51bGwsbnVsbCxjdXN0b21QcmV2LG51bGxdICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ByLl8kJHVwZGF0ZUNvZGUgPSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX05PVEhJTkc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMudmlzaWJsZSApIHtcclxuICAgICAgICAgICAgZW5jb2RlQ2hpbGRyZW4oIHRoaXMsbTQuaWRlbnRpdHkoKSwgWzEsMSwxLDFdLCBbTmFOLE5hTixOYU4sTmFOXSwgMCApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgZW5jb2RlZEJ1ZmZlcnMubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zlckxpc3QucHVzaCggZW5jb2RlZEJ1ZmZlcnNbaV1bMF0uYnVmZmVyICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGVuY29kZWRCdWZmZXJzW2ldWzFdICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyTGlzdC5wdXNoKCBlbmNvZGVkQnVmZmVyc1tpXVsxXS5idWZmZXIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICggZW5jb2RlZEJ1ZmZlcnNbaV1bM10gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJMaXN0LnB1c2goIGVuY29kZWRCdWZmZXJzW2ldWzNdLmJ1ZmZlciApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbZW5jb2RlZEJ1ZmZlcnMsdHJhbnNmZXJMaXN0XTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW251bGwsbnVsbF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5TcHJpdGUubGFzdElkID0gMTtcclxuU3ByaXRlLmZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCBTcHJpdGUuZmluYWxpemVIYW5kbGVyICk7XHJcblNwcml0ZS5sb2FkZWRFdmVudERpc3BhdGNoZXIgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XHJcblxyXG5cclxuU3ByaXRlLlNwcml0ZVR5cGVzID0ge1xyXG4gICAgU1BSSVRFOiAgICAwLFxyXG4gICAgQklUTUFQOiAgICAxLFxyXG4gICAgTUVTSDogICAgICAyLFxyXG4gICAgVEVYVEZJRUxEOiAzLFxyXG4gICAgUElYRUw6ICAgICA0LFxyXG4gICAgU0hBUEU6ICAgICA1LFxyXG59O1xyXG5TcHJpdGUuVXBkYXRlQ29kZXMgPSB7XHJcbiAgICBVUERBVEVfTk9USElORzogICAgIDAsXHJcbiAgICBVUERBVEVfRVhUUkE6ICAgICAgIDEsXHJcbiAgICBVUERBVEVfQ0xFQVJfUFJFVjogIDIsXHJcbiAgICBVUERBVEVfQ1VTVE9NX1BSRVY6IDQsXHJcbn07XHJcblNwcml0ZS5DYWNoZUJpdG1hcE1vZGVzID0ge1xyXG4gICAgTk9fQ0FDSEU6IDAsXHJcbiAgICBTTkFQU0hPVDogMSxcclxuICAgIEZJTFRFUjogICAyLFxyXG59O1xyXG5cclxuXHJcbi8qKiBcclxuICogQGVudW0ge251bWJlcn1cclxuKi9cclxuU3ByaXRlLkJsZW5kTW9kZXMgPSB7XHJcbiAgICBOT1JNQUw6ICAgICAwLCAvL1tnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgTVVMVElQTFk6ICAgMSwgLy9bZ2wuRFNUX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgIEFERDogICAgICAgIDIsIC8vW2dsLk9ORSwgZ2wuRFNUX0FMUEhBXTtcclxuICAgIFNDUkVFTjogICAgIDMsIC8vW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19DT0xPUl07XHJcbiAgICBOT1JNQUxfTlBNOiA0LCAvL1tnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICBBRERfTlBNOiAgICA1LCAvL1tnbC5TUkNfQUxQSEEsIGdsLkRTVF9BTFBIQSwgZ2wuT05FLCBnbC5EU1RfQUxQSEFdO1xyXG4gICAgU0NSRUVOX05QTTogNiwgLy9bZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQ09MT1JdO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL1Nwcml0ZSc7XHJcbmltcG9ydCB7IG00IH0gZnJvbSAndHdnbC5qcyc7XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgU3RhZ2UgZXh0ZW5kcyBTcHJpdGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlzU3RhZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG59IiwiXHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgVGltZXIgfSBmcm9tICcuL1RpbWVyJztcclxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcclxuXHJcblxyXG4vLyDqsIEg7Iqk7Yag66as7KeAIOyEpOuqhVxyXG4vL2h0dHBzOi8vYmxvZy5zZXNzaW9uc3RhY2suY29tL2hvdy1qYXZhc2NyaXB0LXdvcmtzLXN0b3JhZ2UtZW5naW5lcy1ob3ctdG8tY2hvb3NlLXRoZS1wcm9wZXItc3RvcmFnZS1hcGktZGE1MDg3OWVmNTc2XHJcbi8vIOy6kOyLnCDrjbDsnbTthLDripQgQ2FjaGUgQVBJXHJcbi8vIOycoOyggCDrjbDsnbTthLDripQgSW5kZXhlZERCIOyTsOudvOqzoCDqtozqs6Ag7ZWY6rOgIOyeiOuLpFxyXG5cclxuZXhwb3J0IGNsYXNzIFN0b3JhZ2UgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoIGRiTmFtZSApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KCBzZWxmLmluZGV4ZWREQiwgXCJpbmRleGVkRELqsIAg7KeA7JuQ65CY7KeAIOyViuuKlCDruIzrnbzsmrDsoIBcIiApO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gMTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbiggZGJOYW1lLHZlcnNpb24gKTtcclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCBldmVudCApID0+IHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCBcImluZGV4ZWREQiDsl7TquLAg7Iuk7YyoXCIgKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCBldmVudCApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGhpc0RiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBcInVwZ3JhZGVcIiApO1xyXG4gICAgICAgICAgICB0aGlzRGIuY3JlYXRlT2JqZWN0U3RvcmUoIFwiZmlsZXNcIiwgeyBrZXlQYXRoOiBcInBhdGhcIiB9ICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICggZXZlbnQgKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRiID0gcmVxdWVzdC5yZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRiID0gZGI7XHJcblxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggZXZlbnQgKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBcInJlYWR5XCIgKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJlYWQoIGtleSApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZGIudHJhbnNhY3Rpb24oIFwiZmlsZXNcIiwgXCJyZWFkb25seVwiICkub2JqZWN0U3RvcmUoIFwiZmlsZXNcIiApLmdldCgga2V5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoIGV2ZW50ICkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggbmV3IEV2ZW50KCBFdmVudC5DT01QTEVURSwgeyBjb250ZW50OiBldmVudC50YXJnZXQucmVzdWx0LmNvbnRlbnQgfSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSggZXZlbnQudGFyZ2V0LnJlc3VsdC5jb250ZW50ICk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmRiICkge1xyXG4gICAgICAgICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCBcInJlYWR5XCIsIGZ1bmMgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICB3cml0ZSgga2V5LCB2YWx1ZSApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZGIudHJhbnNhY3Rpb24oIFwiZmlsZXNcIiwgXCJyZWFkd3JpdGVcIiApLm9iamVjdFN0b3JlKCBcImZpbGVzXCIgKS5wdXQoIHsgcGF0aDoga2V5LCBjb250ZW50OiB2YWx1ZSB9ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoIGV2ZW50ICkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggbmV3IEV2ZW50KCBFdmVudC5DT01QTEVURSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdGhpcy5kYiApIHtcclxuICAgICAgICAgICAgICAgIGZ1bmMoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25jZSggXCJyZWFkeVwiLCBmdW5jICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHN0YXRpYyBsb2FkRmlsZSggZmlsZW5hbWUgKSB7XHJcbiAgICAgICAgLy8gLyoqIEB0eXBlIHtQSVhJLkxvYWRlcn0gKi9cclxuICAgICAgICAvLyAvL0B0cy1pZ25vcmVcclxuICAgICAgICAvLyBjb25zdCBsb2FkZXIgPSBQSVhJLkxvYWRlci5zaGFyZWQ7XHJcbiAgICAgICAgLy8gY29uc3QgciA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgICAgICAgLy8gaWYgKCBsb2FkZXIucmVzb3VyY2VzW2ZpbGVuYW1lXSApIHtcclxuICAgICAgICAvLyAgICAgaWYgKCBsb2FkZXIucmVzb3VyY2VzW2ZpbGVuYW1lXS5pc0NvbXBsZXRlICkge1xyXG4gICAgICAgIC8vICAgICAgICAgVGltZXIuZGVsYXllZENhbGwoIDAsICgpPT4gci5kaXNwYXRjaEV2ZW50KCBFdmVudC5DT01QTEVURSx7IGRhdGE6IGxvYWRlci5yZXNvdXJjZXNbZmlsZW5hbWVdLmRhdGEgfSApICk7XHJcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgICAgICBsb2FkZXIubG9hZCggKCBsb2FkZXIscmVzb3VyY2VzICk9PiByLmRpc3BhdGNoRXZlbnQoIEV2ZW50LkNPTVBMRVRFLHsgZGF0YTogcmVzb3VyY2VzW2ZpbGVuYW1lXS5kYXRhIH0gKSApO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgbG9hZGVyLmFkZCggZmlsZW5hbWUsZmlsZW5hbWUgKTtcclxuICAgICAgICAvLyAgICAgbG9hZGVyLmxvYWQoICggbG9hZGVyLHJlc291cmNlcyApPT4ge1xyXG4gICAgICAgIC8vICAgICAgICAgaWYgKCByZXNvdXJjZXNbZmlsZW5hbWVdLmVycm9yICkgdGhyb3cgbmV3IEVycm9yKCByZXNvdXJjZXNbZmlsZW5hbWVdLmVycm9yICk7XHJcbiAgICAgICAgLy8gICAgICAgICByLmRpc3BhdGNoRXZlbnQoIEV2ZW50LkNPTVBMRVRFLHsgZGF0YTogcmVzb3VyY2VzW2ZpbGVuYW1lXS5kYXRhIH0gKTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICApO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy8gcmV0dXJuIHI7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IEZvbnQgfSBmcm9tIFwiLi9Gb250QmFzZVwiO1xyXG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tIFwiLi9TcHJpdGVcIjtcclxuaW1wb3J0IHsgVHJ1ZVR5cGVGb250IH0gZnJvbSBcIi4vVHJ1ZVR5cGVGb250XCI7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi9UeXBlc1wiO1xyXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gXCIuL1V0aWxzXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFRleHRGaWVsZCBleHRlbmRzIFNwcml0ZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGV4dEZpZWxkLlxyXG4gICAgICogQHBhcmFtIHtGb250fSBmb250XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxyXG4gICAgICogQHBhcmFtIHsqfSBzdHlsZXNcclxuICAgICAqIEBtZW1iZXJvZiBUZXh0RmllbGRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoIGZvbnQsIHRleHQsIHN0eWxlcyApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XHJcbiAgICAgICAgdGhpcy51c2VCYXNlbGluZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuXyQkc3ByaXRlVHlwZSA9IFNwcml0ZS5TcHJpdGVUeXBlcy5URVhURklFTEQ7XHJcbiAgICAgICAgdGhpcy5fJCR1cGRhdGVDb2RlID0gU3ByaXRlLlVwZGF0ZUNvZGVzLlVQREFURV9FWFRSQTtcclxuICAgICAgICAvLyDtirjro6jtg4DsnoXtj7Dtirjrpbwg7LqU67KE7Iqk7JeQIOq3uOuguOuLpOqwgCDthY3siqTss5DroZwg67CU6r6464qU642wIOydtCDrlYwg7JWM7YyM7JeQIOqygOygleydtCDshJ7snbTripQg6rKD7J2EIOu5vOugpOuptCDri6TsnYzqs7wg6rCZ7J20IO2VtOyVvO2VnOuLpC5cclxuICAgICAgICB0aGlzLmNvbG9yQWRkID0gKCBmb250IGluc3RhbmNlb2YgVHJ1ZVR5cGVGb250ICkgPyBbMSwxLDEsMF0gOiBbMCwwLDAsMF07XHJcbiAgICAgICAgdGhpcy5jdXN0b21Cb3VuZHMgPSBuZXcgUmVjdCgpO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHRleHQoIHRleHQgKSB7XHJcbiAgICAgICAgaWYgKCB0ZXh0ICE9IHRoaXMuX3RleHQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQm91bmRzLndpZHRoID0gdGhpcy5mb250Lm1lYXN1cmVUZXh0V2lkdGgoIHRleHQsdGhpcy5mb250U2l6ZSApO1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbUJvdW5kcy5oZWlnaHQgPSB0aGlzLmZvbnRTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZm9udFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5yZWZlcmVuY2VTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUZXh0Q29sb3IoIGMsYSApIHtcclxuICAgICAgICAvLyB0aGlzLmNvbG9yQWRkID0gVXRpbHMuaGV4MnJnYmEoIGMsYSApO1xyXG4gICAgICAgIHRoaXMuc2V0T3ZlcnJpZGVDb2xvciggYyxhICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZyb21UZXh0V3JhcCggdGV4dCwgYXJlYVdpZHRoLCBhcmVhSGVpZ2h0LCBsaW5lU3BhY2luZywgZm9udCwgYWxpZ24sIGlnbm9yZVdvcmRXcmFwICkge1xyXG4gICAgICAgIGNvbnN0IHdvcmRXcmFwU3R5bGUgPSB7XHJcbiAgICAgICAgICAgIGFsaWduOiAgICAgICAgIGFsaWduICE9IG51bGwgPyBhbGlnbiA6IFwibGVmdFwiLFxyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAgICBsaW5lU3BhY2luZyxcclxuICAgICAgICAgICAgd29yZFdyYXA6ICAgICAgYXJlYVdpZHRoICE9IG51bGwgJiYgIWlnbm9yZVdvcmRXcmFwLFxyXG4gICAgICAgICAgICB3aGl0ZVNwYXRlOiAgICBcIm5vcm1hbFwiLFxyXG4gICAgICAgICAgICB0cmltOiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICBicmVha1dvcmQ6ICAgICBhcmVhV2lkdGggIT0gbnVsbCAmJiAhaWdub3JlV29yZFdyYXAsXHJcbiAgICAgICAgICAgIHdvcmRXcmFwV2lkdGg6IGFyZWFXaWR0aFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHRmID0gbmV3IFRleHRGaWVsZCggZm9udCwgdGV4dCwgd29yZFdyYXBTdHlsZSApO1xyXG5cclxuICAgICAgICAvL3Nwci5hZGRDaGlsZCggdGYgKTtcclxuICAgICAgICAvL1RPRE86IO2LgOuguOydjFxyXG4gICAgICAgIHRmLmFuY2hvclggPSAoIGFsaWduID09IFwiY2VudGVyXCIgKSA/IDAuNSA6ICggYWxpZ24gPT0gXCJyaWdodFwiID8gMS4wIDogMC4wICk7XHJcblxyXG4gICAgICAgIC8vdGYuX19waXhpLnggPSAoYWxpZ24gPT0gXCJjZW50ZXJcIikgPyBhcmVhV2lkdGggKiAwLjUgOiAoYWxpZ24gPT0gXCJyaWdodFwiID8gYXJlYVdpZHRoIDogMC4wKTtcclxuICAgICAgICBpZiAoIGFyZWFXaWR0aCAhPSBudWxsICkge1xyXG4gICAgICAgICAgICB0Zi54ICs9IGFyZWFXaWR0aCAqIHRmLmFuY2hvclBvc2l0aW9uLng7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGY7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBlbmNvZGVFeHRyYVJlbmRlcmluZ0luZm8oKSB7XHJcbiAgICAgICAgbGV0IGVuY29kZWRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCAyICk7XHJcblxyXG4gICAgICAgIGVuY29kZWRCdWZmZXJbMF0gPSB0aGlzLmZvbnQuYXNzZXQuaWQ7XHJcbiAgICAgICAgZW5jb2RlZEJ1ZmZlclsxXSA9ICt0aGlzLnVzZUJhc2VsaW5lO1xyXG5cclxuICAgICAgICByZXR1cm4gW2VuY29kZWRCdWZmZXIsW3RoaXMudGV4dF1dO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEFzc2V0IH0gZnJvbSAnLi9Bc3NldCc7XHJcbmltcG9ydCB7IFRleHR1cmVCYXNlIH0gZnJvbSAnLi9UZXh0dXJlQmFzZSc7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL1R5cGVzJztcclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICcuL1V0aWxzJztcclxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL0V2ZW50JztcclxuZXhwb3J0IGNsYXNzIFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlQmFzZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGV4dHVyZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJcclxuICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9uXHJcbiAgICAgKiBAbWVtYmVyb2YgVGV4dHVyZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciggZmlsZW5hbWUsIGZpbHRlciA9IGZhbHNlLCBvcHRpb24gPSB7fSApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuYXNzZXQgPSBuZXcgQXNzZXQoIGZpbGVuYW1lLEFzc2V0LkFzc2V0VHlwZXMuVGV4dHVyZSApO1xyXG4gICAgICAgIGNvbnN0IHNpemUgPSBVdGlscy5nZXRJbWFnZVNpemUoIGZpbGVuYW1lICk7XHJcblxyXG4gICAgICAgIHRoaXMudXZSZWN0ID0gb3B0aW9uLnJlY3QgfHwgbmV3IFJlY3QoIDAsMCxzaXplLndpZHRoLHNpemUuaGVpZ2h0ICk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMudXZSZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy51dlJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuYXNzZXQubG9hZCggeyB3aWR0aDogc2l6ZS53aWR0aCxoZWlnaHQ6IHNpemUuaGVpZ2h0LHV2UmVjdDogdGhpcy51dlJlY3QsIGZpbHRlcjogZmlsdGVyIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHBhcmFtIHthbnk9fSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc09uY2U9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7VGV4dHVyZX1cclxuICAgICAqIEBtZW1iZXJvZiBUZXh0dXJlXHJcbiAgICAgKi9cclxuICAgIGFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgZnVuYywgY29udGV4dCA9IG51bGwsIGlzT25jZSA9IGZhbHNlICkge1xyXG4gICAgICAgIGlmICggZXZlbnROYW1lID09IEV2ZW50LkxPQURFRCApIHtcclxuICAgICAgICAgICAgdGhpcy5hc3NldC5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMuZGlzcGF0Y2hFdmVudC5iaW5kKCB0aGlzLEV2ZW50LkxPQURFRCApLCBudWxsLCBpc09uY2UgKTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiBzdXBlci5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIGZ1bmMsIGNvbnRleHQsIGlzT25jZSApO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBBc3NldCB9IGZyb20gJy4vQXNzZXQnO1xyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFBvaW50LCBSZWN0IH0gZnJvbSAnLi9UeXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgVGV4dHVyZUJhc2UgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtBc3NldH0gKi9cclxuICAgICAgICB0aGlzLmFzc2V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKiBAdHlwZSB7UmVjdH0gKi9cclxuICAgICAgICB0aGlzLnV2UmVjdCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMud2lkdGgsdGhpcy5oZWlnaHRdO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBUZXh0dXJlQmFzZSB9IGZyb20gJy4vVGV4dHVyZUJhc2UnO1xyXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4vVXRpbHMnO1xyXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vRXZlbnQnO1xyXG5pbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi9UeXBlcyc7XHJcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUnO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBUZXh0dXJlUGFjayBleHRlbmRzIFRleHR1cmVCYXNlIHtcclxuICAgIC8qKlxyXG4gICAgICpDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRleHR1cmVQYWNrLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB0eHRmaWxlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VmaWxlXHJcbiAgICAgKiBAcGFyYW0ge1RleHR1cmVCYXNlLkZpbHRlcnN9IGZpbHRlclxyXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zXHJcbiAgICAgKiBAbWVtYmVyb2YgVGV4dHVyZVBhY2tcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoIHR4dGZpbGUsaW1hZ2VmaWxlLGZpbHRlcixvcHRpb25zICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9ICBpbWFnZWZpbGU7XHJcbiAgICAgICAgdGhpcy5yZWdpb25zID0ge307XHJcblxyXG4gICAgICAgIGlmICggdHlwZW9mKCB0eHRmaWxlICkgPT0gXCJzdHJpbmdcIiApIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IFV0aWxzLmdldEVtYmVkZGVkRmlsZSggdHh0ZmlsZSApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmICggcyAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzLnNwbGl0KCBcIlxcblwiICk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggY29uc3QgbGluZSBvZiBsaW5lcyApIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cobGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gLyhbXixdKyksXFxzKihcXGQrKSxcXHMqKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspLy5leGVjKCBsaW5lICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVzdWx0ICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFssIG5hbWUsIHgsIHksIHdpZHRoLCBoZWlnaHRdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGAke25hbWV9ICR7eH0gJHt5fSAke3dpZHRofSAke2hlaWdodH1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5ldyBSZWN0KCBwYXJzZUZsb2F0KCB4ICksIHBhcnNlRmxvYXQoIHkgKSwgcGFyc2VGbG9hdCggd2lkdGggKSwgcGFyc2VGbG9hdCggaGVpZ2h0ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uc1tuYW1lXSA9IG5ldyBUZXh0dXJlKCB0aGlzLmZpbGVuYW1lLGZhbHNlLHsgcmVjdCB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHh0ZmlsZSDrtoDrtoTsl5Ag6rCc7LK066W8IOuEo+ydgCDqsr3smrBcclxuICAgICAgICAgICAgZm9yICggbGV0IG5hbWUgaW4gdHh0ZmlsZSApIHtcclxuICAgICAgICAgICAgICAgIGxldCByZWN0QXJyID0gdHh0ZmlsZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gbmV3IFJlY3QoIC4uLnJlY3RBcnIgKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbnNbbmFtZV0gPSBuZXcgVGV4dHVyZSggdGhpcy5maWxlbmFtZSxmaWx0ZXIseyByZWN0IH0gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRUZXh0dXJlUmVnaW9uKCBuYW1lICkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lvbnNbbmFtZV07XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlJztcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4vTWVzaCc7XHJcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4vU2hhZGVyJztcclxuaW1wb3J0IHsgVGV4dHVyZUJhc2UgfSBmcm9tICcuL1RleHR1cmVCYXNlJztcclxuXHJcbi8qXHJcblxyXG4yMDE5LTEwLTA1XHJcbnJlc2l6ZeqwgCDrhIjrrLQg64qQ66Ck7IScIOyymOydjOyXkCDrqZTsi5zrpbwg66eM65Ok7Ja0IOuRkOuKlCDsqr3snLzroZwg7ZaI64ukXHJcblxyXG4yMDIxLTExLTIxXHJcblxyXG5tZXNo66W8IGNoaWxk66GcIOqwgOyngOqzoCDsnojripQg6rKD7J2EIOq3uOuDpSBtZXNo66W8IGV4dGVuZO2VmOqyjCDsiJjsoJXtlZjqsbDrgphcclxu7Iio6rKo7KSY7JW87ZWoXHJcblxyXG4qL1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQHRoaXMge1RpbGVNYXB9XHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eFxyXG4gKiBAcGFyYW0ge251bWJlcn0gdHlcclxuICogQHJldHVybnMge251bWJlcltdfVxyXG4gKi9cclxuZnVuY3Rpb24gdGlsZVRvUmVjdCggdHgsIHR5ICkge1xyXG4gICAgY29uc3QgeDEgPSB0eCAqICggdGhpcy5fX3RpbGVXaWR0aCArIHRoaXMuX19zcGFjaW5nWCApICsgdGhpcy5fX21hcmdpblg7XHJcbiAgICBjb25zdCB5MSA9IHR5ICogKCB0aGlzLl9fdGlsZUhlaWdodCArIHRoaXMuX19zcGFjaW5nWSApICsgdGhpcy5fX21hcmdpblk7XHJcblxyXG4gICAgLy8g6riw642w66Gc7Iqk7J2YIHV27KKM7ZGcIOuzgO2ZmOyLnCDsg53quLDripQg66y47KCcIOuVjOusuOyXkCAwLjk5OTk566W8IOqzse2VqFxyXG4gICAgLy9yZXR1cm4gW3gxLHkxLHgxICsgdGhpcy5fX3RpbGVXaWR0aCAqIDAuOTk5OTkseTEgKyB0aGlzLl9fdGlsZUhlaWdodCAqIDAuOTk5OTldO1xyXG4gICAgLy9yZXR1cm4gW3gxLCB5MSwgeDEgKyB0aGlzLl9fdGlsZVdpZHRoICx5MSArIHRoaXMuX190aWxlSGVpZ2h0XTtcclxuICAgIC8vIHJldHVybiBbeDEgPj4+IDAsIHkxID4+PiAwLCB4MSArIHRoaXMuX190aWxlV2lkdGggPj4+IDAsIHkxICsgdGhpcy5fX3RpbGVIZWlnaHQgPj4+IDBdO1xyXG4gICAgcmV0dXJuIFt4MSwgeTEsIHgxICsgdGhpcy5fX3RpbGVXaWR0aCwgeTEgKyB0aGlzLl9fdGlsZUhlaWdodF07XHJcbiAgICAvLyBsZXQgW2EsIGIsIGMsIGRdID0gWzAuMDMsMC4xMjUsLTAuMDMsLTAuMTI1XTtcclxuICAgIC8vIHJldHVybiBbeDEgKyBhLCB5MSArIGIsIHgxICsgdGhpcy5fX3RpbGVXaWR0aCArIGMsIHkxICsgdGhpcy5fX3RpbGVIZWlnaHQgKyBkXTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZU1lc2hEYXRhKCBtLCBpLCB4MSwgeTEsIHgyLCB5MiwgdHgxLCB0eTEsIHR4MiwgdHkyLCBjMSwgYTEsIGMyLCBhMiwgYzMsIGEzLCBjNCwgYTQgKSB7XHJcbiAgICBjb25zdCBbblZ0eCwgblV2LCBuVmMsIG5JZHhdID0gW2kgKiA0LGkgKiA0LCBpICogNCwgaSAqIDZdO1xyXG5cclxuICAgIG0uc2V0VmVydGljZXMoXHJcbiAgICAgICAgblZ0eCArIDAsIHgxLCB5MSxcclxuICAgICAgICBuVnR4ICsgMSwgeDIsIHkxLFxyXG4gICAgICAgIG5WdHggKyAyLCB4MSwgeTIsXHJcbiAgICAgICAgblZ0eCArIDMsIHgyLCB5MlxyXG4gICAgKTtcclxuICAgIG0uc2V0VGV4dHVyZUNvb3JkaW5hdGVzKFxyXG4gICAgICAgIG5VdiArIDAsIHR4MSwgdHkxLFxyXG4gICAgICAgIG5VdiArIDEsIHR4MiwgdHkxLFxyXG4gICAgICAgIG5VdiArIDIsIHR4MSwgdHkyLFxyXG4gICAgICAgIG5VdiArIDMsIHR4MiwgdHkyXHJcbiAgICApO1xyXG4gICAgbS5zZXRDb2xvcnMoXHJcbiAgICAgICAgblZjICsgMCwgYzEsIGExLFxyXG4gICAgICAgIG5WYyArIDEsIGMyLCBhMixcclxuICAgICAgICBuVmMgKyAyLCBjMywgYTMsXHJcbiAgICAgICAgblZjICsgMywgYzQsIGE0XHJcbiAgICApO1xyXG4gICAgbS5zZXRJbmRpY2VzKFxyXG4gICAgICAgIG5JZHggKyAwLCBuVnR4ICsgMCxcclxuICAgICAgICBuSWR4ICsgMSwgblZ0eCArIDEsXHJcbiAgICAgICAgbklkeCArIDIsIG5WdHggKyAyLFxyXG4gICAgICAgIG5JZHggKyAzLCBuVnR4ICsgMSxcclxuICAgICAgICBuSWR4ICsgNCwgblZ0eCArIDMsXHJcbiAgICAgICAgbklkeCArIDUsIG5WdHggKyAyXHJcbiAgICApO1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBUaWxlTWFwIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIC8qKlxyXG4gICAgICpDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRpbGVNYXAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSB7VGV4dHVyZUJhc2V9IHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlV2lkdGhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlSGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NwYWNpbmdYPTBdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NwYWNpbmdZPTBdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21hcmdpblg9MF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWFyZ2luWT0wXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaXNwbGF5V2lkdGg9dGlsZVdpZHRoXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaXNwbGF5SGVpZ2h0PXRpbGVIZWlnaHRdXHJcbiAgICAgKiBAbWVtYmVyb2YgVGlsZU1hcFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvciggd2lkdGgsIGhlaWdodCwgdGV4dHVyZSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBzcGFjaW5nWCA9IDAsIHNwYWNpbmdZID0gMCwgbWFyZ2luWCA9IDAsIG1hcmdpblkgPSAwLCBkaXNwbGF5V2lkdGggPSB0aWxlV2lkdGgsIGRpc3BsYXlIZWlnaHQgPSB0aWxlSGVpZ2h0ICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fX21hcFdpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fX21hcEhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLl9fdGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgdGhpcy5fX3RpbGVXaWR0aCA9IHRpbGVXaWR0aDtcclxuICAgICAgICB0aGlzLl9fdGlsZUhlaWdodCA9IHRpbGVIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fX3NwYWNpbmdYID0gc3BhY2luZ1g7XHJcbiAgICAgICAgdGhpcy5fX3NwYWNpbmdZID0gc3BhY2luZ1k7XHJcbiAgICAgICAgdGhpcy5fX21hcmdpblggPSBtYXJnaW5YO1xyXG4gICAgICAgIHRoaXMuX19tYXJnaW5ZID0gbWFyZ2luWTtcclxuICAgICAgICB0aGlzLl9fZGlzcGxheVdpZHRoID0gZGlzcGxheVdpZHRoIHx8IHRpbGVXaWR0aDtcclxuICAgICAgICB0aGlzLl9fZGlzcGxheUhlaWdodCA9IGRpc3BsYXlIZWlnaHQgfHwgdGlsZUhlaWdodDtcclxuICAgICAgICBjb25zdCBtID0gbmV3IE1lc2goKTtcclxuXHJcbiAgICAgICAgbS5zZXRUZXh0dXJlKCB0ZXh0dXJlICk7XHJcbiAgICAgICAgdGhpcy5fX21lc2ggPSBtO1xyXG4gICAgICAgIHRoaXMudXNlQ3VzdG9tTG9jYWxCb3VuZHMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuXyQkbG9jYWxCb3VuZHMud2lkdGggPSB3aWR0aCAqIHRpbGVXaWR0aDtcclxuICAgICAgICB0aGlzLl8kJGxvY2FsQm91bmRzLmhlaWdodCA9IGhlaWdodCAqIHRpbGVIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5jbGVhckFsbFRpbGVzKCk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCggbSApO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyQWxsVGlsZXMoKSB7XHJcbiAgICAgICAgY29uc3QgW3Z0eCwgaWR4LCB1diwgdmNdID0gW1tdLCBbXSwgW10sIFtdXTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IHkgPSAwOyB5IDwgdGhpcy5fX21hcEhlaWdodDsgeSsrICkge1xyXG4gICAgICAgICAgICBmb3IgKCBsZXQgeCA9IDA7IHggPCB0aGlzLl9fbWFwV2lkdGg7IHgrKyApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFt4MSx5MSx4Mix5Ml0gPSBbeCAqIHRoaXMuX19kaXNwbGF5V2lkdGgseSAqIHRoaXMuX19kaXNwbGF5SGVpZ2h0LCggeCArIDEgKSAqIHRoaXMuX19kaXNwbGF5V2lkdGgsKCB5ICsgMSApICogdGhpcy5fX2Rpc3BsYXlIZWlnaHRdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZ0eC5wdXNoKCB4MSx5MSx4Mix5MSx4MSx5Mix4Mix5MiApO1xyXG4gICAgICAgICAgICAgICAgdXYucHVzaCggMCwwLDAsMCwwLDAsMCwwICk7XHJcbiAgICAgICAgICAgICAgICB2Yy5wdXNoKCAwLDAsMCwwLDAsMCwwLDAgKTtcclxuICAgICAgICAgICAgICAgIGlkeC5wdXNoKCAwLDAsMCwgMCwwLDAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbSA9IHRoaXMuX19tZXNoO1xyXG5cclxuICAgICAgICBtLnNldFZlcnRleEFycmF5KCB2dHggKTtcclxuICAgICAgICBtLnNldEluZGV4QXJyYXkoIGlkeCApO1xyXG4gICAgICAgIG0uc2V0VGV4dHVyZUNvb3JkaW5hdGVBcnJheSggdXYgKTtcclxuICAgICAgICBtLnNldENvbG9yQXJyYXkoIHZjICk7XHJcbiAgICAgICAgdGhpcy5fX21hcCA9IFtdO1xyXG4gICAgfVxyXG5cdFxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHlcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsaXA9ZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2MxPTB4ZmZmZmZmXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthMT0xLjBdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2MyPWMxXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthMj1hMV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYzM9YzFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2EzPWExXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjND1jMV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYTQ9YTFdXHJcbiAgICAgKiBAbWVtYmVyb2YgVGlsZU1hcFxyXG4gICAgICovXHJcbiAgICBzZXRUaWxlKCB4LHksdHgsdHksZmxpcCA9IGZhbHNlLGMxID0gMHhmZmZmZmYsYTEgPSAxLjAsYzIgPSBjMSxhMiA9IGExLGMzID0gYzEsYTMgPSBhMSxjNCA9IGMxLGE0ID0gYTEgKSB7XHJcbiAgICAgICAgaWYgKCB0eCA9PSBudWxsIHx8IHR5ID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaWxlKCB4LHkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLl9fbWFwV2lkdGg7XHJcbiAgICAgICAgY29uc3QgW3gxLHkxLHgyLHkyXSA9IFt4ICogdGhpcy5fX2Rpc3BsYXlXaWR0aCx5ICogdGhpcy5fX2Rpc3BsYXlIZWlnaHQsKCB4ICsgMSApICogdGhpcy5fX2Rpc3BsYXlXaWR0aCwoIHkgKyAxICkgKiB0aGlzLl9fZGlzcGxheUhlaWdodF07XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX19tZXNoO1xyXG4gICAgICAgIGNvbnN0IFt0eDEsdHkxLHR4Mix0eTJdID0gdGlsZVRvUmVjdC5jYWxsKCB0aGlzLHR4LHR5ICk7XHJcbiAgICAgICAgbGV0IHQgPSB0aGlzLl9fbWFwW3kgKiB0aGlzLl9fbWFwV2lkdGggKyB4XTtcclxuXHJcbiAgICAgICAgLy8gaWYgKCB0ID09IG51bGwgKSB7XHJcblxyXG4gICAgICAgIC8vICAgICBjb25zdCBuVnR4ID0gbS5nZXRWZXJ0ZXhBcnJheVNpemUoKTtcclxuXHJcbiAgICAgICAgLy8gICAgIG0ucmVzaXplVmVydGV4QXJyYXkoIG5WdHggKyA0ICk7XHJcbiAgICAgICAgLy8gICAgIG0ucmVzaXplVGV4dHVyZUNvb3JkaW5hdGVBcnJheSggblZ0eCArIDQgKTtcclxuICAgICAgICAvLyAgICAgbS5yZXNpemVDb2xvckFycmF5KCBuVnR4ICsgNCApO1xyXG4gICAgICAgIC8vICAgICBtLnJlc2l6ZUluZGV4QXJyYXkoIG5WdHggLyA0ICogNiArIDYgKTtcclxuICAgICAgICAvLyAgICAgcmVwbGFjZU1lc2hEYXRhKCBtLCBuVnR4IC8gNCAsXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgeDEsIHkxLCB4MiwgeTIsXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgdHgxLCB0eTEsIHR4MiwgdHkyLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIGMxLCBhMSwgYzIsIGEyLCBjMywgYTMsIGM0LCBhNCApO1xyXG4gICAgICAgIC8vICAgICB0ID0gW3R4LCB0eSwgZmxpcCwgYzEsIGExLCBjMiwgYTIsIGMzLCBhMywgYzQsIGE0LCBuVnR4IC8gNCBdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIHJlcGxhY2VNZXNoRGF0YSggbSwgeCArIHkgKiB0aGlzLl9fbWFwV2lkdGgsLy8gdFsxMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB4MSx5MSx4Mix5MixcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHR4MSx0eTEsdHgyLHR5MixcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGMxLGEyLGMyLGEyLGMzLGEzLGM0LGE0ICk7XHJcbiAgICAgICAgdCA9IFt0eCwgdHksIGZsaXAsIGMxLCBhMSwgYzIsIGEyLCBjMywgYTMsIGM0LCBhNCwgeCArIHkgKiB0aGlzLl9fbWFwV2lkdGhdOy8vdFsxMV1dO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgdGhpcy5fX21hcFt5ICogdGhpcy5fX21hcFdpZHRoICsgeF0gPSB0O1xyXG4gICAgfVxyXG5cdFxyXG4gICAgZ2V0VGlsZSggeCx5ICkge1xyXG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLl9fbWFwW3kgKiB0aGlzLl9fbWFwV2lkdGggKyB4XTtcclxuXHJcbiAgICAgICAgaWYgKCB0ICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHRcclxuICAgIGdldEFycmF5KCB4LHkgKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuX19tYXBbeSAqIHRoaXMuX19tYXBXaWR0aCArIHhdO1xyXG5cclxuICAgICAgICBpZiAoIHQgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcG9zID0gdFsxMV07XHJcbiAgICAgICAgY29uc3QgW25WdHgsbklkeF0gPSBbcG9zICogNCxwb3MgKiA2XTtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fX21lc2g7XHJcbiAgICAgICAgY29uc3QgdnR4ID0gW107XHJcbiAgICAgICAgY29uc3QgdXYgPSBbXTtcclxuICAgICAgICBjb25zdCB2YyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyBpKysgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gbS5nZXRWZXJ0ZXgoIG5WdHggKyBpICk7XHJcblxyXG4gICAgICAgICAgICB2dHgucHVzaCggeCx5ICk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeDogdSwgeTogdiB9ID0gbS5nZXRUZXh0dXJlQ29vcmRpbmF0ZSggblZ0eCArIGkgKTtcclxuXHJcbiAgICAgICAgICAgIHV2LnB1c2goIHUsdiApO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbG9yLCBhbHBoYSB9ID0gbS5nZXRDb2xvciggblZ0eCArIGkgKTtcclxuXHJcbiAgICAgICAgICAgIHZjLnB1c2goIGNvbG9yLGFscGhhICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpKysgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtLmdldEluZGV4KCBuSWR4ICsgaSApO1xyXG5cclxuICAgICAgICAgICAgaWR4LnB1c2goIHYgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBbdnR4LHV2LHZjLGlkeF07XHJcbiAgICB9XHJcblx0XHJcbiAgICBjbGVhclRpbGUoIHgseSApIHtcclxuICAgICAgICBjb25zdCB0ID0gdGhpcy5fX21hcFt5ICogdGhpcy5fX21hcFdpZHRoICsgeF07XHJcblxyXG4gICAgICAgIGlmICggdCAhPSBudWxsICkge1xyXG4gICAgICAgICAgICBjb25zdCBuSWR4ID0gdFsxMV0gKiA2O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fX21lc2guc2V0SW5kaWNlcyhcclxuICAgICAgICAgICAgICAgIG5JZHggKyAwLCAwLFxyXG4gICAgICAgICAgICAgICAgbklkeCArIDEsIDAsXHJcbiAgICAgICAgICAgICAgICBuSWR4ICsgMiwgMCxcclxuICAgICAgICAgICAgICAgIG5JZHggKyAzLCAwLFxyXG4gICAgICAgICAgICAgICAgbklkeCArIDQsIDAsXHJcbiAgICAgICAgICAgICAgICBuSWR4ICsgNSwgMFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fX21hcFt5ICogdGhpcy5fX21hcFdpZHRoICsgeF0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLypcclxuXHRzaGlmdChvZmZzZXRYLG9mZnNldFkpIHtcclxuXHRcclxuXHR9XHJcblx0Ki9cclxuXHJcblxyXG4gICAgc2V0VGV4dHVyZSggdGV4dHVyZSApIHtcclxuICAgICAgICB0aGlzLl9fbWVzaC5zZXRUZXh0dXJlKCB0ZXh0dXJlICk7Ly8sIG1hdHJpeCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1NoYWRlcn0gc2hhZGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgVGlsZU1hcFxyXG4gICAgICovXHJcbiAgICBzZXRTaGFkZXIoIHNoYWRlciApIHtcclxuICAgICAgICB0aGlzLl9fbWVzaC5zZXRTaGFkZXIoIHNoYWRlciApO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFRpbGVDb2xvciggeCwgeSwgY29sb3IsIGFscGhhLCBpc0Nvcm5lciApIHtcclxuICAgICAgICBjb25zdCB3ID0gdGhpcy5fX21hcFdpZHRoO1xyXG5cclxuICAgICAgICBpZiAoICFpc0Nvcm5lciApIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuX19tYXBbeSAqIHRoaXMuX19tYXBXaWR0aCArIHhdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0ICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgblZjID0gdFsxMV0gKiA0O1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX19tZXNoLnNldENvbG9ycyhcclxuICAgICAgICAgICAgICAgICAgICBuVmMgKyAwLCBjb2xvciwgYWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgblZjICsgMSwgY29sb3IsIGFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgIG5WYyArIDIsIGNvbG9yLCBhbHBoYSxcclxuICAgICAgICAgICAgICAgICAgICBuVmMgKyAzLCBjb2xvciwgYWxwaGFcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDsvZTrhIjsnZgg7Lus65+sXHJcbiAgICAgICAgICAgIC8vIDEyXHJcbiAgICAgICAgICAgIC8vIDMwXHJcbiAgICAgICAgICAgIGNvbnN0IHQwID0gdGhpcy5fX21hcFt5ICogdGhpcy5fX21hcFdpZHRoICsgeF07XHJcbiAgICAgICAgICAgIGNvbnN0IHQxID0gKCB5ID4gMCAmJiB4ID4gMCApID8gdGhpcy5fX21hcFsoIHkgLSAxICkgKiB0aGlzLl9fbWFwV2lkdGggKyB4IC0gMV0gOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCB0MiA9ICggeSA+IDAgKSA/IHRoaXMuX19tYXBbKCB5IC0gMSApICogdGhpcy5fX21hcFdpZHRoICsgeF0gOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCB0MyA9ICggeCA+IDAgKSA/IHRoaXMuX19tYXBbeSAqIHRoaXMuX19tYXBXaWR0aCArIHggLSAxXSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHQwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX21lc2guc2V0Q29sb3IoIHQwWzExXSAqIDQgKyAwLCBjb2xvciwgYWxwaGEgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCB0MSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19tZXNoLnNldENvbG9yKCB0MVsxMV0gKiA0ICsgMywgY29sb3IsIGFscGhhICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICggdDIgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbWVzaC5zZXRDb2xvciggdDJbMTFdICogNCArIDIsIGNvbG9yLCBhbHBoYSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHQzICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX21lc2guc2V0Q29sb3IoIHQzWzExXSAqIDQgKyAxLCBjb2xvciwgYWxwaGEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5UaWxlTWFwLkZMSVBfRElBR09OQUwgPSBcImZsaXBEaWFnb25hbFwiO1xyXG5UaWxlTWFwLkZMSVBfSE9SSVpPTlRBTCA9IFwiZmxpcEhvcml6b250YWxcIjtcclxuVGlsZU1hcC5GTElQX1ZFUlRJQ0FMID0gXCJmbGlwVmVydGljYWxcIjtcclxuXHJcblxyXG4iLCJcclxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vRXZlbnQnO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBUaW1lciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICAvKipcclxuICAgICAqIO2DgOydtOuouCDqsJzssrTrpbwg66eM65Og64ukLlxyXG4gICAgICog7YOA7J2066i464qUIOuwlOuhnCDsi5zsnpHtlZjsp4Ag7JWK7Jy866mwIHN0YXJ066W8IOu2iOufrOyVvCDsi5zsnpHtlZzri6QuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIG1zIOuLqOychFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXBlYXRDb3VudD0wXSAtIOuqhyDrsojsnYQg67CY67O17ZWY64qUIO2DgOydtOuouOyduOqwgD8gMOydtOuptCDrrLTtlZwg67CY67O1XHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoIGRlbGF5LCByZXBlYXRDb3VudCA9IDAgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XHJcbiAgICAgICAgdGhpcy5yZXBlYXRDb3VudCA9IHJlcGVhdENvdW50O1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgIHRoaXMuX190aW1lciA9IHNldEludGVydmFsKCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBFdmVudCggRXZlbnQuVElNRVIgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgZS50aW1lciA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLnJlcGVhdENvdW50ICE9IDAgJiYgdGhpcy5jb3VudCA+PSB0aGlzLnJlcGVhdENvdW50ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLmRlbGF5ICk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBpZiAoIHRoaXMuX190aW1lciApIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCggdGhpcy5fX3RpbWVyICk7XHJcbiAgICAgICAgICAgIHRoaXMuX190aW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEN1cnJlbnRDb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcclxuICAgIH1cclxuXHJcbiAgICBnZXREZWxheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWxheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGRlbGF5IOunjO2BvOydmCDsp4Dsl7Dsi5zqsIQg7ZuE7JeQIO2VqOyImOulvCDsi6TtlontlZzri6RcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBtcyDri6jsnIQuIDDsnYQg7KSY64+EIOuPmeq4sOyggeycvOuhnCDsi6TtlonrkJjsp4Ag7JWK64qU64ukLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xyXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7VGltZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlbGF5ZWRDYWxsKCBkZWxheSwgZnVuYywgY29udGV4dCApIHtcclxuICAgICAgICBjb25zb2xlLmFzc2VydCggZnVuYyAhPSBudWxsICk7XHJcbiAgICAgICAgY29uc3QgdCA9IG5ldyBUaW1lciggZGVsYXksIDEgKTtcclxuXHJcbiAgICAgICAgdC5hZGRFdmVudExpc3RlbmVyKCBFdmVudC5USU1FUiwgZnVuYywgY29udGV4dCApO1xyXG4gICAgICAgIHQuc3RhcnQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDtmITsnqwg7Iuc6rCE7J2EIOuwgOumrOyEuOy7qOuTnCDri6jsnITroZwg64+M66Ck7KSA64ukXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbm93KCkge1xyXG4gICAgICAgIHJldHVybiAoICtuZXcgRGF0ZSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog7Y287Y+s66i87IqkIO2DgOydtOuouOuKlCBUaW1lci5ub3coKeuztOuLpCDrjZQg7KCV7ZmV7ZWcIOyLnOqwhCDqsITqsqnsnYQg7Lih7KCV7ZWgIOyImCDsnojsp4Drp4xcclxuICAgICAqIOydtOqyg+ydtCDtmITsnqwg7Iuc6rCE7J2EIO2RnOyLnO2VmOqzoCDsnojripQg6rKD7J2AIOyVhOuLmOyXkCDso7zsnZguIFRpbWVyLm5vdygp7JmAIOuLpOuluCDqsJLsnbTri6QuXHJcbiAgICAgKiDqsITqsqnsnYAg66ek7JqwIOygle2Zle2VmOupsCAxbXMg7J207IOB7J2YIO2VtOyDgeuPhOulvCDrj4zroKTspIDri6QuIOq3uOufrOuCmCDsnbQg7Zi47LacIOyekOyytOqwgCDruYTsi7jri6QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0UGVyZm9ybWFjZVRpbWVyKCkge1xyXG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIO2MjOydvOydtOumhOydtOuCmCDroZzqt7jsl5Ag7Lac66Cl7ZWgIOuVjCDsgqzsmqntlZjquLAg7Y647ZWcIElTT+2PrOupp+ydmCDsi5zqsIQg7ZGc7Iuc66W8IOuPjOugpOykgOuLpFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7RGF0ZX0gW2RhdGU9bmV3IERhdGUoKV1cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFNob3J0RGF0ZSggZGF0ZSA9IG5ldyBEYXRlKCkgKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgd2FpdCggbXMgKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUscmVqZWN0ICk9PntcclxuICAgICAgICAgICAgdGhpcy5kZWxheWVkQ2FsbCggbXMscmVzb2x2ZSApO1xyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgd2FpdEZyYW1lKCBmcmFtZSApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSxyZWplY3QgKT0+e1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRDYWxsKCAxMDAwIC8gNjAgKiBmcmFtZSxyZXNvbHZlICk7XHJcbiAgICAgICAgfSApO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBtNCB9IGZyb20gJ3R3Z2wuanMnO1xuXG5cbmV4cG9ydCBjbGFzcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgIHRoaXMuX2FuY2hvclggPSAwO1xuICAgICAgICB0aGlzLl9hbmNob3JZID0gMDtcbiAgICAgICAgdGhpcy5fc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5fc2NhbGVZID0gMTtcbiAgICAgICAgdGhpcy5fcm90YXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9tYXRyaXhEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtNC5pZGVudGl0eSgpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGVDYWxsYmFjayA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9XG5cbiAgICBnZXQgYW5jaG9yWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvclg7XG4gICAgfVxuXG4gICAgZ2V0IGFuY2hvclkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JZO1xuICAgIH1cblxuXG4gICAgZ2V0IHNjYWxlWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWDtcbiAgICB9XG5cbiAgICBnZXQgc2NhbGVZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVZO1xuICAgIH1cblxuICAgIGdldCByb3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uOyAgICAgICBcbiAgICB9XG5cbiAgICBzZXQgeCggdiApIHtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSggdGhpcy5feCAhPSB2ICk7XG4gICAgICAgIHRoaXMuX3ggPSB2O1xuICAgIH1cblxuICAgIHNldCB5KCB2ICkge1xuICAgICAgICB0aGlzLnNldERpcnR5KCB0aGlzLl95ICE9IHYgKTtcbiAgICAgICAgdGhpcy5feSA9IHY7XG4gICAgfVxuXG4gICAgc2V0IGFuY2hvclgoIHYgKSB7XG4gICAgICAgIHRoaXMuc2V0RGlydHkoIHRoaXMuX2FuY2hvclggIT0gdiApO1xuICAgICAgICB0aGlzLl9hbmNob3JYID0gdjtcbiAgICB9XG5cbiAgICBzZXQgYW5jaG9yWSggdiApIHtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSggdGhpcy5fYW5jaG9yWSAhPSB2ICk7XG4gICAgICAgIHRoaXMuX2FuY2hvclkgPSB2O1xuICAgIH1cblxuICAgIHNldCBzY2FsZVgoIHYgKSB7XG4gICAgICAgIHRoaXMuc2V0RGlydHkoIHRoaXMuX3NjYWxlWCAhPSB2ICk7XG4gICAgICAgIHRoaXMuX3NjYWxlWCA9IHY7XG4gICAgfVxuXG4gICAgc2V0IHNjYWxlWSggdiApIHtcbiAgICAgICAgdGhpcy5zZXREaXJ0eSggdGhpcy5fc2NhbGVZICE9IHYgKTtcbiAgICAgICAgdGhpcy5fc2NhbGVZID0gdjtcbiAgICB9XG5cbiAgICBzZXQgcm90YXRpb24oIHYgKSB7XG4gICAgICAgIHRoaXMuc2V0RGlydHkoIHRoaXMuX3JvdGF0aW9uICE9IHYgKTtcbiAgICAgICAgdGhpcy5fcm90YXRpb24gPSB2O1xuICAgIH1cblxuICAgIGdldCBtYXRyaXgoKSB7XG4gICAgICAgIGlmICggdGhpcy5fbWF0cml4RGlydHkgKSB7XG4gICAgICAgICAgICBjb25zdCBtYXQgPSAgbTQudHJhbnNsYXRpb24oIFt0aGlzLl94LHRoaXMuX3ksMF0gKTtcblxuICAgICAgICAgICAgLy8g7JW17Luk66eM7YG8IOyXreycvOuhnCDsnbTrj5ntlZwg64uk7J2MXG4gICAgICAgICAgICAvLyDsl6zquLDqsIAg6rWs67KE7KCE6rO8IOuLpOuluCDsoJBcbiAgICAgICAgICAgIC8vIG00LnRyYW5zbGF0ZSggbWF0LCBbdGhpcy5hbmNob3JQb3NpdGlvbi54LHRoaXMuYW5jaG9yUG9zaXRpb24ueSwwXSxtYXQgKTtcbiAgICAgICAgICAgIG00LnNjYWxlKCBtYXQsIFt0aGlzLl9zY2FsZVgsdGhpcy5fc2NhbGVZLDFdICxtYXQgKTtcbiAgICAgICAgICAgIG00LnJvdGF0ZVooIG1hdCx0aGlzLl9yb3RhdGlvbiAqIE1hdGguUEkgLyAxODAgLG1hdCApOyAgICAgICAgXG4gICAgICAgICAgICAvLyDsl6zquLDshJwg64uk7IucIOyVtey7pOunjO2BvCDsnbTrj5ntlbTslbwg7ZWY64qU642wXG4gICAgICAgICAgICAvLyDsnbQg7LKY66as64qUIHZz7JeQ7IScIO2VnOuLpFxuICAgICAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0O1xuICAgICAgICAgICAgdGhpcy5fbWF0cml4RGlydHkgPSBmYWxzZTtcbiAgICAgICAgfSBcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeDtcbiAgICB9XG5cbiAgICBzZXREaXJ0eSggdiApIHtcbiAgICAgICAgaWYgKCB0aGlzLmludmFsaWRhdGVDYWxsYmFjayAmJiB2ICkge1xuICAgICAgICAgICAgLy8gX21hdHJpeERpcnR56rCAIOydtOuyiOyXkCBmYWxzZeyXkOyEnCB0cnVl6rCAIOuQoCDrlYzrp4wg7Zi47Lac7ZWY64qU6rKMIOyVhOuLiOqzoFxuICAgICAgICAgICAgLy8gdHJ1ZeyXkOyEnCB0cnVl6rCAIOuQoCDrlYzrj4Qg7Zi47LacIO2VnOuLpC5cbiAgICAgICAgICAgIC8vIOq3uOuemOyVvCBfYm91bmRzRGlydHnqsIAg7KCc64yA66GcIOyymOumrCDrkJjquLAg65WM66y4XG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGVDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hdHJpeERpcnR5ID0gdGhpcy5fbWF0cml4RGlydHkgfHwgdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHJldHVybnMge1RyYW5zZm9ybX0gXG4gICAgICogQG1lbWJlcm9mIFRyYW5zZm9ybVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBuZXdUcmFuc2Zvcm0gPSB7fTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKCBuZXdUcmFuc2Zvcm0sdGhpcyApO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoIG5ld1RyYW5zZm9ybSx0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSApO1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG5ld1RyYW5zZm9ybTtcbiAgICB9XG59XG5cblxuIiwiXG5pbXBvcnQgeyBBc3NldCB9IGZyb20gJy4vQXNzZXQnO1xuaW1wb3J0IHsgRm9udEJhc2UgfSBmcm9tICcuL0ZvbnRCYXNlJztcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAnLi9VdGlscyc7XG5cbmV4cG9ydCBjbGFzcyBUcnVlVHlwZUZvbnQgZXh0ZW5kcyBGb250QmFzZSB7XG4gICAgY29uc3RydWN0b3IoIHRydWVUeXBlRm9udE5hbWUscmVmZXJlbmNlU2l6ZSwgc3R5bGVzICkge1xuICAgICAgICBzdXBlciggdHJ1ZVR5cGVGb250TmFtZSwgcmVmZXJlbmNlU2l6ZSwgc3R5bGVzICk7XG4gICAgICAgIC8vIFRURlxuICAgICAgICB0aGlzLmFzc2V0ID0gbmV3IEFzc2V0KCB0cnVlVHlwZUZvbnROYW1lLEFzc2V0LkFzc2V0VHlwZXMuVHJ1ZVR5cGVGb250ICk7XG4gICAgICAgIHRoaXMuYXNzZXQubG9hZCggeyBcbiAgICAgICAgICAgIHJlZmVyZW5jZVNpemU6IHRoaXMucmVmZXJlbmNlU2l6ZSwgXG4gICAgICAgICAgICBzdHlsZXM6ICAgICAgICB0aGlzLnN0eWxlcyBcbiAgICAgICAgfSApO1xuICAgICAgICB0aGlzLmZvbnRMb2FkZWQgPSBmYWxzZTtcbiAgICB9ICAgIFxuXG4gICAgbWVhc3VyZVRleHRXaWR0aCggc3RyLHNpemUgKSB7XG4gICAgICAgIHN1cGVyLm1lYXN1cmVUZXh0V2lkdGgoIHN0cixzaXplICk7XG5cbiAgICAgICAgY29uc3QgZm9udEluZm8gPSB0aGlzLmFzc2V0LmZvbnRJbmZvO1xuXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQ29kZUF0KCBpICk7XG4gICAgICAgICAgICBjb25zdCBjaGFySW5mbyA9IGZvbnRJbmZvLmNoYXJzW2NoYXJdO1xuXG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGNoYXJJbmZvICkgKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggKz0gY2hhckluZm9bMF07XG4gICAgICAgICAgICAgICAgaWYgKCBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAvLyDtgazroazsl5DshJzripQg7J20IOyymOumrOqwgCDtlYTsmpTsl4bripQg6rKDIOqwmeydjC4g64uk66W4IOu4jOudvOyasOyggOyXkOyEnCDtmZXsnbgg7ZWE7JqUXG4gICAgICAgICAgICAgICAgLy8g7LKr6riA7J6Q6rCAIOyVnuycvOuhnCDsgpDsoLjrgpjsmKgg6rK97JqwXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA9PSAwICYmIGNoYXJJbmZvWzFdIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IC1jaGFySW5mb1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyDrp4jsp4Drp4kg6riA7J6Q6rCAIOuSpOuhnCDsgpDsoLjrgpjsmKgg6rK97JqwXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA9PSBzdHIubGVuZ3RoIC0gMSAmJiBjaGFySW5mb1syXSA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBjaGFySW5mb1syXTtcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaGFySW5mbyAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IGNoYXJJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBpIDwgc3RyLmxlbmd0aCAtIDEgJiYgZm9udEluZm8ua2VybmluZ1BhaXJzICkge1xuICAgICAgICAgICAgLy/rp4jsp4Drp4kg6riA7J6Q6rCAIOyVhOuLjOqyveyasCBrZXJuaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhck5leHQgPSBzdHIuY2hhckNvZGVBdCggaSArIDEgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGtlcm5pbmcgPSBmb250SW5mby5rZXJuaW5nUGFpcnNbY2hhciArIFwiLFwiICsgY2hhck5leHRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBrZXJuaW5nICkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBrZXJuaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGggLyBmb250SW5mby51bml0c1BlckVtICogKCBzaXplIHx8IHRoaXMucmVmZXJlbmNlU2l6ZSApO1xuICAgIH1cbn1cblxuXG4iLCJpbXBvcnQgeyBFdmVudCB9IGZyb20gJy4vRXZlbnQnO1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXInO1xuaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAnLi9TcHJpdGUnO1xuaW1wb3J0IHsgZWFzaW5nIH0gZnJvbSAnLi9lYXNpbmcnO1xuaW1wb3J0IHsgU3RhZ2UgfSBmcm9tICcuL1N0YWdlJztcbmltcG9ydCB7IGFwcGxpY2F0aW9uIH0gZnJvbSAnLi9BcHBsaWNhdGlvbic7XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvcFxuICogQHByb3BlcnR5IHtmdW5jdGlvbnxzdHJpbmc9fSBlYXNlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW49fSBhdXRvUGxheVxuICogQHByb3BlcnR5IHtib29sZWFuPX0gc3dhcFZhbHVlc1xuICogQHByb3BlcnR5IHtib29sZWFuPX0gcmVmbGVjdFxuICogQHByb3BlcnR5IHtudW1iZXI9fSBkZWxheVxuICogQHByb3BlcnR5IHtudW1iZXI9fSByZXBlYXRDb3VudFxuICogQHByb3BlcnR5IHtib29sZWFuPX0gZGlzcGF0Y2hFdmVudHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyPX0gdGltZVNjYWxlXG4gKiBAcHJvcGVydHkge1R3ZWVuPX0gbmV4dFR3ZWVuXG4gKi9cblxuXG5cbi8qXG5iYXNlIG9uIEdUd2VlbiBmb3IgR2lkZXJvcztcblRoaXMgY29kZSBpcyBNSVQgbGljZW5zZWQsIHNlZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocDtcbkNvcHlyaWdodCAoYykgMjAxMCAtIDIwMTEgR2lkZXJvcyBNb2JpbGU7XG5CYXNlZCBvbiBUd2VlbiAyLjAxIGZvciBBY3Rpb25TY3JpcHQgMztcbmh0dHA6Ly9nc2tpbm5lci5jb20vbGlicmFyaWVzL0dUd2Vlbi9cbkdUd2VlbiAyLjAxIGZvciBBY3Rpb25TY3JpcHQgMyBpcyBNSVQgbGljZW5zZWQsIHNlZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocDtcbkNvcHlyaWdodCAoYykgMjAwOSBHcmFudCBTa2lubmVyO1xuTm90ZXM6XG4qIERvY3VtZW50YXRpb24gaXMgZGVyaXZlZCBmcm9tIEdUd2VlbiAyLjAxJ3Mgb3JpZ2luYWwgZG9jdW1lbnRhdGlvbi5cbiovXG5cbi8qXG5cdCogVHdlZW4gaXMgYSBsaWdodC13ZWlnaHQgaW5zdGFuY2Ugb3JpZW50ZWQgdHdlZW4gZW5naW5lLiBUaGlzIG1lYW5zIHRoYXQgeW91IGluc3RhbnRpYXRlIHR3ZWVucyBmb3Igc3BlY2lmaWMgcHVycG9zZXMsICYmIHRoZW4gcmV1c2UsIHVwZGF0ZSB8fCBkaXNjYXJkIHRoZW0uXG5cdCogVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBjZW50cmFsaXplZCB0d2VlbiBlbmdpbmVzIHdoZXJlIHlvdSBcInJlZ2lzdGVyXCIgdHdlZW5zIHdpdGggYSBnbG9iYWwgb2JqZWN0LiBUaGlzIHByb3ZpZGVzIGEgbW9yZSBmYW1pbGlhciAmJiB1c2VmdWwgaW50ZXJmYWNlO1xuXHQqIGZvciBvYmplY3Qgb3JpZW50ZWQgcHJvZ3JhbW1lcnMuXG5cblx0KiBUd2VlbiBib2FzdHMgYSBudW1iZXIgb2YgYWR2YW5jZWQgZmVhdHVyZXM6XG5cdCogLSBmcmFtZSAmJiB0aW1lIGJhc2VkIGR1cmF0aW9ucy9wb3NpdGlvbnMgd2hpY2ggY2FuIGJlIHNldCBwZXIgdHdlZW47XG5cdCogLSBzaW1wbGUgc2VxdWVuY2VkIHR3ZWVucyB1c2luZyAubmV4dFR3ZWVuO1xuXHQqIC0gcGF1c2UgJiYgcmVzdW1lIGluZGl2aWR1YWwgdHdlZW5zIHx8IGFsbCB0d2VlbnM7XG5cdCogLSBqdW1wIGRpcmVjdGx5IHRvIHRoZSB9IHx8IGJlZ2lubmluZyBvZiBhIHR3ZWVuIHdpdGggOnRvRW5kKCkgfHwgOnRvQmVnaW5uaW5nKCk7XG5cdCogLSBqdW1wIHRvIGFueSBhcmJpdHJhcnkgcG9pbnQgaW4gdGhlIHR3ZWVuIHdpdGggOnNldFBvc2l0aW9uKCk7XG5cdCogLSBjb21wbGV0ZSwgaW5pdCwgJiYgY2hhbmdlIGNhbGxiYWNrcztcblx0KiAtIHNtYXJ0IGdhcmJhZ2UgY29sbGVjdG9yIGludGVyYWN0aW9ucyAocHJldmVudHMgY29sbGVjdGlvbiB3aGlsZSBhY3RpdmUsIGFsbG93cyBjb2xsZWN0aW9uIGlmIHRhcmdldCBpcyBjb2xsZWN0ZWQpO1xuXHQqIC0gZWFzeSB0byBzZXQgdXAgaW4gYSBzaW5nbGUgbGluZSBvZiBjb2RlO1xuXHQqIC0gY2FuIHJlcGVhdCB8fCByZWZsZWN0IGEgdHdlZW4gYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzO1xuXHQqIC0gZGV0ZXJtaW5pc3RpYywgc28gc2V0dGluZyBhIHBvc2l0aW9uIG9uIGEgdHdlZW4gd2lsbCAoYWxtb3N0KSBhbHdheXMgcmVzdWx0IGluIHByZWRpY3RhYmxlIHJlc3VsdHM7XG4qL1xuXG5mdW5jdGlvbiBoZXhUb1JnYiggYyApIHtcbiAgICByZXR1cm4gWyggYyA+PiAxNiApIC8gMjU1LCAoICggYyA+PiA4ICkgJiAweGZmICkgLyAyNTUsICggYyAmIDB4ZmYgKSAvIDI1NV07XG59XG5cblxuY29uc3QgY29weVRpY2tMaXN0ID0gW107XG5cbmV4cG9ydCBjbGFzcyBUd2VlbiBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG4gICAgLyoqXG4gICAgICpDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFR3ZWVuLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufFByb3A9fSBwcm9wc1xuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCB0YXJnZXQsIGR1cmF0aW9uLCB2YWx1ZXMsIHByb3BzICkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9kZWxheSA9IDA7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gTnVtYmVyLk5hTjtcbiAgICAgICAgdGhpcy5faXNFbmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRvUGxheSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVwZWF0Q291bnQgPSAxO1xuICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IDE7XG4gICAgICAgIHRoaXMuZWFzZSA9IFR3ZWVuLmRlZmF1bHRFYXNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRzID0gVHdlZW4uZGVmYXVsdERpc3BhdGNoRXZlbnRzO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnJlZmxlY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmV4dFR3ZWVuID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgc3dhcCA9IG51bGw7XG5cbiAgICAgICAgaWYgKCB0eXBlb2YgcHJvcHMgPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBwcm9wcyA9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBwcm9wcyA9IHsgZWFzZTogcHJvcHMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcHJvcHMgIT0gbnVsbCApIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgc3dhcCA9IHByb3BzLnN3YXBWYWx1ZXM7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHByb3BzLnN3YXBWYWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbiggdGhpcywgcHJvcHMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdHlwZW9mIHRoaXMuZWFzZSA9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgdGhpcy5lYXNlID0gZWFzaW5nW3RoaXMuZWFzZV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmFzc2VydCggdGhpcy5lYXNlICE9IG51bGwgKTtcbiAgICAgICAgdGhpcy5yZXNldFZhbHVlcyggdmFsdWVzICk7XG5cbiAgICAgICAgaWYgKCBzd2FwICkge1xuICAgICAgICAgICAgdGhpcy5zd2FwVmFsdWVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuZHVyYXRpb24gPT0gMCAmJiB0aGlzLmdldERlbGF5KCkgPT0gMCAmJiB0aGlzLmF1dG9QbGF5ICkge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiggMCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhVHdlZW4uYWN0aXZlICkge1xuICAgICAgICAgICAgYXBwbGljYXRpb24uc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lciggRXZlbnQuRU5URVJfRlJBTUUsIFR3ZWVuLm9uVGljayApO1xuICAgICAgICAgICAgVHdlZW4uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG5cdFx0KiBQbGF5cyBvciBwYXVzZXMgYSB0d2Vlbi4gWW91IGNhbiBzdGlsbCBjaGFuZ2UgdGhlIHBvc2l0aW9uIHZhbHVlIGV4dGVybmFsbHkgb24gYSBwYXVzZWQ7XG5cdFx0KiB0d2VlbiwgYnV0IGl0IHdpbGwgIWJlIHVwZGF0ZWQgYXV0b21hdGljYWxseS4gV2hpbGUgcGF1c2VkIGlzIGZhbHNlLCB0aGUgdHdlZW4gaXMgYWxzbyBwcmV2ZW50ZWQ7XG5cdFx0KiBmcm9tIGJlaW5nIGdhcmJhZ2UgY29sbGVjdGVkIHdoaWxlIGl0IGlzIGFjdGl2ZS5cblx0XHQqIFRoaXMgaXMgYWNoaWV2ZWQgaW4gb25lIG9mIHR3byB3YXlzOlxuXHRcdCogMS4gSWYgdGhlIHRhcmdldCBvYmplY3QgZGVyaXZlcyBmcm9tIEV2ZW50RGlzcGF0Y2hlciwgdGhlbiB0aGUgdHdlZW4gd2lsbCBzdWJzY3JpYmUgdG8gYSBkdW1teSBldmVudCB1c2luZyBhIGhhcmQgcmVmZXJlbmNlLiBUaGlzIGFsbG93cztcblx0XHQqIHRoZSB0d2VlbiB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZCBpZiBpdHMgdGFyZ2V0IGlzIGFsc28gY29sbGVjdGVkLCAmJiB0aGVyZSBhcmUgbm8gb3RoZXIgZXh0ZXJuYWwgcmVmZXJlbmNlcyB0byBpdC5cblx0XHQqIDIuIElmIHRoZSB0YXJnZXQgb2JqZWN0IGlzICFhbiBFdmVudERpc3BhdGNoZXIsIHRoZW4gdGhlIHR3ZWVuIGlzIHBsYWNlZCBpbiBhIGdsb2JhbCBsaXN0LCB0byBwcmV2ZW50IGNvbGxlY3Rpb24gdW50aWwgaXQgaXMgcGF1c2VkIHx8IGNvbXBsZXRlcy5cblx0XHQqIE5vdGUgdGhhdCBwYXVzaW5nIGFsbCB0d2VlbnMgdmlhIHRoZSBUd2Vlbi5wYXVzZUFsbCBzdGF0aWMgcHJvcGVydHkgd2lsbCAhZnJlZSB0aGUgdHdlZW5zIGZvciBjb2xsZWN0aW9uLlxuXHQqL1xuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgVHdlZW5cbiAgICAgKi9cbiAgICBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgICB9XG5cblxuICAgIGlzRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNFbmQ7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zZXRQYXVzZWQoIHRydWUgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIHNldFBhdXNlZCggdmFsdWUgKSB7XG4gICAgICAgIGlmICggdmFsdWUgPT0gdGhpcy5fcGF1c2VkICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKCB0aGlzLl9wYXVzZWQgKSB7XG4gICAgICAgICAgICBUd2Vlbi5hY3RpdmVUd2Vlbkxpc3QuZGVsZXRlKCB0aGlzICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIE51bWJlci5pc05hTiggdGhpcy5fcG9zaXRpb24gKSB8fCAoIHRoaXMucmVwZWF0Q291bnQgIT0gMCAmJiB0aGlzLl9wb3NpdGlvbiA+PSB0aGlzLnJlcGVhdENvdW50ICogdGhpcy5kdXJhdGlvbiApICkge1xuICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgdGhlIGVuZCwgcmVzZXQuXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZFBvc2l0aW9uT2xkID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdGlvID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdGlvT2xkID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uT2xkID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IC10aGlzLmdldERlbGF5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFR3ZWVuLmFjdGl2ZVR3ZWVuTGlzdC5zZXQoIHRoaXMsdHJ1ZSApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcEFsbCgpIHtcbiAgICAgICAgZm9yICggY29uc3QgW3R3ZWVuXSBvZiBUd2Vlbi5hY3RpdmVUd2Vlbkxpc3QgKSB7XG4gICAgICAgICAgICB0d2Vlbi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qXG5cdFx0KiBHZXRzICYmIHNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0d2VlbiBpbiBmcmFtZXMgfHwgc2Vjb25kcyAoZGVwZW5kaW5nIG9uIC51c2VGcmFtZXMpLiBUaGlzIHZhbHVlIHdpbGw7XG5cdFx0KiBiZSBjb25zdHJhaW5lZCBiZXR3ZWVuIC1kZWxheSAmJiByZXBlYXRDb3VudCpkdXJhdGlvbi4gSXQgd2lsbCBiZSByZXNvbHZlZCB0byBhIC5jYWxjdWxhdGVkUG9zaXRpb24gYmVmb3JlO1xuXHRcdCogYmVpbmcgYXBwbGllZC5cblx0XHQqXG5cdFx0KiBOZWdhdGl2ZSB2YWx1ZXM6XG5cdFx0KiBWYWx1ZXMgYmVsb3cgMCB3aWxsIGFsd2F5cyByZXNvbHZlIHRvIGEgY2FsY3VsYXRlZFBvc2l0aW9uIG9mIDAuIE5lZ2F0aXZlIHZhbHVlcyBjYW4gYmUgdXNlZCB0byBzZXQgdXAgYSBkZWxheSBvbiB0aGUgdHdlZW4sIGFzIHRoZSB0d2VlbiB3aWxsIGhhdmUgdG8gY291bnQgdXAgdG8gMCBiZWZvcmUgaW5pdGluZy5cblx0XHQqXG5cdFx0KiBQb3NpdGl2ZSB2YWx1ZXM6XG5cdFx0KiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIHJlc29sdmVkIGJhc2VkIG9uIHRoZSBkdXJhdGlvbiwgcmVwZWF0Q291bnQsICYmIHJlZmxlY3QgcHJvcGVydGllcy5cblx0Ki9cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uKCBwb3MgKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25PbGQgPSB0aGlzLl9wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5yYXRpb09sZCA9IHRoaXMucmF0aW87XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlZFBvc2l0aW9uT2xkID0gdGhpcy5jYWxjdWxhdGVkUG9zaXRpb247XG4gICAgICAgIGNvbnN0IG1heFBvc2l0aW9uID0gdGhpcy5yZXBlYXRDb3VudCAqIHRoaXMuZHVyYXRpb247XG4gICAgICAgIGNvbnN0IGlzRW5kID0gcG9zID49IG1heFBvc2l0aW9uICYmIHRoaXMucmVwZWF0Q291bnQgPiAwO1xuXG4gICAgICAgIGlmICggaXNFbmQgKSB7XG4gICAgICAgICAgICBpZiAoIHRoaXMuY2FsY3VsYXRlZFBvc2l0aW9uT2xkID09IG1heFBvc2l0aW9uICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBtYXhQb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZFBvc2l0aW9uID0gKCB0aGlzLnJlZmxlY3QgJiYgKCB0aGlzLnJlcGVhdENvdW50ICUgMiA9PSAwICkgKSAmJiAwIHx8IHRoaXMuZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHBvcztcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZFBvc2l0aW9uID0gKCB0aGlzLl9wb3NpdGlvbiA8IDAgKSA/IDAgOiAoIHRoaXMuX3Bvc2l0aW9uICUgdGhpcy5kdXJhdGlvbiApO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMucmVmbGVjdCAmJiBNYXRoLmZsb29yKCB0aGlzLmdldFBvc2l0aW9uKCkgLyB0aGlzLmR1cmF0aW9uICkgJSAyICE9IDAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkUG9zaXRpb24gPSB0aGlzLmR1cmF0aW9uIC0gdGhpcy5jYWxjdWxhdGVkUG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJhdGlvID0gKCB0aGlzLmR1cmF0aW9uID09IDAgJiYgdGhpcy5fcG9zaXRpb24gPj0gMCApID8gMSA6IHRoaXMuZWFzZSggdGhpcy5jYWxjdWxhdGVkUG9zaXRpb24gLyB0aGlzLmR1cmF0aW9uLCAwLCAxLCAxICk7XG5cbiAgICAgICAgaWYgKCB0aGlzLnRhcmdldCAmJiAoIHRoaXMuX3Bvc2l0aW9uID49IDAgfHwgdGhpcy5wb3NpdGlvbk9sZCA+PSAwICkgJiYgdGhpcy5jYWxjdWxhdGVkUG9zaXRpb24gIT0gdGhpcy5jYWxjdWxhdGVkUG9zaXRpb25PbGQgKSB7XG4gICAgICAgICAgICBpZiAoICF0aGlzLl9pbml0ZWQgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoIGNvbnN0IG4gaW4gdGhpcy5fZW5kVmFsdWVzICkge1xuICAgICAgICAgICAgICAgIGxldCBpbml0VmFsLCByYW5nZVZhbCwgdmFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBuID09IFwiY29sb3JcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g7Lus65+s64qUIOyqvOqwnOyEnCDtirjsnIjtlbTslbztlZzri6RcbiAgICAgICAgICAgICAgICAgICAgaW5pdFZhbCA9IHRoaXMuX2luaXRWYWx1ZXNbbl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlVmFsID0gdGhpcy5fcmFuZ2VWYWx1ZXNbbl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbDEgID0gaW5pdFZhbFswXSArIHJhbmdlVmFsWzBdICogdGhpcy5yYXRpbztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsMiAgPSBpbml0VmFsWzFdICsgcmFuZ2VWYWxbMV0gKiB0aGlzLnJhdGlvO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwzICA9IGluaXRWYWxbMl0gKyByYW5nZVZhbFsyXSAqIHRoaXMucmF0aW87XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuc2V0Q29sb3JNdWx0aXBsaWVyKCB2YWwxLCB2YWwyLCB2YWwzICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFZhbCA9IHRoaXMuX2luaXRWYWx1ZXNbbl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlVmFsID0gdGhpcy5fcmFuZ2VWYWx1ZXNbbl07XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGluaXRWYWwgKyByYW5nZVZhbCAqIHRoaXMucmF0aW87XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCB0aGlzLnRhcmdldFtuXSAhPSBudWxsICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0W25dID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5kaXNwYXRjaEV2ZW50cyApIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggXCJjaGFuZ2VcIiApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpc0VuZCApIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGF1c2VkKCB0cnVlICk7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5uZXh0VHdlZW4gKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0VHdlZW4uc2V0UGF1c2VkKCBmYWxzZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRoaXMuZGlzcGF0Y2hFdmVudHMgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBcImNvbXBsZXRlXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLypcblx0XHQqIFRoZSBsZW5ndGggb2YgdGhlIGRlbGF5IGluIGZyYW1lcyB8fCBzZWNvbmRzIChkZXBlbmRpbmcgb24gLnVzZUZyYW1lcykuXG5cdFx0KiBUaGUgZGVsYXkgb2NjdXJzIGJlZm9yZSBhIHR3ZWVuIHJlYWRzIGluaXRpYWwgdmFsdWVzIHx8IHN0YXJ0cyBwbGF5aW5nLlxuXHQqL1xuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIGdldERlbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgKiBAbWVtYmVyb2YgVHdlZW5cbiAgICAgKi9cbiAgICBzZXREZWxheSggdmFsdWUgKSB7XG4gICAgICAgIGlmICggdGhpcy5fcG9zaXRpb24gPD0gMCApIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gLXZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVsYXkgPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIC8qXG5cdFx0KiBTZXRzIHRoZSBudW1lcmljIGVuZCB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IG9iamVjdCB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHR3ZWVuLlxuXHRcdCogRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50ZWQgdG8gdHdlZW4gdG8gYSBuZXcgeCBwb3NpdGlvbiwgeW91IGNvdWxkIHVzZTogbXlUd2Vlbi5zZXRWYWx1ZShcInhcIiw0MDApLlxuXHRcdCpcblx0XHQqIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byB0d2Vlbi5cblx0XHQqIHZhbHVlOiBUaGUgbnVtZXJpYyBlbmQgdmFsdWUgKHRoZSB2YWx1ZSB0byB0d2VlbiB0bykuXG5cdCovXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgKiBAbWVtYmVyb2YgVHdlZW5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZSggbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgIHRoaXMuX2VuZFZhbHVlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKlxuXHRcdCogUmV0dXJucyB0aGUgZW5kIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlmIG9uZSBleGlzdHMuXG5cdFx0KlxuXHRcdCogbmFtZTogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHVybiBhIH0gdmFsdWUgZm9yLlxuXHQqL1xuICAgIGdldFZhbHVlKCBuYW1lICkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVmFsdWVzW25hbWVdO1xuICAgIH1cblxuICAgIC8qXG5cdFx0KiBSZW1vdmVzIGEgZW5kIHZhbHVlIGZyb20gdGhlIHR3ZWVuLiBUaGlzIHByZXZlbnRzIHRoZSBUd2VlbiBpbnN0YW5jZSBmcm9tIHR3ZWVuaW5nIHRoZSBwcm9wZXJ0eS5cblx0XHQqXG5cdFx0KiBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgZW5kIHByb3BlcnR5IHRvIGRlbGV0ZS5cblx0Ki9cbiAgICBkZWxldGVWYWx1ZSggbmFtZSApIHtcbiAgICAgICAgdGhpcy5fcmFuZ2VWYWx1ZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICB0aGlzLl9pbml0VmFsdWVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZW5kVmFsdWVzW25hbWVdICE9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZW5kVmFsdWVzW25hbWVdID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuXG4gICAgLypcblx0XHQqIFNob3J0aGFuZCBtZXRob2QgZm9yIG1ha2luZyBtdWx0aXBsZSBzZXRQcm9wZXJ0eSBjYWxscyBxdWlja2x5LlxuXHRcdCogVGhpcyBhZGRzIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcyB0byB0aGUgdmFsdWVzIGxpc3QuXG5cdFx0KiBcblx0XHQqIEV4YW1wbGU6IHNldCB4IGFuZCB5IGVuZCB2YWx1ZXM6XG5cdFx0KiBteVR3ZWVuLnNldEVuZFZhbHVlcyh7eDoyMDAsIHk6NDAwfSk7XG5cdFx0KlxuXHRcdCogcHJvcGVydGllczogQW4gb2JqZWN0IGNvbnRhaW5pbmcgZW5kIHByb3BlcnR5IHZhbHVlcy5cblx0Ki9cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgKiBAbWVtYmVyb2YgVHdlZW5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZXMoIHZhbHVlcyApIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbiggdGhpcy5fZW5kVmFsdWVzLCB2YWx1ZXMgKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLypcblx0XHQqIFNpbWlsYXIgdG8gLnNldEVuZFZhbHVlcygpLCBidXQgY2xlYXJzIGFsbCBwcmV2aW91cyBlbmQgdmFsdWVzO1xuXHRcdCogYmVmb3JlIHNldHRpbmcgdGhlIG5ldyBvbmVzLlxuXHRcdCpcblx0XHQqIHByb3BlcnRpZXM6IEFuIG9iamVjdCBjb250YWluaW5nIGVuZCBwcm9wZXJ0eSB2YWx1ZXMuXG5cdCovXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVzXG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIHJlc2V0VmFsdWVzKCB2YWx1ZXMgKSB7XG4gICAgICAgIHRoaXMuX2VuZFZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLnNldFZhbHVlcyggdmFsdWVzICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLypcblx0XHQqIFJldHVybnMgdGhlIHRhYmxlIG9mIGFsbCBlbmQgcHJvcGVydGllcyAmJiB0aGVpciB2YWx1ZXMuIFRoaXMgaXMgYSBjb3B5IG9mIHZhbHVlcywgc28gbW9kaWZ5aW5nO1xuXHRcdCogdGhlIHJldHVybmVkIG9iamVjdCB3aWxsIG5vdCBhZmZlY3QgdGhlIHR3ZWVuLlxuXHQqL1xuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIGdldFZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLl9lbmRWYWx1ZXMgKTtcbiAgICB9XG5cbiAgICAvKlxuXHRcdCogUmV0dXJucyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cblx0XHQqIE5vdGUgdGhhdCB0aGUgdmFsdWUgd2lsbCBub3QgYmUgYXZhaWxhYmxlIHVudGlsIHRoZSB0d2VlbiBpbml0cy5cblx0Ki9cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAbWVtYmVyb2YgVHdlZW5cbiAgICAgKi9cbiAgICBnZXRJbml0VmFsdWUoIG5hbWUgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0VmFsdWVzW25hbWVdO1xuICAgIH1cblxuICAgIC8qXG5cdFx0KiBTd2FwcyB0aGUgaW5pdCAmJiB9IHZhbHVlcyBmb3IgdGhlIHR3ZWVuLCBlZmZlY3RpdmVseSByZXZlcnNpbmcgaXQuXG5cdFx0KiBUaGlzIHNob3VsZCBnZW5lcmFsbHkgb25seSBiZSBjYWxsZWQgYmVmb3JlIHRoZSB0d2VlbiBzdGFydHMgcGxheWluZy5cblx0XHQqIFRoaXMgd2lsbCBmb3JjZSB0aGUgdHdlZW4gdG8gaW5pdCBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBkb25lIHNvLCB3aGljaDtcblx0XHQqIG1heSByZXN1bHQgaW4gYW4gb25Jbml0IGNhbGwuXG5cdFx0KiBJdCB3aWxsIGFsc28gZm9yY2UgYSByZW5kZXIgKHNvIHRoZSB0YXJnZXQgaW1tZWRpYXRlbHkganVtcHMgdG8gdGhlIG5ldyB2YWx1ZXM7XG5cdFx0KiBpbW1lZGlhdGVseSkgd2hpY2ggd2lsbCByZXN1bHQgaW4gdGhlIG9uQ2hhbmdlIGNhbGxiYWNrIGJlaW5nIGNhbGxlZC5cblx0XHQqIFxuXHRcdCogWW91IGNhbiBhbHNvIHVzZSB0aGUgc3BlY2lhbCBcInN3YXBWYWx1ZXNcIiBwcm9wZXJ0eSBvbiB0aGUgcHJvcHMgcGFyYW1ldGVyIG9mO1xuXHRcdCogdGhlIFR3ZWVuIGNvbnN0cnVjdG9yIHRvIGNhbGwgOnN3YXBWYWx1ZXMoKSBhZnRlciB0aGUgdmFsdWVzIGFyZSBzZXQuXG5cdFx0KiBcblx0XHQqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSB3b3VsZCB0d2VlbiB0aGUgdGFyZ2V0IGZyb20gMTAwLDEwMCB0byBpdHMgY3VycmVudCBwb3NpdGlvbjpcblx0XHQqIG5ldyBUd2VlbihiYWxsLCAyLCB7eD0xMDAsIHk9MTAwfSwge3N3YXBWYWx1ZXM9dHJ1ZX0pO1xuXHQqL1xuICAgIHN3YXBWYWx1ZXMoKSB7XG4gICAgICAgIGlmICggIXRoaXMuX2luaXRlZCApIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX2VuZFZhbHVlcztcblxuICAgICAgICB0aGlzLl9lbmRWYWx1ZXMgPSB0aGlzLl9pbml0VmFsdWVzO1xuICAgICAgICB0aGlzLl9pbml0VmFsdWVzID0gbztcblxuICAgICAgICBmb3IgKCBjb25zdCBuIGluIHRoaXMuX3JhbmdlVmFsdWVzICkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuX3JhbmdlVmFsdWVzW25dO1xuXG4gICAgICAgICAgICB0aGlzLl9yYW5nZVZhbHVlc1tuXSA9IC12O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVkUG9zaXRpb24gPSBudWxsO1xuXG4gICAgICAgIGlmICggdGhpcy5fcG9zaXRpb24gPCAwICkge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5wb3NpdGlvbk9sZDtcblxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiggMCApO1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uT2xkO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbk9sZCA9IHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oIHRoaXMuX3Bvc2l0aW9uICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuXHRcdCogUmVhZHMgYWxsIG9mIHRoZSBpbml0aWFsIHZhbHVlcyBmcm9tIHRhcmdldCAmJiBjYWxscyB0aGUgb25Jbml0IGNhbGxiYWNrLlxuXHRcdCogVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIGEgdHdlZW4gYmVjb21lcyBhY3RpdmUgKGZpbmlzaGVzIGRlbGF5aW5nKTtcblx0XHQqICYmIHdoZW4gOnN3YXBWYWx1ZXMoKSBpcyBjYWxsZWQuIEl0IHdvdWxkIHJhcmVseSBiZSB1c2VkIGRpcmVjdGx5O1xuXHRcdCogYnV0IGlzIGV4cG9zZWQgZm9yIHBvc3NpYmxlIHVzZSBieSBwb3dlciB1c2Vycy5cblx0Ki9cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl9pbml0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbml0VmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX3JhbmdlVmFsdWVzID0ge307XG5cbiAgICAgICAgZm9yICggY29uc3Qga2V5IGluIHRoaXMuX2VuZFZhbHVlcyApIHtcbiAgICAgICAgICAgIGlmICgga2V5ID09IFwiY29sb3JcIiApIHtcbiAgICAgICAgICAgICAgICAvLyBoZXjroZwg65Ok7Ja07JioIOqwkuydhCByLCBnLCBiIOqwkuycvOuhnCDrgpjriKDshJwg7KCA7J6l7ZWc64ukXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFZhbHVlc1trZXldID0gaGV4VG9SZ2IoIHRoaXMudGFyZ2V0LmNvbG9yTXVsdGlwbGllciApO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gaGV4VG9SZ2IoIHRoaXMuX2VuZFZhbHVlc1trZXldICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VWYWx1ZXNba2V5XSA9IFtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMF0gLSBwYXJzZUZsb2F0KCB0aGlzLl9pbml0VmFsdWVzW2tleV1bMF0gKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMV0gLSBwYXJzZUZsb2F0KCB0aGlzLl9pbml0VmFsdWVzW2tleV1bMV0gKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMl0gLSBwYXJzZUZsb2F0KCB0aGlzLl9pbml0VmFsdWVzW2tleV1bMl0gKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8v64KY66i47KeAIOybkOuzuOycvOuhnFxuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCB0aGlzLnRhcmdldFtrZXldICE9IG51bGwsIGDtirjsnIjsnLzroZwg7KGw7J6R7ZWY66Ck64qUIOqwkuydtCBudWxs7J2064ukLmAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0VmFsdWVzW2tleV0gPSB0aGlzLnRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhbmdlVmFsdWVzW2tleV0gPSB0aGlzLl9lbmRWYWx1ZXNba2V5XSAtIHRoaXMuX2luaXRWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5kaXNwYXRjaEV2ZW50cyApIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggXCJpbml0XCIgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG5cdFx0KiBKdW1wcyB0aGUgdHdlZW4gdG8gaXRzIGJlZ2lubmluZyAmJiBwYXVzZXMgaXQuIFRoaXMgaXMgdGhlIHNhbWUgYXMgY2FsbGluZyAuc2V0UG9zaXRpb24oMCkgYW5kIC5zZXRQYXVzZWQodHJ1ZSkuXG5cdCovXG4gICAgdG9TdGFydCgpIHtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiggMCApO1xuICAgICAgICAvL3RoaXMuc2V0UGF1c2VkKHRydWUpO1xuICAgIH1cblxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiggMCApO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG5cbiAgICAvKlxuXHRcdCogSnVtcHMgdGhlIHR3ZWVuIHRvIGl0cyBlbmQgYW5kIHBhdXNlcyBpdC4gVGhpcyBpcyByb3VnaGx5IHRoZSBzYW1lIGFzIGNhbGxpbmcgLnNldFBvc2l0aW9uKHJlcGVhdENvdW50KmR1cmF0aW9uKS5cblx0Ki9cbiAgICB0b0VuZCgpIHtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiggKCB0aGlzLnJlcGVhdENvdW50ID4gMCApICYmIHRoaXMucmVwZWF0Q291bnQgKiB0aGlzLmR1cmF0aW9uIHx8IHRoaXMuZHVyYXRpb24gKTtcbiAgICB9XG5cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICB0aGlzLl9pbml0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIHRoaXMuX3Bvc2l0aW9uID4gMCApIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5hdXRvUGxheSApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGF1c2VkKCBmYWxzZSApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIG9uQ29tcGxldGVSZW1vdmVGcm9tUGFyZW50KCkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIFwiY29tcGxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sdGhpcyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHBhcmFtIHthbnk9fSBkYXRhXG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIG9uQ29tcGxldGUoIGZ1bmMsZGF0YSApIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCBcImNvbXBsZXRlXCIsZnVuYyxkYXRhICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcGFyYW0ge2FueT19IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICogQG1lbWJlcm9mIFR3ZWVuXG4gICAgICovXG4gICAgb25DaGFuZ2UoIGZ1bmMsZGF0YSApIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCBcImNoYW5nZVwiLGZ1bmMsZGF0YSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1R3ZWVufSB0d2VlblxuICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgKiBAbWVtYmVyb2YgVHdlZW5cbiAgICAgKi9cbiAgICBzZXROZXh0VHdlZW4oIHR3ZWVuICkge1xuICAgICAgICB0aGlzLm5leHRUd2VlbiA9IHR3ZWVuO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258UHJvcD19IHByb3BzXG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIHR3ZWVuKCBkdXJhdGlvbiwgdmFsdWVzLCBwcm9wcyApIHtcbiAgICAgICAgY29uc3QgbmV3VHdlZW4gPSBuZXcgVHdlZW4oIHRoaXMudGFyZ2V0LCBkdXJhdGlvbiwgdmFsdWVzLCBwcm9wcyApO1xuXG4gICAgICAgIGlmICggIXRoaXMuaXNFbmQoKSApIHtcbiAgICAgICAgICAgIG5ld1R3ZWVuLnNldFBhdXNlZCggdHJ1ZSApO1xuICAgICAgICAgICAgdGhpcy5zZXROZXh0VHdlZW4oIG5ld1R3ZWVuICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VHdlZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uID0gMF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxQcm9wPX0gcHJvcHNcbiAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICogQG1lbWJlcm9mIFR3ZWVuXG4gICAgICovXG4gICAgbW92ZSggeCwgeSwgZHVyYXRpb24gPSAwLCBwcm9wcyApIHtcbiAgICAgICAgY29uc3QgbmV3VHdlZW4gPSBuZXcgVHdlZW4oIHRoaXMudGFyZ2V0LCBkdXJhdGlvbiwgeyB4OiB4LCB5OiB5IH0sIHByb3BzICk7XG5cbiAgICAgICAgaWYgKCAhdGhpcy5pc0VuZCgpICkge1xuICAgICAgICAgICAgbmV3VHdlZW4uc2V0UGF1c2VkKCB0cnVlICk7XG4gICAgICAgICAgICB0aGlzLnNldE5leHRUd2VlbiggbmV3VHdlZW4gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdUd2VlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj0wXVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBmdW5jXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBjb250ZXh0XG4gICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAqIEBtZW1iZXJvZiBUd2VlblxuICAgICAqL1xuICAgIHdhaXQoIGR1cmF0aW9uID0gMCwgZnVuYywgY29udGV4dCApIHtcbiAgICAgICAgY29uc3QgbmV3VHdlZW4gPSBuZXcgVHdlZW4oIHRoaXMudGFyZ2V0LCBkdXJhdGlvbiApO1xuXG4gICAgICAgIGlmICggZnVuYyApIHtcbiAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSggZnVuYywgY29udGV4dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhdGhpcy5pc0VuZCgpICkge1xuICAgICAgICAgICAgbmV3VHdlZW4uc2V0UGF1c2VkKCB0cnVlICk7XG4gICAgICAgICAgICB0aGlzLnNldE5leHRUd2VlbiggbmV3VHdlZW4gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdUd2VlbjtcbiAgICB9XG5cbiAgICBzdG9wVHdlZW5DaGFpbigpIHtcbiAgICAgICAgVHdlZW4uc3RvcFRhcmdldCggdGhpcy50YXJnZXQgKTtcbiAgICB9XG5cblxuICAgIHN0YXRpYyBsaW5lYXJFYXNlKCBhLCBiLCBjLCBkICkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBzdGF0aWMgb25UaWNrKCkge1xuICAgICAgICBpZiAoIFR3ZWVuLnBhdXNlQWxsICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHQgPSAxIC8gNjAgKiBUd2Vlbi50aW1lU2NhbGVBbGwgKiAxMDAwO1xuXG4gICAgICAgIGZvciAoIGNvbnN0IFt0d2Vlbl0gb2YgVHdlZW4uYWN0aXZlVHdlZW5MaXN0ICkge1xuICAgICAgICAgICAgY29weVRpY2tMaXN0LnB1c2goIHR3ZWVuICk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3B5VGlja0xpc3QubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBjb25zdCB0d2VlbiA9IGNvcHlUaWNrTGlzdFtpXTtcblxuICAgICAgICAgICAgdHdlZW4uc2V0UG9zaXRpb24oIHR3ZWVuLl9wb3NpdGlvbiArICggdHdlZW4udXNlRnJhbWVzICYmIFR3ZWVuLnRpbWVTY2FsZUFsbCB8fCBkdCApICogdHdlZW4udGltZVNjYWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGNvcHlUaWNrTGlzdC5sZW5ndGggPT0gMCApIHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uLnN0YWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIEV2ZW50LkVOVEVSX0ZSQU1FLCBUd2Vlbi5vblRpY2sgKTtcbiAgICAgICAgICAgIFR3ZWVuLmFjdGl2ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb3B5VGlja0xpc3QubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvLyDtg4Dqsp/sl5Ag6rG466awIO2KuOyciCDrqqjrkZAg7KCV7KeAXG4gICAgc3RhdGljIHN0b3BUYXJnZXQoIHRhcmdldCApIHtcbiAgICAgICAgZm9yICggY29uc3QgW3R3ZWVuXSBvZiBUd2Vlbi5hY3RpdmVUd2Vlbkxpc3QgKSB7XG4gICAgICAgICAgICBpZiAoIHR3ZWVuLnRhcmdldCA9PSB0YXJnZXQgKSB7XG4gICAgICAgICAgICAgICAgdHdlZW4uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcblx0KiBDb25zdHJ1Y3RzIGEgbmV3IFR3ZWVuIGluc3RhbmNlLlxuXHQqXG5cdCogdGFyZ2V0OiBUaGUgb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgd2lsbCBiZSB0d2VlbmVkLlxuXHQqIGR1cmF0aW9uOiBUaGUgbGVuZ3RoIG9mIHRoZSB0d2VlbiBpbiBmcmFtZXMgfHwgc2Vjb25kcyBkZXBlbmRpbmcgb24gdGhlIHRpbWluZ01vZGUuXG5cdCogdmFsdWVzOiBBbiBvYmplY3QgY29udGFpbmluZyB9IHByb3BlcnR5IHZhbHVlcy4gRm9yIGV4YW1wbGUsIHRvIHR3ZWVuIHRvIHg9MTAwLCB5PTEwMCwgeW91IGNvdWxkIHBhc3Mge3g9MTAwLCB5PTEwMH0gYXMgdGhlIHZhbHVlcyBvYmplY3QuXG5cdCogcHJvcHM6IEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gc2V0IG9uIHRoaXMgdHdlZW4uIEZvciBleGFtcGxlLCB5b3UgY291bGQgcGFzcyB7ZWFzZT1teUVhc2V9IHRvIHNldCB0aGUgZWFzZSBwcm9wZXJ0eSBvZiB0aGUgbmV3IGluc3RhbmNlLiBJdCBhbHNvIHN1cHBvcnRzIGEgc2luZ2xlIHNwZWNpYWwgcHJvcGVydHkgXCJzd2FwVmFsdWVzXCIgdGhhdCB3aWxsIGNhdXNlIDpzd2FwVmFsdWVzKCkgdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSB2YWx1ZXMgc3BlY2lmaWVkIGluIHRoZSB2YWx1ZXMgcGFyYW1ldGVyIGFyZSBzZXQuXG4gICAgKi9cbn1cblxuLypcblxu7Yq47JyI7J2EIOyXsOqysO2VtOyEnCDslaDri4jrqZTsnbTshZjsnYQg66eM65OkIOyImCDsnojrj4TroZ0g7ZWY6riwIOychO2VtOyEnCDsnpHshLFcblNwcml0ZSDtjIzsnbzsl5Ag7ZWo7IiY66W8IOygleydmO2VmOuptCDsg4HtmLjssLjsobAg65WM66y47JeQIOyViOuQqFxuc3ByLm1vdmUoMTAsMTAsMTAwKS5tb3ZlKDEwMCw1MCwyMDApLi4uXG5cbiovXG5cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudHdlZW4gPSBmdW5jdGlvbiAoIGR1cmF0aW9uLCB2YWx1ZXMsIHByb3BzICkge1xuICAgIHJldHVybiBuZXcgVHdlZW4oIHRoaXMsIGR1cmF0aW9uLCB2YWx1ZXMsIHByb3BzICk7XG59O1xuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoIHgsIHksIGR1cmF0aW9uID0gMCwgcHJvcHMgKSB7XG4gICAgcmV0dXJuIG5ldyBUd2VlbiggdGhpcywgZHVyYXRpb24sIHsgeDogeCwgeTogeSB9LCBwcm9wcyApO1xufTtcblxuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS53YWl0ID0gZnVuY3Rpb24gKCBkdXJhdGlvbiA9IDAsIGZ1bmMsIGNvbnRleHQgKSB7XG4gICAgcmV0dXJuIG5ldyBUd2VlbiggdGhpcywgZHVyYXRpb24gKS5vbkNvbXBsZXRlKCBmdW5jLGNvbnRleHQgKTtcbn07XG5cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZ2V0VHdlZW5zID0gZnVuY3Rpb24gKCBwbGF5aW5nT25seSApIHtcbiAgICBjb25zdCB0d2VlbnMgPSBbXTtcblxuICAgIGZvciAoIGNvbnN0IFt0d2Vlbl0gb2YgVHdlZW4uYWN0aXZlVHdlZW5MaXN0ICkge1xuICAgICAgICBpZiAoIHR3ZWVuLnRhcmdldCA9PSB0aGlzICkge1xuICAgICAgICAgICAgaWYgKCAhcGxheWluZ09ubHkgfHwgdHdlZW4ucGF1c2VkICkge1xuICAgICAgICAgICAgICAgIHR3ZWVucy5wdXNoKCB0d2VlbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR3ZWVucy5sZW5ndGggPiAwID8gdHdlZW5zIDogbnVsbDtcbn07XG5cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuc3RvcEFsbFR3ZWVucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBUd2Vlbi5zdG9wVGFyZ2V0KCB0aGlzICk7XG59O1xuXG5Ud2Vlbi5hY3RpdmUgPSBmYWxzZTtcblR3ZWVuLmRlZmF1bHREaXNwYXRjaEV2ZW50cyA9IHRydWU7XG5Ud2Vlbi5kZWZhdWx0RWFzZSA9IFR3ZWVuLmxpbmVhckVhc2U7XG5Ud2Vlbi5wYXVzZUFsbCA9IGZhbHNlO1xuVHdlZW4udGltZVNjYWxlQWxsID0gMTtcblR3ZWVuLmFjdGl2ZVR3ZWVuTGlzdCA9IG5ldyBNYXAoKTtcblxuXG4iLCJcclxuZnVuY3Rpb24gZ2V0UmVjdExpa2UoIHIgKSB7XHJcbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHIgKSB8fCByIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHJbMF0seTogclsxXSwgd2lkdGg6IHJbMl0saGVpZ2h0OiByWzNdIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQb2ludExpa2UoIHAgKSB7XHJcbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHAgKSB8fCBwIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHBbMF0seTogcFsxXSB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBSZWN0IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZWN0LlxyXG4gICAgICogQHBhcmFtIHtbbnVtYmVyLG51bWJlcixudW1iZXIsbnVtYmVyXXxGbG9hdDMyQXJyYXl8bnVtYmVyfFJlY3Q9fSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gd2lkdGhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gaGVpZ2h0XHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjdFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciggeCx5LHdpZHRoLGhlaWdodCApIHtcclxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHggKSB8fCB4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xyXG4gICAgICAgICAgICB0aGlzLnggID0geFswXTtcclxuICAgICAgICAgICAgdGhpcy55ID0geFsxXTtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHhbMl07XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0geFszXTtcclxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiApIHtcclxuICAgICAgICAgICAgdGhpcy54ID0geC54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB4Lnk7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB4LndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHguaGVpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy55ID0geSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZWN0fVxyXG4gICAgICogQG1lbWJlcm9mIFJlY3RcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KCB0aGlzICk7ICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRDb3JuZXJQb2ludHMoKSB7XHJcbiAgICAgICAgY29uc3QgeyB4LHksd2lkdGgsaGVpZ2h0IH0gPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gW3gseSx4ICsgd2lkdGgseSx4LHkgKyBoZWlnaHQseCArIHdpZHRoLHkgKyBoZWlnaHRdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XTtcclxuICAgIH1cclxuXHJcbiAgICBleHRlbmRQb2ludCggeCx5ICkge1xyXG4gICAgICAgIGlmICggdGhpcy54ID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCB4IDwgdGhpcy54ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCArPSB0aGlzLnggLSB4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHkgPCB0aGlzLnkgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCArPSB0aGlzLnkgLSB5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoIHRoaXMucmlnaHQseCApIC0gdGhpcy54O1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KCB0aGlzLmJvdHRvbSx5ICkgLSB0aGlzLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4dGVuZFJlY3QoIHIgKSB7XHJcbiAgICAgICAgdGhpcy5leHRlbmRQb2ludCggci54LHIueSApO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5kUG9pbnQoIHIucmlnaHQsci55ICk7XHJcbiAgICAgICAgdGhpcy5leHRlbmRQb2ludCggci54LHIuYm90dG9tICk7XHJcbiAgICAgICAgdGhpcy5leHRlbmRQb2ludCggci5yaWdodCxyLmJvdHRvbSApO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB4eXdoKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgeHl3aCggciApIHtcclxuICAgICAgICBjb25zdCByMiA9IGdldFJlY3RMaWtlKCByICk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHIyLng7XHJcbiAgICAgICAgdGhpcy55ID0gcjIueTtcclxuICAgICAgICB0aGlzLndpZHRoID0gcjIud2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSByMi5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGxlZnQoKSB7IHJldHVybiB0aGlzLng7IH1cclxuXHJcbiAgICBnZXQgcmlnaHQoKSB7IHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoOyB9XHJcblxyXG4gICAgZ2V0IHRvcCgpIHsgcmV0dXJuIHRoaXMueTsgfVxyXG5cclxuICAgIGdldCBib3R0b20oKSB7IHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDsgfVxyXG5cclxuICAgIGNvbnRhaW5zKCB4LHkgKSB7XHJcbiAgICAgICAgcmV0dXJuICggeCA+PSB0aGlzLmxlZnQgJiYgeCA8IHRoaXMucmlnaHQgJiYgeSA+PSB0aGlzLnRvcCAmJiB5IDwgdGhpcy5ib3R0b20gKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBQb2ludCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge1tudW1iZXIsbnVtYmVyXXxGbG9hdDMyQXJyYXl8bnVtYmVyfFBvaW50PX0geFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSB5XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9pbnRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoIHgseSApIHtcclxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHggKSB8fCB4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4WzBdO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB4WzFdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4Lng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHgueTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHkgfHwgMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQb2ludH1cclxuICAgICAqIEBtZW1iZXJvZiBQb2ludFxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCB0aGlzICk7ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGdldEFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy54LHRoaXMueV07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHh5KCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy54LHRoaXMueV07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHh5KCBwICkge1xyXG4gICAgICAgIGNvbnN0IHAyID0gZ2V0UG9pbnRMaWtlKCBwICk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHAyLng7XHJcbiAgICAgICAgdGhpcy55ID0gcDIueTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvaW5066W8IOuNlO2VnOuLpC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fG51bWJlcn0gcFxyXG4gICAgICogQHJldHVybnMge1BvaW50fVxyXG4gICAgICogQG1lbWJlcm9mIFBvaW50XHJcbiAgICAgKi9cclxuICAgIGFkZCggcCApIHtcclxuICAgICAgICBjb25zdCBwMiA9IGdldFBvaW50TGlrZSggcCApO1xyXG5cclxuICAgICAgICB0aGlzLnggKz0gcDIueDtcclxuICAgICAgICB0aGlzLnkgKz0gcDIueTtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCB0aGlzICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb2ludOulvCDruoDri6QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQb2ludHxudW1iZXJ9IHBcclxuICAgICAqIEByZXR1cm5zIHtQb2ludH1cclxuICAgICAqIEBtZW1iZXJvZiBQb2ludFxyXG4gICAgICovXHJcbiAgICBzdWJ0cmFjdCggcCApIHtcclxuICAgICAgICBjb25zdCBwMiA9IGdldFBvaW50TGlrZSggcCApO1xyXG5cclxuICAgICAgICB0aGlzLnggLT0gcDIueDtcclxuICAgICAgICB0aGlzLnkgLT0gcDIueTtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCB0aGlzICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UG9pbnR8bnVtYmVyfSBwXHJcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9pbnRcclxuICAgICAqL1xyXG4gICAgbXVsKCBwICkge1xyXG4gICAgICAgIGNvbnN0IHAyID0gZ2V0UG9pbnRMaWtlKCBwICk7XHJcblxyXG4gICAgICAgIHRoaXMueCAqPSBwMi54O1xyXG4gICAgICAgIHRoaXMueSAqPSBwMi55O1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoIHRoaXMgKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBUeXBlZEFycmF5SGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVnaW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGVuZ3RoXHJcbiAgICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSBcclxuICAgICAqIEBtZW1iZXJvZiBUeXBlZEFycmF5SGVscGVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBVaW50OFRvRmxvYXQzMiggdWludDhBcnIsYmVnaW4gPSAwLGxlbmd0aCA9IG51bGwgKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoIHVpbnQ4QXJyLmJ1ZmZlcix1aW50OEFyci5ieXRlT2Zmc2V0ICsgYmVnaW4sKCBsZW5ndGggIT0gbnVsbCApID8gTWF0aC5jZWlsKCBsZW5ndGggLyA0ICkgOiBudWxsICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7VWludDE2QXJyYXl9IHVpbnQxNkFyclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGxlbmd0aFxyXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gXHJcbiAgICAgKiBAbWVtYmVyb2YgVHlwZWRBcnJheUhlbHBlclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgVWludDE2VG9GbG9hdDMyKCB1aW50MTZBcnIsYmVnaW4gPSAwLGxlbmd0aCA9IG51bGwgKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoIHVpbnQxNkFyci5idWZmZXIsdWludDE2QXJyLmJ5dGVPZmZzZXQgKyBiZWdpbiAqIDIsbGVuZ3RoICE9IG51bGwgPyBNYXRoLmNlaWwoIGxlbmd0aCAvIDIgKSA6IG51bGwgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGZsb2F0MzJBcnJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBsZW5ndGhcclxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBcclxuICAgICAqIEBtZW1iZXJvZiBUeXBlZEFycmF5SGVscGVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBGbG9hdDMyVG9VaW50OCggZmxvYXQzMkFycixiZWdpbiA9IDAsbGVuZ3RoID0gbnVsbCApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoIGZsb2F0MzJBcnIuYnVmZmVyLGZsb2F0MzJBcnIuYnl0ZU9mZnNldCArIGJlZ2luICogNCxsZW5ndGggIT0gbnVsbCA/IGxlbmd0aCAqIDQgOiBudWxsICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBmbG9hdDMyQXJyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVnaW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGVuZ3RoXHJcbiAgICAgKiBAcmV0dXJucyB7VWludDE2QXJyYXl9IFxyXG4gICAgICogQG1lbWJlcm9mIFR5cGVkQXJyYXlIZWxwZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIEZsb2F0MzJUb1VpbnQxNiggZmxvYXQzMkFycixiZWdpbiA9IDAsbGVuZ3RoID0gbnVsbCApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KCBmbG9hdDMyQXJyLmJ1ZmZlcixmbG9hdDMyQXJyLmJ5dGVPZmZzZXQgKyBiZWdpbiAqIDQsbGVuZ3RoICE9IG51bGwgPyBsZW5ndGggKiAyIDogbnVsbCApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxVaW50MTZBcnJheXxVaW50OEFycmF5fSB0eXBlZEFyclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGxlbmd0aFxyXG4gICAgICogQHJldHVybnMgeyp9IFxyXG4gICAgICogQG1lbWJlcm9mIFR5cGVkQXJyYXlIZWxwZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN1YmFycmF5KCB0eXBlZEFycixiZWdpbiA9IDAsbGVuZ3RoID0gbnVsbCApIHsgICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0eXBlZEFyci5zdWJhcnJheSggYmVnaW4sIGxlbmd0aCAhPSBudWxsID8gYmVnaW4gKyBsZW5ndGggOiBudWxsICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fFVpbnQxNkFycmF5fFVpbnQ4QXJyYXl9IHR5cGVkQXJyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3U2l6ZVxyXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheXxVaW50MTZBcnJheXxVaW50OEFycmF5fVxyXG4gICAgICogQG1lbWJlcm9mIFR5cGVkQXJyYXlIZWxwZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlc2l6ZSggdHlwZWRBcnIsIG5ld1NpemUgKSB7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgY29uc3QgbmV3QXJyID0gbmV3ICggdHlwZWRBcnIuY29uc3RydWN0b3IgKSggbmV3U2l6ZSApO1xyXG5cclxuICAgICAgICBuZXdBcnIuc2V0KCB0eXBlZEFyciwwLE1hdGgubWluKCBuZXdTaXplLHR5cGVkQXJyLmxlbmd0aCApICk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0FycjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgbWVtY3B5KCBkc3QsZHN0T2Zmc2V0LHNyYyxzcmNPZmZzZXQsc3JjTGVuZ3RoICkge1xyXG4gICAgICAgIC8vIHdlYnBhY2sgcG9seWZpbGwg7J2EIOyCrOyaqe2VmOuKlCDsvZTrk5xcclxuICAgICAgICAvLyBjb25zdCBlbGVtZW50U2l6ZSA9IGRzdC5jb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcbiAgICAgICAgLy8gZHN0T2Zmc2V0ID0gZHN0LmJ5dGVPZmZzZXQgKyBkc3RPZmZzZXQgKiBlbGVtZW50U2l6ZTtcclxuICAgICAgICAvLyBzcmNPZmZzZXQgPSBzcmMuYnl0ZU9mZnNldCArIHNyY09mZnNldCAqIGVsZW1lbnRTaXplO1xyXG4gICAgICAgIC8vIHNyY0xlbmd0aCAqPSBlbGVtZW50U2l6ZTtcclxuXHJcbiAgICAgICAgLy8gQnVmZmVyLmZyb20oIHNyYy5idWZmZXIsIHNyY09mZnNldCxzcmNMZW5ndGggKS5jb3B5KCBCdWZmZXIuZnJvbSggZHN0LmJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNMZW5ndGggKSApO1xyXG5cclxuICAgICAgICBpZiAoIHNyY0xlbmd0aCA8IDEwMCApIHtcclxuICAgICAgICAgICAgY29uc3QgZHN0MiA9IGRzdC5zdWJhcnJheSggZHN0T2Zmc2V0ICk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNyYzIgPSBzcmMuc3ViYXJyYXkoIHNyY09mZnNldCApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgc3JjTGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBkc3QyW2ldID0gc3JjMltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBzcmNMZW5ndGggKiBzcmMuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHU4ZHN0ID0gbmV3IFVpbnQ4QXJyYXkoIGRzdC5idWZmZXIsZHN0LmJ5dGVPZmZzZXQgKyBkc3RPZmZzZXQgKiBkc3QuQllURVNfUEVSX0VMRU1FTlQgKTtcclxuICAgICAgICAgICAgY29uc3QgdThzcmMgPSBuZXcgVWludDhBcnJheSggc3JjLmJ1ZmZlcixzcmMuYnl0ZU9mZnNldCArIHNyY09mZnNldCAqIHNyYy5CWVRFU19QRVJfRUxFTUVOVCxieXRlTGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICB1OGRzdC5zZXQoIHU4c3JjICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSAgICBcclxufVxyXG4iLCJcclxuXHJcblxyXG5jbGFzcyBBc3luY1ZhbHVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoICggcmVzb2x2ZSxyZWplY3QgKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc29sdmUoIHYgKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHY7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSggdiApO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2U7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc29sdmU7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlamVjdDtcclxuICAgIH1cclxuXHJcbiAgICByZWplY3QoIGUgKSB7XHJcbiAgICAgICAgdGhpcy5fcmVqZWN0KCBlICk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucHJvbWlzZTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fcmVzb2x2ZTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fcmVqZWN0O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVXRpbHMgPSB7XHJcblxyXG4gICAgQXN5bmNWYWx1ZSxcclxuICAgIC8qKlxyXG4gICAgICogQ3RybC1zaGlmdC1IXHJcbiAgICAgKiBBbHQtUiDsg4Htg5zroZwg64uk7J2MIOyhsOqxtCDrs4DtmZjtlZjsl6wg7J286rSEIOyCreygnO2VoCDsiJgg7J6I64ukXHJcbiAgICAgKiBVdGlsc1xcLm51bGxSZXBsYWNlXFwoKFteLF0rKVxccyosXFxzKihbXildKylcXClcclxuICAgICAqICQxICE9IG51bGwgPyAkMSA6ICQyXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xyXG4gICAgICovXHJcbiAgICBudWxsUmVwbGFjZSggdGFyZ2V0LCB2YWx1ZSApIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0ICE9IG51bGwgPyB0YXJnZXQgOiB2YWx1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFV0aWxzXHJcbiAgICAgKi9cclxuICAgIHJhbmRvbSggYSwgYiApIHtcclxuICAgICAgICBjb25zb2xlLmFzc2VydCggKCBhID09IG51bGwgJiYgYiA9PSBudWxsICkgfHwgKCBhICE9IG51bGwgJiYgYiAhPSBudWxsICksIGByYW5kb20oJHthfSwke2J9KSDqtazrrLjsnYAg7ZeI7Jqp65CY7KeAIOyViuydjC4gcmFuZG9tKDEsYSkg7Zi57J2AIHJhbmRvbSgwLGEp66W8IOuqhe2Zle2eiCDsk7gg6rKDYCApO1xyXG5cclxuICAgICAgICBpZiAoIGIgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgLy8gWzEsaV1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiBhICsgMSApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGEgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gW2ksal1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGIgLSBhICsgMSApICsgYSApO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gYVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgVXRpbHNcclxuICAgICAqL1xyXG4gICAgcHJlY2lzaW9uKCBhLCBiICkge1xyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICkudG9QcmVjaXNpb24oIGIgKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xyXG4gICAgICovXHJcbiAgICBpZGl2KCBhLCBiICkge1xyXG4gICAgICAgIC8vIOydjOyImOyXkCDrjIDtlbTshJwg67CU66W06rKMIOyymOumrO2VqFxyXG4gICAgICAgIHJldHVybiBhIC8gYiA+PiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdjFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFV0aWxzXHJcbiAgICAgKi9cclxuICAgIGxlcnAoIHYwLCB2MSwgYSApIHtcclxuICAgICAgICByZXR1cm4gdjAgKyAoIHYxIC0gdjAgKSAqIGE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xyXG4gICAgICovXHJcbiAgICBjbGFtcCggdiwgbWluLCBtYXggKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKCBNYXRoLm1heCggdiwgbWluICksIG1heCApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFV0aWxzXHJcbiAgICAgKi9cclxuICAgIGRpc3RhbmNlKCB4MSwgeTEsIHgyLCB5MiApIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCAoIHgyIC0geDEgKSAqICggeDIgLSB4MSApICsgKCB5MiAtIHkxICkgKiAoIHkyIC0geTEgKSApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgVXRpbHNcclxuICAgICAqL1xyXG4gICAgZnJhYyggYSApIHtcclxuICAgICAgICByZXR1cm4gYSAlIDE7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlZ2FjeSggbXNnID0gXCJcIiApIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggYOKZqCBMZWdhY3kgQVBJICR7bXNnfWAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgbm90SW1wbGVtZW50cyggbXNnID0gXCJcIiApIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggYOKZqCBOb3QgSW1wbGVtZW50ZWQuICR7bXNnfWAgKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xyXG4gICAgICovXHJcbiAgICBnZXRFbWJlZGRlZEZpbGUoIGZpbGVuYW1lICkge1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KCBzZWxmLl9lbWJlZGRlZEZpbGVzW2ZpbGVuYW1lLnRvTG93ZXJDYXNlKCldICE9IG51bGwgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX2VtYmVkZGVkRmlsZXNbZmlsZW5hbWVdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cclxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xyXG4gICAgICovXHJcbiAgICBnZXRFbWJlZGRlZEJpbmFyeUZpbGUoIGZpbGVuYW1lICkge1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KCBzZWxmLl9lbWJlZGRlZEZpbGVzW2ZpbGVuYW1lLnRvTG93ZXJDYXNlKCldICE9IG51bGwgKTtcclxuICAgICAgICBjb25zdCBiYXNlNjREYXRhID0gc2VsZi5fZW1iZWRkZWRGaWxlc1tmaWxlbmFtZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgICAgICBjb25zdCBsb29rdXBUYWJsZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XHJcbiAgICAgICAgY29uc3QgYXJyID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGJhc2U2NERhdGEubGVuZ3RoOyApIHtcclxuICAgICAgICAgICAgY29uc3QgZCA9IGxvb2t1cFRhYmxlLmluZGV4T2YoIGJhc2U2NERhdGEuY2hhckF0KCBpKysgKSApO1xyXG4gICAgICAgICAgICBjb25zdCBlID0gbG9va3VwVGFibGUuaW5kZXhPZiggYmFzZTY0RGF0YS5jaGFyQXQoIGkrKyApICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSBsb29rdXBUYWJsZS5pbmRleE9mKCBiYXNlNjREYXRhLmNoYXJBdCggaSsrICkgKTtcclxuICAgICAgICAgICAgY29uc3QgZyA9IGxvb2t1cFRhYmxlLmluZGV4T2YoIGJhc2U2NERhdGEuY2hhckF0KCBpKysgKSApO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gKCBkIDw8IDIgKSB8ICggZSA+PiA0ICk7XHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSAoICggZSAmIDE1ICkgPDwgNCApIHwgKCBmID4+IDIgKTtcclxuICAgICAgICAgICAgY29uc3QgYyA9ICggKCBmICYgMyApIDw8IDYgKSB8IGc7XHJcblxyXG4gICAgICAgICAgICBhcnIucHVzaCggYSApO1xyXG4gICAgICAgICAgICBpZiAoIGYgIT0gNjQgKSBhcnIucHVzaCggYiApO1xyXG4gICAgICAgICAgICBpZiAoIGcgIT0gNjQgKSBhcnIucHVzaCggYyApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoIGFyciApO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbWJlZGRlZEZpbGVFeGlzdCggZmlsZW5hbWUgKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuX2VtYmVkZGVkRmlsZXNbZmlsZW5hbWVdICE9IG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcclxuICAgICAqIEByZXR1cm5zIHtYTUxEb2N1bWVudH1cclxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xyXG4gICAgICovXHJcbiAgICBnZXRFbWJlZGRlZFhtbEZpbGUoIGZpbGVuYW1lICkge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBjb25zdCB4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIFV0aWxzLmdldEVtYmVkZGVkRmlsZSggZmlsZW5hbWUgKSwgXCJ0ZXh0L3htbFwiICk7XHJcblxyXG4gICAgICAgIHJldHVybiB4bWw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGVkZWYge29iamVjdH0gU2l6ZVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7U2l6ZX1cclxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xyXG4gICAgICovXHJcbiAgICBnZXRJbWFnZVNpemUoIGZpbGVuYW1lICkge1xyXG4gICAgICAgIGNvbnN0IGltYWdlSW5mbyA9IHNlbGYuX2ltYWdlU2l6ZXNbZmlsZW5hbWUudG9Mb3dlckNhc2UoKV07XHJcblxyXG4gICAgICAgIGlmICggaW1hZ2VJbmZvICkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VJbmZvO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiAwLGhlaWdodDogMCB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDrrLjsnpDsl7Tsl5DshJwgPHRhZz4gPC90YWc+IO2Yle2DnOulvCDstpTstpztlZzri6RcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqIEBtZW1iZXJvZiBUZXh0RmllbGRcclxuICAgICAqL1xyXG4gICAgc3BsaXRTdHJpbmdXaXRoVGFnKCBzdHIgKSB7XHJcbiAgICAgICAgY29uc3QgdGFnUmVnRXhwID0gLzwoW14+XSspPi9nO1xyXG4gICAgICAgIGNvbnN0IHRhZ1N0YWNrID0gW1wiZGVmYXVsdFwiXTtcclxuICAgICAgICBjb25zdCByZXN1bHRBcnIgPSBbXTtcclxuXHJcbiAgICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlICggdHJ1ZSApIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGFnUmVnRXhwLmV4ZWMoIHN0ciApO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0VGFnID0gdGFnU3RhY2tbdGFnU3RhY2subGVuZ3RoIC0gMV07IFxyXG5cclxuICAgICAgICAgICAgaWYgKCByZXN1bHQgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIC8vIO2DnOq3uCDrqrvssL7snYxcclxuICAgICAgICAgICAgICAgIGlmICggbGFzdEluZGV4IDwgc3RyLmxlbmd0aCApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRBcnIucHVzaCggW2xhc3RUYWcsc3RyLnN1YnN0cmluZyggbGFzdEluZGV4ICldICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0QXJyO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IHJlc3VsdFsxXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0luZGV4ID0gcmVzdWx0LmluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdGFnTmFtZVswXSAhPSAnLycgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnU3RhY2sucHVzaCggdGFnTmFtZSApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbGFzdFRhZyA9PSB0YWdOYW1lLnN1YnN0cmluZyggMSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ1N0YWNrLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIGlmICggbGFzdEluZGV4ICE9IHRhZ0luZGV4ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEFyci5wdXNoKCBbbGFzdFRhZyxzdHIuc3Vic3RyaW5nKCBsYXN0SW5kZXgsdGFnSW5kZXggKV0gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IHRhZ1JlZ0V4cC5sYXN0SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBbcixnLGIsYV0g6rCAIOuLtOq4tCDslrTroIjsnbTrpbwg67CY7ZmY7ZWc64ukLiByLGcsYuuKlCAwfjEuMOydmCDqsJLsnbTri6QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYVxyXG4gICAgICogQHJldHVybnMge1tudW1iZXIsbnVtYmVyLG51bWJlcixudW1iZXJdfVxyXG4gICAgICogQG1lbWJlcm9mIFV0aWxzXHJcbiAgICAgKi9cclxuICAgIGhleDJyZ2JhKCBjLGEgKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICAgIC8vIGIsZyxyLGEg7Iic7IScXHJcbiAgICAgICAgcmVzdWx0WzBdID0gKCAoIGMgJiAweGZmMDAwMCApID4+IDE2ICkgLyAyNTU7XHJcbiAgICAgICAgcmVzdWx0WzFdID0gKCAoIGMgJiAweGZmMDAgKSA+PiA4ICkgLyAyNTU7XHJcbiAgICAgICAgcmVzdWx0WzJdID0gKCBjICYgMHhmZiApIC8gMjU1O1xyXG4gICAgICAgIGlmICggYSAhPSBudWxsICkge1xyXG4gICAgICAgICAgICByZXN1bHRbM10gPSBhO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFszXSA9ICggKCBjICYgMHhmZjAwMDAwMCApID4+IDI0ICkgLyAyNTU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHJnYmEyaGV4KCBhcnIsIGkgKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gaSB8fCAwO1xyXG5cclxuICAgICAgICByZXR1cm4gKCAoIGFycltpZHhdICogMjU1ICkgPDwgMTYgKSB8ICggKCBhcnJbaWR4ICsgMV0gKiAyNTUgKSA8PCA4ICkgfCAoIGFycltpZHggKyAyXSAqIDI1NSApIHwgKCAoIGFycltpZHggKyAzXSAqIDI1NSApIDw8IDI0ICk7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIFV0aWxzXHJcbiAgICAgKi9cclxuICAgIGFuZ2xlVG9EaXIoIGFuZ2xlICkge1xyXG4gICAgICAgIGxldCBkaXI7XHJcblxyXG4gICAgICAgIGlmICggLTEzNSA8IGFuZ2xlICYmIGFuZ2xlIDw9IC00NSApIHtcclxuICAgICAgICAgICAgZGlyID0gMTtcclxuICAgICAgICB9IGVsc2UgaWYgKCAtNDUgPCBhbmdsZSAmJiBhbmdsZSA8PSA0NSApIHtcclxuICAgICAgICAgICAgZGlyID0gMjtcclxuICAgICAgICB9IGVsc2UgaWYgKCA0NSA8IGFuZ2xlICYmIGFuZ2xlIDw9IDEzNSApIHtcclxuICAgICAgICAgICAgZGlyID0gMztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaXIgPSA0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRpcjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJcclxuICAgICAqIEByZXR1cm5zIHtbbnVtYmVyLG51bWJlcl19XHJcbiAgICAgKiBAbWVtYmVyb2YgVXRpbHNcclxuICAgICAqL1xyXG4gICAgZGlyVG9PZmZzZXQoIGRpciApIHtcclxuICAgICAgICBsZXQgYXgsIGF5O1xyXG5cclxuICAgICAgICBpZiAoIGRpciA9PSAxICkge1xyXG4gICAgICAgICAgICBbYXgsIGF5XSA9IFswLCAtMV07XHJcbiAgICAgICAgfSBlbHNlIGlmICggZGlyID09IDIgKSB7XHJcbiAgICAgICAgICAgIFtheCwgYXldID0gWzEsIDBdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGRpciA9PSAzICkge1xyXG4gICAgICAgICAgICBbYXgsIGF5XSA9IFswLCAxXTtcclxuICAgICAgICB9IGVsc2UgaWYgKCBkaXIgPT0gNCApIHtcclxuICAgICAgICAgICAgW2F4LCBheV0gPSBbLTEsIDBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFtheCwgYXldO1xyXG4gICAgfSxcclxuXHJcblxyXG5cclxuICAgIGZpbHRlckF0dHJpYiggYXR0cmliLCB3aGl0ZUxpc3QsIGJsYWNrTGlzdCApIHtcclxuICAgICAgICAvLyDshLHqs7XtlZjrqbQgdHJ1ZVxyXG4gICAgICAgIGNvbnN0IHdoaXRlTGlzdFN0ciA9IHdoaXRlTGlzdCAhPSBudWxsID8gKCBBcnJheS5pc0FycmF5KCB3aGl0ZUxpc3QgKSA/IFwiLFwiICsgd2hpdGVMaXN0LmpvaW4oIFwiLFwiICkgKyBcIixcIiA6IFwiLFwiICsgd2hpdGVMaXN0ICsgXCIsXCIgKSA6IFwiLCosXCI7XHJcbiAgICAgICAgY29uc3QgYmxhY2tMaXN0U3RyID0gYmxhY2tMaXN0ICE9IG51bGwgPyAoIEFycmF5LmlzQXJyYXkoIGJsYWNrTGlzdCApID8gXCIsXCIgKyBibGFja0xpc3Quam9pbiggXCIsXCIgKSArIFwiLFwiIDogXCIsXCIgKyBibGFja0xpc3QgKyBcIixcIiApIDogXCJcIjtcclxuICAgICAgICBjb25zdCBhdHRyaWJzID0gYXR0cmliICE9IG51bGwgPyAoIEFycmF5LmlzQXJyYXkoIGF0dHJpYiApID8gYXR0cmliIDogYXR0cmliLnNwbGl0KCBcIixcIiApICkgOiBbXTtcclxuXHJcblxyXG4gICAgICAgIGxldCB3aGl0ZVBhc3M7XHJcblxyXG4gICAgICAgIGlmICggYmxhY2tMaXN0U3RyLmluZGV4T2YoIFwiLCosXCIgKSA+PSAwICkge1xyXG4gICAgICAgICAgICAvLyBibGFja+ydtCAqIOuptCDqt7jrg6Ug7Iuk7YyoXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKCB3aGl0ZUxpc3RTdHIuaW5kZXhPZiggXCIsKixcIiApID49IDAgKSB7XHJcbiAgICAgICAgICAgIC8vd2hpdGXqsIAgKiDrqbQg6re464OlIO2GteqzvFxyXG4gICAgICAgICAgICB3aGl0ZVBhc3MgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIGF0dHJpYnMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgZm9yICggY29uc3QgdiBvZiBhdHRyaWJzICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCB3aGl0ZUxpc3RTdHIuaW5kZXhPZiggXCIsXCIgKyB2ICsgXCIsXCIgKSA+PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v7ZmU7J207Yq47JeQ7IScIO2VmOuCmOudvOuPhCDsnojsnLzrqbQg7Ya16rO8XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVQYXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8v7Ja07Yq466as67ew7Yq46rCAIO2VmOuCmOuPhCDso7zslrTsp4Dsp4Ag7JWK7JWY7J2EIOqyveyasCDsi6TtjKhcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB3aGl0ZVBhc3MgKSB7XHJcbiAgICAgICAgICAgIGZvciAoIGNvbnN0IHYgb2YgYXR0cmlicyApIHtcclxuICAgICAgICAgICAgICAgIGlmICggYmxhY2tMaXN0U3RyLmluZGV4T2YoIFwiLFwiICsgdiArIFwiLFwiICkgPj0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+u4lOuemeyXkOyEnCDtlZjrgpjrnbzrj4Qg7J6I7Jy866m0IOy1nOyihSDsi6TtjKhcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgZm9ybWF0KCB0ZXh0LCAuLi5hcmdzICkge1xyXG4gICAgICAgIGxldCBzO1xyXG5cclxuICAgICAgICBpZiAoIGFyZ3MubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgLy8gJXMgJWRcclxuICAgICAgICAgICAgLy8gJTAgJTEgJTIgJTMgJTQuLi5cclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIHMgPSB0ZXh0LnJlcGxhY2UoIC8lW3N8ZF0vZywgZnVuY3Rpb24gKCBzICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAlJHtjb3VudCsrfWA7XHJcbiAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBgJSR7aX1gLCBhcmdzW2ldICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgcyA9IHRleHQ7XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc05vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICggdHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gXCJ1bmRlZmluZWRcIiApO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc1dlYldvcmtlcigpIHtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICByZXR1cm4gIXRoaXMuaXNOb2RlKCkgXHJcbiAgICAgICAgICAgICYmICggdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICkgXHJcbiAgICAgICAgICAgICYmICggdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09IFwiZnVuY3Rpb25cIiApIFxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcclxuICAgICAgICAgICAgJiYgKCBuYXZpZ2F0b3IgaW5zdGFuY2VvZiBXb3JrZXJOYXZpZ2F0b3IgKTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXJPYmplY3QoIG9iaiApIHtcclxuICAgICAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKCBvYmogKTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwLG4gPSBwcm9wcy5sZW5ndGg7IGkgPCBuOyBpKysgKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcbiIsIi8qXHJcbkVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBBUzMgdHdlZW5pbmcgZXF1YXRpb25zLlxyXG4qL1xyXG5cclxuZXhwb3J0IGNvbnN0IGVhc2luZyA9IHt9O1xyXG5cclxuY29uc3QgYmFja1MgPSAxLjcwMTU4O1xyXG5cclxuZWFzaW5nLmluQmFjayA9IGZ1bmN0aW9uICggdCApIHtcclxuICAgIHJldHVybiB0ICogdCAqICggKCBiYWNrUyArIDEgKSAqIHQgLSBiYWNrUyApO1xyXG59O1xyXG5cclxuZWFzaW5nLm91dEJhY2sgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICB0ID0gdCAtIDE7XHJcblxyXG4gICAgcmV0dXJuIHQgKiB0ICogKCAoIGJhY2tTICsgMSApICogdCArIGJhY2tTICkgKyAxO1xyXG59O1xyXG5cclxuZWFzaW5nLmluT3V0QmFjayA9IGZ1bmN0aW9uICggdCApIHtcclxuICAgIHQgPSB0ICogMjtcclxuXHJcbiAgICBpZiAoIHQgPCAxICkgcmV0dXJuIDAuNSAqICggdCAqIHQgKiAoICggYmFja1MgKiAxLjUyNSArIDEgKSAqIHQgLSBiYWNrUyAqIDEuNTI1ICkgKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHQgPSB0IC0gMjtcclxuXHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICggdCAqIHQgKiAoICggYmFja1MgKiAxLjUyNSArIDEgKSAqIHQgKyBiYWNrUyAqIDEuNTI1ICkgKyAyICk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5lYXNpbmcuaW5Cb3VuY2UgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICByZXR1cm4gMSAtIGVhc2luZy5vdXRCb3VuY2UoIDEgLSB0ICk7XHJcbn07XHJcblxyXG5lYXNpbmcub3V0Qm91bmNlID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgaWYgKCB0IDwgMSAvIDIuNzUgKSB7XHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xyXG4gICAgfSBlbHNlIGlmICggdCA8IDIgLyAyLjc1ICkge1xyXG4gICAgICAgIHQgPSB0IC0gMS41IC8gMi43NTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHQgKiB0ICsgMC43NTtcclxuICAgIH0gZWxzZSBpZiAoIHQgPCAyLjUgLyAyLjc1ICkge1xyXG4gICAgICAgIHQgPSB0IC0gMi4yNSAvIDIuNzU7XHJcblxyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiB0ICogdCArIDAuOTM3NTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdCA9IHQgLSAyLjYyNSAvIDIuNzU7XHJcblxyXG4gICAgICAgIHJldHVybiA3LjU2MjUgKiB0ICogdCArIDAuOTg0Mzc1O1xyXG4gICAgfVxyXG59O1xyXG5cclxuZWFzaW5nLmluT3V0Qm91bmNlID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgdCA9IHQgKiAyO1xyXG4gICAgaWYgKCB0IDwgMSApIHJldHVybiAwLjUgKiBlYXNpbmcuaW5Cb3VuY2UoIHQgKTtcclxuICAgIGVsc2UgcmV0dXJuIDAuNSAqIGVhc2luZy5vdXRCb3VuY2UoIHQgLSAxICkgKyAwLjU7XHJcbn07XHJcblxyXG5lYXNpbmcuaW5DaXJjdWxhciA9IGZ1bmN0aW9uICggdCApIHtcclxuICAgIHJldHVybiAtKCBNYXRoLnNxcnQoIDEgLSB0ICogdCApIC0gMSApO1xyXG59O1xyXG5cclxuZWFzaW5nLm91dENpcmN1bGFyID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCggMSAtICggdCAtIDEgKSAqICggdCAtIDEgKSApO1xyXG59O1xyXG5cclxuZWFzaW5nLmluT3V0Q2lyY3VsYXIgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICB0ID0gdCAqIDI7XHJcblxyXG4gICAgaWYgKCB0IDwgMSApIHJldHVybiAtMC41ICogKCBNYXRoLnNxcnQoIDEgLSB0ICogdCApIC0gMSApO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdCA9IHQgLSAyO1xyXG5cclxuICAgICAgICByZXR1cm4gMC41ICogKCBNYXRoLnNxcnQoIDEgLSB0ICogdCApICsgMSApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZWFzaW5nLmluQ3ViaWMgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xyXG59O1xyXG5cclxuZWFzaW5nLm91dEN1YmljID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgdCA9IHQgLSAxO1xyXG5cclxuICAgIHJldHVybiB0ICogdCAqIHQgKyAxO1xyXG59O1xyXG5cclxuZWFzaW5nLmluT3V0Q3ViaWMgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICBpZiAoIHQgPCAwLjUgKSByZXR1cm4gNCAqIHQgKiB0ICogdDtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHQgPSB0IC0gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDQgKiB0ICogdCAqIHQgKyAxO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGVsYXN0aWNBID0gMTtcclxudmFyIGVsYXN0aWNQID0gMC4zO1xyXG52YXIgZWxhc3RpY1MgPSBlbGFzdGljUCAvIDQ7XHJcblxyXG5lYXNpbmcuaW5FbGFzdGljID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgaWYgKCB0ID09IDAgfHwgdCA9PSAxICkgcmV0dXJuIHQ7XHJcbiAgICB0ID0gdCAtIDE7XHJcblxyXG4gICAgcmV0dXJuIC0oIGVsYXN0aWNBICogTWF0aC5wb3coIDIsIDEwICogdCApICogTWF0aC5zaW4oICggdCAtIGVsYXN0aWNTICkgKiAoIDIgKiBNYXRoLlBJICkgLyBlbGFzdGljUCApICk7XHJcbn07XHJcblxyXG5lYXNpbmcub3V0RWxhc3RpYyA9IGZ1bmN0aW9uICggdCApIHtcclxuICAgIGlmICggdCA9PSAwIHx8IHQgPT0gMSApIHJldHVybiB0O1xyXG5cclxuICAgIHJldHVybiBlbGFzdGljQSAqIE1hdGgucG93KCAyLCAtMTAgKiB0ICkgKiBNYXRoLnNpbiggKCB0IC0gZWxhc3RpY1MgKSAqICggMiAqIE1hdGguUEkgKSAvIGVsYXN0aWNQICkgKyAxO1xyXG59O1xyXG5cclxuZWFzaW5nLmluT3V0RWxhc3RpYyA9IGZ1bmN0aW9uICggdCApIHtcclxuICAgIGlmICggdCA9PSAwIHx8IHQgPT0gMSApIHJldHVybiB0O1xyXG4gICAgdCA9IHQgKiAyIC0gMTtcclxuICAgIGlmICggdCA8IDAgKSByZXR1cm4gLTAuNSAqICggZWxhc3RpY0EgKiBNYXRoLnBvdyggMiwgMTAgKiB0ICkgKiBNYXRoLnNpbiggKCB0IC0gZWxhc3RpY1MgKiAxLjUgKSAqICggMiAqIE1hdGguUEkgKSAvICggZWxhc3RpY1AgKiAxLjUgKSApICk7XHJcblxyXG4gICAgcmV0dXJuIDAuNSAqIGVsYXN0aWNBICogTWF0aC5wb3coIDIsIC0xMCAqIHQgKSAqIE1hdGguc2luKCAoIHQgLSBlbGFzdGljUyAqIDEuNSApICogKCAyICogTWF0aC5QSSApIC8gKCBlbGFzdGljUCAqIDEuNSApICkgKyAxO1xyXG59O1xyXG5cclxuZWFzaW5nLmluRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICBpZiAoIHQgPT0gMCApIHJldHVybiAwO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnBvdyggMiwgMTAgKiAoIHQgLSAxICkgKTtcclxufTtcclxuXHJcbmVhc2luZy5vdXRFeHBvbmVudGlhbCA9IGZ1bmN0aW9uICggdCApIHtcclxuICAgIGlmICggdCA9PSAxICkgcmV0dXJuIDE7XHJcblxyXG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdyggMiwgLTEwICogdCApO1xyXG59O1xyXG5cclxuZWFzaW5nLmluT3V0RXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICBpZiAoIHQgPT0gMCB8fCB0ID09IDEgKSByZXR1cm4gdDtcclxuICAgIHQgPSB0ICogMiAtIDE7XHJcbiAgICBpZiAoIHQgPCAwICkgcmV0dXJuIDAuNSAqIE1hdGgucG93KCAyLCAxMCAqIHQgKTtcclxuXHJcbiAgICByZXR1cm4gMSAtIDAuNSAqIE1hdGgucG93KCAyLCAtMTAgKiB0ICk7XHJcbn07XHJcblxyXG5lYXNpbmcubGluZWFyID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgcmV0dXJuIHQ7XHJcbn07XHJcblxyXG5lYXNpbmcuaW5RdWFkcmF0aWMgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICByZXR1cm4gdCAqIHQ7XHJcbn07XHJcblxyXG5lYXNpbmcub3V0UXVhZHJhdGljID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgcmV0dXJuIC10ICogKCB0IC0gMiApO1xyXG59O1xyXG5cclxuZWFzaW5nLmluT3V0UXVhZHJhdGljID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgaWYgKCB0IDwgMC41ICkgcmV0dXJuIDIgKiB0ICogdDtcclxuXHJcbiAgICByZXR1cm4gLTIgKiB0ICogKCB0IC0gMiApIC0gMTtcclxufTtcclxuXHJcbmVhc2luZy5pblF1YXJ0aWMgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcclxufTtcclxuXHJcbmVhc2luZy5vdXRRdWFydGljID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgdCA9IHQgLSAxO1xyXG5cclxuICAgIHJldHVybiAxIC0gdCAqIHQgKiB0ICogdDtcclxufTtcclxuXHJcbmVhc2luZy5pbk91dFF1YXJ0aWMgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICBpZiAoIHQgPCAwLjUgKSByZXR1cm4gOCAqIHQgKiB0ICogdCAqIHQ7XHJcbiAgICB0ID0gdCAtIDE7XHJcblxyXG4gICAgcmV0dXJuIC04ICogdCAqIHQgKiB0ICogdCArIDE7XHJcbn07XHJcblxyXG5lYXNpbmcuaW5RdWludGljID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xyXG59O1xyXG5cclxuZWFzaW5nLm91dFF1aW50aWMgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICB0ID0gdCAtIDE7XHJcblxyXG4gICAgcmV0dXJuIDEgKyB0ICogdCAqIHQgKiB0ICogdDtcclxufTtcclxuXHJcbmVhc2luZy5pbk91dFF1aW50aWMgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICBpZiAoIHQgPCAwLjUgKSByZXR1cm4gMTYgKiB0ICogdCAqIHQgKiB0ICogdDtcclxuICAgIHQgPSB0IC0gMTtcclxuXHJcbiAgICByZXR1cm4gMTYgKiB0ICogdCAqIHQgKiB0ICogdCArIDE7XHJcbn07XHJcblxyXG5lYXNpbmcuaW5TaW5lID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyggdCAqICggTWF0aC5QSSAvIDIgKSApO1xyXG59O1xyXG5cclxuZWFzaW5nLm91dFNpbmUgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zaW4oIHQgKiAoIE1hdGguUEkgLyAyICkgKTtcclxufTtcclxuXHJcbmVhc2luZy5pbk91dFNpbmUgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICByZXR1cm4gLTAuNSAqICggTWF0aC5jb3MoIHQgKiBNYXRoLlBJICkgLSAxICk7XHJcbn07XHJcblxyXG5lYXNpbmcub3V0RWxhc3RpY1Ntb290aCA9IGZ1bmN0aW9uICggdCApIHtcclxuICAgIGlmICggdCA9PSAwIHx8IHQgPT0gMSApIHJldHVybiB0O1xyXG4gICAgdmFyIGVsYXN0aWNBID0gMSwgZWxhc3RpY1AgPSAwLjM4O1xyXG4gICAgdmFyIGVsYXN0aWNTID0gZWxhc3RpY1AgLyA0O1xyXG5cclxuICAgIHJldHVybiBlbGFzdGljQSAqIE1hdGgucG93KCAyLjUsIC0xMCAqIHQgKSAqIE1hdGguc2luKCAoIHQgLSBlbGFzdGljUyApICogKCAyICogTWF0aC5QSSApIC8gZWxhc3RpY1AgKSArIDE7XHJcbn07XHJcblxyXG5lYXNpbmcuaW5FbGFzdGljU21vb3RoMiA9IGZ1bmN0aW9uICggdCApIHtcclxuICAgIGlmICggdCA9PSAwIHx8IHQgPT0gMSApIHJldHVybiB0O1xyXG4gICAgdCA9IHQgLSAxO1xyXG4gICAgdmFyIGVsYXN0aWNBID0gMSwgZWxhc3RpY1AgPSAwLjU3O1xyXG4gICAgdmFyIGVsYXN0aWNTID0gZWxhc3RpY1AgLyA0O1xyXG5cclxuICAgIHJldHVybiAtKCBlbGFzdGljQSAqIE1hdGgucG93KCAyLjYsIDEwICogdCApICogTWF0aC5zaW4oICggdCAtIGVsYXN0aWNTICkgKiAoIDIgKiBNYXRoLlBJICkgLyBlbGFzdGljUCApICk7XHJcbn07XHJcblxyXG5lYXNpbmcub3V0RWxhc3RpY1Ntb290aDIgPSBmdW5jdGlvbiAoIHQgKSB7XHJcbiAgICBpZiAoIHQgPT0gMCB8fCB0ID09IDEgKSByZXR1cm4gdDtcclxuICAgIHZhciBlbGFzdGljQSA9IDEsIGVsYXN0aWNQID0gMC41NztcclxuICAgIHZhciBlbGFzdGljUyA9IGVsYXN0aWNQIC8gNDtcclxuXHJcbiAgICByZXR1cm4gZWxhc3RpY0EgKiBNYXRoLnBvdyggMi42LCAtMTAgKiB0ICkgKiBNYXRoLnNpbiggKCB0IC0gZWxhc3RpY1MgKSAqICggMiAqIE1hdGguUEkgKSAvIGVsYXN0aWNQICkgKyAxO1xyXG59O1xyXG5cclxuZWFzaW5nLm91dEVsYXN0aWNXYXZlID0gZnVuY3Rpb24gKCB0ICkge1xyXG4gICAgaWYgKCB0ID09IDAgfHwgdCA9PSAxICkgcmV0dXJuIHQ7XHJcbiAgICB2YXIgZWxhc3RpY1AgPSAwLjE5O1xyXG4gICAgdmFyIGVsYXN0aWNTID0gZWxhc3RpY1AgLyA0O1xyXG4gICAgdmFyIHRQb3cgPSBNYXRoLnBvdyggdCwgNCApO1xyXG4gICAgdmFyIHYgPSBNYXRoLnBvdyggMjIwLCAtMC43ICogTWF0aC5wb3coIHQsIDAuNCApICkgKiBNYXRoLnNpbiggKCBNYXRoLnBvdyggdCwgMC45NSApIC0gZWxhc3RpY1MgKSAqICggMiAqIE1hdGguUEkgKSAvIGVsYXN0aWNQICkgKyAxO1xyXG5cclxuICAgIHJldHVybiB2ICogKCAxIC0gdFBvdyApICsgdFBvdztcclxufTtcclxuXHJcblxyXG4iLCJleHBvcnQgeyBBcHBsaWNhdGlvbixhcHBsaWNhdGlvbixzdGFnZSB9IGZyb20gXCIuL0FwcGxpY2F0aW9uLmpzXCI7XHJcbmV4cG9ydCB7IEJpdG1hcCB9IGZyb20gXCIuL0JpdG1hcC5qc1wiO1xyXG5leHBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi9Db21wb25lbnQuanNcIjtcclxuZXhwb3J0IHsgQ29tcG9uZW50SG9sZGVyIH0gZnJvbSBcIi4vQ29tcG9uZW50SG9sZGVyLmpzXCI7XHJcbmV4cG9ydCB7IEV2ZW50IH0gZnJvbSBcIi4vRXZlbnQuanNcIjtcclxuZXhwb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcIi4vRXZlbnREaXNwYXRjaGVyLmpzXCI7XHJcbmV4cG9ydCB7IFRydWVUeXBlRm9udCB9IGZyb20gXCIuL1RydWVUeXBlRm9udC5qc1wiO1xyXG5leHBvcnQgeyBCaXRtYXBGb250IH0gZnJvbSBcIi4vQml0bWFwRm9udC5qc1wiO1xyXG5leHBvcnQgeyBNc2RmRm9udCB9IGZyb20gXCIuL01zZGZGb250LmpzXCI7XHJcbmV4cG9ydCB7IEtleUNvZGUgfSBmcm9tIFwiLi9LZXlDb2RlLmpzXCI7XHJcbmV4cG9ydCB7IExheW91dCB9IGZyb20gXCIuL0xheW91dC5qc1wiO1xyXG5leHBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9NYXRyaXguanNcIjtcclxuZXhwb3J0IHsgTWVzaCB9IGZyb20gXCIuL01lc2guanNcIjtcclxuZXhwb3J0IHsgTW92aWVDbGlwIH0gZnJvbSBcIi4vTW92aWVDbGlwLmpzXCI7XHJcbmV4cG9ydCB7IFBhcnRpY2xlcyB9IGZyb20gXCIuL1BhcnRpY2xlcy5qc1wiO1xyXG5leHBvcnQgeyBQaXhlbCB9IGZyb20gXCIuL1BpeGVsLmpzXCI7XHJcbmV4cG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gXCIuL1JlbmRlclRhcmdldC5qc1wiO1xyXG5leHBvcnQgeyBTY2VuZU1hbmFnZXIgfSBmcm9tIFwiLi9TY2VuZU1hbmFnZXIuanNcIjtcclxuZXhwb3J0IHsgU2hhZGVyIH0gZnJvbSBcIi4vU2hhZGVyLmpzXCI7XHJcbmV4cG9ydCB7IFNoYXBlIH0gZnJvbSBcIi4vU2hhcGUuanNcIjtcclxuZXhwb3J0IHsgU291bmQgfSBmcm9tIFwiLi9Tb3VuZC5qc1wiO1xyXG5leHBvcnQgeyBTcGluZSB9IGZyb20gXCIuL1NwaW5lLmpzXCI7XHJcbmV4cG9ydCB7IFNwcml0ZSB9IGZyb20gXCIuL1Nwcml0ZS5qc1wiO1xyXG5leHBvcnQgeyBTdGFnZSB9IGZyb20gXCIuL1N0YWdlLmpzXCI7XHJcbmV4cG9ydCB7IFN0b3JhZ2UgfSBmcm9tIFwiLi9TdG9yYWdlLmpzXCI7XHJcbmV4cG9ydCB7IFRleHRGaWVsZCB9IGZyb20gXCIuL1RleHRGaWVsZC5qc1wiO1xyXG5leHBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIi4vVGV4dHVyZS5qc1wiO1xyXG5leHBvcnQgeyBUZXh0dXJlQmFzZSB9IGZyb20gXCIuL1RleHR1cmVCYXNlLmpzXCI7XHJcbmV4cG9ydCB7IFRleHR1cmVQYWNrIH0gZnJvbSBcIi4vVGV4dHVyZVBhY2suanNcIjtcclxuZXhwb3J0IHsgVGlsZU1hcCB9IGZyb20gXCIuL1RpbGVNYXAuanNcIjtcclxuZXhwb3J0IHsgVGltZXIgfSBmcm9tIFwiLi9UaW1lci5qc1wiO1xyXG5leHBvcnQgeyBUd2VlbiB9IGZyb20gXCIuL1R3ZWVuLmpzXCI7XHJcbmV4cG9ydCB7IFV0aWxzIH0gZnJvbSBcIi4vVXRpbHMuanNcIjtcclxuZXhwb3J0IHsgZWFzaW5nIH0gZnJvbSBcIi4vZWFzaW5nLmpzXCI7XHJcbmV4cG9ydCB7IGhhbmd1bCB9IGZyb20gXCIuL2hhbmd1bC5qc1wiO1xyXG5leHBvcnQgeyBQb2ludCwgUmVjdCB9IGZyb20gXCIuL1R5cGVzLmpzXCI7XHJcbmV4cG9ydCB7IFNlcmlhbGl6ZXIgfSBmcm9tIFwiLi9TZXJpYWxpemVyLmpzXCI7XHJcbiIsIlxuY29uc3QgY2hvU3VuZ1RhYmxlID0gW1wi44SxXCIsIFwi44SyXCIsIFwi44S0XCIsIFwi44S3XCIsIFwi44S4XCIsIFwi44S5XCIsIFwi44WBXCIsIFwi44WCXCIsIFwi44WDXCIsIFwi44WFXCIsIFwi44WGXCIsIFwi44WHXCIsIFwi44WIXCIsIFwi44WJXCIsIFwi44WKXCIsIFwi44WLXCIsIFwi44WMXCIsIFwi44WNXCIsIFwi44WOXCJdO1xuY29uc3QganVuZ1N1bmdUYWJsZSA9IFtcbiAgICBcIuOFj1wiLCBcIuOFkFwiLCBcIuOFkVwiLCBcIuOFklwiLCBcIuOFk1wiLCAvLyAwfjQ7XG4gICAgXCLjhZRcIiwgXCLjhZVcIiwgXCLjhZZcIiwgXCLjhZdcIiwgXCLjhZhcIiwgLy8gNX45O1xuICAgIFwi44WZXCIsIFwi44WaXCIsIFwi44WbXCIsIFwi44WcXCIsIFwi44WdXCIsIC8vIDEwfjE0O1xuICAgIFwi44WeXCIsIFwi44WfXCIsIFwi44WgXCIsIFwi44WhXCIsIFwi44WiXCIsIC8vIDE1fjE5O1xuICAgIFwi44WjXCJdO1xuY29uc3Qgam9uZ1N1bmdUYWJsZSA9IFtcIiBcIiwgXCLjhLFcIiwgXCLjhLJcIiwgXCLjhLNcIiwgXCLjhLRcIiwgXCLjhLVcIiwgXCLjhLZcIiwgXCLjhLdcIiwgXCLjhLlcIiwgXCLjhLpcIiwgXCLjhLtcIiwgXCLjhLxcIiwgXCLjhL1cIiwgXCLjhL5cIiwgXCLjhL9cIiwgXCLjhYBcIiwgXCLjhYFcIiwgXCLjhYJcIiwgXCLjhYRcIiwgXCLjhYVcIiwgXCLjhYZcIiwgXCLjhYdcIiwgXCLjhYhcIiwgXCLjhYpcIiwgXCLjhYtcIiwgXCLjhYxcIiwgXCLjhY1cIiwgXCLjhY5cIl07XG5cbmNvbnN0IGNob1N1bmdUb0NvZGUgPSB7fTtcbmNvbnN0IGp1bmdTdW5nVG9Db2RlID0ge1xuICAgIFtcIuOFj+OFo1wiXTogIDEsXG4gICAgW1wi44Wj44WPXCJdOiAgMixcbiAgICBbXCLjhZHjhaNcIl06ICAzLFxuICAgIFtcIuOFk+OFo1wiXTogIDUsXG4gICAgW1wi44Wj44WTXCJdOiAgNixcbiAgICBbXCLjhZXjhaNcIl06ICA3LFxuICAgIFtcIuOFl+OFj1wiXTogIDksXG4gICAgW1wi44WX44WQXCJdOiAgMTAsXG4gICAgW1wi44WX44WP44WjXCJdOiAxMCxcbiAgICBbXCLjhZfjhaNcIl06ICAxMSxcbiAgICBbXCLjhaPjhZdcIl06ICAxMixcbiAgICBbXCLjhZzjhZNcIl06ICAxNCxcbiAgICBbXCLjhZzjhZRcIl06ICAxNSxcbiAgICBbXCLjhZzjhZPjhaNcIl06IDE1LFxuICAgIFtcIuOFnOOFo1wiXTogIDE2LFxuICAgIFtcIuOFoeOFnFwiXTogIDE3LFxuICAgIFtcIuOFoeOFo1wiXTogIDE5LFxufTtcbmNvbnN0IGpvbmdTdW5nVG9Db2RlID0ge307XG5cbmZvciAoIGxldCBpID0gMDsgaSA8IGNob1N1bmdUYWJsZS5sZW5ndGg7IGkrKyApIHtcbiAgICBjb25zdCB2ID0gY2hvU3VuZ1RhYmxlW2ldO1xuXG4gICAgY2hvU3VuZ1RvQ29kZVt2XSA9IGk7XG59XG5cbmZvciAoIGxldCBpID0gMDsgaSA8IGp1bmdTdW5nVGFibGUubGVuZ3RoOyBpKysgKSB7XG4gICAgY29uc3QgdiA9IGp1bmdTdW5nVGFibGVbaV07XG5cbiAgICBqdW5nU3VuZ1RvQ29kZVt2XSA9IGk7XG59XG5cbmZvciAoIGxldCBpID0gMDsgaSA8IGpvbmdTdW5nVGFibGUubGVuZ3RoOyBpKysgKSB7XG4gICAgY29uc3QgdiA9IGpvbmdTdW5nVGFibGVbaV07XG5cbiAgICBqb25nU3VuZ1RvQ29kZVt2XSA9IGk7XG59XG5cbmNvbnN0IHVuaUNvZGVIYW5ndWxCYXNlID0gMHhhYzAwO1xuY29uc3QgdW5pQ29kZUhhbmd1bExhc3QgPSAweGQ3OWY7XG5cbmV4cG9ydCBjb25zdCBoYW5ndWwgPSB7fTtcblxuZnVuY3Rpb24gdWNoYXJUb051bWJlciggdWNoYXIgKSB7XG4gICAgcmV0dXJuIHVjaGFyLmNoYXJDb2RlQXQoIDAgKTtcbn1cblxuY29uc3QgcmFuZ2VIYW5ndWwgPSBbdWNoYXJUb051bWJlciggXCLqsIBcIiApLCB1Y2hhclRvTnVtYmVyKCBcIu2eo1wiICldO1xuXG5oYW5ndWwuaXNWYWxpZFVuaWNvZGUgPSBmdW5jdGlvbiAoIHVjaGFyICkge1xuICAgIC8vW+qwgC3tnqNdIOqygOyCrCwgXG4gICAgY29uc3QgbnVtID0gdWNoYXJUb051bWJlciggdWNoYXIgKTtcblxuICAgIHJldHVybiBudW0gPj0gcmFuZ2VIYW5ndWxbMF0gJiYgbnVtIDw9IHJhbmdlSGFuZ3VsWzFdO1xufTtcblxuY29uc3QgcmFuZ2VIYW5ndWxKYSA9IFt1Y2hhclRvTnVtYmVyKCBcIuOEsVwiICksIHVjaGFyVG9OdW1iZXIoIFwi44WOXCIgKV07XG5jb25zdCByYW5nZUhhbmd1bE1vID0gW3VjaGFyVG9OdW1iZXIoIFwi44WPXCIgKSwgdWNoYXJUb051bWJlciggXCLjhaNcIiApXTtcblxuaGFuZ3VsLmlzSmFtbyA9IGZ1bmN0aW9uICggdWNoYXIgKSB7XG4gICAgLy/snpDrqqgg7Jes67aAIOqygOyCrCDqsoDsgqxcbiAgICBjb25zdCBudW0gPSB1Y2hhclRvTnVtYmVyKCB1Y2hhciApO1xuXG4gICAgcmV0dXJuICggbnVtID49IHJhbmdlSGFuZ3VsSmFbMF0gJiYgbnVtIDw9IHJhbmdlSGFuZ3VsSmFbMV0gKSB8fFxuXHRcdCggbnVtID49IHJhbmdlSGFuZ3VsTW9bMF0gJiYgbnVtIDw9IHJhbmdlSGFuZ3VsTW9bMV0gKTtcbn07XG5cbi8vIOuniOyngOunieydtCDsooXshLHsnbQg6rKA7IKsXG5oYW5ndWwuaXNKb25nU3VuZyA9IGZ1bmN0aW9uICggc3RyICkge1xuICAgIGNvbnN0IGNoYXIgPSBzdHIuc3Vic3RyKCBzdHIubGVuZ3RoIC0gMSApO1xuICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoIDAgKTtcblxuICAgIGlmICggY29kZSA8IHVuaUNvZGVIYW5ndWxCYXNlIHx8IGNvZGUgPiB1bmlDb2RlSGFuZ3VsTGFzdCApIHtcbiAgICAgICAgY29uc3QgY2hvU3VuZyA9IGNob1N1bmdUb0NvZGVbY2hhcl07XG5cbiAgICAgICAgaWYgKCBjaG9TdW5nICkge1xuICAgICAgICAgICAgLy8g7J6Q7J2M7J2AIOuqqOuRkCDrsJvsuajsnbQg7J6I6rKMIOuwnOydjOuQnOuLpFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIFwiYmNkZmdoamtsbW5wcXJzdHZ3eHoxMzY3ODBcIi5pbmRleE9mKCBjaGFyICkgPj0gMCApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIOu2hO2VtO2VtOyEnCDrsJvsuajsnbQg7J6I64qU7KeAIOuzuOuLpFxuICAgIGxldCB1YyA9IGNvZGUgLSB1bmlDb2RlSGFuZ3VsQmFzZTtcblxuICAgIC8vY29uc3QgY2hvU3VuZyA9IE1hdGguZmxvb3IodWMgLyAoMjEgKiAyOCkpO1xuICAgIHVjID0gdWMgJSAoIDIxICogMjggKTtcbiAgICAvL2NvbnN0IGp1bmdTdW5nID0gTWF0aC5mbG9vcih1YyAvIDI4KTtcbiAgICB1YyA9IHVjICUgMjg7XG4gICAgY29uc3Qgam9uZ1N1bmcgPSB1YztcblxuICAgIHJldHVybiBqb25nU3VuZyA+IDA7XG59O1xuXG5cblxuXG4vLyDrjIDtlZzrr7zqta1766W8fSDqsIDroKTrqbQgW+u5hO2Wieq4sF177J2EfSDtg4DrnbxcblxuaGFuZ3VsLnJlcGxhY2VKb1NhID0gZnVuY3Rpb24gKCBpbnB1dFRleHQgKSB7XG4gICAgaWYgKCBpbnB1dFRleHQgPT0gbnVsbCB8fCBpbnB1dFRleHQgPT0gXCJcIiApIHJldHVybiBpbnB1dFRleHQ7XG5cbiAgICAvL2xldCB3b3JkcyA9IGlucHV0VGV4dC5tYXRjaCgvXFxzKihbXFxTXSspeyhbXi99XSspfS9nKTtcbiAgICBjb25zdCByZSA9IC99PyhbXn1dKil7KFteL31dKil9L2c7XG4gICAgbGV0IHJlc3VsdCA9IHJlLmV4ZWMoIGlucHV0VGV4dCApO1xuICAgIC8vY29uc3Qgd29yZHMgPSBbXTtcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICBsZXQgcyA9IFwiXCI7XG5cbiAgICB3aGlsZSAoIHJlc3VsdCAhPSBudWxsICkge1xuICAgICAgICBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIGNvbnN0IFtwcmUsIGpvU2EsIGxhc3RDaGFyXSA9IFtcbiAgICAgICAgICAgIC8vUmVnRXhwLmxhc3RNYXRjaCxcbiAgICAgICAgICAgIFJlZ0V4cC4kMSxcbiAgICAgICAgICAgIFJlZ0V4cC4kMixcbiAgICAgICAgICAgIFJlZ0V4cC4kMS5tYXRjaCggLy5bJ1wiYF4oKVtcXF1dPyQvIClbMF0uc3Vic3RyKCAwLCAxICksIC8vIOuniOyngOuniSDquIDsnpBcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaXNKb25nU3VuZyA9IGhhbmd1bC5pc0pvbmdTdW5nKCBsYXN0Q2hhciApO1xuICAgICAgICBjb25zdCBqb25nU3VuZyA9IGlzSm9uZ1N1bmcgPyBoYW5ndWwuZGl2aWRlSmFTbyggbGFzdENoYXIgKVsyXSA6IG51bGw7XG4gICAgICAgIGxldCBuZXdKb1NhO1xuXG4gICAgICAgIGlmICggam9TYSA9PSBcIuydhFwiIHx8IGpvU2EgPT0gXCLrpbxcIiApIHtcbiAgICAgICAgICAgIG5ld0pvU2EgPSBpc0pvbmdTdW5nID8gXCLsnYRcIiA6IFwi66W8XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIGpvU2EgPT0gXCLsnbRcIiB8fCBqb1NhID09IFwi6rCAXCIgKSB7XG4gICAgICAgICAgICBuZXdKb1NhID0gaXNKb25nU3VuZyA/IFwi7J20XCIgOiBcIuqwgFwiO1xuICAgICAgICB9IGVsc2UgaWYgKCBqb1NhID09IFwi6rO8XCIgfHwgam9TYSA9PSBcIuyZgFwiICkge1xuICAgICAgICAgICAgbmV3Sm9TYSA9IGlzSm9uZ1N1bmcgPyBcIuqzvFwiIDogXCLsmYBcIjtcbiAgICAgICAgfSBlbHNlIGlmICggam9TYSA9PSBcIuydgFwiIHx8IGpvU2EgPT0gXCLripRcIiApIHtcbiAgICAgICAgICAgIG5ld0pvU2EgPSBpc0pvbmdTdW5nID8gXCLsnYBcIiA6IFwi64qUXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIGpvU2EgPT0gXCLsnbTripRcIiApIHtcbiAgICAgICAgICAgIG5ld0pvU2EgPSBpc0pvbmdTdW5nID8gXCLsnbTripRcIiA6IFwi64qUXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIGpvU2EgPT0gXCLsnbTsmYBcIiApIHtcbiAgICAgICAgICAgIG5ld0pvU2EgPSBpc0pvbmdTdW5nID8gXCLsnbTsmYBcIiA6IFwi7JmAXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIGpvU2EgPT0gXCLsl6xcIiB8fCBqb1NhID09IFwi7J207JesXCIgKSB7XG4gICAgICAgICAgICBuZXdKb1NhID0gaXNKb25nU3VuZyA/IFwi7J207JesXCIgOiBcIuyXrFwiO1xuICAgICAgICB9IGVsc2UgaWYgKCBqb1NhID09IFwi7Jy866GcXCIgfHwgam9TYSA9PSBcIuuhnFwiICkge1xuICAgICAgICAgICAgbmV3Sm9TYSA9ICggaXNKb25nU3VuZyAmJiBqb25nU3VuZyAhPSBcIuOEuVwiICkgPyBcIuycvOuhnFwiIDogXCLroZxcIjtcbiAgICAgICAgfSBlbHNlIGlmICggam9TYSA9PSBcIuydtOuEpFwiIHx8IGpvU2EgPT0gXCLrhKRcIiApIHtcbiAgICAgICAgICAgIG5ld0pvU2EgPSBpc0pvbmdTdW5nID8gXCLsnbTrhKRcIiA6IFwi64SkXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIGpvU2EgPT0gXCLsnbTrnpFcIiB8fCBqb1NhID09IFwi656RXCIgKSB7XG4gICAgICAgICAgICBuZXdKb1NhID0gaXNKb25nU3VuZyA/IFwi7J20656RXCIgOiBcIuuekVwiO1xuICAgICAgICB9IGVsc2UgaWYgKCBqb1NhID09IFwi6528XCIgKSB7XG4gICAgICAgICAgICBuZXdKb1NhID0gaXNKb25nU3VuZyA/IFwi7J206528XCIgOiBcIuudvFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcyA9IHMgKyBwcmUgKyBuZXdKb1NhO1xuXG4gICAgICAgIHJlc3VsdCA9IHJlLmV4ZWMoIGlucHV0VGV4dCApO1xuICAgIH1cblxuICAgIHJldHVybiBzICsgaW5wdXRUZXh0LnN1YnN0ciggbGFzdEluZGV4ICk7XG59O1xuXG5oYW5ndWwuZm9ybWF0ID0gZnVuY3Rpb24gKCB0ZXh0LCAuLi5hcmdzICkge1xuICAgIGxldCBzO1xuXG4gICAgaWYgKCBhcmdzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIC8vICVzICVkXG4gICAgICAgIC8vICUwICUxICUyICUzICU0Li4uXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgcyA9IHRleHQucmVwbGFjZSggLyVbc3xkXS9nLCBmdW5jdGlvbiAoIHMgKSB7XG4gICAgICAgICAgICByZXR1cm4gYCUke2NvdW50Kyt9YDtcbiAgICAgICAgfSApO1xuXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBgJSR7aX1gLCBhcmdzW2ldICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgcyA9IHRleHQ7XG5cbiAgICByZXR1cm4gaGFuZ3VsLnJlcGxhY2VKb1NhKCBzICk7XG59O1xuXG4vLyDsnpDshozrpbwg7ZWp7Lmc64ukXG5oYW5ndWwubWVyZ2VKYVNvID0gZnVuY3Rpb24gKCBjaG9TdW5nLCBqdW5nU3VuZywgam9uZ1N1bmcgKSB7XG4gICAgLy9sb2coY2hvU3VuZyxqdW5nU3VuZyxqb25nU3VuZyk7XG4gICAgY29uc3QgY2hvU3VuZ1BvcyA9IGNob1N1bmdUb0NvZGVbY2hvU3VuZ107XG4gICAgY29uc3QganVuZ1N1bmdQb3MgPSBqdW5nU3VuZ1RvQ29kZVtqdW5nU3VuZ107XG4gICAgY29uc3Qgam9uZ1N1bmdQb3MgPSBqb25nU3VuZyA/IGpvbmdTdW5nVG9Db2RlW2pvbmdTdW5nXSA6IDA7XG4gICAgY29uc3QgY29kZSA9IHVuaUNvZGVIYW5ndWxCYXNlICsgKCBjaG9TdW5nUG9zICogMjEgKyBqdW5nU3VuZ1BvcyApICogMjggKyBqb25nU3VuZ1BvcztcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjb2RlICk7XG59O1xuXG4vLyDquIDsnpDtlZjrgpjrpbwg7J6Q7IaM66GcIOu2hOumrO2VnOuLpFxuaGFuZ3VsLmRpdmlkZUphU28gPSBmdW5jdGlvbiAoIGNoYXIgKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCggMCApO1xuXG4gICAgaWYgKCBjb2RlIDwgdW5pQ29kZUhhbmd1bEJhc2UgfHwgY29kZSA+IHVuaUNvZGVIYW5ndWxMYXN0ICkge1xuICAgICAgICBjb25zdCBjaG9TdW5nID0gY2hvU3VuZ1RvQ29kZVtjaGFyXTtcblxuICAgICAgICBpZiAoIGNob1N1bmcgKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Nob1N1bmdUYWJsZVtjaG9TdW5nXV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBqdW5nU3VuZyA9IGp1bmdTdW5nVG9Db2RlW2NoYXJdO1xuXG4gICAgICAgIGlmICgganVuZ1N1bmcgKSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIGp1bmdTdW5nVGFibGVbanVuZ1N1bmddXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgdWMgPSBjb2RlIC0gdW5pQ29kZUhhbmd1bEJhc2U7XG4gICAgY29uc3QgY2hvU3VuZyA9IE1hdGguZmxvb3IoIHVjIC8gKCAyMSAqIDI4ICkgKTtcblxuICAgIHVjID0gdWMgJSAoIDIxICogMjggKTtcbiAgICBjb25zdCBqdW5nU3VuZyA9IE1hdGguZmxvb3IoIHVjIC8gMjggKTtcblxuICAgIHVjID0gdWMgJSAyODtcbiAgICBjb25zdCBqb25nU3VuZyA9IHVjO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgY2hvU3VuZ1RhYmxlW2Nob1N1bmddLFxuICAgICAgICBqdW5nU3VuZ1RhYmxlW2p1bmdTdW5nXSxcbiAgICAgICAgKCBqb25nU3VuZyA+IDAgJiYgam9uZ1N1bmdUYWJsZVtqb25nU3VuZ10gfHwgbnVsbCApXG4gICAgXTtcbn07XG5cbi8vIOydtCDsupDrpq3thLDqsIAg7J6Q7IaM7KSR7JeQIO2VmOuCmOyduOyngCDqsoDsgqxcbmhhbmd1bC5nZXRUeXBlT2ZKYVNvID0gZnVuY3Rpb24gKCBjaGFyICkge1xuICAgIGxldCBbZjEsIGYyLCBmM10gPSBbZmFsc2UsIGZhbHNlLCBmYWxzZV07XG4gICAgY29uc3QgY2hvU3VuZyA9IGNob1N1bmdUb0NvZGVbY2hhcl07XG5cbiAgICBpZiAoIGNob1N1bmcgKSB7XG4gICAgICAgIGYxID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBqdW5nU3VuZyA9IGp1bmdTdW5nVG9Db2RlW2NoYXJdO1xuXG4gICAgaWYgKCBqdW5nU3VuZyApIHtcbiAgICAgICAgZjIgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGpvbmdTdW5nID0gam9uZ1N1bmdUb0NvZGVbY2hhcl07XG5cbiAgICBpZiAoIGpvbmdTdW5nICkge1xuICAgICAgICBmMyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtmMSwgZjIsIGYzXTtcbn07XG5cbi8vIGNvbnNvbGUubG9nKGhhbmd1bC5kaXZpZGVKYVNvKFwi7ZWcXCIpKTtcbi8vIGNvbnNvbGUubG9nKGhhbmd1bC5tZXJnZUphU28oLi4uaGFuZ3VsLmRpdmlkZUphU28oXCLquIBcIikpKTtcbi8vIGNvbnNvbGUubG9nKGhhbmd1bC5pc0phbW8oXCLtlZxcIikpO1xuLy8gY29uc29sZS5sb2coaGFuZ3VsLmlzSmFtbyhcIuOFj1wiKSk7XG4vLyBjb25zb2xlLmxvZyhoYW5ndWwuaXNKb25nU3VuZyhcIuqwhFwiKSk7XG4vLyBjb25zb2xlLmxvZyhoYW5ndWwuaXNKb25nU3VuZyhcIuqwgFwiKSk7XG4vLyBjb25zb2xlLmxvZyhoYW5ndWwuaXNKb25nU3VuZyhcImJvYlwiKSk7XG4vLyBjb25zb2xlLmxvZyhoYW5ndWwucmVwbGFjZUpvU2EoXCLrjIDtlZzrr7zqta1766W8fSDqsIDroKTrqbQgJ+u5hO2Wieq4sCd77J2EfSDtg4DrnbwgMzIze+uhnH1cIikpO1xuIiwiaW1wb3J0IHsgYXBwbGljYXRpb24sIFJlbmRlclRhcmdldCwgVGltZXIsIEV2ZW50LCBCaXRtYXAgfSBmcm9tIFwiQGVuZ2luZS9mbGF0ZmFzdFwiO1xyXG5pbXBvcnQgeyB2c1N0YWdlLCBWc1BhbGV0dGUsVnNTcHJpdGUsVnNIYW5ndWwgfSBmcm9tIFwiLi92c1dyYXBwZXIvdnNcIjtcclxuXHJcblxyXG5jb25zdCBkaWFsb2dEYXRhID0ge1xyXG4gICAgXCIxcFwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkFcIiwgdGltZTogMCwgZGlhbG9nOiBcIuyXkOq1rOyXkOq1rC4uXFxu65iQ64uk7IucIOy2nOqyqeydtOudvOuLiC4uXCIgfSxcclxuICAgIF0sXHJcbiAgICBcIjJwXCI6IFtcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi7IKw7IaMLCDstpzqsqntlanri4jri6R+IVwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCIxcDJwXCI6IFtcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAzLCBkaWFsb2c6IFwi7JWE7J207YWc7J2AIOqzte2Pie2VmOqyjFxcbuuCmOuIoOuoueq4sOyXkOyalCFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDAsIGRpYWxvZzogXCLqt7jqsbDslbwg64ql66Cl6ruPIOuoueuKlOqxsOyngFxcbu2XkO2XkH5cIiB9LFxyXG4gICAgXSxcclxuICAgIFwiZXhpdFwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkNcIiwgdGltZTogMiwgZGlhbG9nOiBcIuqwiOugpOqzoD8g6re465+8IOyngOq1rOuKlCDrgrQg7LCo7KeA64u3IVxcbu2BrO2RuO2VmO2DgO2DgO2DgO2DgCFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJDXCIsIHRpbWU6IDIsIGRpYWxvZzogXCLqt7jrnpgg66eo64KgIOqzteu2gOunjCDtlbTrnbwhXFxu7LmY7IKs7ZWcIOuFgOyEnSDqsJnsnLzri4h+XCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRFwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7Ja0ISDsp4Tsp5wg6rCI66Ck6rOgPyDqsIDsp4Drp4jsnol+XFxu7KKAIOuNlCDtlbTrtJDsnol+XCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiAzLCBkaWFsb2c6IFwiRVhJVCBUTyBET1M/XCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwiRE9T64qUIOydtOygnCDsl4bslrRcXG7rqrvrgpjqsIBcIiB9LFxyXG4gICAgICAgIHsgZXZlbnQ6IFwibW9kZTp0aXRsZVwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCI5XCI6IFtcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi64KY64qUIOygnOyekeyekEHri6QuXFxu67aA65SUIDHrk7Hsg4HsnYQg7YOA7Jik6riwIOuwlOuegOuLpC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsnbjsgrzsnYQg66i57Jy866m0IOyVhOuemCDqsozsnbTsp4Dsl5BcXG7tlZjrgpjslKkg67aI7J20IOy8nOynhOuLpC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsm5DtlZjripQg7YyM7JuM7JeF7JeQIOu2iOydtCDsvJzsp4jrlYxcXG7tjIzsm4zsl4Ug67KE7Yq87J2EIOuIhOultOuptCDrkJzri6QuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7ZWg67CV7IKs64qUIOy7pOyEnO2CpOyZgFxcbk4sIE3snLzroZwg7KGw7KKF7ZWY6rOgXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7IKw7IaM64qUIFdBU0TtgqTsmYBcXG5aLCBY66GcIOyhsOyihe2VmOuptCDrkJzri6QuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi64ukIOyVhOuKlCDqsbDri4jquYwg6re466eM7ZW0XFxu7Iuc64GE65+964ukLi4g7K+nLlwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCIxNlwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkJcIiwgdGltZTogMywgZGlhbG9nOiBcIuyVlywg64iI7J20IOu2gOyFlCFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDQsIGRpYWxvZzogXCIxMDBr6rKM7J6E7JeQIOydtCDsoJXrj4TsnZgg7Yq57IiYXFxu7Zqo6rO8652864uILi4g64yA64uo7ZWY6rWwLlwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogMCwgZGlhbG9nOiBcIu2bhO2bhO2bhCDsnbQg7KCV64+E66W8IOqwgOyngOqzoFxcbuyRpeyKpOufveqyjC5cIiB9LFxyXG4gICAgXSxcclxuICAgIFwiMjBcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJCXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLqs4Tsho0g65iR6rCZ7J2AIOuwsOqyveunjCDrgpjsmKTsnpbslYQuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi662j7J20ISDsnpDshLjtnogg67O066m0XFxu7KGw6riI7JSpIOuLpOultOuLqCDrp5DsnbTri6QhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiAzLCBkaWFsb2c6IFwi7JWXLCDsnpDrhKgg64iE6rWw6rCAP1wiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkZcIiwgdGltZTogNCwgZGlhbG9nOiBcIuydjC4uIOyGjOqwnOqwgCDriqbsl4jqtbAuXFxu64KY64qUIOygnOyekeyekELsmpQuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7Jqp65+J7J2EIOyVhOuBvOuKkOudvCDqt7jrn7DqsbDri4hcXG7rsLDqsr3snbQg7I2w66CB7ZW064+EIOydtO2VtO2VmOyKiC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJCXCIsIHRpbWU6IDAsIGRpYWxvZzogXCLsp4Dro6jtlbQuLiAtXy07XCIgfSxcclxuICAgIF0sXHJcbiAgICBcIjI3XCI6IFtcclxuICAgICAgICB7IGZhY2U6IFwiQ1wiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7ZuX7ZuX7ZuXLi4g65Oc65SU7Ja0IOuztOyKpOq1sC5cXG7rgrQg7J2066aE7J2AIOyCtOuqqOyCrCFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJDXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsoITtjrjsl5DshJzripQg642w66qo7JeQ66eMIOuCmOyYqFxcbuu5hOyatOydmCDslYXsl63snbTsp4AhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiAzLCBkaWFsb2c6IFwi7IK066qo7IKsIOuwleyCrOudvOq1rCFcXG7sgrDshozslbwsIOyhsOyLrO2VtOudvCFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJCXCIsIHRpbWU6IDAsIGRpYWxvZzogXCLrhKQsIO2VoOyVhOuyhOyngCFcIiB9LFxyXG4gICAgXSxcclxuICAgIFwiMzFcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJEXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsmrDslKguLiDrkZDqs6Drs7TsnpAhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi66mU7JeQ66GxflwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCIzNFwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkJcIiwgdGltZTogNCwgZGlhbG9nOiBcIuyXrOq4tCDsmrDrpqztlZnqtZDsnpbslYQhXFxu6re8642wIOyZnCDsnbTrpqwg7J207IOB7ZW0P1wiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogNCwgZGlhbG9nOiBcIuyaqeufieuVjOusuOyXkFxcbuuLpCDsgq3soJztlbTshJwg6re4656YLlwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkFcIiwgdGltZTogMywgZGlhbG9nOiBcIuyghO2OuOyXkOyEoCDsooAg64KY7JWY64qU642wLi5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJGXCIsIHRpbWU6IDAsIGRpYWxvZzogXCLsp4DquIgg67Cw6rK97J2AIOyghO2OuOydmFxcbjEvMTDrtoTrn4nsnZgg7YOA7J287J207JW8IVwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCIzOVwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkFcIiwgdGltZTogMywgZGlhbG9nOiBcIuyVly4uIOuPhOyEnOq0gOydtC4uXFxu7IK066qo7IKs7J2YIOynk+yduOqwgC4uXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAzLCBkaWFsb2c6IFwi64KY7IGcIOuFgOyEnS4uXFxu7JWE66aE64uk7Jq0IO2Vmeq1kOulvC4uXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRlwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi66+47JWI7ZWY64ukLlxcbuyaqeufieuVjOusuOyXkCDrgrTqsIAg6re465+w6rGw7JW8flwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCI0M1wiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkJcIiwgdGltZTogMCwgZGlhbG9nOiBcIuydtOqyjCDrrZDslbwgLV8tO1wiIH0sXHJcbiAgICBdLFxyXG4gICAgXCI0NVwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogNCwgZGlhbG9nOiBcIuydtOu0kOydtOu0kCwg7KCV7Iug7LCo66CkIVxcbuuztOyKpCDrk7HsnqXsnbTri6QhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiA2LCBkaWFsb2c6IFwi7J2067KIIOuztOyKpOuKlC4uXFxu7KCE7Y647JeQIOydtOyWtCDstIjrjIDtmJUg7Jik66asIVwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogNCwgZGlhbG9nOiBcIi4u66GcIO2VoOugpOqzoCDtlojripTrjbBcXG7sgq3soJzrkJDri6QuIO2XmO2XmC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJDXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsooAg6re87IKs7ZWcIOqxuOuhnFxcbuyjvOyngCDqt7jrnqzslrQhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi7J6QLCDslrTsqIzrk6Ag64yA6rKw7J2064ukIVwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCI1MVwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkRcIiwgdGltZTogNCwgZGlhbG9nOiBcIuu2gC4u67aE7ZWY64ukIVxcbuuztOyKpOunjCDsu7jslrTrj4QuLiFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsnpDqs6DroZwg7KCV7J2Y64qUIOyKueumrO2VmOuKlCDrspUhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi66mL7J6I7Ja07JqUIO2VoOyVhOuyhOyngH5cIiB9LFxyXG4gICAgXSxcclxuICAgIFwiNTVcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLslrTrlYwsXFxuMeuTseyDgeydgCDtg4gg7IiYIOyeiOydhOqygyDqsJnrgpg/XCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7K+n7K+ULi4g7J6Q6rOg66GcIOusvOyaleyXkFxcbuuIiOydtCDslrTrkZDsm4zshKAg66ed7ZWY64qU67KVLlwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogMywgZGlhbG9nOiBcIuuLueyLoOuPhCDrnbzrqbTrp4wg66i57Jy866mwXFxu6rKM7J6EIOunjOuTpOyWtCDrtJAhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiAzLCBkaWFsb2c6IFwi6rKM7J6E7KCc7J6R7J6Q6rCAIOyWvOuniOuCmFxcbuuwsOqzoO2UiOyngCDslYzslYQ/XCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRlwiLCB0aW1lOiAzLCBkaWFsb2c6IFwi7Z2R7Z2RLi4g7J20IOqyjOyehCDrp4zrk5zripDrnbxcXG7rgpjtnZjrj5nslYgg7LSI7L2U7YyM7J2067CW7JeQIOuqu+uoueyXiOuLpC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLqt7jrnpgg7J206rG466GcIO2VnCDrqqtcXG7snqHripTqsbDslbwg7KCc7J6R7J6QQiFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJGXCIsIHRpbWU6IDAsIGRpYWxvZzogXCLrlLDrnLvtlZwg67Cl7J20IOuoueqzoOyLtuuLpFxcbuygnOyekeyekEEhXCIgfSxcclxuICAgIF0sXHJcbiAgICBcIjYzXCI6IFtcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7JmcIOqzhOyGjSDsmrDso7zrp4wg64KY7Jik64qU6rGw7KeALlwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkZcIiwgdGltZTogNCwgZGlhbG9nOiBcIuyaqeufieuVnOyXkCDsgq3soJztlojslrQuLlwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkJcIiwgdGltZTogNCwgZGlhbG9nOiBcIuyXkOydtCDsjbDroIHtlbQhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi64SIIOqzhOyGjSDrlqDrk6TrqbRcXG7rqLjrpqzsubTrnb0g7Z2U65Ok66as64qUIOqxsFwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogNCwgZGlhbG9nOiBcIuygleyngOyLnOy8nOuyhOumsOuLpCFcXG427ZSE66CI7J6E7J2064KYIOuQnOuLqOunkOyVvC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJGXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLqt7jrnpgg6re465+s7J6QflxcbuyaqeufieydtCDslYTquZ3ri6QuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi7LmrLi4g7LmY7IKs7ZW0Li5cIiB9LFxyXG4gICAgXSxcclxuICAgIFwiNzFcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDIsIGRpYWxvZzogXCLrs7TsiqTrk7HsnqUhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQ1wiLCB0aW1lOiAyLCBkaWFsb2c6IFwi7KCc7J6R7J6QIOyWkeuwmCxcXG7snbTrsojsl5Qg7KKAIO2BsCDqsbjro6guLlwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogNiwgZGlhbG9nOiBcIuydtOuyiOyXlCDrr7/slrTrtJAhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiAyLCBkaWFsb2c6IFwi7JWELi4g7JWE64uIIOydtOqxtC4uIVwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkJcIiwgdGltZTogNCwgZGlhbG9nOiBcIuyaqeufiSDslYTrgoDrjIDrjZTri4guLlxcbuydtOqyjCDrrZDslbwhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7J2MLi4g7J6Q6rOg66GcLi5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsoovsnYDqsowg7KKL7J2A6rGw7KeAXFxuXl9eO1wiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkNcIiwgdGltZTogNCwgZGlhbG9nOiBcIuunnuyVhCDrp57slYR+XCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi7Jy87J206rWsIOuCqOyekOuTpOydtOuegDtcIiB9LFxyXG4gICAgXSxcclxuICAgIFwiODFcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJEXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLrr7jsnbjqs4Trj4Qg7Iuk7Yyo7JW8Li5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsqZ0uLiDslYTsib3qtbAuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7ZWg7JWE67KE7KeAIVwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkNcIiwgdGltZTogMCwgZGlhbG9nOiBcIuuRkOqzoOuztOyekCDtnZHtnZEuLlwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCI4NlwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogNCwgZGlhbG9nOiBcIuqxsOydmCDri6Qg7JmU64ukLlxcbuydtOuyiCDtjJDsnYAg7KKAIOyWtOugpOybjC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsl6zquLDquYzsp4Ag7JmA7IScXFxu66y865+s64KgIOyInCDsl4bsp4AhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7Z6Y64K07J6QLCDtmZTsnbTtjIUhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi66CI7J207KCA66Gc64qUIOydtCDsiqTthYzsnbTsp4DrpbxcXG7thrXqs7ztlZjsp4Ag66q77ZW0LlwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkZcIiwgdGltZTogMCwgZGlhbG9nOiBcIuyKpO2FjOydtOyngCDstIjrsJjsl5BcXG4n6r2dJ+ydhCDrqLnslrTrkZDrj4TroZ0uXCIgfSxcclxuICAgIF0sXHJcbiAgICBcIjkyXCI6IFtcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7ZeJ7ZeJLi5cXG7soJXrp5Ag7Z6Y65OgIOyKpO2FjOydtOyngOq1sC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsgrDshozslbxcXG7sl6zquLDshJwg7Y+s6riw7ZWY66m0IOyViOuPvC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJGXCIsIHRpbWU6IDAsIGRpYWxvZzogXCLquLjsnYQg7J6YIOyEoO2Dne2VmOuPhOuhnS5cIiB9LFxyXG4gICAgXSxcclxuICAgIFwiOTZcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJGXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLrk5zrlJTslrQg67O07Iqk6rmM7KeAIOyZlOq1sC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsnbTrsogg67O07Iqk64+EIOuMgO2YleydtOuLpC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLqsbDsp5Prp5Ag66eIXFxu7J207KCgIOuCqOydgCDsmqnrn4nsnbQg7JeG7J2E6rG4LlwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkJcIiwgdGltZTogMywgZGlhbG9nOiBcIuunnuyVhFxcbjEwMGsg64ukIOyNvOqyoOuLpC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDYsIGRpYWxvZzogXCLqt7jrn7wg7J206rG0IOyWtOuVjD9cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLsnLztl4kg7J206rKMIOutkOyVvCAtXy07XCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAzLCBkaWFsb2c6IFwi67Cc7JWF7J2EIO2VmOuKlOq1sC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJDXCIsIHRpbWU6IDAsIGRpYWxvZzogXCLtm5ftm5ftm5csIOydtOygnCDrhIjtnbAg64Gd7J6l7J2064ukIVwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCIxMDVcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJEXCIsIHRpbWU6IDIsIGRpYWxvZzogXCIuLi5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJEXCIsIHRpbWU6IDIsIGRpYWxvZzogXCIuLi5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJEXCIsIHRpbWU6IDIsIGRpYWxvZzogXCIuLi5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJCXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLrrZDslbwsIOutkCDrp5DtlaDrnbzqtawuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRFwiLCB0aW1lOiAwLCBkaWFsb2c6IFwiLi4uIFRfVFwiIH0sXHJcbiAgICBdLFxyXG4gICAgXCIxMTFcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJGXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLrk5zrlJTslrQg64Gd7YyQ7J2064ukLlxcbu2bjOulre2VtC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsu6jti7DribTqsIAg66qHIOqwnOuCmCDrgqjslZjsp4AuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiAwLCBkaWFsb2c6IFwi6rO87JewIOyXlOuUqeydhCDrs7wg7IiYIOyeiOydhOq5jC5cIiB9LFxyXG4gICAgXSxcclxuICAgIFwiMTE1XCI6IFtcclxuICAgICAgICB7IGZhY2U6IFwiRVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7LWc7KKF67O07Iqk64ukLCDsobDsi6ztlbQhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQ1wiLCB0aW1lOiAzLCBkaWFsb2c6IFwi7ZuE7ZuELi4g7J2067KI7JeQ64qUXFxu7LWc6rCV7J2YIOyasOyjvOuzkeq4sCxcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJDXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLstZzsi6DsmIgg7JWE7Iqk7Lm0XFxu67aI6riw65Gl7J2064ukIVwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkZcIiwgdGltZTogMCwgZGlhbG9nOiBcIuyggCDrhYDshJ0g7Ja47KCcXFxu7KCA6rG4IO2blOyzpOyngC4uXCIgfSxcclxuICAgIF0sXHJcbiAgICBcIm1vbml0b3JcIjogW1xyXG4gICAgICAgIHsgZmFjZTogXCJDXCIsIHRpbWU6IDYsIGRpYWxvZzogXCLsl5Dsnocg6re466CH64uk66m0XFxu67mE7J6l7J2YIOyImOuLqOydtOuLtyFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLslZcg7JWIIOuPvCEhIVxcbjHrk7Hsg4Hsnbgg66qo64uI7YSw64ukISFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJGXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLrqqjri4jthLDripQg6rG065Oc66as7KeA66eIIVxcbuqyjOyehOyYpOuyhOyLnO2CrOqxsOyVvCFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLruYTsi7zqsbTrjbAgVF9UXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQ1wiLCB0aW1lOiAzLCBkaWFsb2c6IFwi7ZuE7ZuELi4g7Iu47Jqw6riw6rCAXFxu7ZWc6rKwIO2OuO2VtOyhjOuKlOqxuC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJBXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLslrTrlrvqsowg7Iu47Jqw656AIOunkOydtOuDkCFcIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJCXCIsIHRpbWU6IDMsIGRpYWxvZzogXCLtlaDslYTrsoTsp4Ag7KGw7Ius7ZW07JqUIVwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogMCwgZGlhbG9nOiBcIuyCtOuqqOyCrCDsnbQg64KY7IGcIOuGiCFcXG7tnpjrgrTrnbwg7ZWg67CV7IKsLOyCsOyGjCFcIiB9LFxyXG4gICAgXSxcclxuICAgIFwibW9uaXRvckJyb2tlblwiOiBbXHJcbiAgICAgICAgeyBmYWNlOiBcIkZcIiwgdGltZTogMywgZGlhbG9nOiBcIjHrk7Hsg4HsnYQg7YSw7Yq466C47Ja0IVwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkVcIiwgdGltZTogMCwgZGlhbG9nOiBcIuuBneuCrOyWtCEg64ukIOuBneuCrOuLpOqzoCFcIiB9LFxyXG4gICAgXSxcclxuICAgIFwiZW5kaW5nXCI6IFtcclxuICAgICAgICB7IGZhY2U6IFwiQ1wiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7J20LCDsnbTrn7AuLiFcXG7snLzsnLzsnLzslYTslYUhIVwiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkRcIiwgdGltZTogNCwgZGlhbG9nOiBcIuyemCDsnojslrTrnbwg64+Z66y065Ok7JWELi5cXG7rgpjripQg7Zmp7LKc7JeQIOqwhOuLpC4uXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7JmAISDsnbTqsrzslrTsmpRcXG7tlaDslYTrsoTsp4AhXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQVwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7Zy0Li4g6rCE7Iug7Z6IIOydtOqyvOq1sC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsnpgg7ZaI64ukLlxcbuy5reywrO2VtOyjvOqzoCDsi7bqtbAuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiRlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7ZWr7ZWrLlxcbuyImOqzoCDrp47snbTtlojri6QuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi7Z2gLi7snbTsoJwg7JeU65Sp7J246rCAP1wiIH0sXHJcbiAgICAgICAgeyBmYWNlOiBcIkZcIiwgdGltZTogNCwgZGlhbG9nOiBcIuycvC4u7JeU65SpP1xcbuyigCDsjbDroIHtlaDthZDrjbAuXCIgfSxcclxuICAgICAgICB7IGZhY2U6IFwiQlwiLCB0aW1lOiA0LCBkaWFsb2c6IFwi6rSc7LCu7Jy864uI6rmMIOuztOyXrOykmC5cIiB9LFxyXG4gICAgICAgIHsgZmFjZTogXCJFXCIsIHRpbWU6IDQsIGRpYWxvZzogXCLsoovslYQuIOydtOygnCDqsozsnoQg64Gd7J2064ukLlwiIH0sXHJcbiAgICAgICAgeyBldmVudDogXCJtb2RlOmludHJvXCIsIGRhdGE6IHsgZW5kaW5nRmxhZzogdHJ1ZSB9IH0sXHJcbiAgICBdXHJcbn07XHJcblxyXG5cclxuY29uc3QgZGlhbG9nU3ByID0gbmV3IFZzU3ByaXRlKCBcImVmZmVjdFwiICk7XHJcbmNvbnN0IHRleHRTcHIgPSBuZXcgVnNIYW5ndWwoKTtcclxuXHJcbmRpYWxvZ1Nwci5hdHRyaWIuZW5hYmxlSGlkZU1lc2ggPSB0cnVlO1xyXG5kaWFsb2dTcHIuYXR0cmliLmRpc2FibGVHcmF2aXR5ID0gdHJ1ZTtcclxuXHJcbmNvbnN0IHRleHRSVCA9IG5ldyBSZW5kZXJUYXJnZXQoIDIwMCw0MCApO1xyXG5jb25zdCB0ZXh0Qml0bWFwID0gbmV3IEJpdG1hcCggdGV4dFJUICk7XHJcblxyXG50ZXh0Qml0bWFwLnh5ID0gWzQ1LDVdO1xyXG5kaWFsb2dTcHIuYWRkQ2hpbGQoIHRleHRCaXRtYXAgKTtcclxuXHJcbmxldCBkaWFsb2dUaW1lcjtcclxuXHJcbmZ1bmN0aW9uIHNob3dEaWFsb2coIG1zZywgaW5kZXggPSAwICkge1xyXG4gICAgaWYgKCBkaWFsb2dUaW1lciApIGRpYWxvZ1RpbWVyLnN0b3AoKTtcclxuICAgIGNvbnNvbGUuYXNzZXJ0KCBtc2csYOyemOuqu+uQnCDrqZTsi5zsp4Ag7JqU7LKtYCApO1xyXG4gICAgbGV0IGQgPSBkaWFsb2dEYXRhW21zZ11baW5kZXhdO1xyXG5cclxuICAgIGlmICggZCA9PSBudWxsICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSBpZiAoIGQuZXZlbnQgKSB7XHJcbiAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggbmV3IEV2ZW50KCBkLmV2ZW50LGQuZGF0YSApICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZGlhbG9nU3ByLnNldEFjdGlvbiggMywwICk7XHJcbiAgICBkaWFsb2dTcHIueHkgPSBbMTUsMTgwXTtcclxuICAgIGRpYWxvZ1Nwci5hdXRvUmVtb3ZlVGltZXIgPSAxMjA7XHJcbiAgICB2c1N0YWdlLmFkZENoaWxkQXQoIGRpYWxvZ1NwciwgdnNTdGFnZS5nZXROdW1DaGlsZHJlbigpICk7XHJcbiAgICB0ZXh0UlQuY2xlYXIoKTtcclxuICAgIHRleHRTcHIuc2V0UGFsZXR0ZSggdnNTdGFnZS5wYWxldHRlICk7XHJcbiAgICB0ZXh0U3ByLnNldENvbG9yKCAwICk7XHJcbiAgICB0ZXh0U3ByLnNldFRleHQoIGQuZGlhbG9nICk7ICBcclxuICAgIHRleHRTcHIueHkgPSBbMSwwXTtcclxuICAgIHRleHRSVC5kcmF3KCB0ZXh0U3ByICk7XHJcbiAgICB0ZXh0U3ByLnh5ID0gWzEsMl07XHJcbiAgICB0ZXh0UlQuZHJhdyggdGV4dFNwciApO1xyXG4gICAgdGV4dFNwci54eSA9IFswLDFdO1xyXG4gICAgdGV4dFJULmRyYXcoIHRleHRTcHIgKTtcclxuICAgIHRleHRTcHIueHkgPSBbMiwxXTtcclxuICAgIHRleHRSVC5kcmF3KCB0ZXh0U3ByICk7XHJcbiAgICB0ZXh0U3ByLnNldENvbG9yKCAxNSApO1xyXG4gICAgdGV4dFNwci54eSA9IFsxLDFdO1xyXG4gICAgdGV4dFJULmRyYXcoIHRleHRTcHIgKTtcclxuICAgIGRpYWxvZ1Nwci5hZGRDaGlsZCggZGlhbG9nU3ByLmdldE1lc2goIGQuZmFjZS5jaGFyQ29kZUF0KCAwICkgLSA0OCApICk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyggZC5kaWFsb2cgKTtcclxuICAgIGRpYWxvZ1RpbWVyID0gVGltZXIuZGVsYXllZENhbGwoIDEwMDAgLyA2MCAqIGQudGltZSAqIDMwLCgpPT57XHJcbiAgICAgICAgc2hvd0RpYWxvZyggbXNnLGluZGV4ICsgMSApO1xyXG4gICAgfSApO1xyXG59XHJcblxyXG5cclxuYXBwbGljYXRpb24ub24oIFwiZGlhbG9nXCIsKCBlICk9PntcclxuICAgIHNob3dEaWFsb2coIGUubXNnLGUuaW5kZXggKTtcclxufSApO1xyXG4iLCJpbXBvcnQgeyBhcHBsaWNhdGlvbiwgVXRpbHMsIEV2ZW50LCBTcHJpdGUgfSBmcm9tIFwiQGVuZ2luZS9mbGF0ZmFzdFwiO1xyXG5pbXBvcnQgR0xPQkFMIGZyb20gXCIuL2dsb2JhbFwiO1xyXG5pbXBvcnQgeyB2c1N0YWdlLCBWc1Nwcml0ZSB9IGZyb20gXCIuL3ZzV3JhcHBlci92c1wiO1xyXG5cclxuXHJcbmZ1bmN0aW9uIGVuZGluZygpIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKCBg7JeU65SpYCApO1xyXG4gICAgLy8gZW5kRmxhZz0xO1xyXG4gICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggbmV3IEV2ZW50KCBcIm1vZGU6aW50cm9cIix7IGVuZGluZ0ZsYWc6IHRydWUgfSApICApO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gbWVzc2FnZTEoIGUgKSB7XHJcbiAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcImRpYWxvZ1wiLHsgbXNnOiBlLnZhcjIgfSApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtdXNpYyggZSApIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKCBg7J2M7JWFICR7ZS52YXIyfWAgKTtcclxuICAgIHN3aXRjaCAoIGUudmFyMiApIHtcclxuICAgIGNhc2UgMDpcclxuICAgICAgICAvLyBwbGF5WGVtKDAsXCJzcGFjZS54ZW1cIik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgICAgLy8gcGxheVhlbSgwLFwic3RhZ2UueGVtXCIpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICAgIC8vIHBsYXlYZW0oMCxcImRlbW8ueGVtXCIpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICAgIC8vIHNGYWRlT3V0KCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDQ6XHJcbiAgICAgICAgLy8gc0ZhZGVPdXQoKTtcclxuICAgICAgICBicmVhaztcclxuICAgIGNhc2UgNTpcclxuICAgICAgICAvLyBzU2V0Vm9sdW1lKDEyNyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDY6XHJcbiAgICAgICAgLy8gc1NldFZvbHVtZShlLnZhcjMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBxdWFrZSggKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyggYOynhOuPmWAgKTtcclxuICAgIC8vIHNldFF1YWtlKGUudmFyMyxlLnZhcjIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2b2ljZSgpIHtcclxuICAgIC8vIOyViOyUgFxyXG59XHJcblxyXG5mdW5jdGlvbiBzY3JvbGxTdG9wKCApIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKCBg7Iqk7YGs66GkIOyKpO2DkWAgKTtcclxuICAgIHZzU3RhZ2Uud29ybGQuc2Nyb2xsVGFyZ2V0LnZlbG9jaXR5LnggPSAwO1xyXG4gICAgdnNTdGFnZS53b3JsZC5ldmVudFRhcmdldC52ZWxvY2l0eS54ID0gMDtcclxuICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwiYmdtXCIseyBmaWxlbmFtZTogYGJvc3NgIH0gKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZFN0YWdlKCBlICkge1xyXG4gICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJzdGFnZVwiLHsgc3RhZ2VOdW1iZXI6IGUudmFyMiB9ICk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3BhY2UoIGUgKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyggYOyasOyjvCDshKTsoJUgJHtlLnZhcjJ9YCApO1xyXG4gICAgc3dpdGNoICggZS52YXIyICkge1xyXG4gICAgY2FzZSAwOlxyXG4gICAgICAgIC8vIHBsYXlYZW0oMCxcInN0YWdlLnhlbVwiKTtcclxuICAgICAgICAvLyBzcGFjZUZsYWc9LTEyODtcclxuICAgICAgICAvLyBzcGFjZU1vdmU9MTtcclxuICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcImJnbVwiLHsgZmlsZW5hbWU6IGBzdGFnZSR7R0xPQkFMLmN1cnJlbnRTdGFnZX1gIH0gKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggYOyasOyjvOyXkOyEnCDsiqTthYzsnbTsp4Ag7KeE7J6FYCApO1xyXG4gICAgICAgIHZzU3RhZ2UucGFsZXR0ZS5mYWRlKCB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiAgICAtMSxcclxuICAgICAgICAgICAgZW5kOiAgICAgIDAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXHJcbiAgICAgICAgICAgIHJhbmdlOiAgICBbMTI4LDI1NSBdLFxyXG4gICAgICAgIH0gKTtcclxuICAgICAgICBicmVhaztcclxuICAgIGNhc2UgMTpcclxuICAgICAgICAvLyBwbGF5WGVtKDAsXCJzcGFjZS54ZW1cIik7XHJcbiAgICAgICAgLy8gc3BhY2VGbGFnPTA7XHJcbiAgICAgICAgLy8gc3BhY2VNb3ZlPS0xO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBg7Iqk7YWM7J207KeA7JeQ7IScIOyasOyjvOuhnCDsp4TsnoVgICk7XHJcbiAgICAgICAgdnNTdGFnZS5wYWxldHRlLmZhZGUoIHtcclxuICAgICAgICAgICAgc3RhcnQ6ICAgIDAsXHJcbiAgICAgICAgICAgIGVuZDogICAgICAtMSxcclxuICAgICAgICAgICAgZHVyYXRpb246IDUwLFxyXG4gICAgICAgICAgICByYW5nZTogICAgWzEyOCwyNTUgXSxcclxuICAgICAgICB9ICk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoYWluKCApIHtcclxuICAgIC8vXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXQoIGUgKSB7XHJcbiAgICBpZiAoIGUudmFyMiA8IDAgKSB7XHJcbiAgICAgICAgdnNTdGFnZS53b3JsZC5ldmVudERhdGEuZXZlbnRWYXJzWy1lLnZhcjJdLmZsYWcgPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2c1N0YWdlLndvcmxkLmV2ZW50RGF0YS5ldmVudFZhcnNbZS52YXIyXS5mbGFnID0gMDtcclxuICAgIH1cclxuICAgIGlmICggZS52YXIzIDwgMCApIHtcclxuICAgICAgICB2c1N0YWdlLndvcmxkLmV2ZW50RGF0YS5ldmVudFZhcnNbLWUudmFyM10uZmxhZyA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZzU3RhZ2Uud29ybGQuZXZlbnREYXRhLmV2ZW50VmFyc1tlLnZhcjNdLmZsYWcgPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKCBlLnZhcjQgPCAwICkge1xyXG4gICAgICAgIHZzU3RhZ2Uud29ybGQuZXZlbnREYXRhLmV2ZW50VmFyc1stZS52YXI0XS5mbGFnID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdnNTdGFnZS53b3JsZC5ldmVudERhdGEuZXZlbnRWYXJzW2UudmFyNF0uZmxhZyA9IDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhbGV0dGUoICkge1xyXG4gICAgLy8gY29uc29sZS5sb2coIGDtjJTroIjtirgg7ISk7KCVYCApO1xyXG4gICAgLy8gZmFkZVBhbGV0dGVXaGVuRmxpcChlLnZhcjIsbWFpblBhbGV0dGUsZS52YXIzLGV2ZW50VmFyNFtjdXJyZW50RXZlbnRdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFsZXR0ZUZhZGUoIGUgKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyggYO2MlOugiO2KuCDtjpjsnbTrk5xgICk7XHJcbiAgICBsZXQgZTIgPSB2c1N0YWdlLndvcmxkLmV2ZW50RGF0YS5ldmVudFZhcnNbZS52YXI0XTtcclxuXHJcbiAgICAvLyBlMi52YXIzIDogZGlyXHJcbiAgICAvLyBlMi52YXI0IDogc3BlZWRcclxuICAgIHZzU3RhZ2UucGFsZXR0ZS5mYWRlKCB7XHJcbiAgICAgICAgcmFuZ2U6ICAgIFtlMi52YXI1LGUudmFyMl0sXHJcbiAgICAgICAgc3RhcnQ6ICAgIGUyLnZhcjEgLyA2NCxcclxuICAgICAgICBlbmQ6ICAgICAgZTIudmFyMiAvIDY0LFxyXG4gICAgICAgIGR1cmF0aW9uOiBlMi52YXI0LFxyXG4gICAgfSApO1xyXG59XHJcblxyXG4vLyBpbnQgc2V0TGVucyhpbnQgeCxpbnQgeSxpbnQsaW50KTtcclxuZnVuY3Rpb24gbGVuc0ZsYXJlKCBlICkge1xyXG4gICAgLy8gY29uc29sZS5sb2coIGDroIzspogg7ZSM66CI7Ja0YCApO1xyXG4gICAgbGV0IHBvcyA9IFswLjEsLTAuMzUsLTAuOSwtMS4xLC0xLjE4XTtcclxuXHJcbiAgICBsZXQgZXNwciA9IG5ldyBWc1Nwcml0ZSggbnVsbCx7IHg6IGUueCx5OiBlLnkgfSApO1xyXG5cclxuICAgIC8vIGVzcHIuYXR0cmliLmVuYWJsZUF1dG9SZW1vdmVTdGFnZU91dCA9IHRydWU7XHJcbiAgICBlc3ByLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICBlc3ByLnNldFVwZGF0ZVBoYXNlQ2FsbGJhY2soICgpPT57XHJcbiAgICAgICAgaWYgKCB2c1N0YWdlLndvcmxkLmdldFN0YWdlWCggZXNwci54ICkgPCB2c1N0YWdlLndpZHRoICsgMTAgKSB7XHJcbiAgICAgICAgICAgIHZzU3RhZ2UucGFsZXR0ZS5mYWRlKCB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogICAgMC43LFxyXG4gICAgICAgICAgICAgICAgZW5kOiAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMzAwLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2U6ICAgIFswLDI1NV1cclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCA1OyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3ByID0gbmV3IFZzU3ByaXRlKCBcImVmZmVjdFwiLHtcclxuICAgICAgICAgICAgICAgICAgICB4OiAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogVXRpbHMucmFuZG9tKCA3LDggKSxcclxuICAgICAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzcHIuYXR0cmliLmRpc2FibGVHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNwci5fY3VycmVudE1lc2guc2V0QmxlbmRNb2RlKCBTcHJpdGUuQmxlbmRNb2Rlcy5BREQgKTtcclxuICAgICAgICAgICAgICAgIHNwci5fY3VycmVudE1lc2guYWxwaGEgPSAwLjU7XHJcbiAgICAgICAgICAgICAgICBzcHIuc2V0VXBkYXRlUGhhc2VDYWxsYmFjayggKCk9PntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZ2luUG9zID0gdnNTdGFnZS53b3JsZC5nZXRTdGFnZUNvb3JkaW5hdGUoIGUueCxlLnkgKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZHggPSBvcmlnaW5Qb3MueCAtIDEyODtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZHkgPSBvcmlnaW5Qb3MueSAtIDEwMDtcclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBkeCA9IGR4ICogcG9zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gZHkgKiBwb3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZsYXJlUG9zID0gdnNTdGFnZS53b3JsZC5nZXRXb3JsZENvb3JkaW5hdGUoIDEyOCArIGR4LDEwMCArIGR5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNwci54ID0gZmxhcmVQb3MueDtcclxuICAgICAgICAgICAgICAgICAgICBzcHIueSA9IGZsYXJlUG9zLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcmlnaW5Qb3MueCA8IC0xMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQuYWRkQ2hpbGQoIHNwciApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVzcHIucmVtb3ZlKCk7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcbiAgICB2c1N0YWdlLndvcmxkLmxheWVyNC5hZGRDaGlsZEF0KCBlc3ByICk7XHJcbn1cclxuXHJcblxyXG4vLyBpbnQgc2V0WmFrbzEoaW50IHgsaW50IHksaW50IGhwLGludCB0eXBlLGludCBsZXZlbCk7XHJcbmZ1bmN0aW9uIHpha28xXzEoIGUgKSB7XHJcbiAgICBsZXQgaTtcclxuXHJcbiAgICBmb3IgKCBpID0gMDsgaSA8IDY7IGkrKyApIHtcclxuICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcInNwYXduOnpha29cIix7XHJcbiAgICAgICAgICAgIHR5cGU6ICAgIFwiemFrbzFcIixcclxuICAgICAgICAgICAgeDogICAgICAgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFgoIHZzU3RhZ2Uud2lkdGggKyBpICogMjAgKSxcclxuICAgICAgICAgICAgeTogICAgICAgZS55LFxyXG4gICAgICAgICAgICBocDogICAgICBlLnZhcjIsXHJcbiAgICAgICAgICAgIHN1YlR5cGU6IDAsXHJcbiAgICAgICAgICAgIGxldmVsOiAgIGUudmFyMyxcclxuICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlRXZlbnQ6IGUsXHJcbiAgICAgICAgICAgICAgICBzdGF0dXM0OiAgICAgaSAqIDEwLFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzMzogICAgIGUudmFyMyxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxuICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwic3Bhd246emFrb1wiLHtcclxuICAgICAgICB0eXBlOiAgICBcInpha28xXCIsXHJcbiAgICAgICAgeDogICAgICAgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFgoIHZzU3RhZ2Uud2lkdGggKyBpICogMjAgKSxcclxuICAgICAgICB5OiAgICAgICBlLnksXHJcbiAgICAgICAgaHA6ICAgICAgZS52YXIyLFxyXG4gICAgICAgIHN1YlR5cGU6IDEsXHJcbiAgICAgICAgbGV2ZWw6ICAgZS52YXIzLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc3ByaXRlRXZlbnQ6IGUsXHJcbiAgICAgICAgICAgIHN0YXR1czQ6ICAgICBpICogMTAsXHJcbiAgICAgICAgfVxyXG4gICAgfSApO1xyXG4gICAgLy9cdFx0bmV3U3ByLnN0YXR1czM9ZS52YXIzO1xyXG59XHJcblxyXG4vLyBpbnQgc2V0WmFrbzIoaW50IHgsaW50IHksaW50IGhwLGludCB0aW1lcik7XHJcbmZ1bmN0aW9uIHpha28yXzEoIGUgKSB7XHJcbiAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcInNwYXduOnpha29cIix7XHJcbiAgICAgICAgdHlwZTogICAgXCJ6YWtvMlwiLFxyXG4gICAgICAgIHg6ICAgICAgIGUueCxcclxuICAgICAgICB5OiAgICAgICBlLnksXHJcbiAgICAgICAgaHA6ICAgICAgZS52YXIyLFxyXG4gICAgICAgIHRpbWVyOiAgIGUudmFyMyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNwcml0ZUV2ZW50OiBlLFxyXG4gICAgICAgIH1cclxuICAgIH0gKTtcclxufVxyXG5cclxuLy8gaW50IHNldFpha28zKGludCB4LGludCB5LGludCBocCxpbnQgdHlwZSk7XHJcbmZ1bmN0aW9uIHpha28zXzEoIGUgKSB7XHJcbiAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcInNwYXduOnpha29cIix7XHJcbiAgICAgICAgdHlwZTogICAgXCJ6YWtvM1wiLFxyXG4gICAgICAgIHg6ICAgICAgIGUueCxcclxuICAgICAgICB5OiAgICAgICBlLnksXHJcbiAgICAgICAgaHA6ICAgICAgZS52YXIyLFxyXG4gICAgICAgIHN1YlR5cGU6IGUudmFyMyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNwcml0ZUV2ZW50OiBlLFxyXG4gICAgICAgIH1cclxuICAgIH0gKTtcclxufVxyXG5cclxuLy8gaW50IHNldFpha280KGludCB4LGludCB5LGludCBocCxpbnQgbGV2ZWwpO1xyXG5mdW5jdGlvbiB6YWtvNF8xKCBlICkge1xyXG4gICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJzcGF3bjp6YWtvXCIse1xyXG4gICAgICAgIHR5cGU6ICAgIFwiemFrbzRcIixcclxuICAgICAgICB4OiAgICAgICBlLngsXHJcbiAgICAgICAgeTogICAgICAgZS55LFxyXG4gICAgICAgIGhwOiAgICAgIGUudmFyMixcclxuICAgICAgICBsZXZlbDogICBlLnZhcjMsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzcHJpdGVFdmVudDogZSxcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcbn1cclxuXHJcblxyXG4vLyBpbnQgc2V0WmFrbzUoaW50IHgsaW50IHksaW50IGhwKTtcclxuZnVuY3Rpb24gemFrbzVfMSggZSApIHtcclxuICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwic3Bhd246emFrb1wiLHtcclxuICAgICAgICB0eXBlOiAgICBcInpha281XCIsXHJcbiAgICAgICAgeDogICAgICAgZS54LFxyXG4gICAgICAgIHk6ICAgICAgIGUueSxcclxuICAgICAgICBocDogICAgICBlLnZhcjIsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzcHJpdGVFdmVudDogZSxcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcbn1cclxuXHJcbi8vIGludCBzZXRaYWtvNihpbnQgeCxpbnQgeSxpbnQgaHApO1xyXG5mdW5jdGlvbiB6YWtvNl8xKCBlICkge1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgNTsgaSsrICkge1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwic3Bhd246emFrb1wiLHtcclxuICAgICAgICAgICAgdHlwZTogICAgXCJ6YWtvNlwiLFxyXG4gICAgICAgICAgICB4OiAgICAgICB2c1N0YWdlLndvcmxkLmdldFdvcmxkWCggdnNTdGFnZS53aWR0aCArIGkgKiAxNSApLFxyXG4gICAgICAgICAgICB5OiAgICAgICB2c1N0YWdlLndvcmxkLmdldFdvcmxkWSggVXRpbHMucmFuZG9tKCAwLCAxODkgKSArIDUgKSxcclxuICAgICAgICAgICAgaHA6ICAgICAgZS52YXIyLFxyXG4gICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGVFdmVudDogZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gKTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gaW50IHNldFpha283KGludCB4LGludCB5LGludCBocCxpbnQgbGV2ZWwpO1xyXG5mdW5jdGlvbiB6YWtvN18xKCBlICkge1xyXG4gICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJzcGF3bjp6YWtvXCIse1xyXG4gICAgICAgIHR5cGU6ICAgIFwiemFrbzdcIixcclxuICAgICAgICB4OiAgICAgICBlLngsXHJcbiAgICAgICAgeTogICAgICAgZS55LFxyXG4gICAgICAgIGhwOiAgICAgIGUudmFyMixcclxuICAgICAgICBsZXZlbDogICBlLnZhcjMsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzcHJpdGVFdmVudDogZSxcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcbn1cclxuXHJcblxyXG4vLyBpbnQgc2V0WmFrbzgoaW50IHgsaW50IHksaW50IGhwLGludCBsZXZlbCk7XHJcbmZ1bmN0aW9uIHpha284XzEoIGUgKSB7XHJcbiAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcInNwYXduOnpha29cIix7XHJcbiAgICAgICAgdHlwZTogICAgXCJ6YWtvOFwiLFxyXG4gICAgICAgIHg6ICAgICAgIGUueCxcclxuICAgICAgICB5OiAgICAgICBlLnksXHJcbiAgICAgICAgaHA6ICAgICAgZS52YXIyLFxyXG4gICAgICAgIGxldmVsOiAgIGUudmFyMyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNwcml0ZUV2ZW50OiBlLFxyXG4gICAgICAgIH1cclxuICAgIH0gKTtcclxufVxyXG5cclxuLy8gaW50IHNldFpha285KGludCB4LGludCB5LGludCBocCk7XHJcbmZ1bmN0aW9uIHpha285XzEoIGUgKSB7XHJcbiAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcInNwYXduOnpha29cIix7XHJcbiAgICAgICAgdHlwZTogICAgXCJ6YWtvOVwiLFxyXG4gICAgICAgIHg6ICAgICAgIGUueCxcclxuICAgICAgICB5OiAgICAgICBlLnksXHJcbiAgICAgICAgaHA6ICAgICAgZS52YXIyLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc3ByaXRlRXZlbnQ6IGUsXHJcbiAgICAgICAgfVxyXG4gICAgfSApO1xyXG59XHJcblxyXG5cclxuLy8gaW50IHNldFpha28xMChpbnQgeCxpbnQgeSxpbnQgdHlwZSk7XHJcbmZ1bmN0aW9uIHpha28xMF8xKCBlICkge1xyXG4gICAgZnVuY3Rpb24gc2V0WmFrbzEwKCB0ICkge1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwic3Bhd246emFrb1wiLHtcclxuICAgICAgICAgICAgdHlwZTogICAgXCJ6YWtvMTBcIixcclxuICAgICAgICAgICAgeDogICAgICAgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFgoIFV0aWxzLnJhbmRvbSggMCwxMTkgKSArIDEwMCApLFxyXG4gICAgICAgICAgICB5OiAgICAgICB2c1N0YWdlLndvcmxkLmdldFdvcmxkWSggMjEwICksXHJcbiAgICAgICAgICAgIHN1YlR5cGU6IHQsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIHNwcml0ZUV2ZW50OiBlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSApOyAgICBcclxuICAgIH1cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGUudmFyMjsgaSsrICkge1xyXG4gICAgICAgIHNldFpha28xMCggMSApO1xyXG4gICAgfVxyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgZS52YXIzOyBpKysgKSB7XHJcbiAgICAgICAgc2V0WmFrbzEwKCAwICk7XHJcbiAgICB9XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBlLnZhcjQ7IGkrKyApIHtcclxuICAgICAgICBzZXRaYWtvMTAoIDIgKTtcclxuICAgIH1cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGUudmFyNTsgaSsrICkge1xyXG4gICAgICAgIHNldFpha28xMCggMyApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLy8gaW50IHNldFpha28xMShpbnQgeCxpbnQgeSxpbnQgaHApO1xyXG5mdW5jdGlvbiB6YWtvMTFfMSggZSApIHtcclxuICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIG5ldyBFdmVudCggXCJzcGF3bjp6YWtvXCIse1xyXG4gICAgICAgIHR5cGU6ICAgIFwiemFrbzExXCIsXHJcbiAgICAgICAgeDogICAgICAgZS54LFxyXG4gICAgICAgIHk6ICAgICAgIGUueSxcclxuICAgICAgICBocDogICAgICBlLnZhcjIsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzcHJpdGVFdmVudDogZSxcclxuICAgICAgICB9XHJcbiAgICB9ICkgKTtcclxufVxyXG5cclxuLy8gaW50IHNldFpha28xMihpbnQgeCxpbnQgeSxpbnQgaHApO1xyXG5mdW5jdGlvbiB6YWtvMTJfMSggZSApIHtcclxuICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwic3Bhd246emFrb1wiLHtcclxuICAgICAgICB0eXBlOiAgICBcInpha28xMlwiLFxyXG4gICAgICAgIHg6ICAgICAgIGUueCxcclxuICAgICAgICB5OiAgICAgICBlLnksXHJcbiAgICAgICAgaHA6ICAgICAgZS52YXIyLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc3ByaXRlRXZlbnQ6IGUsXHJcbiAgICAgICAgfVxyXG4gICAgfSApO1xyXG59XHJcblxyXG4vLyBpbnQgc2V0WmFrbzEzKGludCB4LGludCB5LGludCBocCk7XHJcbmZ1bmN0aW9uIHpha28xM18xKCBlICkge1xyXG4gICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJzcGF3bjp6YWtvXCIse1xyXG4gICAgICAgIHR5cGU6ICAgIFwiemFrbzEzXCIsXHJcbiAgICAgICAgeDogICAgICAgZS54LFxyXG4gICAgICAgIHk6ICAgICAgIGUueSxcclxuICAgICAgICBocDogICAgICBlLnZhcjIsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzcHJpdGVFdmVudDogZSxcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBtb3ZlR2hvc3QoIGUgKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyggYOyKpO2BrOuhpO2DgOqynyDsnbTrj5kgJHtlLnh9LCR7ZS55fWAgKTtcclxuICAgIC8vIOyblOuTnCDslYTrnpjsnZgg66qo65OgIOyKpO2UhOudvOydtO2KuOulvCDqsJnsnbQg7Jiu6rKo7KSA64ukLlxyXG4gICAgLy8g7J206rKD7J2AIOq1rCBWU+yXlOynhOydtCDsooztkZzqs4Trpbwg64uk66Oo64qUIOusuOygnOyZgOydmCDtmLjtmZjshLEg65WM66y47JeQIO2VmOuKlCDqsoPsnbTri6QuXHJcbiAgICAvLyDsiqTthYzsnbTsp4Ag7LSI67CY7JeQIOyasOyjvOyXkOyEnCDsp4TsnoXtlaAg65WMIO2VnCDrsogg7J287Ja064Kc64ukLlxyXG4gICAgLy8gbGV0IGFkanVzdFggPSB2c1N0YWdlLndvcmxkLnNjcm9sbFRhcmdldC54IC0gZS54O1xyXG4gICAgLy8gbGV0IGFkanVzdFkgPSB2c1N0YWdlLndvcmxkLnNjcm9sbFRhcmdldC55IC0gZS55O1xyXG4gICAgLy8gbGV0IHNwcnMgPSB2c1N0YWdlLndvcmxkLnNlYXJjaENoaWxkcmVuKCk7XHJcbiAgICAvLyBmb3IgKCBsZXQgc3ByIG9mIHNwcnMgKSB7XHJcbiAgICAvLyAgICAgaWYgKHNwciBpbnN0YW5jZW9mIFZzU3ByaXRlKSB7XHJcbiAgICAvLyAgICAgICAgIHNwci54IC09IGFkanVzdFg7XHJcbiAgICAvLyAgICAgICAgIHNwci55IC09IGFkanVzdFk7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfVxyXG4gICAgLy8gdnNTdGFnZS53b3JsZC5zY3JvbGxUYXJnZXQueCA9IGUueDtcclxuICAgIC8vIHZzU3RhZ2Uud29ybGQuc2Nyb2xsVGFyZ2V0LnkgPSBlLnk7XHJcbiAgICB2c1N0YWdlLndvcmxkLmV2ZW50VGFyZ2V0LnggPSBlLng7XHJcbiAgICB2c1N0YWdlLndvcmxkLmV2ZW50VGFyZ2V0LnkgPSBlLnk7XHJcbiAgICB2c1N0YWdlLndvcmxkLnNjcm9sbFRhcmdldC52ZWxvY2l0eS54ID0gR0xPQkFMLnNjcm9sbFNwZWVkO1xyXG4gICAgLy8gY29uc29sZS5sb2coIHZzU3RhZ2Uud29ybGQuc2Nyb2xsVGFyZ2V0LnggKTtcclxufVxyXG5cclxuY29uc3QgZXZlbnRUYWJsZSA9IFtcclxuICAgIG51bGwsICAgICAgICAgICAgICAgICAgIC8vMFxyXG4gICAgbWVzc2FnZTEsXHJcbiAgICBtdXNpYyxcclxuICAgIGNoYWluLFxyXG4gICAgcXVha2UsXHJcbiAgICB2b2ljZSxcclxuICAgIHNjcm9sbFN0b3AsXHJcbiAgICBtb3ZlR2hvc3QsXHJcbiAgICBsb2FkU3RhZ2UsXHJcbiAgICBzcGFjZSxcclxuICAgIC8vMTBcclxuICAgIGluaXQsXHJcbiAgICBwYWxldHRlLFxyXG4gICAgcGFsZXR0ZUZhZGUsXHJcbiAgICBsZW5zRmxhcmUsXHJcbiAgICBlbmRpbmcsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIC8vMjBcclxuICAgIHpha28xXzEsXHJcbiAgICB6YWtvMl8xLFxyXG4gICAgemFrbzNfMSxcclxuICAgIHpha280XzEsXHJcbiAgICB6YWtvNV8xLFxyXG4gICAgemFrbzZfMSxcclxuICAgIHpha283XzEsXHJcbiAgICB6YWtvOF8xLFxyXG4gICAgemFrbzlfMSxcclxuICAgIHpha28xMF8xLFxyXG4gICAgLy8zMFxyXG4gICAgemFrbzExXzEsXHJcbiAgICB6YWtvMTJfMSxcclxuICAgIHpha28xM18xLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIC8vNDBcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICAvLzUwXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgLy82MFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIC8vNzBcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICAvLzgwXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgLy85MFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIC8vMTAwXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICAvLzExMFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuXTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0dhbWVFdmVudCggZSApIHtcclxuICAgIGlmICggZS5ldmVudE51bWJlciA9PSAwICkgcmV0dXJuO1xyXG4gICAgLy8gY29uc29sZS5sb2coIGDqsozsnoTsnbTrsqTtirg6JHtlLmV2ZW50TnVtYmVyfSwke2UuZXZlbnRUeXBlTnVtYmVyfWAgKTtcclxuXHJcbiAgICBjb25zdCB3b3JsZCA9IHZzU3RhZ2Uud29ybGQ7XHJcblxyXG4gICAgbGV0IGV2ZW50TnVtID0gZS5ldmVudE51bWJlcjtcclxuXHJcbiAgICBpZiAoIGV2ZW50TnVtICE9IG51bGwgKSB7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAvLyB2YXIx7J20IHR5cGVcclxuICAgICAgICAgICAgbGV0IGV2ZW50VHlwZU51bSA9IHdvcmxkLmV2ZW50RGF0YS5ldmVudFZhcnNbZXZlbnROdW1dLnZhcjE7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCggZXZlbnRUeXBlTnVtICE9IDAgJiYgZXZlbnRUYWJsZVtldmVudFR5cGVOdW1dLCBg7KG07J6s7ZWY7KeAIOyViuuKlCDsnbTrsqTtirjrpbwg7Zi47LacICR7ZXZlbnRUeXBlTnVtfWAgKTtcclxuICAgICAgICAgICAgbGV0IGV2YXJzID0gd29ybGQuZXZlbnREYXRhLmV2ZW50VmFyc1tldmVudE51bV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIGV2YXJzLmZsYWcgPT0gMCApIHtcclxuICAgICAgICAgICAgICAgIC8vIO2UjOuemOq3uOqwgCAwIOydtOyXiOydhCDqsr3smrAg7Iuk7ZaJXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggYOydtOuypO2KuOyLpO2WiToke2V2ZW50TnVtfS0+JHtldmVudFR5cGVOdW19LCR7SlNPTi5zdHJpbmdpZnkoIGV2YXJzICl9YCApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGV2ZW50VGFibGVbIGV2ZW50VHlwZU51bSBdKCBldmFycyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggZXZhcnMuZmxhZyA8IDI1NSApIHtcclxuICAgICAgICAgICAgICAgICAgICBldmFycy5mbGFnKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIGlmICggcmVzdWx0ICE9IHRydWUgJiYgZXZhcnMudmFyNSA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROdW0gPSBldmFycy52YXI1O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudE51bSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXZlbnROdW0gPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKCBldmVudE51bSA+IDAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXZlbnRUYWJsZVsgZS5ldmVudFR5cGVOdW0gXSggZS5ldmVudFZhcnMgKTtcclxuICAgIH1cclxufVxyXG5cclxuYXBwbGljYXRpb24ub24oIFwiZ2FtZUV2ZW50XCIsIHByb2Nlc3NHYW1lRXZlbnQgKTtcclxuIiwiaW1wb3J0IHsgYXBwbGljYXRpb24sIFBpeGVsLFV0aWxzLCBFdmVudCwgU3ByaXRlLCBTb3VuZCB9IGZyb20gXCJAZW5naW5lL2ZsYXRmYXN0XCI7XHJcbmltcG9ydCBHTE9CQUwgZnJvbSBcIi4vZ2xvYmFsXCI7XHJcbmltcG9ydCB7IHZzU3RhZ2UsIFZzUGFsZXR0ZSxWc1dvcmxkLFZzU3ByaXRlLFZzU3lzdGVtVGV4dCB9IGZyb20gXCIuL3ZzV3JhcHBlci92c1wiO1xyXG5cclxuY29uc3QgU1RBUlRfU1RBR0UgPSAxO1xyXG5cclxubGV0IHN0YXJTcGVlZDtcclxubGV0IG9yaWdpbmFsU3RhclNwZWVkO1xyXG5cclxubGV0IGNvbnRpbnVlU2Nyb2xsVmVsb2NpdHk7XHJcbmxldCBjb250aW51ZUV2ZW50VmVsb2NpdHk7XHJcbmxldCBjb250aW51ZVNwcjtcclxuXHJcbmxldCBzY3JvbGxUYXJnZXRTcHIgPSBuZXcgVnNTcHJpdGUoKTtcclxuXHJcbmxldCBldmVudFRhcmdldFNwciA9ICBuZXcgVnNTcHJpdGUoKTtcclxuXHJcbmV2ZW50VGFyZ2V0U3ByLm9uU3RhZ2UoIEV2ZW50LkVOVEVSX0ZSQU1FLGZ1bmN0aW9uKCkge1xyXG4gICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggbmV3IEV2ZW50KCBcImdhbWVFdmVudFwiLHsgZXZlbnROdW1iZXI6IHZzU3RhZ2Uud29ybGQuZ2V0TWFwRXZlbnROdW1iZXIoIHRoaXMueCx0aGlzLnkgKSB9ICkgKTtcclxufSApO1xyXG5cclxubGV0IHN0YXR1c1NwciA9IFtdO1xyXG5cclxuY29uc3QgTUFYX1NUQVIgPSA0MDtcclxuXHJcbmZ1bmN0aW9uIGNoYW5nZUJHTSggZSApIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKCBg7IKs7Jq065OcIO2UjOugiOydtCAke2UuZmlsZW5hbWV9YCApO1xyXG4gICAgU291bmQucGxheVNpbmdsZVNvdW5kKCBgJHtlLmZpbGVuYW1lfS5tNGFgLDAuNSx0cnVlLFwiYmdtXCIgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0U3RhcnMoKSB7XHJcbiAgICAvLyBpbml0IHN0YXJzXHJcblxyXG4gICAgY29uc3Qgc3RhckNvbG9yQXJyYXkgPSBbNyw4LDE1XTtcclxuXHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBNQVhfU1RBUjsgaSsrICkge1xyXG4gICAgICAgIGxldCB4ID0gVXRpbHMucmFuZG9tKCAwLDI1OSApO1xyXG4gICAgICAgIGxldCB5ID0gVXRpbHMucmFuZG9tKCAwLDE5OSApO1xyXG4gICAgICAgIGxldCB2eCA9IFV0aWxzLnJhbmRvbSggMSwzICk7XHJcbiAgICAgICAgbGV0IGMgPSBzdGFyQ29sb3JBcnJheVtVdGlscy5yYW5kb20oIDAsMiApXTtcclxuICAgICAgICBsZXQgcHggPSBuZXcgUGl4ZWwoIFZzUGFsZXR0ZS5pbmRleFRvQ29sb3IoIGMgKSwxICk7XHJcblxyXG4gICAgICAgIHB4LnNldFNoYWRlciggdnNTdGFnZS5wYWxldHRlLmNyZWF0ZVNoYWRlcigpICk7XHJcbiAgICAgICAgcHgueHkgPSBbeCx5XTtcclxuICAgICAgICBweC5vblN0YWdlKCBFdmVudC5FTlRFUl9GUkFNRSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHB4LnggLT0gc3RhclNwZWVkIC8gdng7XHJcbiAgICAgICAgICAgIGlmICggcHgueCA8IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBweC54ID0gMjYwICsgVXRpbHMucmFuZG9tKCAwLDI2MCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG4gICAgICAgIHZzU3RhZ2UuYWRkQ2hpbGQoIHB4ICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFN0YXR1cyggcGxheWVyICkge1xyXG4gICAgbGV0IHBsYXllclNwciA9IEdMT0JBTC5wbGF5ZXJzW3BsYXllcl07XHJcbiAgICBsZXQgc3ByID0gbmV3IFNwcml0ZSgpO1xyXG4gICAgbGV0IHRleHQ7XHJcblxyXG4gICAgaWYgKCBwbGF5ZXJTcHIgPT0gbnVsbCB8fCBwbGF5ZXJTcHIuZ2FtZU92ZXIgKSB7XHJcbiAgICAgICAgaWYgICggR0xPQkFMLnBsYXllcnNbMyAtIHBsYXllcl0gPT0gbnVsbCB8fCBHTE9CQUwucGxheWVyc1szIC0gcGxheWVyXS5nYW1lT3ZlciApIHtcclxuICAgICAgICAvLyDqsozsnoQg7Jik67KEXHJcbiAgICAgICAgICAgIHNob3dDb250aW51ZSgpO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgaWYgKCBHTE9CQUwucmVzdENvaW4gPiAwICkge1xyXG4gICAgICAgICAgICB0ZXh0ID0gbmV3IFZzU3lzdGVtVGV4dCggYENPTlRJTlVFICR7R0xPQkFMLnJlc3RDb2lufWAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0ID0gbmV3IFZzU3lzdGVtVGV4dCggYEdBTUUgT1ZFUmAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dC54eSA9IFsoIHBsYXllciAtIDEgKSAqIDEyOCArIDQwLDE5Ml07XHJcbiAgICAgICAgc3ByLmFkZENoaWxkKCB0ZXh0ICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRleHQgPSBuZXcgVnNTeXN0ZW1UZXh0KCBgJHtwbGF5ZXJTcHIubmFtZX0gJHtwbGF5ZXJTcHIucmVzdH0gJHtwbGF5ZXJTcHIuc2NvcmUudG9TdHJpbmcoKS5wYWRTdGFydCggOCxcIjBcIiApfWAgKTtcclxuICAgICAgICB0ZXh0Lnh5ID0gWyggcGxheWVyIC0gMSApICogMTI4ICsgMjAsMTkyXTtcclxuICAgICAgICBzcHIuYWRkQ2hpbGQoIHRleHQgKTtcclxuXHJcbiAgICAgICAgbGV0IGVmZmVjdFNwciA9IG5ldyBWc1Nwcml0ZSggXCJlZmZlY3RcIiApO1xyXG5cclxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCA3OyBpKysgKSB7XHJcbiAgICAgICAgICAgIGlmICggcGxheWVyU3ByLnBvd2VyID09IGkgKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYmFyVGV4dCA9IGVmZmVjdFNwci5nZXRNZXNoKCBpICk7XHJcblxyXG4gICAgICAgICAgICAgICAgYmFyVGV4dC54eSA9IFsoIHBsYXllciAtIDEgKSAqIDEyOCArIDIwICsgaSAqIDEyLDE4NV07XHJcbiAgICAgICAgICAgICAgICBsZXQgYmFyID0gZWZmZWN0U3ByLmdldE1lc2goIHBsYXllclNwci5pc0JhckVtcHR5W2ldID8gMTAgOiA5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgYmFyLnh5ID0gWyggcGxheWVyIC0gMSApICogMTI4ICsgMjAgKyBpICogMTIsMTg1XTtcclxuICAgICAgICAgICAgICAgIHNwci5hZGRDaGlsZCggYmFyICk7XHJcbiAgICAgICAgICAgICAgICBzcHIuYWRkQ2hpbGQoIGJhclRleHQgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBiYXIgPSBlZmZlY3RTcHIuZ2V0TWVzaCggcGxheWVyU3ByLmlzQmFyRW1wdHlbaV0gPyA4IDogNyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGJhci54eSA9IFsoIHBsYXllciAtIDEgKSAqIDEyOCArIDIwICsgaSAqIDEyLDE4NV07XHJcbiAgICAgICAgICAgICAgICBzcHIuYWRkQ2hpbGQoIGJhciApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCBzdGF0dXNTcHJbcGxheWVyXSApIHN0YXR1c1NwcltwbGF5ZXJdLnJlbW92ZUZyb21QYXJlbnQoKTtcclxuICAgIHN0YXR1c1NwcltwbGF5ZXJdID0gc3ByO1xyXG4gICAgdnNTdGFnZS5hZGRDaGlsZCggc3ByICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRvQ29udGludWUoKSB7XHJcbiAgICBpZiAoIGNvbnRpbnVlU3ByICkge1xyXG4gICAgICAgIGNvbnRpbnVlU3ByLnJlbW92ZUZyb21QYXJlbnQoKTtcclxuICAgICAgICBjb250aW51ZVNwciA9IG51bGw7XHJcbiAgICAgICAgdnNTdGFnZS53b3JsZC5zY3JvbGxUYXJnZXQudmVsb2NpdHkueCA9IGNvbnRpbnVlU2Nyb2xsVmVsb2NpdHk7XHJcbiAgICAgICAgdnNTdGFnZS53b3JsZC5ldmVudFRhcmdldC52ZWxvY2l0eS54ID0gY29udGludWVFdmVudFZlbG9jaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIHNldFN0YXR1cyggMSApO1xyXG4gICAgc2V0U3RhdHVzKCAyICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dDb250aW51ZSgpIHtcclxuICAgIGlmICggY29udGludWVTcHIgKSByZXR1cm47XHJcbiAgICBsZXQgc3ByID0gbmV3IFZzU3lzdGVtVGV4dCgpO1xyXG4gICAgbGV0IGNvbnRpbnVlVGltZXIgPSA2MDA7XHJcblxyXG4gICAgY29udGludWVTcHIgPSBzcHI7XHJcbiAgICBzcHIueHkgPSBbMTAwLDkzXTtcclxuICAgIGNvbnRpbnVlU2Nyb2xsVmVsb2NpdHkgPSB2c1N0YWdlLndvcmxkLnNjcm9sbFRhcmdldC52ZWxvY2l0eS54O1xyXG4gICAgY29udGludWVFdmVudFZlbG9jaXR5ID0gdnNTdGFnZS53b3JsZC5ldmVudFRhcmdldC52ZWxvY2l0eS54O1xyXG4gICAgdnNTdGFnZS53b3JsZC5zY3JvbGxUYXJnZXQudmVsb2NpdHkueCA9IDA7XHJcbiAgICB2c1N0YWdlLndvcmxkLmV2ZW50VGFyZ2V0LnZlbG9jaXR5LnggPSAwO1xyXG5cclxuICAgIHNwci5vbiggRXZlbnQuRU5URVJfRlJBTUUsKCk9PntcclxuICAgICAgICBpZiAoIGNvbnRpbnVlU3ByID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHNwci5yZW1vdmVGcm9tUGFyZW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCAoIGNvbnRpbnVlVGltZXIgJSA2MCApID09IDAgKSB7XHJcbiAgICAgICAgICAgIGlmICggR0xPQkFMLnJlc3RDb2luID4gMCApIHtcclxuICAgICAgICAgICAgICAgIHNwci5zZXRUZXh0KCBgQ09OVElOVUU/ICR7Y29udGludWVUaW1lciAvIDYwfWAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNwci5zZXRUZXh0KCBgR0FNRSBPVkVSYCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRpbnVlVGltZXItLTtcclxuICAgICAgICBpZiAoIGNvbnRpbnVlVGltZXIgPD0gLTYwICkge1xyXG4gICAgICAgICAgICAvLyDsmYTsoITtnogg64GdXHJcbiAgICAgICAgICAgIHNwci5yZW1vdmVGcm9tUGFyZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlU3ByID0gbnVsbDtcclxuICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJtb2RlOnRpdGxlXCIgKTtcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcbiAgICB2c1N0YWdlLmFkZENoaWxkKCBzcHIgKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2FtZUxvb3AoIGdhbWVTZXR0aW5nICkge1xyXG4gICAgdnNTdGFnZS5jbGVhckNoaWxkcmVuKCk7XHJcbiAgICB2c1N0YWdlLmJhY2tncm91bmRDb2xvciA9IDEyODtcclxuICAgIEdMT0JBTC5wbGF5ZXJzID0gW107XHJcblxyXG4gICAgc2V0U3RhcnMoKTtcclxuXHJcbiAgICAvLyDsl6zquLDrpbwg7IiY7KCV7ZWY66m0IOyLnOyekSDsiqTthYzsnbTsp4DqsIAg67CU64CQ64ukXHJcbiAgICBjaGFuZ2VTdGFnZSggeyBzdGFnZU51bWJlcjogU1RBUlRfU1RBR0UgfSApO1xyXG5cclxuICAgIGlmICggZ2FtZVNldHRpbmcucGxheWVyMSApIHtcclxuICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcInNwYXduOnBsYXllclwiLHsgcGxheWVyOiAxIH0gKTtcclxuICAgIH1cclxuICAgIGlmICggZ2FtZVNldHRpbmcucGxheWVyMiApIHtcclxuICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcInNwYXduOnBsYXllclwiLHsgcGxheWVyOiAyIH0gKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTdGF0dXMoIDEgKTtcclxuICAgIHNldFN0YXR1cyggMiApO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBjaGFuZ2VTdGFnZSggZSApIHtcclxuICAgIGxldCBzY3JvbGxTcGVlZDtcclxuICAgIGxldCBsZWdhY3lDb29yZGluYXRlTW9kZSA9IDA7XHJcbiAgICBsZXQgY2FuQnJlYWtCbG9jayA9IGZhbHNlO1xyXG5cclxuICAgIHZzU3RhZ2Uuc2V0UGFsZXR0ZSggbmV3IFZzUGFsZXR0ZSggYHN0YWdlJHtlLnN0YWdlTnVtYmVyfWAgKSApO1xyXG5cclxuICAgIHN3aXRjaCAoIGUuc3RhZ2VOdW1iZXIgKSB7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgICAgdnNTdGFnZS5wYWxldHRlLnJvdGF0ZSgpO1xyXG4gICAgICAgIHNjcm9sbFNwZWVkID0gMC41O1xyXG4gICAgICAgIG9yaWdpbmFsU3RhclNwZWVkID0gc3RhclNwZWVkID0gMC41O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICAgIHZzU3RhZ2UucGFsZXR0ZS5yb3RhdGUoIHtcclxuICAgICAgICAgICAgcmFuZ2U6IFsyNTYgLSA4LDI1NF0sXHJcbiAgICAgICAgICAgIHNwZWVkOiA0XHJcbiAgICAgICAgfSApO1xyXG4gICAgICAgIHNjcm9sbFNwZWVkID0gMC41O1xyXG4gICAgICAgIG9yaWdpbmFsU3RhclNwZWVkID0gc3RhclNwZWVkID0gMC41O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICAgIHZzU3RhZ2UucGFsZXR0ZS5yb3RhdGUoIHtcclxuICAgICAgICAgICAgcmFuZ2U6IFsyNTYgLSAyMCwyNTJdLFxyXG4gICAgICAgICAgICBzcGVlZDogNFxyXG4gICAgICAgIH0gKTtcclxuICAgICAgICBzY3JvbGxTcGVlZCA9IDAuMjU7XHJcbiAgICAgICAgb3JpZ2luYWxTdGFyU3BlZWQgPSBzdGFyU3BlZWQgPSAxO1xyXG4gICAgICAgIGxlZ2FjeUNvb3JkaW5hdGVNb2RlID0gMTtcclxuICAgICAgICBicmVhaztcclxuICAgIGNhc2UgNDpcclxuICAgICAgICBjYW5CcmVha0Jsb2NrID0gdHJ1ZTtcclxuICAgICAgICB2c1N0YWdlLnBhbGV0dGUucm90YXRlKCk7XHJcbiAgICAgICAgc2Nyb2xsU3BlZWQgPSAxMCAvIDE2O1xyXG4gICAgICAgIG9yaWdpbmFsU3RhclNwZWVkID0gc3RhclNwZWVkID0gMTAgLyAxNjtcclxuICAgICAgICBicmVhaztcclxuICAgIGNhc2UgNTpcclxuICAgICAgICB2c1N0YWdlLnBhbGV0dGUucm90YXRlKCk7XHJcbiAgICAgICAgc2Nyb2xsU3BlZWQgPSAwLjI1O1xyXG4gICAgICAgIG9yaWdpbmFsU3RhclNwZWVkID0gc3RhclNwZWVkID0gMC4yNTtcclxuICAgICAgICBsZWdhY3lDb29yZGluYXRlTW9kZSA9IDI7XHJcbiAgICAgICAgdnNTdGFnZS5wYWxldHRlLmNvbG9yQXJyYXlbMTI4XSA9IDA7ICAgIC8vIOyKpO2FjOydtOyngCA1IO2MlOugiO2KuCDrsLDqsr3snbQg7ZqM7IOJ7Jy866GcIOuQmOyWtOyeiOyWtOyEnCDsiJjsoJVcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyDrsLDqsr3rp4wg7Iio6rmAXHJcbiAgICB2c1N0YWdlLnBhbGV0dGUuYWRkKCAtMSwxMjgsMjU1ICk7XHJcbiAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcImJnbVwiLHsgZmlsZW5hbWU6IGBzcGFjZWAgfSApO1xyXG5cclxuICAgIGxldCBvbGRXb3JsZFBvcztcclxuXHJcbiAgICBpZiAoIHZzU3RhZ2Uud29ybGQgKSBvbGRXb3JsZFBvcyA9IHZzU3RhZ2Uud29ybGQucG9zaXRpb247XHJcbiAgICB2c1N0YWdlLnNldFdvcmxkKCBuZXcgVnNXb3JsZCggYHN0YWdlJHtlLnN0YWdlTnVtYmVyfWAgKSx0cnVlICk7XHJcblxyXG4gICAgaWYgKCB2c1N0YWdlLndvcmxkLnNjcm9sbFRhcmdldCApIHtcclxuICAgICAgICB2c1N0YWdlLndvcmxkLnNjcm9sbFRhcmdldC5yZW1vdmVGcm9tUGFyZW50KCk7XHJcbiAgICB9XHJcbiAgICB2c1N0YWdlLndvcmxkLmdyYXZpdHkueSA9IDAuMTM4ODtcclxuICAgIC8vIGNvbnNvbGUubG9nKCBg66e17IKs7J207KaIICR7dnNTdGFnZS53b3JsZC5tYXBXaWR0aH0sJHt2c1N0YWdlLndvcmxkLm1hcEhlaWdodH1gICk7XHJcbiAgICBpZiAoIGxlZ2FjeUNvb3JkaW5hdGVNb2RlID09IDEgKSB7XHJcbiAgICAgICAgc2Nyb2xsVGFyZ2V0U3ByLnh5ID0gWy0zOTAsMTgwXTtcclxuICAgIH0gZWxzZSBpZiAoIGxlZ2FjeUNvb3JkaW5hdGVNb2RlID09IDIgKSB7XHJcbiAgICAgICAgc2Nyb2xsVGFyZ2V0U3ByLnh5ID0gWy0zOTAgKyA4MiwxODBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzY3JvbGxUYXJnZXRTcHIueHkgPSBbLTg0LDE4MF07XHJcbiAgICB9XHJcbiAgICBzY3JvbGxUYXJnZXRTcHIuYXR0cmliLmVuYWJsZURlYnVnID0gdHJ1ZTtcclxuICAgIHNjcm9sbFRhcmdldFNwci5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgLy8gY29uc29sZS5sb2coIGDsiqTtgazroaQg7Iuc7J6RIOyngOygkCAke3Njcm9sbFRhcmdldFNwci54fSwke3Njcm9sbFRhcmdldFNwci55fWAgKTtcclxuICAgIHNjcm9sbFRhcmdldFNwci52ZWxvY2l0eS54ID0gMC41Oy8vc2Nyb2xsU3BlZWQ7XHJcbiAgICB2c1N0YWdlLndvcmxkLnNldFNjcm9sbFRhcmdldCggc2Nyb2xsVGFyZ2V0U3ByICk7XHJcbiAgICB2c1N0YWdlLndvcmxkLmV2ZW50VGFyZ2V0ID0gZXZlbnRUYXJnZXRTcHI7XHJcbiAgICBldmVudFRhcmdldFNwci52ZWxvY2l0eS54ID0gc2Nyb2xsU3BlZWQ7XHJcbiAgICBldmVudFRhcmdldFNwci54eSA9IFt2c1N0YWdlLndvcmxkLmV2ZW50RGF0YS5ldmVudFZhcnNbMF0ueCx2c1N0YWdlLndvcmxkLmV2ZW50RGF0YS5ldmVudFZhcnNbMF0ueV07XHJcbiAgICBldmVudFRhcmdldFNwci5hdHRyaWIuZW5hYmxlRGVidWcgPSB0cnVlO1xyXG4gICAgZXZlbnRUYXJnZXRTcHIuYXR0cmliLmRpc2FibGVHcmF2aXR5ID0gdHJ1ZTtcclxuICAgIC8vIHZzU3RhZ2Uud29ybGQuc2FmZUJvcmRlciA9IDUgKiAxNjtcclxuICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIwLmFkZENoaWxkKCBzY3JvbGxUYXJnZXRTcHIgKTtcclxuICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIwLmFkZENoaWxkKCBldmVudFRhcmdldFNwciApO1xyXG5cclxuICAgIEdMT0JBTC5zY3JvbGxTcGVlZCA9IHNjcm9sbFNwZWVkO1xyXG4gICAgR0xPQkFMLmNhbkJyZWFrQmxvY2sgPSBjYW5CcmVha0Jsb2NrO1xyXG4gICAgR0xPQkFMLmN1cnJlbnRTdGFnZSA9IGUuc3RhZ2VOdW1iZXI7XHJcblxyXG4gICAgdnNTdGFnZS53b3JsZC5wcm9jZXNzU2Nyb2xsKCk7XHJcblxyXG4gICAgaWYgKCBvbGRXb3JsZFBvcyApIHtcclxuICAgICAgICBsZXQgc3BycyA9IHZzU3RhZ2Uud29ybGQuc2VhcmNoQ2hpbGRyZW4oKTtcclxuICAgICAgICBsZXQgYWRqdXN0WCA9IG9sZFdvcmxkUG9zLnggLSB2c1N0YWdlLndvcmxkLng7XHJcbiAgICAgICAgbGV0IGFkanVzdFkgPSBvbGRXb3JsZFBvcy55IC0gdnNTdGFnZS53b3JsZC55O1xyXG5cclxuICAgICAgICBmb3IgKCBsZXQgc3ByIG9mIHNwcnMgKSB7XHJcbiAgICAgICAgICAgIGlmICggc3ByIGluc3RhbmNlb2YgVnNTcHJpdGUgJiYgc3ByICE9IHNjcm9sbFRhcmdldFNwciAmJiBzcHIgIT0gZXZlbnRUYXJnZXRTcHIgKSB7XHJcbiAgICAgICAgICAgICAgICBzcHIueCArPSBhZGp1c3RYO1xyXG4gICAgICAgICAgICAgICAgc3ByLnkgKz0gYWRqdXN0WTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuYXBwbGljYXRpb24ub24oIFwiYmdtXCIsIGNoYW5nZUJHTSApO1xyXG5hcHBsaWNhdGlvbi5vbiggXCJzdGFnZVwiLCBjaGFuZ2VTdGFnZSApO1xyXG5hcHBsaWNhdGlvbi5vbiggXCJtb2RlOmdhbWVMb29wXCIsIGdhbWVMb29wICk7XHJcbmFwcGxpY2F0aW9uLm9uKCBcInJlZnJlc2hVSVwiLCAoIGUgKT0+e1xyXG4gICAgc2V0U3RhdHVzKCBlLnBsYXllciApO1xyXG59ICk7XHJcbmFwcGxpY2F0aW9uLm9uKCBcImNvbnRpbnVlXCIsIGRvQ29udGludWUgKTtcclxuIiwiaW1wb3J0IHsgUGxheWVyIH0gZnJvbSBcIi4vcGxheWVyXCI7XHJcblxyXG5cclxuY2xhc3MgQXBwRGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IDA7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtQbGF5ZXJbXX0gKi9cclxuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnJlc3RDb2luID0gMDtcclxuICAgICAgICB0aGlzLmNhbkJyZWFrQmxvY2sgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgR0xPQkFMID0gbmV3IEFwcERhdGEoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdMT0JBTDtcclxuIiwiaW1wb3J0IHsgYXBwbGljYXRpb24sIFRpbWVyLCBFdmVudCwgS2V5Q29kZSwgU3ByaXRlIH0gZnJvbSBcIkBlbmdpbmUvZmxhdGZhc3RcIjtcclxuaW1wb3J0IHsgdnNTdGFnZSwgVnNQYWxldHRlLFZzU3ByaXRlLFZzSGFuZ3VsIH0gZnJvbSBcIi4vdnNXcmFwcGVyL3ZzXCI7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBpbnRybyggZSApIHtcclxuICAgIGNvbnN0IGRlbW9QYWwgPSBuZXcgVnNQYWxldHRlKCBcImRlbW9cIiApO1xyXG5cclxuICAgIHZzU3RhZ2Uuc2V0UGFsZXR0ZSggZGVtb1BhbCApO1xyXG4gICAgdnNTdGFnZS5iYWNrZ3JvdW5kQ29sb3IgPSAwO1xyXG4gICAgdnNTdGFnZS5jbGVhckNoaWxkcmVuKCk7XHJcbiAgICBjb25zdCBkZW1vU3ByID0gbmV3IFZzU3ByaXRlKCBcImRlbW9cIiApO1xyXG4gICAgbGV0IHRpbWVyO1xyXG5cclxuICAgIGNvbnN0IGV2ZW50U3ByID0gbmV3IFNwcml0ZSgpO1xyXG5cclxuICAgIHZzU3RhZ2UuYWRkQ2hpbGQoIGV2ZW50U3ByICk7XHJcblxyXG4gICAgZnVuY3Rpb24gaHB1dHMoIHMseCx5ICkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBg642w66qo66mU7Iuc7KeAOiR7c31gICk7XHJcbiAgICAgICAgbGV0IHQgPSBuZXcgVnNIYW5ndWwoKTtcclxuXHJcbiAgICAgICAgdC5zZXRDb2xvciggMTI4IC0gMzIgKyAxNSwxMjggLSAzMiApO1xyXG4gICAgICAgIHQuc2V0VGV4dCggcyApO1xyXG4gICAgICAgIHQueHkgPSBbeCx5XTtcclxuICAgICAgICB2c1N0YWdlLmFkZENoaWxkKCB0ICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVtb0ZhZGUoIHNsaWRlTnVtICkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlICk9PntcclxuICAgICAgICAgICAgZGVtb1BhbC5mYWRlKCB7IHN0YXJ0OiAtMSxlbmQ6IDEsIGR1cmF0aW9uOiA0MDAsIHJhbmdlOiBbMTI4IC0gMzIsMTI4IC0gMzIgKyAxNV0gfSApO1xyXG4gICAgICAgICAgICBpZiAoIHNsaWRlTnVtID4gMCApIHtcclxuICAgICAgICAgICAgICAgIGxldCBzID0gZGVtb1Nwci5nZXRNZXNoKCBzbGlkZU51bSArIDcgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzLnh5ID0gWzE1LDEwXTtcclxuICAgICAgICAgICAgICAgIHZzU3RhZ2UuYWRkQ2hpbGQoIHMgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aW1lciA9IFRpbWVyLmRlbGF5ZWRDYWxsKCAxMDAwIC8gNjAgKiA3MDUsICgpPT57XHJcbiAgICAgICAgICAgICAgICB2c1N0YWdlLmNsZWFyQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgIHZzU3RhZ2UuYWRkQ2hpbGQoIGV2ZW50U3ByICk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coIGDsnbjtirjroZwg7ZmU66m0YCApO1xyXG4gICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJiZ21cIix7IGZpbGVuYW1lOiBcImludHJvXCIgfSApO1xyXG4gICAgZXZlbnRTcHIub24oIEV2ZW50LlJFTU9WRURfRlJPTV9TVEFHRSwgKCkgPT4ge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBcIuyduO2KuOuhnCDsnbTrsqTtirgg7Iqk7ZSE65287J207Yq4IOyCreygnFwiICk7XHJcbiAgICAgICAgdGltZXIuc3RvcCgpO1xyXG4gICAgfSApO1xyXG4gICAgZXZlbnRTcHIub24oIEV2ZW50LktFWV9ET1dOLCBlID0+IHtcclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBg7YKk7J6F66ClICR7ZS5rZXlDb2RlfWAgKTtcclxuICAgICAgICBpZiAoIGUua2V5Q29kZSA9PSBLZXlDb2RlLlNQQUNFIHx8IGUua2V5Q29kZSA9PSBLZXlDb2RlLkVTQyB8fCBlLmtleUNvZGUgPT0gS2V5Q29kZS5FTlRFUiApIHtcclxuICAgICAgICAgICAgdnNTdGFnZS5jbGVhckNoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgIHRpbWVyLnN0b3AoKTtcclxuICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJtb2RlOnRpdGxlXCIgKTtcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcbiAgICBpZiAoIGUuZW5kaW5nRmxhZyA9PSB0cnVlICkge1xyXG4gICAgICAgIGhwdXRzKCAgXCLtlaDrsJXsgqwg7J287ZaJ7J2AIOyasOyjvCDrjIDslYXrp4gg7IK066qo7IKsIOuwleyCrOulvFxcblwiICtcclxuICAgICAgICAgICAgICAgIFwi66y07LCM66W06rOgIOyngOq1rOuhnCDqt4DtmZjtlZjsmIDri6QuXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgXCLri6Tsi5wg7Jqw7KO87JeQ64qUIO2Pie2ZlOqwgCDssL7slYTsmZTri6QuLi5cIiwxMCwxMjAgKTtcclxuICAgICAgICBhd2FpdCBkZW1vRmFkZSggNCApO1xyXG4gICAgICAgIGhwdXRzKCAgXCLsp4DquIjquYzsp4Ag67O4IOqyjOyehOydhCDtlIzroIjsnbTtlbTso7zsi6BcXG5cIiArXHJcbiAgICAgICAgICAgICAgICBcIuyXrOufrOu2hOq7mCDquYrsnYAg6rCQ7IKs66W8IOuTnOumveuLiOuLpC5cXG5cIiArXHJcbiAgICAgICAgICAgICAgICBcIuyYpOu4jOygne2KuCDsiqTtgJjslrTsnZgg64uk7J2MIOqyjOyehOyduFxcblwiICtcclxuICAgICAgICAgICAgICAgIFwi7ZWZ7JuQIO2YuOufrCDslrTrk5zrsqTss5AgKDguMTXtlbTsoIDrk5wp66W8XFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgXCLquLDrjIDtlbQg7KO87Iut7Iuc7JikISDslrjsoJwg64KY7Jis7KeEIOuqsOudvOyalC5cIiwxMCw0MCApO1xyXG4gICAgICAgIGF3YWl0IGRlbW9GYWRlKCAwICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhwdXRzKCBcIuyasOumrOuKlCDsl63sgqzsmYAg66+87KGxIOyVnuyXkCDsp4Tsi6zsnLzroZxcXG7ssLjtmoztlZjrqbAg7J20IOq4sOuhneydhCDrgqjquLTri6RcIiwxMCw3MCApO1xyXG4gICAgICAgIGhwdXRzKCBcIiAgICAgICAgIDE5OTfrhYQgMuyblFxcbiAgICDtkZzrpZggODUw7J287Ke4LCBEUi7tlaBcIiw4MCwxMzAgKTtcclxuICAgICAgICBhd2FpdCBkZW1vRmFkZSggMCApO1xyXG5cclxuICAgICAgICBocHV0cyggXCLri6jquLAgMTk5NysyMzMz64WEXCIsMTAsMTAgKTtcclxuICAgICAgICBocHV0cyggXCLsmKTruIzsoJ3tirgg7Iqk7YCY7Ja0IOyVnuycvOuhnCDsnZjrrLjsnZhcXG7stIjrjIDsnqXsnbQg64+E7LCp7ZWY7JiA64ukLlwiLDMwLDMwICk7XHJcbiAgICAgICAgaHB1dHMoICBcIigxMDBLIOqyjOyehCDqs7XrqqjsoITsnYQg6rCc7LWc7ZWc64ukLlxcblwiICtcclxuICAgICAgICAgICAgICAgIFwiICAgIC0g6ri47Ja07IScIOyCreygnCAtXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgXCIg67aA65SUIOyZleumvO2VmOyXrCDsnpDrpqzrpbwg67mb64K07KO86riwIOuwlOuegOuLpClcXG5cIiArXHJcbiAgICAgICAgICAgICAgICBcIiAgICAgICAgZnJvbSDtlZjsnbTthZQg6rKM7J6E7KCc7J6R64+Z7Zi47ZqMXCIsMzAsNzAgKTtcclxuICAgICAgICBsZXQgY2FyZFNwciA9IG5ldyBWc1Nwcml0ZSggXCJkZW1vXCIseyB4OiAxMjgseTogMTcwIH0gKTtcclxuXHJcbiAgICAgICAgdnNTdGFnZS5hZGRDaGlsZCggY2FyZFNwciApO1xyXG4gICAgICAgIGF3YWl0IGRlbW9GYWRlKCAwICk7XHJcblxyXG4gICAgICAgIGhwdXRzKCBcIuyYpOu4jOygne2KuCDsiqTtgJjslrQg7YyA7J2AIDPrhYTsoIQg7Jqw7KO8IOuMgOyVheuniFxcblwiICtcclxuICAgICAgICAgICAgXCLsgrTrqqjsgqwg67CV7IKs7JeQ6rKMIOuMgO2Vre2VmOq4sCDsnITtlbQg7ZWg67CV7IKs7JmAXFxuXCIgK1xyXG4gICAgICAgICAgICBcIuyCsOyGjOulvCDrs7Trg4jri6QuXCIsMTAsMTIwICk7XHJcbiAgICAgICAgYXdhaXQgZGVtb0ZhZGUoIDEgKTtcclxuXHJcbiAgICAgICAgaHB1dHMoIFwi6re465+s64KYIOqzteynnOuhnCDslrvsnYAg7Lqh7Law67O065Oc66W8IOuBvOyasOuLpFxcblwiICtcclxuICAgICAgICAgICAgXCLtlZjrk5zrpbwg64Kg66Ck66i564qUIOyYpOu4jOygne2KuCDsiqTtgJjslrQg7YyALi4uXFxuXCIgK1xyXG4gICAgICAgICAgICBcIuuNleu2hOyXkCDtlaDrsJXsgqzsmYAg7IKw7IaM64qUIDEg7Iqk7YWM7J207KeA66W8XFxuXCIgK1xyXG4gICAgICAgICAgICBcIu2BtOumrOyWtCDtm4Qg7Jqw7KO866+47JWE6rCAIOuQmOqzoOunjOuLpC5cIiwxMCwxMjAgKTtcclxuICAgICAgICBhd2FpdCBkZW1vRmFkZSggMiApO1xyXG5cclxuICAgICAgICBocHV0cyggXCLsp4DqtazroZwg64+M7JWE6rCA6rOgIOyLtuydgCDsgrDshozsmYAg7ZWg67CV7IKsLFxcblwiICtcclxuICAgICAgICAgICAgXCLqt7jrn6zrgpgg6re465Ok7J2AIOyYpOu4jOygne2KuCDsiqTtgJjslrTrpbwg7JuQ66ed7ZWY7KeAXFxuXCIgK1xyXG4gICAgICAgICAgICBcIuyViuyVmOuLpCFcIiwxMCwxMjAgKTtcclxuICAgICAgICBhd2FpdCBkZW1vRmFkZSggMyApO1xyXG5cclxuICAgICAgICBocHV0cyggXCLqs6Dsg50g64Gd7JeQIOuCmeydtCDsmKTripQg67KVLiDqs7Xsp5zrpbwg67Cd7Z6I64qUXFxuXCIgK1xyXG4gICAgICAgICAgICBcIuyYpOu4jOygne2KuCDsiqTtgJjslrQg7YyA7J2YIOyVvOyaleqzvCDtlajqu5gg7ZWg67CV7IKsXFxuXCIgK1xyXG4gICAgICAgICAgICBcIuydvO2WieydgCDsp4DqtazroZwg64+M7JWE7Jio64ukLiDqt7jrk6Tsl5Dqsowg64K066Ck7KeEXFxuXCIgK1xyXG4gICAgICAgICAgICBcIuyehOustOuKlCDqs7XrqqjsoITsl5DshJwg7IOB7J2EIO2DgOyYpOuKlCDqsoMuXCIsMTAsMTIwICk7XHJcbiAgICAgICAgYXdhaXQgZGVtb0ZhZGUoIDQgKTtcclxuXHJcbiAgICAgICAgaHB1dHMoIFwiMTAwS+yXkCDrgbzsm4wg66ee7LaU6riwIOychO2VtCDrgrTsmqnsnYQg66eI6rWsXFxuXCIgK1xyXG4gICAgICAgICAgICBcIuyCreygnO2VnCA4NeuQmOyXiOyImOuLpCDsiqTtjpjshZzqs7wg7ZWo6ruYIOuRkOuqheydgFxcblwiICtcclxuICAgICAgICAgICAgXCLri6Tsi5wg7Lac6rKp7ZWY7KeA66eMLCDsl63si5wg7J2067KIIOuMgO2ajOyXkOuPhFxcblwiICtcclxuICAgICAgICAgICAgXCLrrZTqsIAg7JWF7J2YIOq4sOyatOydtC4uLlwiLDEwLDEyMCApO1xyXG4gICAgICAgIGF3YWl0IGRlbW9GYWRlKCA1ICk7XHJcbiAgICB9XHJcbiAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcIm1vZGU6dGl0bGVcIiApO1xyXG59XHJcblxyXG5hcHBsaWNhdGlvbi5vbiggXCJtb2RlOmludHJvXCIsaW50cm8gKTtcclxuXHJcbiIsImltcG9ydCB7IGFwcGxpY2F0aW9uLFV0aWxzLCBFdmVudCwgS2V5Q29kZSwgU291bmQgfSBmcm9tIFwiQGVuZ2luZS9mbGF0ZmFzdFwiO1xyXG5pbXBvcnQgR0xPQkFMIGZyb20gXCIuL2dsb2JhbFwiO1xyXG5pbXBvcnQgeyB2c1N0YWdlLFZzV29ybGQsVnNTcHJpdGUgfSBmcm9tIFwiLi92c1dyYXBwZXIvdnNcIjtcclxuXHJcbmNvbnN0IGNvbnRyb2xLZXlzID0ge1xyXG4gICAgXCIxXCI6IHtcclxuICAgICAgICBcInVwXCI6ICAgICAgW0tleUNvZGUuVVAsS2V5Q29kZS5JXSxcclxuICAgICAgICBcImRvd25cIjogICAgW0tleUNvZGUuRE9XTixLZXlDb2RlLktdLFxyXG4gICAgICAgIFwibGVmdFwiOiAgICBbS2V5Q29kZS5MRUZULEtleUNvZGUuSl0sXHJcbiAgICAgICAgXCJyaWdodFwiOiAgIFtLZXlDb2RlLlJJR0hULEtleUNvZGUuTF0sXHJcbiAgICAgICAgXCJzaG9vdFwiOiAgIFtLZXlDb2RlLlNQQUNFLEtleUNvZGUuTl0sXHJcbiAgICAgICAgXCJwb3dlclVwXCI6IFtLZXlDb2RlLkNUUkwsS2V5Q29kZS5NXSwgICAgXHJcbiAgICB9LFxyXG4gICAgXCIyXCI6IHtcclxuICAgICAgICBcInVwXCI6ICAgICAgW0tleUNvZGUuV10sXHJcbiAgICAgICAgXCJkb3duXCI6ICAgIFtLZXlDb2RlLlNdLFxyXG4gICAgICAgIFwibGVmdFwiOiAgICBbS2V5Q29kZS5BXSxcclxuICAgICAgICBcInJpZ2h0XCI6ICAgW0tleUNvZGUuRF0sXHJcbiAgICAgICAgXCJzaG9vdFwiOiAgIFtLZXlDb2RlLlpdLFxyXG4gICAgICAgIFwicG93ZXJVcFwiOiBbS2V5Q29kZS5YXSwgICAgXHJcbiAgICB9XHJcbn07XHJcblxyXG5jb25zdCBPcHRpb25JbnRlcnZhbCA9IDE2O1xyXG5cclxuLyoqXHJcbiAqIO2UjOugiOydtOyWtCDsiqTtlITrnbzsnbTtirgg7YG0656Y7IqkXHJcbiAqIFxyXG4gKlxyXG4gKiBAY2xhc3MgUGxheWVyXHJcbiAqIEBleHRlbmRzIHtWc1Nwcml0ZX1cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQbGF5ZXIgZXh0ZW5kcyBWc1Nwcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvciggZSApIHtcclxuICAgICAgICBzdXBlciggZS5wbGF5ZXIgPT0gMSA/IFwicF9oYWxcIiA6IFwicF9jcnlzXCIgKTtcclxuICAgICAgICBsZXQgeCA9IDYwO1xyXG4gICAgICAgIGxldCB5ID0gZS5wbGF5ZXIgPT0gMSA/IDUwIDogMTEwO1xyXG4gXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRDb29yZGluYXRlKCB4LHkgKTtcclxuICAgICAgICB0aGlzLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uQm90dG9tID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25Ub3AgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvbkxlZnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvblJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAvLyB0aGlzLmF0dHJpYi5lbmFibGVEZWJ1ZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBlLnBsYXllcjtcclxuICAgICAgICB0aGlzLm5hbWUgPSBlLnBsYXllciA9PSAxID8gXCJIQUxcIiA6IFwiTzIgXCI7XHJcbiAgICAgICAgdGhpcy5yZXN0ID0gMztcclxuICAgICAgICB0aGlzLmdhbWVPdmVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY29yZSA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXhPcHRpb24gPSAzO1xyXG4gICAgICAgIHRoaXMucmVhZHlUaW1lciA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VXBkYXRlUGhhc2VDYWxsYmFjayggdGhpcy51cGRhdGUgKTtcclxuICAgICAgICB0aGlzLnNldE1hcENvbGxpc2lvblBoYXNlQ2FsbGJhY2soICggZmxhZyApPT57XHJcbiAgICAgICAgICAgIGlmICggZmxhZyAhPSAwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkhpdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG4gICAgICAgIHRoaXMub24oIEV2ZW50LktFWV9ET1dOLHRoaXMua2V5SGFuZGxlci5iaW5kKCB0aGlzLHRydWUgKSApO1xyXG4gICAgICAgIHRoaXMub24oIEV2ZW50LktFWV9VUCx0aGlzLmtleUhhbmRsZXIuYmluZCggdGhpcyxmYWxzZSApICk7XHJcbiAgICAgICAgdGhpcy5pbnB1dHMgPSB7fTtcclxuICAgICAgICB0aGlzLm5ld0lucHV0cyA9IHt9O1xyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbkluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLm9wdGlvbkJ1ZmZlciA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVzZXRQb3dlclVwKCk7XHJcbiAgICAgICAgdGhpcy5vbiggXCJoaXRcIix0aGlzLm9uSGl0ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV2aXZlKCkge1xyXG4gICAgICAgIHRoaXMueCA9IHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRYKCAtMTAgKTtcclxuICAgICAgICB0aGlzLnNldEFjdGlvbiggMTIgKTtcclxuICAgICAgICB0aGlzLnJlYWR5VGltZXIgPSAyMDA7XHJcbiAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlRmxpY2tlciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uTGVmdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvblJpZ2h0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uVG9wID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uQm90dG9tID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zZXRNYXBDb2xsaXNpb25QaGFzZUNhbGxiYWNrKCBudWxsICk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZU92ZXIgPSBmYWxzZTtcclxuICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcImNvbnRpbnVlXCIgKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkhpdCggZSApIHtcclxuICAgICAgICBpZiAoIHRoaXMuZ2FtZU92ZXIgKSByZXR1cm47XHJcbiAgICAgICAgaWYgKCBlICE9IG51bGwgJiYgZS5mb3JjZUhpdCAhPSB0cnVlICYmIHRoaXMucmVhZHlUaW1lciA+IDAgKSByZXR1cm47XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tYXhPcHRpb24gPSAzO1xyXG4gICAgICAgIFNvdW5kLnBsYXlTb3VuZCggYGJhbmcud2F2YCApO1xyXG4gICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwiZXhwbG9zaW9uXCIsIHsgeDogdGhpcy54LHk6IHRoaXMueSxjb3VudDogMTAscG93ZXI6IDEgfSApO1xyXG4gICAgICAgIHRoaXMucmVzZXRQb3dlclVwKCk7XHJcbiAgICAgICAgaWYgKCB0aGlzLnJlc3QgPT0gMCApIHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dHMuc2hvb3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5yZXN0ID0gMztcclxuICAgICAgICAgICAgdGhpcy5nYW1lT3ZlciA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aW9uKCAwICk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRYKCAtNTAgKTtcclxuICAgICAgICAgICAgLy8gdGhpcy55ID0gdnNTdGFnZS53b3JsZC5nZXRXb3JsZFkoIC0xMDAgKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uTGVmdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25SaWdodCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25Ub3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uQm90dG9tID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwicmVmcmVzaFVJXCIseyBwbGF5ZXI6IHRoaXMucGxheWVyIH0gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3QtLTtcclxuICAgICAgICAgICAgdGhpcy5yZXZpdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXRQb3dlclVwKCkge1xyXG4gICAgICAgIHRoaXMucG93ZXIgPSAtMTtcclxuICAgICAgICB0aGlzLmlzQmFyRW1wdHkgPSBbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdO1xyXG4gICAgICAgIHRoaXMubWlzc2lsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW92ZVNwZWVkID0gMC41NTtcclxuICAgICAgICB0aGlzLndlYXBvbiA9IFwibm9ybWFsXCI7XHJcbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm9wdGlvbnMgKSApIHRoaXMub3B0aW9ucy5mb3JFYWNoKCBzcHIgPT4ge1xyXG4gICAgICAgICAgICBzcHIucmVtb3ZlKCBcInJlc2V0XCIgKTtcclxuICAgICAgICB9ICk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5zaGllbGQgPSBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuYXV0b1Nob290Q29vbERvd24gPSAxMDtcclxuICAgICAgICB0aGlzLmF1dG9TaG9vdFJlc2V0ID0gMTE7XHJcbiAgICAgICAgdGhpcy5hdXRvU2hvb3RDb3VudCA9IHRoaXMuYXV0b1Nob290UmVzZXQ7XHJcblxyXG4gICAgICAgIHRoaXMubWlzc2lsZURlbGF5ID0gNjA7XHJcbiAgICAgICAgdGhpcy5taXNzaWxlQ291bnQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGtleUhhbmRsZXIoIGlzRG93bixlICkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBlICk7XHJcbiAgICAgICAgaWYgKCBpc0Rvd24gPT0gZmFsc2UgJiYgZS5rZXlDb2RlID09IEtleUNvZGUuTyApIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwic3RhZ2VcIix7IHN0YWdlTnVtYmVyOiAyIH0gKTtcclxuICAgICAgICBsZXQgY29udHJvbE1hcCA9IGNvbnRyb2xLZXlzW3RoaXMucGxheWVyXTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IGlucHV0IGluIGNvbnRyb2xNYXAgKSB7XHJcbiAgICAgICAgICAgIGlmICggY29udHJvbE1hcFtpbnB1dF0uaW5kZXhPZiggZS5rZXlDb2RlICkgPj0gMCApIHtcclxuICAgICAgICAgICAgICAgIGlmICggaXNEb3duICYmICF0aGlzLmlucHV0c1tpbnB1dF0gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdJbnB1dHNbaW5wdXRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzW2lucHV0XSA9IGlzRG93bjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmdhbWVPdmVyICkge1xyXG4gICAgICAgICAgICBpZiAoIEdMT0JBTC5yZXN0Q29pbiA+IDAgJiYgdGhpcy5pbnB1dHMuc2hvb3QgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBcclxuICAgICAgICAgICAgICAgIEdMT0JBTC5yZXN0Q29pbi0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXZpdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzLnNob290ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBTb3VuZC5wbGF5U291bmQoIGBwb3dlci53YXZgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnJlYWR5VGltZXIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZHlUaW1lci0tO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMucmVhZHlUaW1lciA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNYXBDb2xsaXNpb25QaGFzZUNhbGxiYWNrKCAoIGZsYWcgKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggZmxhZyAhPSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uSGl0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlRmxpY2tlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uTGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25SaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25Ub3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uQm90dG9tID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDsiqTtgazroaQg7IaN64+E7JeQIOunnuy2mOuLpFxyXG4gICAgICAgIGxldCBzY3JvbGxTcGVlZCA9IHZzU3RhZ2Uud29ybGQuc2Nyb2xsVGFyZ2V0LnZlbG9jaXR5Lng7XHJcbiAgICAgICAgbGV0IGlzTW92ZWQgPSBmYWxzZTtcclxuXHJcblxyXG4gICAgICAgIC8vIOuwqe2Wpe2CpCDsspjrpqxcclxuICAgICAgICBpZiAoIHRoaXMucmVhZHlUaW1lciA8IDE0MCApIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmlucHV0cy51cCApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aW9uKCAxICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSAtdGhpcy5tb3ZlU3BlZWQ7XHJcbiAgICAgICAgICAgICAgICBpc01vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5pbnB1dHMuZG93biApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aW9uKCAzICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSB0aGlzLm1vdmVTcGVlZDtcclxuICAgICAgICAgICAgICAgIGlzTW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDsg4HtlZgg7JuA7KeB7J6E7J20IOyXhuydhCDqsr3smrBcclxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5hY3Rpb24gPT0gMSApIHRoaXMuc2V0QWN0aW9uKCAyICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuYWN0aW9uID09IDMgKSB0aGlzLnNldEFjdGlvbiggNCApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS55ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuaW5wdXRzLmxlZnQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSAtdGhpcy5tb3ZlU3BlZWQ7XHJcbiAgICAgICAgICAgICAgICBpc01vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5pbnB1dHMucmlnaHQgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSB0aGlzLm1vdmVTcGVlZDtcclxuICAgICAgICAgICAgICAgIGlzTW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkueSA9IDA7ICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDtmZTrqbQg67CW7Jy866GcIOuEmOyWtOqwgOyngCDrqrvtlZjqsowg7LKY66asXHJcbiAgICAgICAgaWYgKCB0aGlzLnggPCB2c1N0YWdlLndvcmxkLmdldFdvcmxkWCggNSApIHx8IHRoaXMueCA+IHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRYKCAyNTAgKSApIHtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy54ID0gVXRpbHMuY2xhbXAoIHRoaXMueCx2c1N0YWdlLndvcmxkLmdldFdvcmxkWCggNSApLHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRYKCAyNTAgKSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMueSA8IHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRZKCA1ICkgfHwgdGhpcy55ID4gdnNTdGFnZS53b3JsZC5nZXRXb3JsZFkoIDE5NSApICkge1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBVdGlscy5jbGFtcCggdGhpcy55LHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRZKCA1ICksdnNTdGFnZS53b3JsZC5nZXRXb3JsZFkoIDE5NSApICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOyKpO2BrOuhpCDsho3rj4Tsl5Ag66ee7Law7IScIOu5hO2WiVxyXG4gICAgICAgIHRoaXMudmVsb2NpdHkueCArPSBzY3JvbGxTcGVlZDtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmlucHV0cy5zaG9vdCApIHtcclxuICAgICAgICAgICAgdGhpcy5zaG9vdCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0b1Nob290Q291bnQgPSB0aGlzLmF1dG9TaG9vdFJlc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMubmV3SW5wdXRzLnBvd2VyVXAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3SW5wdXRzLnBvd2VyVXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5wb3dlclVwKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMubWlzc2lsZUNvdW50ID4gMCApIHRoaXMubWlzc2lsZUNvdW50LS07XHJcblxyXG4gICAgICAgIGlmICggaXNNb3ZlZCAmJiB0aGlzLm9wdGlvbnMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25CdWZmZXIucHVzaCggW3ZzU3RhZ2Uud29ybGQuZ2V0U3RhZ2VYKCB0aGlzLnggKSx2c1N0YWdlLndvcmxkLmdldFN0YWdlWSggdGhpcy55ICldICk7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25CdWZmZXIubGVuZ3RoID4gT3B0aW9uSW50ZXJ2YWwgKiB0aGlzLm9wdGlvbkJ1ZmZlci5sZW5ndGggKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbkJ1ZmZlciA9IHRoaXMub3B0aW9uQnVmZmVyLnNwbGljZSggMCx0aGlzLm9wdGlvbkJ1ZmZlci5sZW5ndGggLSAoIE9wdGlvbkludGVydmFsICogdGhpcy5vcHRpb25CdWZmZXIubGVuZ3RoICkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25VcGRhdGUoKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtQbGF5ZXJ9ICovXHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgbGV0IG93bmVyID0gdGhpcy5vd25lcjtcclxuXHJcbiAgICAgICAgaWYgKCBvd25lci5vcHRpb25CdWZmZXIubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgbGV0IHJlYWRQb3MgPSBNYXRoLm1heCggMCxvd25lci5vcHRpb25CdWZmZXIubGVuZ3RoIC0gdGhpcy5vcHRpb25JbmRleCAqIE9wdGlvbkludGVydmFsICk7XHJcbiAgICAgICAgICAgIGxldCB4ID0gb3duZXIub3B0aW9uQnVmZmVyW3JlYWRQb3NdWzBdO1xyXG4gICAgICAgICAgICBsZXQgeSA9IG93bmVyLm9wdGlvbkJ1ZmZlcltyZWFkUG9zXVsxXTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB2c1N0YWdlLndvcmxkLmdldFdvcmxkQ29vcmRpbmF0ZSggeCx5ICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG93bmVyLnBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaG9vdCgpIHtcclxuICAgICAgICBjb25zdCBjcmVhdGVCdWxsZXQgPSAoIGRhbWFnZSApPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3ByID0gdGhpcy5jcmVhdGVWc1Nwcml0ZSgge1xyXG4gICAgICAgICAgICAgICAgeDogICAgICB0aGlzLngsXHJcbiAgICAgICAgICAgICAgICB5OiAgICAgIHRoaXMueSxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogNSxcclxuICAgICAgICAgICAgfSApO1xyXG5cclxuICAgICAgICAgICAgc3ByLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwci5hdHRyaWIuZW5hYmxlQXV0b1JlbW92ZVN0YWdlT3V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3ByLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25SaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwci52ZWxvY2l0eS54ID0gMTA7XHJcbiAgICAgICAgICAgIHNwci5zZXRNYXBDb2xsaXNpb25QaGFzZUNhbGxiYWNrKCAoIGZsYWcsIGluZm8gKT0+e1xyXG4gICAgICAgICAgICAgICAgaWYgKCBmbGFnICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggR0xPQkFMLmNhbkJyZWFrQmxvY2sgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uY29sbGlkZUxpc3QuZm9yRWFjaCggdj0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xsaWRlTGlzdOuKlCDstqnrj4wg7KCV67O066W8IOuLtOydgCDslrTroIjsnbRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3gseSxtYXBOdW1dIOyInOycvOuhnCDri7Tqsqgg7J6I64ukXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhbWFnZSA+PSAxMCAmJiAoIHZbMl0gPT0gMSB8fCB2WzJdID09IDIgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOugiOydtOyggOuKlCBkYW1hZ2XqsIAgNeuLiOq5jCDsnbzrsJgg7YOE66eMIOu4lOuhneydhCDrtoDsiKAg7IiYIOyeiOuPhOuhnVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwiZXhwbG9zaW9uXCIsIHsgeDogKCB2WzBdIDw8IDQgKSArIDgseTogKCB2WzFdIDw8IDQgKSArIDgsY291bnQ6IDEscG93ZXI6IDAgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvdW5kLnBsYXlTb3VuZCggYHpha28ud2F2YCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQuc2V0TWFwKCB2WzBdLHZbMV0sdlsyXSAtIDEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3ByLnJlbW92ZSggXCJibG9ja1wiICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgc3ByLnNldENvbGxpc2lvblBoYXNlQ2FsbGJhY2soICggc3BycyApPT57XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBsZXQgdGFyZ2V0IG9mIHNwcnMgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YXJnZXQuaXNFbmVteSAmJiBzcHIuY2hlY2tSYW5nZSggdGFyZ2V0LDAsMCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCggXCJoaXRcIix7IHR5cGU6IFwiYnVsbGV0XCIsIGRhbWFnZTogZGFtYWdlLCBvd25lcjogdGhpcyB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwci5yZW1vdmUoIFwiZW5lbXlIaXRcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICByZXR1cm4gc3ByO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5vcHRpb25JbmRleCA9PSAwICkgdGhpcy5vcHRpb25zLmZvckVhY2goICggb3B0aW9uICk9PntcclxuICAgICAgICAgICAgb3B0aW9uLm1pc3NpbGUgPSB0aGlzLm1pc3NpbGU7XHJcbiAgICAgICAgICAgIG9wdGlvbi5taXNzaWxlQ291bnQgPSB0aGlzLm1pc3NpbGVDb3VudDtcclxuICAgICAgICAgICAgb3B0aW9uLndlYXBvbiA9IHRoaXMud2VhcG9uO1xyXG4gICAgICAgICAgICBvcHRpb24uYXV0b1Nob290Q291bnQgPSB0aGlzLmF1dG9TaG9vdENvdW50O1xyXG4gICAgICAgICAgICBvcHRpb24uYXV0b1Nob290Q29vbERvd24gPSB0aGlzLmF1dG9TaG9vdENvb2xEb3duO1xyXG4gICAgICAgICAgICBvcHRpb24uc2hvb3QoKTsgXHJcbiAgICAgICAgfSApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMubWlzc2lsZSAmJiB0aGlzLm1pc3NpbGVDb3VudCA9PSAwICkge1xyXG4gICAgICAgICAgICBsZXQgc3ByID0gY3JlYXRlQnVsbGV0KCA0MCApO1xyXG5cclxuICAgICAgICAgICAgc3ByLmFjdGlvbiA9IDc7XHJcbiAgICAgICAgICAgIHNwci52ZWxvY2l0eS54ID0gMS43NTtcclxuICAgICAgICAgICAgc3ByLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25Ub3AgPSB0cnVlO1xyXG4gICAgICAgICAgICBzcHIuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvbkJvdHRvbSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwci5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uTGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwci5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgc3ByLnNldE1hcENvbGxpc2lvblBoYXNlQ2FsbGJhY2soICggZmxhZyApPT57XHJcbiAgICAgICAgICAgICAgICBpZiAoIGZsYWcgJiBWc1dvcmxkLlRJTEVBVFRSSUJfUldBTEwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ByLnJlbW92ZSggXCJibG9ja1wiICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgLy8gc3ByLnNldE1hcENvbGxpc2lvblBoYXNlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgdnNTdGFnZS53b3JsZC5sYXllcjIuYWRkQ2hpbGQoIHNwciApO1xyXG4gICAgICAgICAgICB0aGlzLm1pc3NpbGVDb3VudCA9IHRoaXMubWlzc2lsZURlbGF5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hdXRvU2hvb3RDb3VudC0tO1xyXG4gICAgICAgIGlmICggdGhpcy5hdXRvU2hvb3RDb3VudCA8IHRoaXMuYXV0b1Nob290Q29vbERvd24gKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5hdXRvU2hvb3RDb3VudCA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvU2hvb3RDb3VudCA9IHRoaXMuYXV0b1Nob290UmVzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLndlYXBvbiA9PSBcIm5vcm1hbFwiIHx8IHRoaXMud2VhcG9uID09IFwiZG91YmxlXCIgKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25JbmRleCA9PSAwICkgU291bmQucGxheVNvdW5kKCBgc2hvb3Qud2F2YCApO1xyXG4gICAgICAgICAgICB2c1N0YWdlLndvcmxkLmxheWVyMi5hZGRDaGlsZCggY3JlYXRlQnVsbGV0KCAxMCApICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggdGhpcy53ZWFwb24gPT0gXCJkb3VibGVcIiApIHtcclxuICAgICAgICAgICAgbGV0IHNwciA9IGNyZWF0ZUJ1bGxldCggMTAgKTtcclxuXHJcbiAgICAgICAgICAgIHNwci52ZWxvY2l0eS55ID0gLTY7XHJcbiAgICAgICAgICAgIHNwci5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uVG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgdnNTdGFnZS53b3JsZC5sYXllcjIuYWRkQ2hpbGQoIHNwciApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMud2VhcG9uID09IFwibGFzZXJcIiApIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLm9wdGlvbkluZGV4ID09IDAgJiYgdGhpcy5hdXRvU2hvb3RDb3VudCA9PSB0aGlzLmF1dG9TaG9vdFJlc2V0IC0gMSApIHtcclxuICAgICAgICAgICAgICAgIFNvdW5kLnBsYXlTb3VuZCggYGxhc2VyLndhdmAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3ByID0gY3JlYXRlQnVsbGV0KCA1ICk7XHJcblxyXG4gICAgICAgICAgICBzcHIuYWN0aW9uID0gNjtcclxuICAgICAgICAgICAgc3ByLnZlbG9jaXR5LnggPSAzMDtcclxuICAgICAgICAgICAgc3ByLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25Ub3AgPSB0cnVlO1xyXG4gICAgICAgICAgICBzcHIuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvbkJvdHRvbSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNwci5zZXRVcGRhdGVQaGFzZUNhbGxiYWNrKCAoKT0+e1xyXG4gICAgICAgICAgICAgICAgc3ByLnkgPSB0aGlzLnk7XHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdnNTdGFnZS53b3JsZC5sYXllcjIuYWRkQ2hpbGQoIHNwciApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwb3dlclVwKCkge1xyXG4gICAgICAgIGlmICggdGhpcy5wb3dlciA8IDAgfHwgdGhpcy5pc0JhckVtcHR5W3RoaXMucG93ZXJdICkgcmV0dXJuO1xyXG4gICAgICAgIFNvdW5kLnBsYXlTb3VuZCggYHBvd2VyLndhdmAgKTtcclxuICAgICAgICBzd2l0Y2ggKCB0aGlzLnBvd2VyICkge1xyXG4gICAgICAgIGNhc2UgMDogLy8g7Iqk7ZS865Oc7JeFXHJcbiAgICAgICAgICAgIHRoaXMubW92ZVNwZWVkICs9IDAuNTtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLm1vdmVTcGVlZCA+PSAzICkgdGhpcy5pc0JhckVtcHR5W3RoaXMucG93ZXJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOiAvLyDrr7jsgqzsnbxcclxuICAgICAgICAgICAgdGhpcy5taXNzaWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5pc0JhckVtcHR5W3RoaXMucG93ZXJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOiAvLyDrjZTruJRcclxuICAgICAgICAgICAgdGhpcy53ZWFwb24gPSBcImRvdWJsZVwiO1xyXG4gICAgICAgICAgICB0aGlzLmlzQmFyRW1wdHlbdGhpcy5wb3dlcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmlzQmFyRW1wdHlbM10gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hdXRvU2hvb3RDb29sRG93biA9IDEwO1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9TaG9vdFJlc2V0ID0gMTE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzogLy8g66CI7J207KCAXHJcbiAgICAgICAgICAgIHRoaXMud2VhcG9uID0gXCJsYXNlclwiO1xyXG4gICAgICAgICAgICB0aGlzLmlzQmFyRW1wdHlbdGhpcy5wb3dlcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmlzQmFyRW1wdHlbMl0gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hdXRvU2hvb3RDb29sRG93biA9IDIwO1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9TaG9vdFJlc2V0ID0gNTA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNDogLy8g7Ji17IWYXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7UGxheWVyfSAqL1xyXG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9uU3ByID0gdGhpcy5jcmVhdGVWc1Nwcml0ZSggeyB4OiB0aGlzLngseTogdGhpcy55LGFjdGlvbjogOCB9ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKCBvcHRpb25TcHIsUGxheWVyLnByb3RvdHlwZSApO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uU3ByLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIG9wdGlvblNwci5vd25lciA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25TcHIucGxheWVyID0gdGhpcy5wbGF5ZXI7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25TcHIuc2V0VXBkYXRlUGhhc2VDYWxsYmFjayggdGhpcy5vcHRpb25VcGRhdGUgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wdXNoKCBvcHRpb25TcHIgKTtcclxuICAgICAgICAgICAgICAgIG9wdGlvblNwci5vcHRpb25JbmRleCA9IHRoaXMub3B0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMub3B0aW9ucy5sZW5ndGggPT0gdGhpcy5tYXhPcHRpb24gKSB0aGlzLmlzQmFyRW1wdHlbdGhpcy5wb3dlcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdnNTdGFnZS53b3JsZC5sYXllcjIuYWRkQ2hpbGQoIG9wdGlvblNwciApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTogLy8g67O07Zi466eJXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCBzaGllbGQgPSB0aGlzLmNyZWF0ZVZzU3ByaXRlKCB7IGFjdGlvbjogMTMgfSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgc2hpZWxkLmxpZmUgPSAxMDA7XHJcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIHNoaWVsZC5wbGF5ZXJOdW1iZXIgPSB0aGlzLnBsYXllcjtcclxuICAgICAgICAgICAgICAgIHNoaWVsZC5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc2hpZWxkLm9uKCBcImhpdFwiLCggZSApPT57XHJcbiAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICAgICAgc2hpZWxkLmxpZmUgLT0gZS5kYW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzaGllbGQubGlmZSA8PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDsi6Trk5wg7YyM6rS0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWVsZC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0JhckVtcHR5WzVdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwicmVmcmVzaFVJXCIseyBwbGF5ZXI6IHRoaXMucGxheWVyIH0gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICAgICAgICBzaGllbGQuc2V0VXBkYXRlUGhhc2VDYWxsYmFjayggKCk9PntcclxuICAgICAgICAgICAgICAgICAgICBzaGllbGQud2hpdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0JhckVtcHR5W3RoaXMucG93ZXJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoIHNoaWVsZCApO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc2hpZWxkID0gc2hpZWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNjogLy8g6r2dXHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRQb3dlclVwKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvd2VyID0gLTE7XHJcbiAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJyZWZyZXNoVUlcIix7IHBsYXllcjogdGhpcy5wbGF5ZXIgfSApO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnYW1lT3ZlcigpIHtcclxuICAgIEdMT0JBTC5yZXN0Q29pbiA9IDA7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDE7IGkgPD0gMjsgaSsrICkge1xyXG4gICAgICAgIGlmICggR0xPQkFMLnBsYXllcnNbaV0gKSB7XHJcbiAgICAgICAgICAgIEdMT0JBTC5wbGF5ZXJzW2ldLnJlc3QgPSAwO1xyXG4gICAgICAgICAgICBHTE9CQUwucGxheWVyc1tpXS5kaXNwYXRjaEV2ZW50KCBuZXcgRXZlbnQoIFwiaGl0XCIseyBmb3JjZUhpdDogdHJ1ZSB9ICkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJyZWZyZXNoVUlcIix7IHBsYXllcjogaSB9ICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwYXduUGxheWVyKCBlICkge1xyXG4gICAgbGV0IHNwciA9IG5ldyBQbGF5ZXIoIGUgKTtcclxuXHJcbiAgICB2c1N0YWdlLndvcmxkLmxheWVyMy5hZGRDaGlsZCggc3ByICk7XHJcbiAgICBHTE9CQUwucGxheWVyc1tlLnBsYXllcl0gPSBzcHI7XHJcbn1cclxuXHJcbmFwcGxpY2F0aW9uLm9uKCBcImdhbWVPdmVyXCIsIGdhbWVPdmVyICk7XHJcbmFwcGxpY2F0aW9uLm9uKCBcInNwYXduOnBsYXllclwiLCBzcGF3blBsYXllciApO1xyXG4iLCJpbXBvcnQgeyBhcHBsaWNhdGlvbiwgUGl4ZWwsVXRpbHMsIFRpbWVyLCBFdmVudCwgS2V5Q29kZSwgU291bmQgfSBmcm9tIFwiQGVuZ2luZS9mbGF0ZmFzdFwiO1xyXG5pbXBvcnQgR0xPQkFMIGZyb20gXCIuL2dsb2JhbFwiO1xyXG5pbXBvcnQgeyB2c1N0YWdlLCBWc1BhbGV0dGUsVnNTcHJpdGUsVnNTeXN0ZW1UZXh0IH0gZnJvbSBcIi4vdnNXcmFwcGVyL3ZzXCI7XHJcblxyXG5jb25zdCBNQVhfU1RBUiA9IDQwOyBcclxuXHJcblxyXG5hc3luYyBmdW5jdGlvbiB0aXRsZSgpIHtcclxuICAgIGNvbnN0IHRpdGxlUGFsID0gbmV3IFZzUGFsZXR0ZSggXCJzdGFnZTFcIiApO1xyXG5cclxuICAgIHZzU3RhZ2Uuc2V0UGFsZXR0ZSggdGl0bGVQYWwgKTtcclxuICAgIHZzU3RhZ2Uuc2V0V29ybGQoIG51bGwgKTsgLy8gd29ybGQg64Kg66as6rOgXHJcbiAgICB2c1N0YWdlLmNsZWFyQ2hpbGRyZW4oKTtcclxuICAgIHZzU3RhZ2UuYmFja2dyb3VuZENvbG9yID0gMDsgLy8g67Cw6rK9IOuplOyLnCDsg53quYBcclxuXHJcbiAgICB7XHJcbiAgICAgICAgLy8gaW5pdCBzdGFyc1xyXG5cclxuICAgICAgICBjb25zdCBzdGFyQ29sb3JBcnJheSA9IFs3LDgsMTVdO1xyXG4gICAgXHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgTUFYX1NUQVI7IGkrKyApIHtcclxuICAgICAgICAgICAgbGV0IHggPSBVdGlscy5yYW5kb20oIDAsMjU5ICk7XHJcbiAgICAgICAgICAgIGxldCB5ID0gVXRpbHMucmFuZG9tKCAwLDE5OSApO1xyXG4gICAgICAgICAgICBsZXQgdnggPSBVdGlscy5yYW5kb20oIDEsMyApO1xyXG4gICAgICAgICAgICBsZXQgYyA9IHN0YXJDb2xvckFycmF5W1V0aWxzLnJhbmRvbSggMCwyICldO1xyXG4gICAgICAgICAgICBsZXQgcHggPSBuZXcgUGl4ZWwoIFZzUGFsZXR0ZS5pbmRleFRvQ29sb3IoIGMgKSwxICk7XHJcblxyXG4gICAgICAgICAgICBweC5zZXRTaGFkZXIoIHZzU3RhZ2UucGFsZXR0ZS5jcmVhdGVTaGFkZXIoKSApO1xyXG4gICAgICAgICAgICBweC54eSA9IFt4LHldO1xyXG4gICAgICAgICAgICBweC5vblN0YWdlKCBFdmVudC5FTlRFUl9GUkFNRSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBweC54IC09IHZ4O1xyXG4gICAgICAgICAgICAgICAgaWYgKCBweC54IDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBweC54ID0gMjYwICsgVXRpbHMucmFuZG9tKCAwLDI1OSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICAgIHZzU3RhZ2UuYWRkQ2hpbGQoIHB4ICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRpdGxlU3ByID0gbmV3IFZzU3ByaXRlKCBcImVmZmVjdFwiLHsgeDogMTI4LHk6IDQwLGFjdGlvbjogMiB9ICk7XHJcblxyXG4gICAgdnNTdGFnZS5hZGRDaGlsZCggdGl0bGVTcHIgKTtcclxuICAgIGNvbnN0IHRpdGxlU3ByMiA9IG5ldyBWc1Nwcml0ZSggXCJlZmZlY3RcIix7IHg6IDEyOCx5OiA0MCxhY3Rpb246IDUgfSApO1xyXG5cclxuICAgIHZzU3RhZ2UuYWRkQ2hpbGQoIHRpdGxlU3ByMiApO1xyXG5cclxuICAgIGxldCBjb2luID0gR0xPQkFMLnJlc3RDb2luID0gNDtcclxuICAgIGxldCB0ZXh0U3ByID0gbmV3IFZzU3lzdGVtVGV4dCgpO1xyXG5cclxuICAgIC8vIHQuc2V0Q29sb3IoIDE1ICk7XHJcbiAgICB0ZXh0U3ByLnNldFRleHQoIGAxUCBTVEFSVFxcblxcbjJQIFNUQVJUXFxuXFxuMVAgYW5kIDJQIFNUQVJUXFxuXFxuUkVQTEFZIElOVFJPXFxuXFxuRVhJVCBUTyBET1NcXG5cXG5cXG5DT05USU5VRSAke2NvaW59YCApO1xyXG4gICAgdGV4dFNwci54eSA9IFsgOTAsMTA1IF07XHJcbiAgICB2c1N0YWdlLmFkZENoaWxkKCB0ZXh0U3ByICk7XHJcblxyXG4gICAgLy8g7L6F7ZWY6rOgIOuyiOypjeqxsOumrOuKlCDtmqjqs7xcclxuICAgIHRpdGxlUGFsLmZhZGUoIHsgc3RhcnQ6IDEsZW5kOiAwLCBkdXJhdGlvbjogNjAsIHJhbmdlOiBbMCwyNTRdIH0gKTtcclxuICAgIC8vIFNvdW5kLnBsYXlTb3VuZCggYGJhbmcud2F2YCApO1xyXG4gICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJiZ21cIix7IGZpbGVuYW1lOiBcInRpdGxlXCIgfSApO1xyXG5cclxuICAgIGNvbnN0IHBsYXllclNwckZpbGVzID0gW1wicF9oYWxcIixcInBfY3J5c1wiXTtcclxuICAgIGNvbnN0IHNlbGVjdG9yU3ByID0gbmV3IFZzU3ByaXRlKCBwbGF5ZXJTcHJGaWxlc1tVdGlscy5yYW5kb20oIDAsMSApXSx7IHg6IDc1LHk6IDEwOCxhY3Rpb246IDAgfSApO1xyXG5cclxuICAgIHZzU3RhZ2UuYWRkQ2hpbGQoIHNlbGVjdG9yU3ByICk7XHJcbiAgICBsZXQgc2VsZWN0b3IgPSAwO1xyXG4gICAgbGV0IGRlbW9UaW1lciA9IFRpbWVyLmRlbGF5ZWRDYWxsKCAxNSAqIDEwMDAsKCk9PntcclxuICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcIm1vZGU6aW50cm9cIiApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIHNlbGVjdG9yU3ByLm9uKCBFdmVudC5SRU1PVkVEX0ZST01fU1RBR0UsICgpID0+IHtcclxuICAgICAgICBkZW1vVGltZXIuc3RvcCgpO1xyXG4gICAgfSApO1xyXG5cclxuICAgIHNlbGVjdG9yU3ByLm9uKCBFdmVudC5LRVlfRE9XTiwgYXN5bmMgKCBlICk9PntcclxuICAgICAgICBpZiAoIGUua2V5Q29kZSA9PSBLZXlDb2RlLlVQICYmIHNlbGVjdG9yID4gMCApIHtcclxuICAgICAgICAgICAgc2VsZWN0b3ItLTtcclxuICAgICAgICAgICAgU291bmQucGxheVNvdW5kKCBgemFrby53YXZgICk7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yU3ByLnkgPSAxMDggKyAxNiAqIHNlbGVjdG9yO1xyXG4gICAgICAgICAgICBkZW1vVGltZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICBkZW1vVGltZXIuc3RhcnQoKTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBlLmtleUNvZGUgPT0gS2V5Q29kZS5ET1dOICYmIHNlbGVjdG9yIDwgNCApIHtcclxuICAgICAgICAgICAgc2VsZWN0b3IrKztcclxuICAgICAgICAgICAgU291bmQucGxheVNvdW5kKCBgemFrby53YXZgICk7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yU3ByLnkgPSAxMDggKyAxNiAqIHNlbGVjdG9yO1xyXG4gICAgICAgICAgICBkZW1vVGltZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICBkZW1vVGltZXIuc3RhcnQoKTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBlLmtleUNvZGUgPT0gS2V5Q29kZS5FTlRFUiB8fCBlLmtleUNvZGUgPT0gS2V5Q29kZS5TUEFDRSB8fCBlLmtleUNvZGUgPT0gS2V5Q29kZS5OICkge1xyXG4gICAgICAgICAgICBTb3VuZC5wbGF5U291bmQoIGBpdGVtLndhdmAgKTtcclxuICAgICAgICAgICAgZGVtb1RpbWVyLnN0b3AoKTtcclxuICAgICAgICAgICAgdGV4dFNwci5yZW1vdmVGcm9tUGFyZW50KCk7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yU3ByLnJlbW92ZUZyb21QYXJlbnQoKTtcclxuICAgICAgICAgICAgaWYgKCBzZWxlY3RvciA9PSAzICkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIG5ldyBFdmVudCggXCJtb2RlOmludHJvXCIseyBlbmRpbmdGbGFnOiBmYWxzZSB9ICkgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNlbGVjdG9yID09IDQgKSB7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggbmV3IEV2ZW50KCBcImRpYWxvZ1wiLHsgbXNnOiBcImV4aXRcIiB9ICkgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBnYW1lU2V0dGluZyA9IHsgY29pbjogY29pbiB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggc2VsZWN0b3IgPT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBuZXcgRXZlbnQoIFwiZGlhbG9nXCIseyBtc2c6IFwiMXBcIiB9ICkgKTtcclxuICAgICAgICAgICAgICAgICAgICBnYW1lU2V0dGluZy5wbGF5ZXIxID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNlbGVjdG9yID09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggbmV3IEV2ZW50KCBcImRpYWxvZ1wiLHsgbXNnOiBcIjJwXCIgfSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZVNldHRpbmcucGxheWVyMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzZWxlY3RvciA9PSAyICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIG5ldyBFdmVudCggXCJkaWFsb2dcIix7IG1zZzogXCIxcDJwXCIgfSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZVNldHRpbmcucGxheWVyMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZVNldHRpbmcucGxheWVyMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBUaW1lci53YWl0RnJhbWUoIDIwMCApO1xyXG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJtb2RlOmdhbWVMb29wXCIsZ2FtZVNldHRpbmcgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gKTtcclxufVxyXG5cclxuYXBwbGljYXRpb24ub24oIFwibW9kZTp0aXRsZVwiLHRpdGxlICk7XHJcbiIsImltcG9ydCB7IFNwaW5lLCBDb21wb25lbnQsIENvbXBvbmVudEhvbGRlciwgU2NlbmVNYW5hZ2VyLCBTZXJpYWxpemVyLCBTdG9yYWdlLCBUd2VlbiwgRm9udCwgUG9pbnQsIFJlY3QsIFRpbGVNYXAsTW92aWVDbGlwLFJlbmRlclRhcmdldCwgUGl4ZWwsZWFzaW5nLCBNZXNoLCBUZXh0dXJlUGFjaywgVXRpbHMsIE1hdHJpeCwgU2hhcGUsIFRpbWVyLCBUZXh0RmllbGQsIEV2ZW50LCBLZXlDb2RlLCBFdmVudERpc3BhdGNoZXIsXHJcbiAgICAgICAgIFNwcml0ZSwgU3RhZ2UsIEJpdG1hcCwgVGV4dHVyZSwgVGV4dHVyZUJhc2UsIEFwcGxpY2F0aW9uLCBTaGFkZXIsIFNvdW5kIH0gZnJvbSBcIkBlbmdpbmUvZmxhdGZhc3RcIjtcclxuXHJcblxyXG5pbXBvcnQgVnNQYWxldHRlIGZyb20gXCIuL3ZzUGFsZXR0ZVwiO1xyXG5pbXBvcnQgVnNXb3JsZCBmcm9tIFwiLi92c1dvcmxkXCI7XHJcbmltcG9ydCBWc1Nwcml0ZSBmcm9tIFwiLi92c1Nwcml0ZVwiO1xyXG5pbXBvcnQgVnNTeXN0ZW1UZXh0IGZyb20gXCIuL3ZzU3lzdGVtVGV4dFwiO1xyXG5pbXBvcnQgVnNIYW5ndWwgZnJvbSBcIi4vdnNIYW5ndWxcIjtcclxuaW1wb3J0IFZzU3RhZ2UgZnJvbSBcIi4vdnNTdGFnZVwiO1xyXG5pbXBvcnQgVnNQYWQgZnJvbSBcIi4vdnNQYWRcIjtcclxuXHJcblxyXG5leHBvcnQgeyBWc1BhZCB9O1xyXG5leHBvcnQgeyBWc1BhbGV0dGUgfTtcclxuZXhwb3J0IHsgVnNXb3JsZCB9O1xyXG5leHBvcnQgeyBWc1Nwcml0ZSB9O1xyXG5leHBvcnQgeyBWc1N5c3RlbVRleHQgfTtcclxuZXhwb3J0IHsgVnNIYW5ndWwgfTtcclxuZXhwb3J0IHsgVnNTdGFnZSB9O1xyXG5cclxuY29uc3QgdnNTdGFnZSA9IFZzU3RhZ2UuaW5zdGFuY2U7XHJcblxyXG5leHBvcnQgeyB2c1N0YWdlIH07XHJcblxyXG5pbXBvcnQgKiBhcyBteXNlbGYgZnJvbSBcIi4vdnNcIjtcclxuZXhwb3J0IGRlZmF1bHQgbXlzZWxmO1xyXG5cclxuIiwiaW1wb3J0IHsgU3BpbmUsIENvbXBvbmVudCwgQ29tcG9uZW50SG9sZGVyLCBTY2VuZU1hbmFnZXIsIFN0b3JhZ2UsIFR3ZWVuLCBGb250LCBQb2ludCwgUmVjdCwgVGlsZU1hcCxNb3ZpZUNsaXAsUmVuZGVyVGFyZ2V0LCBQaXhlbCxlYXNpbmcsIE1lc2gsIFRleHR1cmVQYWNrLCBVdGlscywgTWF0cml4LCBTaGFwZSwgVGltZXIsIFRleHRGaWVsZCwgRXZlbnQsIEtleUNvZGUsIEV2ZW50RGlzcGF0Y2hlcixcclxuICAgICAgICAgU3ByaXRlLCBTdGFnZSwgQml0bWFwLCBUZXh0dXJlLCBUZXh0dXJlQmFzZSwgQXBwbGljYXRpb24sIFNoYWRlciwgU291bmQgfSBmcm9tIFwiQGVuZ2luZS9mbGF0ZmFzdFwiO1xyXG5cclxuaW1wb3J0IFZzU3RhZ2UgZnJvbSBcIi4vdnNTdGFnZVwiO1xyXG5pbXBvcnQgVnNQYWxldHRlIGZyb20gXCIuL3ZzUGFsZXR0ZVwiO1xyXG5cclxuLy8gVE9ETzog7Jm46rO97ISgIOyymOumrCDtlbTslbztlahcclxuXHJcbmNvbnN0IHdpZHRoVGFibGUgPSB7XHJcbiAgICBcIklcIjogNSxcclxuICAgIFwiSlwiOiA2LFxyXG4gICAgXCJpXCI6IDUsXHJcbiAgICBcImpcIjogNixcclxuICAgIFwibFwiOiA1LFxyXG4gICAgXCJ8XCI6IDQsXHJcbiAgICBcIntcIjogNixcclxuICAgIFwifVwiOiA1LFxyXG59O1xyXG5cclxuLy8gNiDrsJTsnbTtirjslKkg7J247L2U65SpIHgseSx3LGgsc3gsc3lcclxuLy8g7ZWc6riA7J2AIO2ajOyghOydtCDsl4bslrTshJwgNuqwnOuptCDrkKhcclxuLy8g7JiB7Ja0IDk17J6QXHJcbmNvbnN0IGhhbmd1bEZvbnRGcmFtZXMgPSBuZXcgVWludDhBcnJheSggW1xyXG4gICAgNDAsNDMsMiwxMiwyLDEsMjA4LDY1LDQsNCwyLDAsMjAsMTUsOCwxMiwwLDAsMCwzMCw4LDE0LDAsMCwyNDAsMCw4LDEwLDAsMiwzMSwwLDgsMTIsMCwwLDE5Niw3MiwyLDQsMywwLDE4LDMwLDQsMTQsMiwwLDIzLDU4LDQsMTQsMiwwLDIyLDczLDgsOCwwLDIsNDEsMTMsOCwxMCwwLDEsMTk5LDcyLDIsNCwzLDEwLDExNiw1MSw4LDIsMCw1LDcyLDcwLDIsMiwyLDEyLDI0OSwwLDYsMTAsMSwyLDE4LDQ1LDYsMTIsMSwwLDI5LDE1LDYsMTIsMSwwLDk1LDEzLDYsMTIsMSwwLDEwMiwxMyw2LDEyLDEsMCwwLDYwLDgsMTIsMCwwLDEwOSwxMyw2LDEyLDEsMCwxMTYsMTMsNiwxMiwxLDAsMTIzLDEzLDYsMTIsMSwwLDEzMCwxMyw2LDEyLDEsMCwxMzcsMTMsNiwxMiwxLDAsMjI4LDEzLDIsMTAsMiwxLDIyOCwyNCwyLDEwLDIsMiwxNDQsMTMsNiwxMiwxLDAsMTI1LDUxLDgsNCwwLDQsMTUxLDEzLDYsMTIsMSwwLDE1OCwxMyw2LDEyLDEsMSw0MCwwLDgsMTIsMCwwLDE2NSwxMyw2LDEyLDEsMCw5LDQ1LDgsMTIsMCwwLDE3MiwxMyw2LDEyLDEsMCw0OSwwLDgsMTIsMCwwLDU4LDAsOCwxMiwwLDAsNjcsMCw4LDEyLDAsMCwxNzksMTMsNiwxMiwxLDAsNzYsMCw4LDEyLDAsMCw0MywzNyw0LDEyLDAsMCw5LDU4LDYsMTQsMCwwLDg1LDAsOCwxMiwwLDAsOTQsMCw4LDEyLDAsMCwxMDMsMCw4LDEyLDAsMCwxMTIsMCw4LDEyLDAsMCwxMjEsMCw4LDEyLDAsMCwxMzAsMCw4LDEyLDAsMCwxMzksMCw4LDEyLDAsMSwxNDgsMCw4LDEyLDAsMCwxODYsMTMsNiwxMiwxLDAsMTU3LDAsOCwxMiwwLDAsMTY2LDAsOCwxMiwwLDAsMTkzLDEzLDYsMTIsMSwwLDE3NSwwLDgsMTIsMCwwLDE4NCwwLDgsMTIsMCwwLDE5MywwLDgsMTIsMCwwLDIwMiwwLDgsMTIsMCwwLDUwLDI0LDQsMTIsMiwwLDIwMCwxMyw2LDEyLDEsMCw0OCwzNyw0LDEyLDIsMCw1NCw1MCw2LDQsMSwwLDE1MSw1OCw4LDIsMCwxMiwxOTYsNzcsMiw0LDMsMCwyMjEsMjYsNiw4LDEsNCwyMDcsMTMsNiwxMiwwLDAsMTYxLDM1LDYsOCwxLDQsMjE0LDEzLDYsMTIsMSwwLDE2OCwzNSw2LDgsMSw0LDIyMSwxMyw2LDEyLDEsMCw0MywyNCw2LDEyLDEsMiwyMTEsMCw4LDEyLDAsMCw1NSwyNCw0LDEyLDAsMCwyMywyOCw0LDE0LDAsMCwyMjAsMCw4LDEyLDAsMCw1MywzNyw0LDEyLDAsMCwzMSw3Myw4LDgsMCw0LDQwLDczLDgsOCwwLDQsMTc1LDM1LDYsOCwxLDQsNjAsMjQsNiwxMCwwLDQsNjcsMjQsNiwxMCwxLDQsMTgyLDM1LDYsOCwwLDQsMTg5LDM1LDYsOCwxLDQsNzQsMjQsNiwxMCwwLDIsODEsMjQsOCw4LDAsNCwxOTYsMzUsNiw4LDEsNCw5NSwyNiw4LDgsMCw0LDEwNCwyNiw4LDgsMCw0LDUwLDEzLDgsMTAsMCw0LDIwMywzNSw2LDgsMSw0LDI1LDQzLDQsMTQsMCwwLDU4LDM3LDIsMTIsMCwwLDI4LDU4LDQsMTQsMCwwLDEzNCw1MSw4LDQsMCw1LDU5LDEzLDgsMTAsMCwxLDYxLDM1LDYsMTAsMCwwLDY4LDM1LDYsMTAsMCwwLDc1LDM1LDYsMTAsMCwwLDgyLDMzLDYsMTAsMCwwLDIxMCwzNSw2LDEwLDAsMCwyMTcsMzUsNiwxMCwwLDAsMjI0LDM1LDYsMTAsMCwwLDIzMSwxMSw2LDEwLDAsMCwyMzEsMjIsNiwxMCwwLDAsMjM4LDExLDYsMTAsMCwwLDIzMSwzMyw2LDEwLDAsMCwyMzgsMjIsNiwxMCwwLDAsMjQ1LDExLDYsMTAsMCwwLDIzOCwzMyw2LDEwLDAsMCwyNDUsMjIsNiwxMCwwLDAsMjQ1LDMzLDYsMTAsMCwwLDI0OSw0NCw2LDEwLDAsMCwyNDIsNTEsNiwxMCwwLDAsNDEsNjIsNiwxMCwwLDAsMjMsNDMsMSwxLDAsMCwxMTMsMjYsOCw4LDAsMCwxMjIsMjYsOCw4LDAsMCwxMzEsMjYsOCw4LDAsMCwxNDAsMjYsOCw4LDAsMCwxNDksMjYsOCw4LDAsMCwxNTgsMjYsOCw4LDAsMCwxNjcsMjYsOCw4LDAsMCwxNzYsMjYsOCw4LDAsMCwxODUsMjYsOCw4LDAsMCwxOTQsMjYsOCw4LDAsMCwyMDMsMjYsOCw4LDAsMCwyMTIsMjYsOCw4LDAsMCw4OSwzNSw4LDgsMCwwLDk4LDM1LDgsOCwwLDAsMTA3LDM1LDgsOCwwLDAsMTE2LDM1LDgsOCwwLDAsMTI1LDM1LDgsOCwwLDAsMTM0LDM1LDgsOCwwLDAsMTQzLDM1LDgsOCwwLDAsMjMsNDMsMSwxLDAsMCwxMTMsMjYsOCw4LDAsMCwxMjIsMjYsOCw4LDAsMCwxMzEsMjYsOCw4LDAsMCwxNDAsMjYsOCw4LDAsMCwxNDksMjYsOCw4LDAsMCwxNTgsMjYsOCw4LDAsMCwxNjcsMjYsOCw4LDAsMCwxNzYsMjYsOCw4LDAsMCwxODUsMjYsOCw4LDAsMCwxOTQsMjYsOCw4LDAsMCwyMDMsMjYsOCw4LDAsMCwyMTIsMjYsOCw4LDAsMCw4OSwzNSw4LDgsMCwwLDk4LDM1LDgsOCwwLDAsMTA3LDM1LDgsOCwwLDAsMTE2LDM1LDgsOCwwLDAsMTI1LDM1LDgsOCwwLDAsMTM0LDM1LDgsOCwwLDAsMTQzLDM1LDgsOCwwLDAsMjMsNDMsMSwxLDAsMCw0OSw3Myw2LDgsMCwwLDU2LDczLDYsOCwwLDAsNjMsNzMsNiw4LDAsMCw3Miw2MSw2LDgsMCwwLDc5LDYxLDYsOCwwLDAsODYsNjEsNiw4LDAsMCw5Myw2MSw2LDgsMCwwLDEwMCw2MSw2LDgsMCwwLDEwNyw2MSw2LDgsMCwwLDExNCw2MSw2LDgsMCwwLDI0OSw1NSw2LDgsMCwwLDEyNCw2Myw2LDgsMCwwLDEzMSw2Myw2LDgsMCwwLDEzOCw2Myw2LDgsMCwwLDE0NSw2Myw2LDgsMCwwLDE1Miw2MSw2LDgsMCwwLDIxNCw1OCw2LDgsMCwwLDIyMSw1OCw2LDgsMCwwLDIyOCw1OCw2LDgsMCwwLDIzLDQzLDEsMSwwLDAsNDksNzMsNiw4LDAsMCw1Niw3Myw2LDgsMCwwLDYzLDczLDYsOCwwLDAsNzIsNjEsNiw4LDAsMCw3OSw2MSw2LDgsMCwwLDg2LDYxLDYsOCwwLDAsOTMsNjEsNiw4LDAsMCwxMDAsNjEsNiw4LDAsMCwxMDcsNjEsNiw4LDAsMCwxMTQsNjEsNiw4LDAsMCwyNDksNTUsNiw4LDAsMCwxMjQsNjMsNiw4LDAsMCwxMzEsNjMsNiw4LDAsMCwxMzgsNjMsNiw4LDAsMCwxNDUsNjMsNiw4LDAsMCwxNTIsNjEsNiw4LDAsMCwyMTQsNTgsNiw4LDAsMCwyMjEsNTgsNiw4LDAsMCwyMjgsNTgsNiw4LDAsMCwyMyw0MywxLDEsMCwwLDIzNSw1OCw2LDgsMCwwLDI0Miw2Miw2LDgsMCwwLDI0OSw2NCw2LDgsMCwwLDcwLDczLDYsOCwwLDAsNzcsNzMsNiw4LDAsMCw4Niw2MSw2LDgsMCwwLDg0LDczLDYsOCwwLDAsOTEsNzMsNiw4LDAsMCw5OCw3Myw2LDgsMCwwLDEwNSw3Myw2LDgsMCwwLDI0OSw1NSw2LDgsMCwwLDExMiw3Myw2LDgsMCwwLDExOSw3Myw2LDgsMCwwLDEyNiw3Myw2LDgsMCwwLDEzMyw3Myw2LDgsMCwwLDE0MCw3Myw2LDgsMCwwLDIxNCw1OCw2LDgsMCwwLDE0Nyw3Myw2LDgsMCwwLDIyOCw1OCw2LDgsMCwwLDIzLDQzLDEsMSwwLDAsODMsNDQsOCw2LDAsMCw5Miw0NCw4LDYsMCwwLDEwMSw0NCw4LDYsMCwwLDExMCw0NCw4LDYsMCwwLDExOSw0NCw4LDYsMCwwLDEyOCw0NCw4LDYsMCwwLDEzNyw0NCw4LDYsMCwwLDE0Niw0NCw4LDYsMCwwLDE1NSw0NCw4LDYsMCwwLDE2NCw0NCw4LDYsMCwwLDE3Myw0NCw4LDYsMCwwLDE4Miw0NCw4LDYsMCwwLDE5MSw0NCw4LDYsMCwwLDIwMCw0NCw4LDYsMCwwLDIzMSw0NCw4LDYsMCwwLDI0MCw0NCw4LDYsMCwwLDE0Myw1MSw4LDYsMCwwLDE1Miw1MSw4LDYsMCwwLDE2MSw1MSw4LDYsMCwwLDIzLDQzLDEsMSwwLDAsMTU5LDY1LDYsNiwwLDAsMTY2LDY1LDYsNiwwLDAsMTczLDY1LDYsNiwwLDAsMTgwLDY1LDYsNiwwLDAsMTg3LDY1LDYsNiwwLDAsMTk0LDY1LDYsNiwwLDAsMjAxLDY1LDYsNiwwLDAsMjEzLDY3LDYsNiwwLDAsMjIwLDY3LDYsNiwwLDAsMjI3LDY3LDYsNiwwLDAsMjM0LDY3LDYsNiwwLDAsMjQxLDcxLDYsNiwwLDAsMjQ4LDczLDYsNiwwLDAsMTU0LDcyLDYsNiwwLDAsMTYxLDcyLDYsNiwwLDAsMTY4LDcyLDYsNiwwLDAsMTc1LDcyLDYsNiwwLDAsMTgyLDcyLDYsNiwwLDAsMTg5LDcyLDYsNiwwLDAsMjMsNDMsMSwxLDAsMCwyOCwyOCw0LDE0LDYsMCwzMCw0Myw0LDE0LDUsMCwzMyw1OCw0LDE0LDYsMCwzMywyOCw0LDE0LDUsMCwzNSw0Myw0LDE0LDQsMCwzNiwxMyw0LDE0LDUsMCwzOCwyOCw0LDE0LDQsMCwxNiw1OCw2LDE0LDMsMCw0Myw1MCwxMCw0LDAsMTAsMCwwLDEwLDE0LDAsMCwwLDE1LDEwLDE0LDAsMCwxMSwxNSw4LDE0LDAsMCw2MSw0NiwxMCw0LDAsMTAsNzIsNDYsMTAsNCwwLDEwLDIyLDAsOCwxNCwwLDAsMTEsMCwxMCwxNCwwLDAsMCw0NSw4LDE0LDAsMCwyMDksNDYsMTAsNCwwLDEwLDYxLDUxLDEwLDIsMCwxMiw5LDMwLDgsMTQsMCwwLDM4LDU4LDIsMTQsNiwwLDIzLDQzLDEsMSwwLDAsMjgsMjgsNCwxNCw2LDAsMzAsNDMsNCwxNCw1LDAsMzMsNTgsNCwxNCw2LDAsMzMsMjgsNCwxNCw1LDAsMzUsNDMsNCwxNCw0LDAsMzYsMTMsNCwxNCw1LDAsMzgsMjgsNCwxNCw0LDAsMTYsNTgsNiwxNCwzLDAsNDMsNTAsMTAsNCwwLDEwLDAsMCwxMCwxNCwwLDAsMCwxNSwxMCwxNCwwLDAsMTEsMTUsOCwxNCwwLDAsNjEsNDYsMTAsNCwwLDEwLDcyLDQ2LDEwLDQsMCwxMCwyMiwwLDgsMTQsMCwwLDExLDAsMTAsMTQsMCwwLDAsNDUsOCwxNCwwLDAsMjA5LDQ2LDEwLDQsMCwxMCw2MSw1MSwxMCwyLDAsMTIsOSwzMCw4LDE0LDAsMCwzOCw1OCwyLDE0LDYsMCwyMyw0MywxLDEsMCwwLDkwLDI0LDQsMTAsNiwwLDI1MiwxMSw0LDEwLDUsMCwyNTIsMjIsNCwxMCw2LDAsMjUyLDMzLDQsMTAsNSwwLDQ4LDYyLDQsMTAsNCwwLDUzLDYyLDYsMTAsMywwLDYwLDYyLDQsMTAsNCwwLDY1LDYxLDYsMTAsMywwLDcyLDUxLDEwLDIsMCw2LDAsNzMsMTAsOCwwLDAsMTEsNzMsMTAsOCwwLDAsMTUyLDM1LDgsOCwwLDAsODMsNTEsMTAsMiwwLDYsOTQsNTEsMTAsMiwwLDcsNjgsMTMsOCwxMCwwLDAsMjI5LDAsMTAsMTAsMCwwLDc3LDEzLDgsMTAsMCwwLDEwNSw1MSwxMCwyLDAsNyw2MSw1MSwxMCwyLDAsNiw4NiwxMyw4LDEwLDAsMCwxMjEsNjEsMiwxMCw2LDAsMjMsNDMsMSwxLDAsMCw5MCwyNCw0LDEwLDYsMCwyNTIsMTEsNCwxMCw1LDAsMjUyLDIyLDQsMTAsNiwwLDI1MiwzMyw0LDEwLDUsMCw0OCw2Miw0LDEwLDQsMCw1Myw2Miw2LDEwLDMsMCw2MCw2Miw0LDEwLDQsMCw2NSw2MSw2LDEwLDMsMCw3Miw1MSwxMCwyLDAsNiwwLDczLDEwLDgsMCwwLDExLDczLDEwLDgsMCwwLDE1MiwzNSw4LDgsMCwwLDgzLDUxLDEwLDIsMCw2LDk0LDUxLDEwLDIsMCw3LDY4LDEzLDgsMTAsMCwwLDIyOSwwLDEwLDEwLDAsMCw3NywxMyw4LDEwLDAsMCwxMDUsNTEsMTAsMiwwLDcsNjEsNTEsMTAsMiwwLDYsODYsMTMsOCwxMCwwLDAsMTIxLDYxLDIsMTAsNiwwLDIzLDQzLDEsMSwwLDAsMTcwLDUxLDgsNiwwLDgsMTc5LDUxLDgsNiwwLDgsMTg4LDUxLDgsNiwwLDgsMTk3LDUxLDgsNiwwLDgsMjA2LDUxLDgsNiwwLDgsMjE1LDUxLDgsNiwwLDgsMjI0LDUxLDgsNiwwLDgsMjMzLDUxLDgsNiwwLDgsNDMsNTUsOCw2LDAsOCw1Miw1NSw4LDYsMCw4LDYxLDU0LDgsNiwwLDgsNzAsNTQsOCw2LDAsOCw3OSw1NCw4LDYsMCw4LDg4LDU0LDgsNiwwLDgsOTcsNTQsOCw2LDAsOCwxMDYsNTQsOCw2LDAsOCwxMTUsNTQsOCw2LDAsOCwxMjQsNTYsOCw2LDAsOCwxNDIsNTgsOCw0LDAsMTAsMjIwLDQ2LDEwLDQsMCwxMCwxMzMsNTYsOCw2LDAsOCwxNjAsNTgsOCw2LDAsOCwxNjksNTgsOCw2LDAsOCwxNzgsNTgsOCw2LDAsOCwxODcsNTgsOCw2LDAsOCwxOTYsNTgsOCw2LDAsOCwyMDUsNTgsOCw2LDAsOCwyMyw0MywxLDEsMCwwLDE3MCw1MSw4LDYsMCw4LDE3OSw1MSw4LDYsMCw4LDE4OCw1MSw4LDYsMCw4LDE5Nyw1MSw4LDYsMCw4LDIwNiw1MSw4LDYsMCw4LDIxNSw1MSw4LDYsMCw4LDIyNCw1MSw4LDYsMCw4LDIzMyw1MSw4LDYsMCw4LDQzLDU1LDgsNiwwLDgsNTIsNTUsOCw2LDAsOCw2MSw1NCw4LDYsMCw4LDcwLDU0LDgsNiwwLDgsNzksNTQsOCw2LDAsOCw4OCw1NCw4LDYsMCw4LDk3LDU0LDgsNiwwLDgsMTA2LDU0LDgsNiwwLDgsMTE1LDU0LDgsNiwwLDgsMTI0LDU2LDgsNiwwLDgsMTQyLDU4LDgsNCwwLDEwLDIyMCw0NiwxMCw0LDAsMTAsMTMzLDU2LDgsNiwwLDgsMTYwLDU4LDgsNiwwLDgsMTY5LDU4LDgsNiwwLDgsMTc4LDU4LDgsNiwwLDgsMTg3LDU4LDgsNiwwLDgsMTk2LDU4LDgsNiwwLDgsMjA1LDU4LDgsNiwwLDgsMjMsNDMsMSwxLDAsMCwxNzAsNTEsOCw2LDEsOCwxNzksNTEsOCw2LDEsOCwxODgsNTEsOCw2LDEsOCwxOTcsNTEsOCw2LDEsOCwyMDYsNTEsOCw2LDEsOCwyMTUsNTEsOCw2LDEsOCwyMjQsNTEsOCw2LDEsOCwyMzMsNTEsOCw2LDEsOCw0Myw1NSw4LDYsMSw4LDUyLDU1LDgsNiwxLDgsNjEsNTQsOCw2LDEsOCw3MCw1NCw4LDYsMSw4LDc5LDU0LDgsNiwxLDgsODgsNTQsOCw2LDEsOCw5Nyw1NCw4LDYsMSw4LDEwNiw1NCw4LDYsMSw4LDExNSw1NCw4LDYsMSw4LDEyNCw1Niw4LDYsMSw4LDE0Miw1OCw4LDQsMSwxMCwyMjAsNDYsMTAsNCwwLDEwLDEzMyw1Niw4LDYsMSw4LDE2MCw1OCw4LDYsMSw4LDE2OSw1OCw4LDYsMSw4LDE3OCw1OCw4LDYsMSw4LDE4Nyw1OCw4LDYsMSw4LDE5Niw1OCw4LDYsMSw4LDIwNSw1OCw4LDYsMSw4LDIzLDQzLDEsMSwwLDAsMTcwLDUxLDgsNiwwLDgsMTc5LDUxLDgsNiwwLDgsMTg4LDUxLDgsNiwwLDgsMTk3LDUxLDgsNiwwLDgsMjA2LDUxLDgsNiwwLDgsMjE1LDUxLDgsNiwwLDgsMjI0LDUxLDgsNiwwLDgsMjMzLDUxLDgsNiwwLDgsNDMsNTUsOCw2LDAsOCw1Miw1NSw4LDYsMCw4LDYxLDU0LDgsNiwwLDgsNzAsNTQsOCw2LDAsOCw3OSw1NCw4LDYsMCw4LDg4LDU0LDgsNiwwLDgsOTcsNTQsOCw2LDAsOCwxMDYsNTQsOCw2LDAsOCwxMTUsNTQsOCw2LDAsOCwxMjQsNTYsOCw2LDAsOCwxNDIsNTgsOCw0LDAsMTAsMjIwLDQ2LDEwLDQsMCwxMCwxMzMsNTYsOCw2LDAsOCwxNjAsNTgsOCw2LDAsOCwxNjksNTgsOCw2LDAsOCwxNzgsNTgsOCw2LDAsOCwxODcsNTgsOCw2LDAsOCwxOTYsNTgsOCw2LDAsOCwyMDUsNTgsOCw2LDAsOFxyXG5dICk7XHJcblxyXG5jb25zdCBoYW5ndWxGb250SW1hZ2UgPSBuZXcgVGV4dHVyZSggYGhhbmd1bGZvbnQucG5nYCApO1xyXG5cclxuXHJcbi8vIO2VnOq4gCDrjbDsnbTthLAg66eM65Ok6riwXHJcbmNvbnN0IGNob3N1bmdUYWJsZSA9IG5ldyBVaW50OEFycmF5KCBbXHJcbiAgICAvLyDsooXshLHsnbQg7JeG7J2EIOuVjCDspJHshLEg67OA7ZmYIO2FjOydtOu4lFxyXG4gICAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMSwgMSxcclxuICAgIC8vIOyiheyEseydtCDsnojsnYQg65WMIOykkeyEsSDrs4DtmZgg7YWM7J2067iUXHJcbiAgICAyLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAzLCAyLCAzLCAzLCAzXHJcbl0gKTtcclxuXHJcbmNvbnN0IGpvb25nc3VuZ1RhYmxlID0gbmV3IFVpbnQ4QXJyYXkoIFtcclxuICAgIC8vIOyiheyEsSDrs4DtmZgg7YWM7J2067iUXHJcbiAgICAwLCAyLCAwLCAyLCAxLCAyLCAxLCAyLCAzLCAwLCAyLCAxLCAzLCAzLCAxLCAyLCAxLCAzLCAzLCAxLCAxLFxyXG4gICAgLy8g7KKF7ISx7J20IOyXhuydhCDrlYwg7LSI7ISxIOuzgO2ZmCDthYzsnbTruJRcclxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDMsIDMsIDMsIDEsIDIsIDQsIDQsIDQsIDIsIDEsIDMsIDAsXHJcbiAgICAvLyDsooXshLHsnbQg7J6I7J2EIOuVjCDstIjshLEg67OA7ZmYIO2FjOydtOu4lFxyXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSwgNSwgNiwgNywgNywgNywgNiwgNiwgNywgNywgNywgNiwgNiwgNywgNVxyXG5dICk7XHJcblxyXG5jb25zdCBjb252Q2hvc3VuZyA9IG5ldyBVaW50OEFycmF5KCBbXHJcbiAgICAvL+OEsSzjhLIs44SzLOOEtCzjhLUs44S2LOOEtyzjhLgs44S5LOOEuizjhLss44S8LOOEvSzjhL4s44S/LOOFgCzjhYEs44WCLOOFgyzjhYQs44WFLOOFhizjhYcs44WILOOFiSzjhYos44WLLOOFjCzjhY0s44WOXHJcbiAgICAwLCAxLCAwLCAyLCAyLCAyLCAzLCA0LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA1LCA2LCA3LCA4LCA3LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4XHJcbl0gKTtcclxuXHJcbmNvbnN0IElOREVYX0NIT1NVTkcgPSA5NTtcclxuY29uc3QgSU5ERVhfSk9PTkdTVU5HID0gKCBJTkRFWF9DSE9TVU5HICsgMTYwICk7XHJcbmNvbnN0IElOREVYX0pPTkdTVU5HID0gKCBJTkRFWF9KT09OR1NVTkcgKyA4NyApO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZzSGFuZ3VsIGV4dGVuZHMgTWVzaCB7XHJcbiAgICAvKipcclxuICAgICAqQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBWc0hhbmd1bEZvbnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNcclxuICAgICAqIEBtZW1iZXJvZiBWc0hhbmd1bEZvbnRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoIHMgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9jb2xvcjEgPSAweDAwZjAwMDtcclxuICAgICAgICB0aGlzLl9jb2xvcjIgPSAweDAwZjAwMDtcclxuICAgICAgICB0aGlzLnNldFRleHR1cmUoIGhhbmd1bEZvbnRJbWFnZSApO1xyXG4gICAgICAgIGlmICggcyApIHRoaXMuc2V0VGV4dCggcyApO1xyXG4gICAgICAgIHRoaXMub25jZSggRXZlbnQuQURERURfVE9fU1RBR0UsKCk9PntcclxuICAgICAgICAgICAgdGhpcy5zZXRQYWxldHRlKCBWc1N0YWdlLmluc3RhbmNlLnBhbGV0dGUgKTtcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGFsZXR0ZSggcGFsICkge1xyXG4gICAgICAgIGxldCBzaCA9IHBhbC5jcmVhdGVTaGFkZXIoIGhhbmd1bEZvbnRJbWFnZSApO1xyXG5cclxuICAgICAgICB0aGlzLnNldFNoYWRlciggc2ggKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBpbmRleDJcclxuICAgICAqIEBtZW1iZXJvZiBWc0hhbmd1bFxyXG4gICAgICovXHJcbiAgICBzZXRDb2xvciggaW5kZXgxLCBpbmRleDIgKSB7XHJcbiAgICAgICAgdGhpcy5fY29sb3IxID0gVnNQYWxldHRlLmluZGV4VG9Db2xvciggaW5kZXgxICk7XHJcbiAgICAgICAgaWYgKCBpbmRleDIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yMiA9IFZzUGFsZXR0ZS5pbmRleFRvQ29sb3IoIGluZGV4MiApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yMiA9IHRoaXMuX2NvbG9yMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy50ZXh0ICE9IG51bGwgKSB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IHRoaXMuZ2V0Q29sb3JBcnJheVNpemUoKTtcclxuICAgICAgICAgICAgbGV0IGNvbG9ycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQgLyA0OyBpKysgKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaCggdGhpcy5fY29sb3IxLDEsdGhpcy5fY29sb3IxLDEsdGhpcy5fY29sb3IyLDEsdGhpcy5fY29sb3IyLDEgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldENvbG9yQXJyYXkoIGNvbG9ycyApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgIFxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAbWVtYmVyb2YgVnNTbWFsbEZvbnRcclxuICAgICAqL1xyXG4gICAgc2V0VGV4dCggcyApIHtcclxuICAgICAgICBsZXQgaWR4ID0gW107XHJcbiAgICAgICAgbGV0IHZ0eCA9IFtdO1xyXG4gICAgICAgIGxldCB1diA9IFtdO1xyXG4gICAgICAgIGxldCBjb2xvcnMgPSBbXTtcclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnRleHQgPSBzO1xyXG5cclxuICAgICAgICBsZXQgYWRkQ2hhciA9ICggY29kZSApID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGFQb3MgPSBjb2RlICogNjtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBoYW5ndWxGb250RnJhbWVzLnNsaWNlKCBkYXRhUG9zLGRhdGFQb3MgKyA2ICk7XHJcbiAgICAgICAgICAgIGxldCBpcG9zID0gdnR4Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgIGxldCBbdSx2LHcsaCxzeCxzeV0gPSBkYXRhO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWR4LnB1c2goIGlwb3MsaXBvcyArIDEsaXBvcyArIDIsaXBvcyArIDEsaXBvcyArIDMsaXBvcyArIDIgKTtcclxuICAgICAgICAgICAgdnR4LnB1c2goIHggKyBzeCx5ICsgc3kseCArIHN4ICsgdyx5ICsgc3kseCArIHN4LHkgKyBzeSArIGgseCArIHN4ICsgdyx5ICsgc3kgKyBoICk7XHJcbiAgICAgICAgICAgIHV2LnB1c2goIHUsdix1ICsgdyx2LHUsdiArIGgsdSArIHcsdiArIGggKTtcclxuICAgICAgICAgICAgY29sb3JzLnB1c2goIHRoaXMuX2NvbG9yMSwxLHRoaXMuX2NvbG9yMSwxLHRoaXMuX2NvbG9yMiwxLHRoaXMuX2NvbG9yMiwxICk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgbGV0IGNoID0gcy5jaGFyQ29kZUF0KCBpICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGNoID09IDB4MjAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDqs7XrsLFcclxuICAgICAgICAgICAgICAgIHggKz0gNztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggY2ggPT0gMTAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDsl5TthLBcclxuICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgeSArPSAxNjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggY2ggPiAweDIwICYmIGNoIDw9IDB4MjAgKyA5NSApIHtcclxuICAgICAgICAgICAgICAgIC8vIOyYgeyWtFxyXG4gICAgICAgICAgICAgICAgYWRkQ2hhciggY2ggLSAzMyApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCB3aWR0aFRhYmxlW3NbaV1dICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggKz0gd2lkdGhUYWJsZVtzW2ldXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCArPSA4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNob3N1bmc7XHJcbiAgICAgICAgICAgICAgICBsZXQgam9vbmdzdW5nO1xyXG4gICAgICAgICAgICAgICAgbGV0IGpvbmdzdW5nO1xyXG4gICAgICAgICAgICAgICAgbGV0IGIxLGIyLGIzO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggY2ggPj0gMHgzMTMxICYmIGNoIDw9IDB4MzE0ZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDsnpDshozrp4wg7Lac66ClXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhciggSU5ERVhfQ0hPU1VORyArIGNvbnZDaG9zdW5nWyggY2ggLSAweDMxMzEgKV0gKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2ggLT0gMHhhYzAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNob3N1bmcgPSBNYXRoLmZsb29yKCBjaCAvICggMjggKiAyMSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgam9vbmdzdW5nID0gTWF0aC5mbG9vciggKCBjaCAlICggMjggKiAyMSApICkgLyAyOCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGpvbmdzdW5nID0gY2ggJSAyODtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYjMgPSBqb29uZ3N1bmdUYWJsZVsgam9vbmdzdW5nIF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBqb25nc3VuZyA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiMiA9IGNob3N1bmdUYWJsZVsgY2hvc3VuZyBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGpvb25nc3VuZ1RhYmxlWyAyMSArIGpvb25nc3VuZyBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY2hvc3VuZ1RhYmxlWyAxOSArIGNob3N1bmcgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBqb29uZ3N1bmdUYWJsZVsgMiAqIDIxICsgam9vbmdzdW5nIF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZENoYXIoIElOREVYX0NIT1NVTkcgKyBjaG9zdW5nICsgYjEgKiAyMCApO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZENoYXIoIElOREVYX0pPT05HU1VORyArIGpvb25nc3VuZyArIGIyICogMjIgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGpvbmdzdW5nICE9IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENoYXIoIElOREVYX0pPTkdTVU5HICsgam9uZ3N1bmcgKyBiMyAqIDI4ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeCArPSAxMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFZlcnRleEFycmF5KCB2dHggKTtcclxuICAgICAgICB0aGlzLnNldEluZGV4QXJyYXkoIGlkeCApO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JBcnJheSggY29sb3JzICk7XHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlQ29vcmRpbmF0ZUFycmF5KCB1diApO1xyXG4gICAgfVxyXG59XHJcblxyXG4vL21vZHVsZS5leHBvcnRzID0gVnNIYW5ndWw7XHJcbiIsImltcG9ydCB7IFV0aWxzLCBFdmVudCwgS2V5Q29kZSwgU3ByaXRlLCBTdGFnZSwgQml0bWFwLCBUZXh0dXJlLCBzdGFnZSwgYXBwbGljYXRpb24gfSBmcm9tIFwiQGVuZ2luZS9mbGF0ZmFzdFwiO1xyXG5cclxuaW1wb3J0IFZzU3RhZ2UgZnJvbSBcIi4vdnNTdGFnZVwiO1xyXG5pbXBvcnQgR0xPQkFMIGZyb20gXCIuLi9nbG9iYWxcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBhZGRCdXR0b24oIHgseSxrZXksY29sb3IgKSB7XHJcbiAgICBsZXQgdCA9IG5ldyBUZXh0dXJlKCBgdnBhZDMwLnBuZ2AgKTtcclxuICAgIGxldCBzID0gbmV3IEJpdG1hcCggdCApO1xyXG5cclxuICAgIHMuc2V0Q29sb3JNdWx0aXBsaWVyKCAuLi5VdGlscy5oZXgycmdiYSggY29sb3IgKSApO1xyXG4gICAgcy5hbHBoYSA9IDAuMztcclxuICAgIHMuc2V0QW5jaG9yUG9pbnQoIDAuNSwwLjUgKTtcclxuICAgIHMueHkgPSBbeCx5XTtcclxuICAgIHMub24oIEV2ZW50LlBPSU5URVJfRE9XTiwoIGUgKT0+e1xyXG4gICAgICAgIGlmICggcy5oaXRUZXN0UG9pbnQoIGUueCxlLnkgKSApIHtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgbGV0IGUyID0gbmV3IEV2ZW50KCBFdmVudC5LRVlfRE9XTiApO1xyXG5cclxuICAgICAgICAgICAgcy5hbHBoYSA9IDAuNTtcclxuICAgICAgICAgICAgZTIua2V5Q29kZSA9IGtleTtcclxuICAgICAgICAgICAgcy5kb3duSWQgPSBlLmlkO1xyXG4gICAgICAgICAgICBWc1N0YWdlLmluc3RhbmNlLmRpc3BhdGNoRXZlbnRXaXRoQ2hpbGRyZW4oIGUyICk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBgRE9XTiAke2tleX1gICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSApO1xyXG4gICAgcy5vbiggRXZlbnQuUE9JTlRFUl9VUCwoIGUgKT0+e1xyXG4gICAgICAgIGlmICggZS5pZCA9PSBzLmRvd25JZCApIHtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgbGV0IGUyID0gbmV3IEV2ZW50KCBFdmVudC5LRVlfVVAgKTtcclxuXHJcbiAgICAgICAgICAgIHMuYWxwaGEgPSAwLjM7XHJcbiAgICAgICAgICAgIGUyLmtleUNvZGUgPSBrZXk7XHJcbiAgICAgICAgICAgIHMuZG93bklkID0gbnVsbDtcclxuICAgICAgICAgICAgVnNTdGFnZS5pbnN0YW5jZS5kaXNwYXRjaEV2ZW50V2l0aENoaWxkcmVuKCBlMiApO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggYFVQICR7a2V5fWAgKTtcclxuICAgICAgICB9XHJcbiAgICB9ICk7XHJcbiAgICByZXR1cm4gcztcclxufVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZzUGFkIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCBhbHdheXNTaG93ICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCBhbHdheXNTaG93IHx8IGFwcGxpY2F0aW9uLnRvdWNoRW5hYmxlZCApIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uLm9uKCBFdmVudC5SRVNJWkUsdGhpcy5pbml0LHRoaXMgKTtcclxuICAgICAgICB9ICAgICAgICBcclxuICAgICAgICAvLyB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJDaGlsZHJlbigpO1xyXG4gICAgICAgIHRoaXMuc2V0RFBhZCggYXBwbGljYXRpb24ubG9naWNhbFJlbmRlckJvdW5kcy5sZWZ0ICsgNTAsYXBwbGljYXRpb24ubG9naWNhbFJlbmRlckJvdW5kcy5ib3R0b20gLSA1MCxLZXlDb2RlLlVQLEtleUNvZGUuRE9XTixLZXlDb2RlLkxFRlQsS2V5Q29kZS5SSUdIVCApO1xyXG4gICAgICAgIHRoaXMuc2V0QnV0dG9uKCBhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLnJpZ2h0IC0gNzAsYXBwbGljYXRpb24ubG9naWNhbFJlbmRlckJvdW5kcy5ib3R0b20gLSA0MCxLZXlDb2RlLlNQQUNFLDB4ZmY0MDQwICk7XHJcbiAgICAgICAgdGhpcy5zZXRCdXR0b24oIGFwcGxpY2F0aW9uLmxvZ2ljYWxSZW5kZXJCb3VuZHMucmlnaHQgLSA0MCxhcHBsaWNhdGlvbi5sb2dpY2FsUmVuZGVyQm91bmRzLmJvdHRvbSAtIDYwLEtleUNvZGUuTSwweDQwMDBmZiApO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERQYWQoIHgseSxrZXlVcCxrZXlEb3duLGtleUxlZnQsa2V5UmlnaHQgKSB7XHJcbiAgICAgICAgbGV0IG9yaWdpblggPSB4O1xyXG4gICAgICAgIGxldCBvcmlnaW5ZID0geTtcclxuICAgICAgICBsZXQgaHggPSB4O1xyXG4gICAgICAgIGxldCBoeSA9IHk7XHJcbiAgICAgICAgbGV0IGJvcmRlciA9IG5ldyBCaXRtYXAoIG5ldyBUZXh0dXJlKCBgdnBhZDUwLnBuZ2AgKSApO1xyXG5cclxuICAgICAgICBib3JkZXIueHkgPSBbeCx5XTtcclxuICAgICAgICBib3JkZXIuc2V0QW5jaG9yUG9pbnQoIDAuNSwwLjUgKTtcclxuICAgICAgICBib3JkZXIuYWxwaGEgPSAwLjI7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCggYm9yZGVyICk7XHJcblxyXG4gICAgICAgIGxldCBkb3QgPSBuZXcgQml0bWFwKCBuZXcgVGV4dHVyZSggYHZwYWQ1LnBuZ2AgKSApO1xyXG5cclxuICAgICAgICBkb3QuYWxwaGEgPSAwLjU7XHJcbiAgICAgICAgZG90LnNldEFuY2hvclBvaW50KCAwLjUsMC41ICk7XHJcbiAgICAgICAgZG90LnNldFZpc2libGUoIGZhbHNlICk7XHJcbiAgICAgICAgZG90Lm9uU3RhZ2UoIEV2ZW50LkVOVEVSX0ZSQU1FLCgpPT57XHJcbiAgICAgICAgICAgIGlmICggVnNTdGFnZS5pbnN0YW5jZS53b3JsZCAmJiBHTE9CQUwucGxheWVycyAmJiBHTE9CQUwucGxheWVyc1sxXSApIHtcclxuICAgICAgICAgICAgICAgIGxldCBweCA9IEdMT0JBTC5wbGF5ZXJzWzFdLng7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHkgPSBHTE9CQUwucGxheWVyc1sxXS55O1xyXG5cclxuICAgICAgICAgICAgICAgIGRvdC5wb3NpdGlvbiA9IFZzU3RhZ2UuaW5zdGFuY2Uud29ybGQuZ2V0U3RhZ2VDb29yZGluYXRlKCBweCxweSApO1xyXG4gICAgICAgICAgICAgICAgZG90LnggKz0gKCBoeCAtIHggKSAqIDAuNjtcclxuICAgICAgICAgICAgICAgIGRvdC55ICs9ICggaHkgLSB5ICkgKiAwLjY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ICk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCggZG90ICk7XHJcblxyXG4gICAgICAgIGxldCBoZWFkID0gbmV3IEJpdG1hcCggbmV3IFRleHR1cmUoIGB2cGFkMzAucG5nYCApICk7XHJcblxyXG4gICAgICAgIGhlYWQueHkgPSBbeCx5XTtcclxuICAgICAgICBoZWFkLnNldEFuY2hvclBvaW50KCAwLjUsMC41ICk7XHJcbiAgICAgICAgaGVhZC5hbHBoYSA9IDAuMztcclxuICAgICAgICB0aGlzLmFkZENoaWxkKCBoZWFkICk7XHJcblxyXG4gICAgICAgIGNvbnN0IGtleVN0YXRlcyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGRpclRvS2V5ID0gW1xyXG4gICAgICAgICAgICBba2V5VXBdLFxyXG4gICAgICAgICAgICBba2V5VXAsa2V5UmlnaHRdLFxyXG4gICAgICAgICAgICBba2V5UmlnaHRdLFxyXG4gICAgICAgICAgICBba2V5RG93bixrZXlSaWdodF0sXHJcbiAgICAgICAgICAgIFtrZXlEb3duXSxcclxuICAgICAgICAgICAgW2tleURvd24sa2V5TGVmdF0sXHJcbiAgICAgICAgICAgIFtrZXlMZWZ0XSxcclxuICAgICAgICAgICAgW2tleVVwLGtleUxlZnRdLFxyXG4gICAgICAgICAgICBbXSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IGdldERpciA9ICggZXgsZXkgKT0+e1xyXG4gICAgICAgICAgICBpZiAoIFV0aWxzLmRpc3RhbmNlKCB4LHksIGV4LGV5ICkgPCAxMCApIHJldHVybiA4O1xyXG4gICAgICAgICAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKCBleCAtIHgsLSggZXkgLSB5ICkgKSAgKiAxODAgLyBNYXRoLlBJICsgMjIuNTtcclxuICAgICAgICAgICAgbGV0IGRpciA9IE1hdGguZmxvb3IoICggYW5nbGUgPCAwID8gYW5nbGUgKyAzNjAgOiBhbmdsZSApIC8gNDUgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBkaXIgKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBoZWFkLm9uKCBFdmVudC5QT0lOVEVSX0RPV04sKCBlICk9PntcclxuICAgICAgICAgICAgaWYgKCBVdGlscy5kaXN0YW5jZSggb3JpZ2luWCxvcmlnaW5ZLCBlLngsZS55ICkgPD0gMTAwICkge1xyXG4gICAgICAgICAgICAgICAgeCA9IGUueDtcclxuICAgICAgICAgICAgICAgIHkgPSBlLnk7XHJcbiAgICAgICAgICAgICAgICBib3JkZXIueHkgPSBbeCx5XTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBoZWFkLmRvd25JZCA9IGUuaWQ7XHJcbiAgICAgICAgICAgICAgICBoZWFkLmFscGhhID0gMC41O1xyXG4gICAgICAgICAgICAgICAgaGVhZC54eSA9IFtlLngsZS55XTtcclxuICAgICAgICAgICAgICAgIGhlYWQubGFzdERpciA9IGdldERpciggZS54LGUueSApO1xyXG4gICAgICAgICAgICAgICAgaHggPSBlLng7XHJcbiAgICAgICAgICAgICAgICBoeSA9IGUueTtcclxuICAgICAgICAgICAgICAgIGRvdC5zZXRWaXNpYmxlKCB0cnVlICk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmICggZGlyVG9LZXlbaGVhZC5sYXN0RGlyXS5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlMSA9IG5ldyBFdmVudCggRXZlbnQuS0VZX0RPV04gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZTEua2V5Q29kZSA9IGRpclRvS2V5W2hlYWQubGFzdERpcl1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAga2V5U3RhdGVzW2UxLmtleUNvZGVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBWc1N0YWdlLmluc3RhbmNlLmRpc3BhdGNoRXZlbnRXaXRoQ2hpbGRyZW4oIGUxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGBET1dOICR7ZTEua2V5Q29kZX1gICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIGRpclRvS2V5W2hlYWQubGFzdERpcl0ubGVuZ3RoID4gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZTIgPSBuZXcgRXZlbnQoIEV2ZW50LktFWV9ET1dOICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGUyLmtleUNvZGUgPSBkaXJUb0tleVtoZWFkLmxhc3REaXJdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleVN0YXRlc1tlMi5rZXlDb2RlXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgVnNTdGFnZS5pbnN0YW5jZS5kaXNwYXRjaEV2ZW50V2l0aENoaWxkcmVuKCBlMiApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBgRE9XTiAke2UyLmtleUNvZGV9YCApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG4gICAgICAgIGhlYWQub24oIEV2ZW50LlBPSU5URVJfTU9WRSwgKCBlICk9PntcclxuICAgICAgICAgICAgaWYgKCBoZWFkLmRvd25JZCAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBlLmlkID09IGhlYWQuZG93bklkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZC54eSA9IFtlLngsZS55XTtcclxuICAgICAgICAgICAgICAgICAgICBoeCA9IGUueDtcclxuICAgICAgICAgICAgICAgICAgICBoeSA9IGUueTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlyID0gZ2V0RGlyKCBlLngsZS55ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBkaXIsaGVhZC5sYXN0RGlyLGtleVN0YXRlcyApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaGVhZC5sYXN0RGlyICE9IGRpciApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZC5sYXN0RGlyID0gZGlyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBsZXQga2V5IGluIGtleVN0YXRlcyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlMSA9IG5ldyBFdmVudCggRXZlbnQuS0VZX1VQICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXJUb0tleVtoZWFkLmxhc3REaXJdLmluZGV4T2YoIGtleSApIDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMS5rZXlDb2RlID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZzU3RhZ2UuaW5zdGFuY2UuZGlzcGF0Y2hFdmVudFdpdGhDaGlsZHJlbiggZTEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggYFVQICR7a2V5fWAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUga2V5U3RhdGVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkaXJUb0tleVtoZWFkLmxhc3REaXJdLmxlbmd0aCA+IDAgJiYgIWtleVN0YXRlc1tkaXJUb0tleVtoZWFkLmxhc3REaXJdWzBdXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlMSA9IG5ldyBFdmVudCggRXZlbnQuS0VZX0RPV04gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMS5rZXlDb2RlID0gZGlyVG9LZXlbaGVhZC5sYXN0RGlyXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVN0YXRlc1tlMS5rZXlDb2RlXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWc1N0YWdlLmluc3RhbmNlLmRpc3BhdGNoRXZlbnRXaXRoQ2hpbGRyZW4oIGUxICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggYERPV04gJHtlMS5rZXlDb2RlfWAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRpclRvS2V5W2hlYWQubGFzdERpcl0ubGVuZ3RoID4gMSAmJiAha2V5U3RhdGVzW2RpclRvS2V5W2hlYWQubGFzdERpcl1bMV1dICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGUyID0gbmV3IEV2ZW50KCBFdmVudC5LRVlfRE9XTiApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmtleUNvZGUgPSBkaXJUb0tleVtoZWFkLmxhc3REaXJdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5U3RhdGVzW2UyLmtleUNvZGVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZzU3RhZ2UuaW5zdGFuY2UuZGlzcGF0Y2hFdmVudFdpdGhDaGlsZHJlbiggZTIgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBgRE9XTiAke2UyLmtleUNvZGV9YCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG4gICAgICAgIGhlYWQub24oIEV2ZW50LlBPSU5URVJfVVAsKCBlICk9PntcclxuICAgICAgICAgICAgaWYgKCBlLmlkID09IGhlYWQuZG93bklkICkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIHggPSBvcmlnaW5YO1xyXG4gICAgICAgICAgICAgICAgeSA9IG9yaWdpblk7XHJcbiAgICAgICAgICAgICAgICBib3JkZXIueHkgPSBbeCx5XTtcclxuXHJcbiAgICAgICAgICAgICAgICBoZWFkLmFscGhhID0gMC4zO1xyXG4gICAgICAgICAgICAgICAgaGVhZC54eSA9IFt4LHldO1xyXG4gICAgICAgICAgICAgICAgZG90LnNldFZpc2libGUoIGZhbHNlICk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBsZXQga2V5IGluIGtleVN0YXRlcyApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZTEgPSBuZXcgRXZlbnQoIEV2ZW50LktFWV9VUCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlMS5rZXlDb2RlID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIFZzU3RhZ2UuaW5zdGFuY2UuZGlzcGF0Y2hFdmVudFdpdGhDaGlsZHJlbiggZTEgKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUga2V5U3RhdGVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGBVUCAke2tleX1gICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoZWFkLmRvd25JZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QnV0dG9uKCB4LHksa2V5LGNvbG9yICkge1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoIGFkZEJ1dHRvbiggeCx5LGtleSxjb2xvciApICk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLy8gbW9kdWxlLmV4cG9ydHMgPSBWc1BhZDsiLCJpbXBvcnQgeyBhcHBsaWNhdGlvbixTcGluZSwgQ29tcG9uZW50LCBDb21wb25lbnRIb2xkZXIsIFNjZW5lTWFuYWdlciwgU3RvcmFnZSwgVHdlZW4sIEZvbnQsIFBvaW50LCBSZWN0LCBUaWxlTWFwLE1vdmllQ2xpcCxSZW5kZXJUYXJnZXQsIFBpeGVsLGVhc2luZywgTWVzaCwgVGV4dHVyZVBhY2ssIFV0aWxzLCBNYXRyaXgsIFNoYXBlLCBUaW1lciwgVGV4dEZpZWxkLCBFdmVudCwgRXZlbnREaXNwYXRjaGVyLFxyXG4gICAgICAgICBTcHJpdGUsIFN0YWdlLCBCaXRtYXAsIFRleHR1cmUsIEFwcGxpY2F0aW9uLCBUZXh0dXJlQmFzZSxTaGFkZXIsIHN0YWdlIH0gZnJvbSBcIkBlbmdpbmUvZmxhdGZhc3RcIjtcclxuaW1wb3J0IFZzU3RhZ2UgZnJvbSBcIi4vdnNTdGFnZVwiO1xyXG5cclxuY29uc3QgdmVydGV4U3JjID0gYFxyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHJcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1XHJcbiNkZWZpbmUgTU9USU9OX0JMVVJfVEhSRVNIT0xEIDIuMFxyXG5cclxuY29uc3QgYm9vbCB1c2VEaXNjYXJkID0gdHJ1ZTtcclxuXHJcbiNpZm5kZWYgTk9fVEVYVFVSRVxyXG4gICAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcclxuICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xyXG4jZW5kaWZcclxuXHJcblxyXG4gICAgdW5pZm9ybSBtYXQ0IHVfdmlld01hdHJpeDtcclxuICAgIHVuaWZvcm0gbWF0NCB1X3dvcmxkTWF0cml4UHJldjtcclxuICAgIHVuaWZvcm0gbWF0NCB1X3dvcmxkTWF0cml4O1xyXG4gICAgdW5pZm9ybSB2ZWMyIHVfYW5jaG9yUHJldjtcclxuICAgIHVuaWZvcm0gdmVjMiB1X2FuY2hvcjtcclxuICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yT3ZlcnJpZGVQcmV2O1xyXG4gICAgdW5pZm9ybSB2ZWM0IHVfY29sb3JPdmVycmlkZTtcclxuICAgIHVuaWZvcm0gZmxvYXQgdV9hbHBoYU1vZDtcclxuICAgIHVuaWZvcm0gZmxvYXQgdV9hbHBoYU1vZDI7XHJcbiAgICB1bmlmb3JtIGZsb2F0IHVfbG9naWNQZXJSZW5kZXJGcmFtZTtcclxuICAgIHVuaWZvcm0gZmxvYXQgdV9zdWJSZW5kZXJGcmFtZTtcclxuXHJcbiAgICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xyXG4gICAgYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcclxuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX2JsZW5kRmFjdG9yO1xyXG5cclxuICAgIHZhcnlpbmcgZmxvYXQgdl9kaXNjYXJkQWxsO1xyXG4gICAgdmFyeWluZyB2ZWM0IHZfY29sb3JPdmVycmlkZTtcclxuXHJcbiAgICB2YXJ5aW5nIGZsb2F0IHZfYWxwaGFDb3JyZWN0aW9uO1xyXG5cclxuXHJcblxyXG4vL2RlY29tcG9zaW5nIGNvZGUgZnJvbVxyXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9kZW94eGEvdHJhbnNmb3JtYXRpb24tbWF0cml4LWpzL2Jsb2IvbWFzdGVyL3NyYy9tYXRyaXguanNcclxuXHJcbnN0cnVjdCBUcmFuc2Zvcm0ge1xyXG4gICAgdmVjMiBwb3NpdGlvbjtcclxuICAgIHZlYzIgc2NhbGU7XHJcbiAgICB2ZWMyIHNrZXc7XHJcbiAgICBmbG9hdCByb3RhdGlvbjtcclxufTtcclxuXHJcblRyYW5zZm9ybSBkZWNvbXBvc2UobWF0NCBtYXQpIHtcclxuICAgIFRyYW5zZm9ybSByZXN1bHQ7XHJcblx0ZmxvYXQgYSA9IG1hdFswXS54O1xyXG4gICAgZmxvYXQgYiA9IG1hdFswXS55O1xyXG4gICAgZmxvYXQgYyA9IG1hdFsxXS54O1xyXG4gICAgZmxvYXQgZCA9IG1hdFsxXS55O1xyXG5cclxuICAgIGZsb2F0IHJvdGF0aW9uID0gMC4wO1xyXG4gICAgdmVjMiBzY2FsZSA9IHZlYzIoMS4wLCAxLjApO1xyXG4gICAgdmVjMiBza2V3ID0gdmVjMigwLjAsIDAuMCk7XHJcblxyXG4gICAgZmxvYXQgZGV0ZXJtID0gYSAqIGQgLSBiICogYztcdC8vIGRldGVybWluYW50KCksIHNraXAgRFJZIGhlcmUuLi5cclxuXHJcbiAgICBpZihhICE9IDAuMCB8fCBiICE9IDAuMCkge1xyXG4gICAgICAgIGZsb2F0IHIgPSBzcXJ0KGEgKiBhICsgYiAqIGIpO1xyXG4gICAgICAgIHJvdGF0aW9uID0gYiA+IDAuMCA/IGFjb3MoYSAvIHIpIDogLWFjb3MoYSAvIHIpO1xyXG4gICAgICAgIHNjYWxlID0gdmVjMihyLCBkZXRlcm0gLyByKTtcclxuICAgICAgICBza2V3LnggPSBhdGFuKChhICogYyArIGIgKiBkKSwgKHIgKiByKSk7XHJcbiAgICB9IGVsc2UgaWYoYyAhPSAwLjAgfHwgZCAhPSAwLjApIHtcclxuICAgICAgICBmbG9hdCBzID0gc3FydChjICogYyArIGQgKiBkKTtcclxuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41IC0gKGQgPiAwLjAgPyBhY29zKC1jIC8gcykgOiAtYWNvcyhjIC8gcykpO1xyXG4gICAgICAgIHNjYWxlID0gdmVjMihkZXRlcm0gLyBzLCBzKTtcclxuICAgICAgICBza2V3LnkgPSBhdGFuKChhICogYyArIGIgKiBkKSwgKHMgKiBzKSk7XHJcbiAgICB9IGVsc2UgeyAvLyBhID0gYiA9IGMgPSBkID0gMFxyXG4gICAgICAgIHNjYWxlID0gdmVjMigwLjAsIDAuMCk7XHRcdC8vID0gaW52YWxpZCBtYXRyaXhcclxuICAgIH0gXHJcbiAgICByZXN1bHQuc2NhbGUgPSBzY2FsZTtcclxuICAgIHJlc3VsdC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG4gICAgcmVzdWx0LnNrZXcgPSBza2V3O1xyXG4gICAgcmVzdWx0LnBvc2l0aW9uID0gbWF0WzNdLnh5O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcbiAgICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbi54eSwxLDEpO1xyXG4gICAgZmxvYXQgYWJmID0gYV9ibGVuZEZhY3RvcjtcclxuICAgIGZsb2F0IGJmID0gKGFfYmxlbmRGYWN0b3IrdV9zdWJSZW5kZXJGcmFtZSkgLyBtYXgoMS4wLHVfbG9naWNQZXJSZW5kZXJGcmFtZSk7XHJcbiAgICBtYXQ0IG1hdHJpeDEgPSB1X3dvcmxkTWF0cml4UHJldjtcclxuICAgIG1hdDQgbWF0cml4MiA9IHVfd29ybGRNYXRyaXg7XHJcblxyXG4jaWZuZGVmIE5PX1RFWFRVUkVcclxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xyXG4jZW5kaWZcclxuXHJcbiAgICBUcmFuc2Zvcm0gdDEgPSBkZWNvbXBvc2UobWF0cml4MSk7XHJcbiAgICBUcmFuc2Zvcm0gdDIgPSBkZWNvbXBvc2UobWF0cml4Mik7XHJcbiAgICBUcmFuc2Zvcm0gdDtcclxuXHJcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKG1hdHJpeDFbM10ueHkgLSBtYXRyaXgyWzNdLnh5KTtcclxuICAgIGJvb2wgaXNOb3RNb3ZlZCA9IGJmPj0xLjAgfHwgKGRpc3Q8PU1PVElPTl9CTFVSX1RIUkVTSE9MRCAmJiB0MS5zY2FsZSA9PSB0Mi5zY2FsZSAmJiB0MS5yb3RhdGlvbiA9PSB0Mi5yb3RhdGlvbik7XHJcblxyXG5cclxuICAgIGlmKGlzTm90TW92ZWQpIHtcclxuICAgICAgICBpZiAodXNlRGlzY2FyZCAmJiBhYmYhPTAuNSkge1xyXG4gICAgICAgICAgICB2X2Rpc2NhcmRBbGwgPSAxLjA7XHJcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZfY29sb3JPdmVycmlkZSA9IHVfY29sb3JPdmVycmlkZTtcclxuICAgICAgICAgICAgdC5wb3NpdGlvbiA9IHQyLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB0LnJvdGF0aW9uID0gdDIucm90YXRpb247XHJcbiAgICAgICAgICAgIHQuc2NhbGUgPSB0Mi5zY2FsZTtcclxuICAgICAgICAgICAgdC5za2V3ID0gdDIuc2tldztcclxuICAgICAgICAgICAgdl9jb2xvck92ZXJyaWRlICo9IGFfY29sb3I7XHJcbiAgICAgICAgICAgIHZfYWxwaGFDb3JyZWN0aW9uID0gMC4wO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdl9hbHBoYUNvcnJlY3Rpb24gPSAxLjA7XHJcbiAgICAgICAgZmxvYXQgYWxwaGEgPSAxLjAgLSBhYnMoYWJmIC0gMC41KSAqIDIuMDtcclxuICAgICAgICB2X2NvbG9yT3ZlcnJpZGUgPSBtaXgodV9jb2xvck92ZXJyaWRlUHJldiwgdV9jb2xvck92ZXJyaWRlLCBiZik7XHJcbiAgICAgICAgdl9jb2xvck92ZXJyaWRlICo9IGFfY29sb3I7XHJcbiAgICAgICAgdl9jb2xvck92ZXJyaWRlLmEgKj0gYV9jb2xvci5hOy8vICogYWxwaGE7XHJcbiAgICAgICAgdC5wb3NpdGlvbiA9IG1peCh0MS5wb3NpdGlvbiwgdDIucG9zaXRpb24sIGJmKTtcclxuICAgICAgICB0LnJvdGF0aW9uID0gbWl4KHQxLnJvdGF0aW9uLCB0Mi5yb3RhdGlvbiwgYmYpO1xyXG4gICAgICAgIHQuc2NhbGUgPSBtaXgodDEuc2NhbGUsIHQyLnNjYWxlLCBiZik7XHJcbiAgICAgICAgdC5za2V3ID0gbWl4KHQxLnNrZXcsIHQyLnNrZXcsIGJmKTtcclxuICAgIH1cclxuICAgIHZfZGlzY2FyZEFsbCA9IDAuMDtcclxuXHJcbiAgICBtYXQ0IHBvc01hdCA9IG1hdDQoMSk7XHJcbiAgICBtYXQ0IHNjYWxlTWF0ID0gbWF0NCgxKTtcclxuICAgIG1hdDQgcm90TWF0ID0gbWF0NCgxKTtcclxuICAgIG1hdDQgc2hlYXJNYXQgPSBtYXQ0KDEpO1xyXG4gICAgbWF0NCBhbmNob3JNYXQgPSBtYXQ0KDEpO1xyXG5cclxuICAgIGFuY2hvck1hdFszXS54eSA9IC1taXgodV9hbmNob3JQcmV2LHVfYW5jaG9yLGJmKTtcclxuXHJcbiAgICBwb3NNYXRbM10ueHkgPSB0LnBvc2l0aW9uO1xyXG4gICAgc2hlYXJNYXRbMF0ueSA9IC10LnNrZXcueDtcclxuICAgIHNoZWFyTWF0WzFdLnggPSB0LnNrZXcueTtcclxuICAgIHNjYWxlTWF0WzBdLnggPSB0LnNjYWxlLng7XHJcbiAgICBzY2FsZU1hdFsxXS55ID0gdC5zY2FsZS55OyAgICBcclxuICAgIHJvdE1hdFswXS54ID0gY29zKHQucm90YXRpb24pO1xyXG4gICAgcm90TWF0WzBdLnkgPSBzaW4odC5yb3RhdGlvbik7XHJcbiAgICByb3RNYXRbMV0ueCA9IC1zaW4odC5yb3RhdGlvbik7XHJcbiAgICByb3RNYXRbMV0ueSA9IGNvcyh0LnJvdGF0aW9uKTtcclxuXHJcbiAgICBnbF9Qb3NpdGlvbiA9IHVfdmlld01hdHJpeCAqIHBvc01hdCAqIHNoZWFyTWF0ICogc2NhbGVNYXQgKiByb3RNYXQgKiBhbmNob3JNYXQgKiBwb3M7XHJcblxyXG59XHJcbiAgICAgICAgICAgIGA7XHJcbmNvbnN0IGZyYWdtZW50U3JjID0gYFxyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHJcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1XHJcblxyXG4jaWZuZGVmIE5PX1RFWFRVUkVcclxuXHJcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgICB1bmlmb3JtIHZlYzIgdV90ZXh0dXJlU2l6ZTtcclxuICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xyXG5cclxuI2VuZGlmXHJcblxyXG4gICAgdW5pZm9ybSB2ZWM0IHVfY29sb3JBZGQ7XHJcblxyXG4gICAgdmFyeWluZyBmbG9hdCB2X2Rpc2NhcmRBbGw7XHJcbiAgICB2YXJ5aW5nIHZlYzQgdl9jb2xvck92ZXJyaWRlO1xyXG4gICAgdmFyeWluZyBmbG9hdCB2X2FscGhhQ29ycmVjdGlvbjtcclxuXHJcbiAgICB1bmlmb3JtIGZsb2F0IHVfYWxwaGFNb2Q7XHJcbiAgICB1bmlmb3JtIGZsb2F0IHVfYWxwaGFNb2QyO1xyXG5cclxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHBhbGV0dGU7XHJcbiAgICB1bmlmb3JtIGZsb2F0IHdoaXRlO1xyXG5cclxudm9pZCBtYWluKCkge1xyXG4gICAgaWYodl9kaXNjYXJkQWxsICE9IDAuMCkgZGlzY2FyZDtcclxuXHJcbiNpZm5kZWYgTk9fVEVYVFVSRVxyXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVfdGV4dHVyZSx2X3RleENvb3JkIC8gdV90ZXh0dXJlU2l6ZSk7XHJcbiNlbHNlXHJcbiAgICB2ZWM0IGMgPSB2ZWM0KDEuMCwxLjAsMS4wLDEuMCk7XHJcbiNlbmRpZlxyXG4gICAgYyArPSB1X2NvbG9yQWRkO1xyXG4gICAgYyAqPSB2X2NvbG9yT3ZlcnJpZGU7XHJcbiAgICB2ZWM0IGljID0gYztcclxuICAgIGZsb2F0IGluZGV4ID0gKGljLmcgKiAxNi4wICsgaWMucioxNi4wICogMTYuMCkvMjU2LjA7XHJcbiAgICBjID0gdmVjNCggXHJcbiAgICAgICAgICAgbWl4ICggdGV4dHVyZTJEKHBhbGV0dGUsdmVjMihpbmRleCwwKSkueHl6LCB2ZWMzKDEsMSwxKSx3aGl0ZSkgXHJcbiAgICAgICAgLCBpYy5hICk7XHJcbiAgICBcclxuICAgIC8vIOuqqOyFmOu4lOufrOuQnCDqsJLsnYQg67O07KCV7ZWY64qUIOyLnVxyXG4gICAgLy8g7KCV7ZmV7ZWcIOqwkuydhCDqtaztlZjripQg6rKD7J2AIOyWtOugteqzoCDqt7zsgqzsuZjrpbwg7IKs7Jqp7ZWc64ukLlxyXG4gICAgLy8g66qo7IWY67iU65+sIDnqsJwg6re466as64qUIOqyg+ydhCDquLDspIDsnLzroZwg6rWs7ZWcIOqwklxyXG4gICAgLy8gYy5hICo9IDEuMCArICgwLjIzLygxLjE4IC0gYy5hKSAtIDEuMCkqdl9hbHBoYUNvcnJlY3Rpb247XHJcbiAgICAvLyDrqqjshZjruJTrn6wgMTXqsJwg6riw7KSAXHJcbiAgICBjLmEgKj0gMS4wICsgKDAuMDkgLyAoMS41IC0gYy5hKSAtIDEuMCkgKiB2X2FscGhhQ29ycmVjdGlvbjtcclxuICAgIGMucmdiICo9IGMuYTtcclxuICAgIGdsX0ZyYWdDb2xvciA9IGM7XHJcbn1cclxuICAgICAgICAgICAgYDtcclxuXHJcblxyXG5jb25zdCBub1RleFNoYWRlciA9IG5ldyBTaGFkZXIoIFwiI2RlZmluZSBOT19URVhUVVJFXFxuXCIgKyB2ZXJ0ZXhTcmMsXCIjZGVmaW5lIE5PX1RFWFRVUkVcXG5cIiArIGZyYWdtZW50U3JjLG51bGwgKTtcclxuXHJcbi8vIO2MlOugiO2KuOulvCDtlZzrsojsl5Ag67OA6rK97ZWgIOyImCDsnojrj4TroZ0g66mU7Iuc66W8IOuvuOumrCDrp4zrk6TslrTrkZTri6QuXHJcbi8vIOy7rOufrOyWtOugiOydtOunjCDspIDruYTtlbTshJwg6re466as66m0IOuQnOuLpC5cclxuY29uc3QgZHJhd01lc2ggPSBuZXcgTWVzaCgpO1xyXG5cclxue1xyXG4gICAgbGV0IHZ0eCA9IFtdO1xyXG4gICAgbGV0IGlkeCA9IFtdO1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8PSAyNTU7IGkrKyApIHtcclxuICAgICAgICBsZXQgdiA9IHZ0eC5sZW5ndGggLyAyO1xyXG5cclxuICAgICAgICB2dHgucHVzaCggaSwwLCBpICsgMSwwLCBpLDEsIGkgKyAxLDEgKTtcclxuICAgICAgICBpZHgucHVzaCggdix2ICsgMSx2ICsgMiwgdiArIDEsdiArIDMsdiArIDIgKTtcclxuICAgIH1cclxuICAgIGRyYXdNZXNoLnNldFZlcnRleEFycmF5KCB2dHggKTtcclxuICAgIGRyYXdNZXNoLnNldEluZGV4QXJyYXkoIGlkeCApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWc1BhbGV0dGUge1xyXG4gICAgY29uc3RydWN0b3IoIHBhbE5hbWUgKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoIFV0aWxzLmdldEVtYmVkZGVkRmlsZSggYHBhbF8ke3BhbE5hbWV9Lmpzb25gICkgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fcnQgPSBuZXcgUmVuZGVyVGFyZ2V0KCAyNTYsMSxmYWxzZSApO1xyXG4gICAgICAgIHRoaXMuY29sb3JBcnJheSA9IGFycjtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3JBcnJheSA9IGFyci5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuX3NldEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5mYWRlSW5mbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yb3RhdGVJbmZvID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJhc2VTaGFkZXIgPSBuZXcgU2hhZGVyKCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBudWxsICk7XHJcbiAgICAgICAgLy8gc2V0VGltZW91dCggKCk9PntcclxuICAgICAgICAvLyAgICAgbGV0IGIgPSBuZXcgQml0bWFwKCB0aGlzLl9ydCApO1xyXG5cclxuICAgICAgICAvLyAgICAgYi5zY2FsZSA9IDE7XHJcbiAgICAgICAgLy8gICAgIHN0YWdlLmFkZENoaWxkKCBiICk7XHJcbiAgICAgICAgLy8gfSwxICk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHRleHR1cmUoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGBhYWFhYWFhYWFhYWFhYWFhYSBwYWxldHRlICR7dGhpcy5fcnQuYXNzZXQuaWR9YCApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ydDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtUZXh0dXJlQmFzZT19IGJhc2VUZXh0dXJlXHJcbiAgICAgKiBAcmV0dXJucyB7U2hhZGVyfVxyXG4gICAgICogQG1lbWJlcm9mIFZzUGFsZXR0ZVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVTaGFkZXIoIGJhc2VUZXh0dXJlICkge1xyXG4gICAgICAgIGxldCBzaDtcclxuXHJcbiAgICAgICAgaWYgKCBiYXNlVGV4dHVyZSApIHtcclxuICAgICAgICAgICAgc2ggPSAgdGhpcy5iYXNlU2hhZGVyLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHNoLnNldFRleHR1cmUoIFwicGFsZXR0ZVwiLHRoaXMuX3J0ICk7XHJcbiAgICAgICAgICAgIHNoLnNldFRleHR1cmUoIFwiYmFzZVwiLGJhc2VUZXh0dXJlICk7XHJcbiAgICAgICAgICAgIHNoLnNldENvbnN0YW50KCBcInRleFNpemVcIiwgYmFzZVRleHR1cmUuc2l6ZSApO1xyXG4gICAgICAgICAgICBzaC5zZXRDb25zdGFudCggXCJ3aGl0ZVwiLCAwICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2ggPSBub1RleFNoYWRlcjtcclxuICAgICAgICAgICAgc2guc2V0VGV4dHVyZSggXCJwYWxldHRlXCIsdGhpcy5fcnQgKTtcclxuICAgICAgICAgICAgc2guc2V0Q29uc3RhbnQoIFwid2hpdGVcIiwgMCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2g7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkKCB2YWx1ZSwgc3RhcnRSYW5nZSA9IDAsIGVuZFJhbmdlID0gMjU1ICkge1xyXG4gICAgICAgIGZvciAoIGxldCBpID0gc3RhcnRSYW5nZTsgaSA8PSBlbmRSYW5nZTsgaSsrICkge1xyXG4gICAgICAgICAgICBsZXQgYXJyID0gVXRpbHMuaGV4MnJnYmEoIHRoaXMuY29sb3JBcnJheVtpXSApO1xyXG4gICAgICAgICAgICBsZXQgcmFyciA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcmFyclswXSA9IFV0aWxzLmNsYW1wKCBhcnJbMF0gKyB2YWx1ZSwgMCwxICk7XHJcbiAgICAgICAgICAgIHJhcnJbMV0gPSBVdGlscy5jbGFtcCggYXJyWzFdICsgdmFsdWUsIDAsMSApO1xyXG4gICAgICAgICAgICByYXJyWzJdID0gVXRpbHMuY2xhbXAoIGFyclsyXSArIHZhbHVlLCAwLDEgKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yQXJyYXlbaV0gPSAoICggcmFyclswXSAqIDI1NSA8PCAxNiApIHwgKCByYXJyWzFdICogMjU1IDw8IDggKSB8ICggcmFyclsyXSAqIDI1NSApICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NldEFycmF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZmFkZSggb3B0aW9ucyApIHtcclxuICAgICAgICB0aGlzLmZhZGVJbmZvID0gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICByb3RhdGUoIG9wdGlvbnMgKSB7XHJcbiAgICAgICAgdGhpcy5yb3RhdGVJbmZvID0gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBfc2V0QXJyYXkoKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IHRoaXMuX2N1cnJlbnRDb2xvckFycmF5O1xyXG4gICAgICAgIGxldCBjb2xvcnMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDw9IDI1NTsgaSsrICApIHtcclxuICAgICAgICAgICAgY29sb3JzLnB1c2goIGFycltpXSwxLCBhcnJbaV0sMSwgYXJyW2ldLDEsIGFycltpXSwxICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRyYXdNZXNoLnNldENvbG9yQXJyYXkoIGNvbG9ycyApO1xyXG4gICAgICAgIHRoaXMuX3J0LmRyYXcoIGRyYXdNZXNoICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2VzcygpIHtcclxuICAgICAgICBpZiAoIHRoaXMuZmFkZUluZm8gKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gdGhpcy5mYWRlSW5mby5yYW5nZSA/IHRoaXMuZmFkZUluZm8ucmFuZ2VbMF0gOiAwO1xyXG4gICAgICAgICAgICBsZXQgZW5kUmFuZ2UgPSB0aGlzLmZhZGVJbmZvLnJhbmdlID8gdGhpcy5mYWRlSW5mby5yYW5nZVsxXSA6IDI1NTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0VmFsdWUgPSB0aGlzLmZhZGVJbmZvLnN0YXJ0IHx8IDA7XHJcbiAgICAgICAgICAgIGxldCBlbmRWYWx1ZSA9IHRoaXMuZmFkZUluZm8uZW5kIHx8IDA7XHJcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbiA9IHRoaXMuZmFkZUluZm8uZHVyYXRpb24gfHwgMDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmFkZUluZm8uY291bnQgPSB0aGlzLmZhZGVJbmZvLmNvdW50KysgfHwgMDtcclxuICAgICAgICAgICAgbGV0IHJhdGlvID0gTWF0aC5taW4oIDEsIGR1cmF0aW9uICE9IDAgPyB0aGlzLmZhZGVJbmZvLmNvdW50IC8gZHVyYXRpb24gOiAwICk7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IFV0aWxzLmxlcnAoIHN0YXJ0VmFsdWUsZW5kVmFsdWUscmF0aW8gKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGxldCBpID0gc3RhcnRSYW5nZTsgaSA8PSBlbmRSYW5nZTsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFyciA9IFV0aWxzLmhleDJyZ2JhKCB0aGlzLmNvbG9yQXJyYXlbaV0gKTtcclxuICAgICAgICAgICAgICAgIGxldCByYXJyID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgcmFyclswXSA9IFV0aWxzLmNsYW1wKCBhcnJbMF0gKyB2YWx1ZSwgMCwxICk7XHJcbiAgICAgICAgICAgICAgICByYXJyWzFdID0gVXRpbHMuY2xhbXAoIGFyclsxXSArIHZhbHVlLCAwLDEgKTtcclxuICAgICAgICAgICAgICAgIHJhcnJbMl0gPSBVdGlscy5jbGFtcCggYXJyWzJdICsgdmFsdWUsIDAsMSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yQXJyYXlbaV0gPSAoICggcmFyclswXSAqIDI1NSA8PCAxNiApIHwgKCByYXJyWzFdICogMjU1IDw8IDggKSB8ICggcmFyclsyXSAqIDI1NSApICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0QXJyYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5mYWRlSW5mby5jb3VudCsrO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuZmFkZUluZm8uY291bnQgPiB0aGlzLmZhZGVJbmZvLmR1cmF0aW9uICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlSW5mbyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB0aGlzLnJvdGF0ZUluZm8gKSB7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaW5kZXhUb0NvbG9yKCBpbmRleCApIHtcclxuICAgICAgICByZXR1cm4gKCAoIE1hdGguZmxvb3IoIGluZGV4IC8gMTYgKSAqIDE2ICkgPDwgMTYgKSB8ICggKCBpbmRleCAlIDE2ICkgKiAxNiA8PCA4ICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IFNwaW5lLCBDb21wb25lbnQsIENvbXBvbmVudEhvbGRlciwgU2NlbmVNYW5hZ2VyLCBTdG9yYWdlLCBUd2VlbiwgRm9udCwgUG9pbnQsIFJlY3QsIFRpbGVNYXAsTW92aWVDbGlwLFJlbmRlclRhcmdldCwgUGl4ZWwsZWFzaW5nLCBNZXNoLCBUZXh0dXJlUGFjaywgVXRpbHMsIE1hdHJpeCwgU2hhcGUsIFRpbWVyLCBUZXh0RmllbGQsIEV2ZW50LCBLZXlDb2RlLCBFdmVudERpc3BhdGNoZXIsXHJcbiAgICAgICAgIFNwcml0ZSwgU3RhZ2UsIEJpdG1hcCwgVGV4dHVyZSwgVGV4dHVyZUJhc2UsIEFwcGxpY2F0aW9uLCBTaGFkZXIsIFNvdW5kIH0gZnJvbSBcIkBlbmdpbmUvZmxhdGZhc3RcIjtcclxuXHJcbmltcG9ydCBWc1N0YWdlIGZyb20gXCIuL3ZzU3RhZ2VcIjtcclxuaW1wb3J0IFZzUGFsZXR0ZSBmcm9tIFwiLi92c1BhbGV0dGVcIjtcclxuaW1wb3J0IFZzV29ybGQgZnJvbSBcIi4vdnNXb3JsZFwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZzU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCBzcHJOYW1lLCBvcHRpb25zICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIGlmICggc3ByTmFtZSAhPSBudWxsICkge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZU5hbWUgPSBgc3ByXyR7c3ByTmFtZX0ucG5nYDtcclxuICAgICAgICAgICAgY29uc3Qgc3ByRGF0YSA9IEpTT04ucGFyc2UoIFV0aWxzLmdldEVtYmVkZGVkRmlsZSggYHNwcl8ke3Nwck5hbWV9Lmpzb25gICkgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX21lc2hlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZSggaW1hZ2VOYW1lICk7XHJcbiAgICAgICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHNwckRhdGEuaW1hZ2VzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGltZyA9IHNwckRhdGEuaW1hZ2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNyYyA9IGltZy5zb3VyY2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IGltZy54O1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBpbWcueTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNoZXNbaV0gPSBuZXcgTWVzaCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVzaGVzW2ldLnNldFZlcnRleEFycmF5KCBbeCx5LCB4ICsgc3JjLndpZHRoLHksIHgseSArIHNyYy5oZWlnaHQsIHggKyBzcmMud2lkdGgseSArIHNyYy5oZWlnaHRdICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGltZy5pbmZsaXAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmZsaXDsnYQg7JOw64qUIOy8gOydtOyKpOqwgCDqsbDsnZgg7JeG64qU642wXHJcbiAgICAgICAgICAgICAgICAvLyB47JeQIGltZy5mbGlwWOulvCDrr7jrpqwg642U7ZW07KSY7JW87ZWgIOyImOuPhCDsnojri6QuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzaGVzW2ldLnNldFRleHR1cmVDb29yZGluYXRlQXJyYXkoIFtzcmMueCArIHNyYy53aWR0aCxzcmMueSwgc3JjLngsc3JjLnksIHNyYy54ICsgc3JjLndpZHRoLHNyYy55ICsgc3JjLmhlaWdodCwgc3JjLngsc3JjLnkgKyBzcmMuaGVpZ2h0XSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc2hlc1tpXS52aXNpYmxlUmVjdCA9IG5ldyBSZWN0KCB4LHksc3JjLndpZHRoLHNyYy5oZWlnaHQgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzaGVzW2ldLnNldFRleHR1cmVDb29yZGluYXRlQXJyYXkoIFtzcmMueCxzcmMueSwgc3JjLnggKyBzcmMud2lkdGgsc3JjLnksIHNyYy54LHNyYy55ICsgc3JjLmhlaWdodCwgc3JjLnggKyBzcmMud2lkdGgsc3JjLnkgKyBzcmMuaGVpZ2h0XSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc2hlc1tpXS52aXNpYmxlUmVjdCA9IG5ldyBSZWN0KCB4LHksc3JjLndpZHRoLHNyYy5oZWlnaHQgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX21lc2hlc1tpXS5zZXRDb2xvckFycmF5KCBbMHhmZmZmZmYsMSwweGZmZmZmZiwxLDB4ZmZmZmZmLDEsMHhmZmZmZmYsMV0gKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21lc2hlc1tpXS5zZXRJbmRleEFycmF5KCBbMCwxLDIsMSwzLDJdICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNoZXNbaV0uc2V0VGV4dHVyZSggdGhpcy50ZXh0dXJlICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNoZXNbaV0uZmxpcFggPSBpbWcuZmxpcFg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNoZXNbaV0uZmxpcFkgPSBpbWcuZmxpcFk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNoZXNbaV0ucmFuZ2VzID0gaW1nLnJhbmdlcztcclxuICAgICAgICAgICAgLy8gM+qwnFxyXG4gICAgICAgICAgICAvLyB4MSx5MSx4Mix5MixmeCxmeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGxldCBhY3Rpb25OdW0gPSAwOyBhY3Rpb25OdW0gPCBzcHJEYXRhLmFjdGlvbnMubGVuZ3RoOyBhY3Rpb25OdW0rKyApIHtcclxuICAgICAgICAgICAgICAgIGxldCB0aW1lbGluZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lcyA9IHNwckRhdGEuYWN0aW9uc1thY3Rpb25OdW1dO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIGxldCBmcmFtZU51bSA9IDA7IGZyYW1lTnVtIDwgZnJhbWVzLmxlbmd0aDsgZnJhbWVOdW0rKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VOdW0gPSBmcmFtZXNbZnJhbWVOdW1dLmltYWdlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGltYWdlTnVtID09IC0xICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLnB1c2goIFstMSAsZnJhbWVzW2ZyYW1lTnVtXS54ID09IC0xID8gYWN0aW9uTnVtIDogZnJhbWVzW2ZyYW1lTnVtXS54LGZyYW1lc1tmcmFtZU51bV0ueV0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUucHVzaCggW2ltYWdlTnVtLCBmcmFtZXNbZnJhbWVOdW1dLngsIGZyYW1lc1tmcmFtZU51bV0ueSBdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWN0aW9uc1thY3Rpb25OdW1dID0gdGltZWxpbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9ucyA9IGFjdGlvbnM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVzaGVzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5pdCggb3B0aW9ucyApO1xyXG5cclxuICAgICAgICAvLyDssqsg7ZSE66CI7J6EIO2RnOyLnO2VoCDrqZTsi5zrpbwg7IWL7JeFXHJcbiAgICAgICAgdGhpcy51cGRhdGVWaXN1YWwoKTtcclxuXHJcbiAgICAgICAgaWYgKCBWc1N0YWdlLmluc3RhbmNlLnBhbGV0dGUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGFsZXR0ZSggVnNTdGFnZS5pbnN0YW5jZS5wYWxldHRlICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vbmNlKCBFdmVudC5BRERFRF9UT19TVEFHRSwoKT0+e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYWxldHRlKCBWc1N0YWdlLmluc3RhbmNlLnBhbGV0dGUgKTtcclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfaW5pdCggb3B0aW9ucyApIHtcclxuICAgICAgICB0aGlzLl93aGl0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZmxpY2tlciA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLmF1dG9SZW1vdmVUaW1lciA9IDA7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdG9wQ291bnRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDE7XHJcblxyXG4gICAgICAgIHRoaXMuYXR0cmliID0gT2JqZWN0LmFzc2lnbigge30sVnNTcHJpdGUuZGVmYXVsdEF0dHJpYiApO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubWFwQ29sbGlzaW9uQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQ2FsbGJhY2sgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLmZsaXBYID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFBvaW50KCAwLDAgKTtcclxuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBQb2ludCggMCwwICk7XHJcblxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIHRoaXMsb3B0aW9ucyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6rCZ7J2AIOuNsOydtO2EsOulvCDsgqzsmqntlZjripQg7Iqk7ZSE65287J207Yq466W8IOyDneyEse2VnOuLpFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1ZzU3ByaXRlfVxyXG4gICAgICogQG1lbWJlcm9mIFZzU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVZzU3ByaXRlKCBvcHRpb25zICkge1xyXG4gICAgICAgIGNvbnN0IHNwciA9IG5ldyBTcHJpdGUoKTtcclxuXHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKCBzcHIsVnNTcHJpdGUucHJvdG90eXBlICk7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbiggc3ByLCB7XHJcbiAgICAgICAgICAgIF9tZXNoZXM6IHRoaXMuX21lc2hlcy5tYXAoIGU9PntcclxuICAgICAgICAgICAgICAgIGxldCBtID0gZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIG0udmlzaWJsZVJlY3QgPSBlLnZpc2libGVSZWN0O1xyXG4gICAgICAgICAgICAgICAgbS5mbGlwWCA9IGUuZmxpcFg7XHJcbiAgICAgICAgICAgICAgICBtLmZsaXBZID0gZS5mbGlwWTtcclxuICAgICAgICAgICAgICAgIG0ucmFuZ2VzID0gZS5yYW5nZXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICAgICAgfSApLFxyXG4gICAgICAgICAgICBfYWN0aW9uczogdGhpcy5fYWN0aW9ucyxcclxuICAgICAgICAgICAgdGV4dHVyZTogIHRoaXMudGV4dHVyZVxyXG4gICAgICAgIH0gKTtcclxuICAgICAgICBcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICBzcHIuc2V0UGFsZXR0ZSggVnNTdGFnZS5pbnN0YW5jZS5wYWxldHRlICk7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgc3ByLl9pbml0KCBvcHRpb25zICk7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgc3ByLnVwZGF0ZVZpc3VhbCgpO1xyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiBzcHI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1cclxuICAgICAqIEByZXR1cm5zIHtmbGF0ZmFzdC5pbnN0YW5jZU9mLk1lc2h9XHJcbiAgICAgKiBAbWVtYmVyb2YgVnNTcHJpdGVcclxuICAgICAqL1xyXG4gICAgZ2V0TWVzaCggbnVtICkge1xyXG4gICAgICAgIGxldCBzaCA9IHRoaXMuX21lc2hlc1tudW1dLmdldFNoYWRlcigpO1xyXG4gICAgICAgIGxldCBtID0gdGhpcy5fbWVzaGVzW251bV0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgbS5zZXRTaGFkZXIoIHNoICk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGFjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEFjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgYWN0aW9uKCBhICkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBhO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWaXN1YWwoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZnJhbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRGcmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgZnJhbWUoIGYgKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lID0gZjtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZpc3VhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBhbGV0dGUoIHBhbCApIHtcclxuICAgICAgICBjb25zb2xlLmFzc2VydCggcGFsIGluc3RhbmNlb2YgVnNQYWxldHRlLCBg7YyU66CI7Yq46rCAIOygnOuMgOuhnCDshLjtjIXrkJjslrTsnojsp4Ag7JWK7Iq164uI64ukYCApO1xyXG4gICAgICAgIGxldCBzaCA9IHBhbC5jcmVhdGVTaGFkZXIoIHRoaXMudGV4dHVyZSApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuX21lc2hlcyA9PSBudWxsICkgcmV0dXJuO1xyXG4gICAgICAgIGZvciAoIGxldCBiIG9mIE9iamVjdC52YWx1ZXMoIHRoaXMuX21lc2hlcyApICkge1xyXG4gICAgICAgICAgICBiLnNldFNoYWRlciggc2ggKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHdoaXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aGl0ZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgd2hpdGUoIHYgKSB7XHJcbiAgICAgICAgdGhpcy5fd2hpdGUgPSB2O1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoLmdldFNoYWRlcigpLnNldENvbnN0YW50KCBcIndoaXRlXCIsdiApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGFjdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBmcmFtZVxyXG4gICAgICogQG1lbWJlcm9mIFZzU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIHNldEFjdGlvbiggYWN0aW9uLCBmcmFtZSApIHtcclxuICAgICAgICBpZiAoIGFjdGlvbiA9PSBudWxsICkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSBmcmFtZSA9PSBudWxsID8gdGhpcy5fY3VycmVudEZyYW1lIDogZnJhbWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLl9jdXJyZW50QWN0aW9uID09IGFjdGlvbiApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IGZyYW1lID09IG51bGwgPyB0aGlzLl9jdXJyZW50RnJhbWUgOiBmcmFtZTsgICAgXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lID0gZnJhbWUgPT0gbnVsbCA/IDAgOiBmcmFtZTsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVWaXN1YWwoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVWaXN1YWwoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLl9hY3Rpb25zID09IG51bGwgKSByZXR1cm4gbmV3IFBvaW50KCAwLDAgKTtcclxuICAgICAgICBsZXQgZnJhbWVEYXRhID0gdGhpcy5fYWN0aW9uc1t0aGlzLl9jdXJyZW50QWN0aW9uXVt0aGlzLl9jdXJyZW50RnJhbWVdO1xyXG5cclxuICAgICAgICBjb25zdCBvbGRJbWFnZUZyYW1lID0gdGhpcy5fb2xkSW1hZ2VGcmFtZTtcclxuXHJcbiAgICAgICAgaWYgKCBmcmFtZURhdGFbMF0gPT0gLTEgKSB7XHJcbiAgICAgICAgICAgIGlmICggZnJhbWVEYXRhWzFdID09IC0yICkge1xyXG4gICAgICAgICAgICAgICAgLy8g64Gd64KY64qUIO2UhOugiOyehFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoIFwiZW5kT2ZBbmltYXRpb25cIiApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCggMCwwICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGZyYW1lRGF0YVsxXSAhPSAtMSApIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBmcmFtZURhdGFbMV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSBmcmFtZURhdGFbMl07XHJcbiAgICAgICAgICAgICAgICBmcmFtZURhdGEgPSB0aGlzLl9hY3Rpb25zW3RoaXMuX2N1cnJlbnRBY3Rpb25dW3RoaXMuX2N1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IFxyXG4gICAgICAgIGlmICggb2xkSW1hZ2VGcmFtZSAhPSBmcmFtZURhdGFbMF0gKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29sZEltYWdlRnJhbWUgPSBmcmFtZURhdGFbMF07XHJcbiAgICAgICAgICAgIGxldCBvbGRXb3JsZE1hdHJpeCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuX2N1cnJlbnRNZXNoICkge1xyXG4gICAgICAgICAgICAgICAgb2xkV29ybGRNYXRyaXggPSB0aGlzLl9jdXJyZW50TWVzaC53b3JsZE1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoLnJlbW92ZUZyb21QYXJlbnQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE1lc2ggPSB0aGlzLl9tZXNoZXNbZnJhbWVEYXRhWzBdXTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE1lc2guc2NhbGVYID0gdGhpcy5mbGlwWCA/IC0xIDogMTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE1lc2gueCA9IHRoaXMuZmxpcFggPyB0aGlzLl9jdXJyZW50TWVzaC5mbGlwWCA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoLnNjYWxlWSA9IHRoaXMuZmxpcFkgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoLnkgPSB0aGlzLmZsaXBZID8gdGhpcy5fY3VycmVudE1lc2guZmxpcFkgOiAwO1xyXG4gICAgICAgICAgICBpZiAoIG9sZFdvcmxkTWF0cml4ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE1lc2guc2V0Q3VzdG9tUHJldiggb2xkV29ybGRNYXRyaXgsdGhpcy5fY3VycmVudE1lc2guY29sb3JPdmVycmlkZSx0aGlzLl9jdXJyZW50TWVzaC5hbmNob3JYLHRoaXMuX2N1cnJlbnRNZXNoLmFuY2hvclkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYXR0cmliLmVuYWJsZUhpZGVNZXNoID09IGZhbHNlICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZEF0KCB0aGlzLl9jdXJyZW50TWVzaCwwICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcy5fY3VycmVudE1lc2gudXBkYXRlQ29kZSAhPSBTcHJpdGUuVXBkYXRlQ29kZXMuVVBEQVRFX0NMRUFSX1BSRVY7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCggZnJhbWVEYXRhWzFdLGZyYW1lRGF0YVsyXSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVnNTcHJpdGXrgbzrpqwg7Lap64+M6rKA7IKsLiByYW5nZeuBvOumrCDqsoDsgqztlZzri6QgcmFuZ2XripQgMH4y7IKs7J20XHJcbiAgICAgKiB0aGlz7JmAIHRhcmdldOydtCDsnbzsuZjtlZjrqbQg7ZWt7IOBIGZhbHNl7J2064ukLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7VnNTcHJpdGV9IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY1JhbmdlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHN0UmFuZ2VcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQG1lbWJlcm9mIFZzU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGNoZWNrUmFuZ2UoIHRhcmdldCxzcmNSYW5nZSxkc3RSYW5nZSApIHtcclxuICAgICAgICBpZiAoIHRoaXMgPT0gdGFyZ2V0ICkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGxldCByMSA9IHRoaXMuX2N1cnJlbnRNZXNoLnJhbmdlc1tzcmNSYW5nZV07XHJcbiAgICAgICAgbGV0IHIyID0gdGFyZ2V0Ll9jdXJyZW50TWVzaC5yYW5nZXNbZHN0UmFuZ2VdO1xyXG4gICAgICAgIGxldCBzeDEgPSByMS54MSArICggdGhpcy5mbGlwWCA/IHIxLmZ4IDogMCApO1xyXG4gICAgICAgIGxldCBzeTEgPSByMS55MSArICggdGhpcy5mbGlwWSA/IHIxLmZ5IDogMCApO1xyXG4gICAgICAgIGxldCBzeDIgPSByMS54MiArICggdGhpcy5mbGlwWCA/IHIxLmZ4IDogMCApO1xyXG4gICAgICAgIGxldCBzeTIgPSByMS55MiArICggdGhpcy5mbGlwWSA/IHIxLmZ5IDogMCApO1xyXG4gICAgICAgIGxldCBkeDEgPSByMi54MSArICggdGFyZ2V0LmZsaXBYID8gcjIuZnggOiAwICk7XHJcbiAgICAgICAgbGV0IGR5MSA9IHIyLnkxICsgKCB0YXJnZXQuZmxpcFkgPyByMi5meSA6IDAgKTtcclxuICAgICAgICBsZXQgZHgyID0gcjIueDIgKyAoIHRhcmdldC5mbGlwWCA/IHIyLmZ4IDogMCApO1xyXG4gICAgICAgIGxldCBkeTIgPSByMi55MiArICggdGFyZ2V0LmZsaXBZID8gcjIuZnkgOiAwICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHBzMSA9IHRoaXMubG9jYWxUb0dsb2JhbCggc3gxLHN5MSApO1xyXG4gICAgICAgIGxldCBwczIgPSB0aGlzLmxvY2FsVG9HbG9iYWwoIHN4MixzeTIgKTtcclxuICAgICAgICBsZXQgcGQxID0gdGFyZ2V0LmxvY2FsVG9HbG9iYWwoIGR4MSxkeTEgKTtcclxuICAgICAgICBsZXQgcGQyID0gdGFyZ2V0LmxvY2FsVG9HbG9iYWwoIGR4MixkeTIgKTtcclxuXHJcbiAgICAgICAgaWYgKCBwczIueCA8IHBkMS54IHx8IHBzMS54ID4gcGQyLnggfHwgcHMyLnkgPCBwZDEueSB8fCBwczEueSA+IHBkMi55ICkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVZlbG9jaXR5QW5kQWNjZWxlcmF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZCggdGhpcy5hY2NlbGVyYXRpb24gKTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9PSBmYWxzZSAmJiBWc1N0YWdlLmluc3RhbmNlLndvcmxkICkge1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eS5hZGQoIFZzU3RhZ2UuaW5zdGFuY2Uud29ybGQuZ3Jhdml0eSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRNYXBDb2xsaXNpb25QaGFzZUNhbGxiYWNrKCBmdW5jICkge1xyXG4gICAgICAgIHRoaXMubWFwQ29sbGlzaW9uQ2FsbGJhY2sgPSBmdW5jO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFVwZGF0ZVBoYXNlQ2FsbGJhY2soIGZ1bmMgKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IGZ1bmM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0Q29sbGlzaW9uUGhhc2VDYWxsYmFjayggZnVuYyApIHtcclxuICAgICAgICB0aGlzLmNvbGxpc2lvbkNhbGxiYWNrID0gZnVuYztcclxuICAgIH1cclxuXHJcbiAgICBzZXRSZW1vdmVDYWxsYmFjayggZnVuYyApIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUNhbGxiYWNrID0gZnVuYztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSByZWFzb25cclxuICAgICAqIEBtZW1iZXJvZiBWc1Nwcml0ZVxyXG4gICAgICovXHJcbiAgICByZW1vdmUoIHJlYXNvbiApIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggcmVhc29uICk7XHJcbiAgICAgICAgLy8g7LKY66asIOuPhOykkSDri6Trpbgg7J2067Kk7Yq466GcIO2KgOuKlCDqsr3smrDrpbwg66eJ6riwIOychO2VtOyEnCDrgYrslrTspIDri6RcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tUGFyZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7VnNTcHJpdGVbXX0gb3RoZXJTcHJpdGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgVnNTcHJpdGVcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzcyggb3RoZXJTcHJpdGVzICkge1xyXG4gICAgICAgIC8vIGF1dG9SZW1vdmVUaW1lciDsspjrpqwuIOy1nOy0iOyXkCAw7J2066m0IOyekeuPmeyViO2VqFxyXG4gICAgICAgIGlmICggdGhpcy5hdXRvUmVtb3ZlVGltZXIgPiAwICkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9SZW1vdmVUaW1lci0tO1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYXV0b1JlbW92ZVRpbWVyID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSggXCJhdXRvUmVtb3ZlVGltZXJcIiApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVZlbG9jaXR5QW5kQWNjZWxlcmF0aW9uKCk7IC8vIOyGjeuPhCwg6rCA7IaN64+ELCDspJHroKVcclxuICAgICAgICBsZXQgZGVsdGEgPSBuZXcgUG9pbnQoIDAsMCApO1xyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYXR0cmliLmRpc2FibGVWZWxvY2l0eSA9PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YS5hZGQoIHRoaXMudmVsb2NpdHkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5hdHRyaWIuZGlzYWJsZUdsb2JhbFZlbG9jaXR5ID09IGZhbHNlICYmIFZzU3RhZ2UuaW5zdGFuY2Uud29ybGQgKSB7XHJcbiAgICAgICAgICAgIGRlbHRhID0gZGVsdGEuYWRkKCBWc1N0YWdlLmluc3RhbmNlLndvcmxkLmNvbnN0YW50VmVsb2NpdHkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy5hbmltYXRpb25TdG9wQ291bnRlciA9PSAwICkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUrKztcclxuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YS5hZGQoIHRoaXMudXBkYXRlVmlzdWFsKCkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByMCA9IHRoaXMuX2N1cnJlbnRNZXNoICYmIHRoaXMuX2N1cnJlbnRNZXNoLnJhbmdlc1swXTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmF0dHJpYi5lbmFibGVEZWJ1ZyAmJiByMCApIHtcclxuICAgICAgICAgICAgaWYgKCB0aGlzLmRlYnVnU2hhcGUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnU2hhcGUucmVtb3ZlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBzID0gbmV3IFNoYXBlKCk7XHJcblxyXG4gICAgICAgICAgICBzLm1ha2VCb3goIHIwLngxLHIwLnkxLHIwLngyIC0gcjAueDEgKyAxLHIwLnkyIC0gcjAueTEgKyAxLDB4ZmYwMDAwLDAuNyApO1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnU2hhcGUgPSBzO1xyXG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKCBzICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBwdXNoIOyymOumrFxyXG4gICAgICAgIC8vIOuLpOuluCDsiqTtlITrnbzsnbTtirjrpbwg66+464qUIOyymOumrFxyXG5cclxuICAgICAgICBpZiAoIHRoaXMuYXR0cmliLmVuYWJsZVB1c2ggPT0gZmFsc2UgKSB7XHJcbiAgICAgICAgICAgIC8vIHB1c2gg7IaN7ISx7J20IOyXhuydhCDqsr3smrDsl5Ag64K0IOyKpO2UhOudvOydtO2KuOulvCDrsIDroKTrgpjqsowg7ZWY6riwIOychO2VnCDsspjrpqxcclxuICAgICAgICAgICAgZm9yICggbGV0IHNwciBvZiBvdGhlclNwcml0ZXMgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHNwci5hdHRyaWIuZW5hYmxlQmxvY2sgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2sg7IaN7ISx7J20IOy8nOynhCDqsr3smrBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCAoIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvbkxlZnQgfHwgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uUmlnaHQgfHwgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uVG9wIHx8IHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvbkJvdHRvbSApICYmIHRoaXMuYW5pbWF0aW9uU3RvcENvdW50ZXIgPT0gMCApIHtcclxuICAgICAgICAgICAgLy8g66e17Lap64+MIOyInOyEnOuKlCDrsJTri6UsIOyynOyepSwg7Jqw7LihLCDsoozsuKFcclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtWc1dvcmxkfSAqL1xyXG4gICAgICAgICAgICBjb25zdCB3b3JsZCA9IFZzU3RhZ2UuaW5zdGFuY2Uud29ybGQ7XHJcblxyXG4gICAgICAgICAgICBsZXQgYWRqdXN0ID0gbmV3IFBvaW50KCAwLDAgKTtcclxuICAgICAgICAgICAgbGV0IGFkanVzdFZlbG9jaXR5ID0gbmV3IFBvaW50KCAwLDAgKTtcclxuICAgICAgICAgICAgbGV0IHRvdWNoZWRNYXBBdHRyaWIgPSAwO1xyXG4gICAgICAgICAgICBsZXQgb3BvcyA9IHRoaXMucG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiDsiqTtlITrnbzsnbTtirjqsIAg6rOE7KadIOq1rOyhsOqwgCDrkJjripQg6rK97Jqw66W8IOy7pOuyhO2VtOyVvO2VqFxyXG4gICAgICAgICAgICAvLyDsooztkZzqs4Qg67CU6r6464qUIOyymOumrOqwgCDtlYTsmpTtlZjri6RcclxuXHJcbiAgICAgICAgICAgIGxldCBscG9zID0gbmV3IFBvaW50KCB0aGlzLnggKyBkZWx0YS54LHRoaXMueSArIGRlbHRhLnkgKTtcclxuICAgICAgICAgICAgbGV0IGNvbGxpZGVMaXN0ID0gW107XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvbkJvdHRvbSAmJiBkZWx0YS55ID4gMCApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoIGxldCB4ID0gKCAoIGxwb3MueCArIHIwLngxICkgPj4gNCApOyB4IDw9ICggKCBscG9zLnggKyByMC54MiApID4+IDQgKTsgeCsrICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSAoIGxwb3MueSArIHIwLnkyICsgMSApID4+IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFwQXR0cmliID0gd29ybGQuZ2V0TWFwQXR0cmliKCB4LHkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXBBdHRyaWIgJiBWc1dvcmxkLlRJTEVBVFRSSUJfRkxPT1IgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpZGVMaXN0LnB1c2goIFt4LHksd29ybGQuZ2V0TWFwKCB4LHkgKV0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHRvdWNoZWRNYXBBdHRyaWIgJiBWc1dvcmxkLlRJTEVBVFRSSUJfRkxPT1IgKSA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0LnkgPSAtKCAoIGxwb3MueSArIHIwLnkyICsgMSApICUgMTYgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFZlbG9jaXR5LnkgPSAtdGhpcy52ZWxvY2l0eS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hlZE1hcEF0dHJpYiB8PSBWc1dvcmxkLlRJTEVBVFRSSUJfRkxPT1I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uVG9wICYmIGRlbHRhLnkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgZm9yICggbGV0IHggPSAoICggbHBvcy54ICsgcjAueDEgKSA+PiA0ICk7IHggPD0gKCAoIGxwb3MueCArIHIwLngyICkgPj4gNCApOyB4KysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9ICggbHBvcy55ICsgcjAueTEgKSA+PiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcEF0dHJpYiA9IHdvcmxkLmdldE1hcEF0dHJpYiggeCx5ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWFwQXR0cmliICYgVnNXb3JsZC5USUxFQVRUUklCX0NFSUwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpZGVMaXN0LnB1c2goIFt4LHksd29ybGQuZ2V0TWFwKCB4LHkgKV0gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIHRvdWNoZWRNYXBBdHRyaWIgJiBWc1dvcmxkLlRJTEVBVFRSSUJfQ0VJTCApID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3QueSA9IC0oIDE2IC0gKCBscG9zLnkgKyByMC55MSApICUgMTYgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFZlbG9jaXR5LnkgPSAtdGhpcy52ZWxvY2l0eS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hlZE1hcEF0dHJpYiB8PSBWc1dvcmxkLlRJTEVBVFRSSUJfQ0VJTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyDspJHroKXsl5Ag7J2Y7ZW07IScIOuwlOuLpeyXkCDstqnrj4ztlojsnYQg65WMIOuwlOuLpeuptOqzvCDsoozsmrAg7Lap64+M7ZWY7KeAIOyViuuPhOuhnSDtlZjquLAg7JyE7ZW07IScIOyXrOq4sOyEnCDrs7TsoJUg7LKY66asIO2VnOuLpCAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBscG9zLnkgKz0gYWRqdXN0Lnk7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uUmlnaHQgJiYgZGVsdGEueCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKCBsZXQgeSA9ICggKCBscG9zLnkgKyByMC55MSApID4+IDQgKTsgeSA8PSAoICggbHBvcy55ICsgcjAueTIgKSA+PiA0ICk7IHkrKyApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gKCBscG9zLnggKyByMC54MiArIDEgKSA+PiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcEF0dHJpYiA9IHdvcmxkLmdldE1hcEF0dHJpYiggeCwgeSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hcEF0dHJpYiAmIFZzV29ybGQuVElMRUFUVFJJQl9SV0FMTCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlkZUxpc3QucHVzaCggW3gseSx3b3JsZC5nZXRNYXAoIHgseSApXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggdG91Y2hlZE1hcEF0dHJpYiAmIFZzV29ybGQuVElMRUFUVFJJQl9SV0FMTCApID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3QueCA9IC0oICggbHBvcy54ICsgcjAueDIgKyAxICkgJSAxNiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0VmVsb2NpdHkueCA9IC10aGlzLnZlbG9jaXR5Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaGVkTWFwQXR0cmliIHw9IFZzV29ybGQuVElMRUFUVFJJQl9SV0FMTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25MZWZ0ICYmIGRlbHRhLnggPCAwICkge1xyXG4gICAgICAgICAgICAgICAgZm9yICggbGV0IHkgPSAoICggbHBvcy55ICsgcjAueTEgKSA+PiA0ICk7IHkgPD0gKCAoIGxwb3MueSArIHIwLnkyICkgPj4gNCApOyB5KysgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9ICggbHBvcy54ICsgcjAueDEgKSA+PiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcEF0dHJpYiA9IHdvcmxkLmdldE1hcEF0dHJpYiggeCwgeSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hcEF0dHJpYiAmIFZzV29ybGQuVElMRUFUVFJJQl9MV0FMTCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlkZUxpc3QucHVzaCggW3gseSx3b3JsZC5nZXRNYXAoIHgseSApXSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggdG91Y2hlZE1hcEF0dHJpYiAmIFZzV29ybGQuVElMRUFUVFJJQl9MV0FMTCApID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3QueCA9IC0oIDE2IC0gKCBscG9zLnggKyByMC54MSApICUgMTYgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdFZlbG9jaXR5LnggPSAtdGhpcy52ZWxvY2l0eS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hlZE1hcEF0dHJpYiB8PSBWc1dvcmxkLlRJTEVBVFRSSUJfTFdBTEw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVE9ETzog67mX66m0IOu4lOuhneyymOumrOqwgCDrk6TslrTqsIgg7J6Q66asLiBwYWxvMuyXkOuKlCDsmqnrn4kg65WM66y47JeQIOu5l+uptCDruJTroZ3sspjrpqzrpbwg67qQ64ukLlxyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLm1hcENvbGxpc2lvbkNhbGxiYWNrICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBDb2xsaXNpb25DYWxsYmFjay5jYWxsKCB0aGlzLCB0b3VjaGVkTWFwQXR0cmliLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0LCBhZGp1c3RWZWxvY2l0eSxjb2xsaWRlTGlzdFxyXG4gICAgICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhLmFkZCggYWRqdXN0ICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYXR0cmliLmRpc2FibGVWZWxvY2l0eSA9PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZCggYWRqdXN0VmVsb2NpdHkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5hbmltYXRpb25TdG9wQ291bnRlciA+IDAgKSB0aGlzLmFuaW1hdGlvblN0b3BDb3VudGVyLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmFkZCggZGVsdGEgKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggdGhpcy55LHRoaXMuX2N1cnJlbnRGcmFtZSxkZWx0YS55ICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJlcGFyZURyYXcoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLmF0dHJpYi5lbmFibGVGbGlja2VyICkge1xyXG4gICAgICAgICAgICB0aGlzLl9mbGlja2VyID0gMSAtIHRoaXMuX2ZsaWNrZXI7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5fZmxpY2tlciApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoLnNldFZpc2libGUoIGZhbHNlICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TWVzaC5zZXRWaXNpYmxlKCB0cnVlICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIHRoaXMuX2N1cnJlbnRNZXNoICkgdGhpcy5fY3VycmVudE1lc2guc2V0VmlzaWJsZSggdHJ1ZSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDtmZTrqbQg67CW7Jy866GcIOuCmOqwgOuptCDsnpDrj5nsnLzroZwg7IKs65287KeA64+E66GdIO2VnOuLpFxyXG4gICAgICAgIGlmICggdGhpcy5hdHRyaWIuZW5hYmxlQXV0b1JlbW92ZVN0YWdlT3V0ICkge1xyXG4gICAgICAgICAgICAvKiogQHR5cGUge1ZzV29ybGR9ICovXHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkID0gVnNTdGFnZS5pbnN0YW5jZS53b3JsZDtcclxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuUmVjdCA9IG5ldyBSZWN0KCAtd29ybGQueCwtd29ybGQueSxWc1N0YWdlLmluc3RhbmNlLndpZHRoLFZzU3RhZ2UuaW5zdGFuY2UuaGVpZ2h0ICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuX21lc2hlcyApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc2hSZWN0ID0gdGhpcy5fY3VycmVudE1lc2gudmlzaWJsZVJlY3Q7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLnggKyBtZXNoUmVjdC5yaWdodCA8IHNjcmVlblJlY3QubGVmdCB8fCB0aGlzLnggKyBtZXNoUmVjdC5sZWZ0ID4gc2NyZWVuUmVjdC5yaWdodCB8fCBcclxuICAgICAgICAgICAgICAgIHRoaXMueSArIG1lc2hSZWN0LnRvcCA+IHNjcmVlblJlY3QuYm90dG9tIHx8IHRoaXMueSArIG1lc2hSZWN0LmJvdHRvbSA8IHNjcmVlblJlY3QudG9wICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCBcImF1dG9SZW1vdmVTdGFnZU91dFwiICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMueCA8IHNjcmVlblJlY3QubGVmdCB8fCB0aGlzLnggPiBzY3JlZW5SZWN0LnJpZ2h0IHx8IFxyXG4gICAgICAgICAgICAgICAgdGhpcy55ID4gc2NyZWVuUmVjdC5ib3R0b20gfHwgdGhpcy55IDwgc2NyZWVuUmVjdC50b3AgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoIFwiYXV0b1JlbW92ZVN0YWdlT3V0XCIgKTtcclxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcHJvY2Vzc0FsbFNwcml0ZXMoKSB7XHJcbiAgICAgICAgLyoqIEB0eXBlIHtTcHJpdGVbXX0gKi9cclxuICAgICAgICBsZXQgc3BycyA9IFZzU3RhZ2UuaW5zdGFuY2Uuc2VhcmNoQ2hpbGRyZW4oIHRydWUgKTtcclxuXHJcbiAgICAgICAgbGV0IHZzU3BycyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCBsZXQgc3ByIG9mIHNwcnMgKSB7XHJcbiAgICAgICAgICAgIGlmICggIXNwci5wYXJlbnQgKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggVnNTdGFnZS5pbnN0YW5jZS5jaGlsZHJlbiApO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIHNwci5wYXJlbnQgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHNwciBpbnN0YW5jZW9mIFZzU3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBzcHIudXBkYXRlQ2FsbGJhY2sgKSBzcHIudXBkYXRlQ2FsbGJhY2suY2FsbCggc3ByICk7XHJcbiAgICAgICAgICAgICAgICB2c1NwcnMucHVzaCggc3ByICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIGxldCBzcHIgb2YgdnNTcHJzICkge1xyXG4gICAgICAgICAgICBzcHIucHJvY2VzcyggdnNTcHJzICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCBsZXQgc3ByIG9mIHZzU3BycyApIHtcclxuICAgICAgICAgICAgaWYgKCBzcHIuY29sbGlzaW9uQ2FsbGJhY2sgKSBzcHIuY29sbGlzaW9uQ2FsbGJhY2suY2FsbCggc3ByLHZzU3BycyApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggbGV0IHNwciBvZiB2c1NwcnMgKSB7XHJcbiAgICAgICAgICAgIHNwci5wcmVwYXJlRHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggdnNTcHJzLmxlbmd0aCApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyByZW1vdmVBbGxTcHJpdGVzKCkge1xyXG4gICAgICAgIGxldCBzcHJzID0gc3RhZ2Uuc2VhcmNoQ2hpbGRyZW4oIHRydWUgKTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IHNwciBvZiBzcHJzICkge1xyXG4gICAgICAgICAgICBpZiAoIHNwci5pc1ZzU3ByaXRlICkge1xyXG4gICAgICAgICAgICAgICAgc3ByLnJlbW92ZSggXCJyZW1vdmVBbGxcIiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblZzU3ByaXRlLkRJUl9MRUZUID0gMHgxMDtcclxuVnNTcHJpdGUuRElSX1JJR0hUID0gMHgyMDtcclxuVnNTcHJpdGUuRElSX1RPUCA9IDB4NDA7XHJcblZzU3ByaXRlLkRJUl9CT1RPT00gPSAweDgwO1xyXG5cclxuVnNTcHJpdGUuZGVmYXVsdEF0dHJpYiA9IHtcclxuICAgIGRpc2FibGVHcmF2aXR5OiAgICAgICAgICAgZmFsc2UsXHJcbiAgICBkaXNhYmxlR2xvYmFsVmVsb2NpdHk6ICAgIGZhbHNlLFxyXG4gICAgZGlzYWJsZVZlbG9jaXR5OiAgICAgICAgICBmYWxzZSxcclxuICAgIGRpc2FibGVDaGFpbkFuaW1hdGlvbjogICAgZmFsc2UsXHJcbiAgICBlbmFibGVBdXRvUmVtb3ZlU3RhZ2VPdXQ6IGZhbHNlLFxyXG4gICAgZW5hYmxlUHVzaDogICAgICAgICAgICAgICBmYWxzZSwgICAgICAgIC8vIHB1c2gg7IaN7ISx7J2EIOy8nOuptCBibG9ja+yGjeyEseydhCDqsIDsp4Qg7Iqk7ZSE65287J207Yq466W8IOuwgCDsiJgg7J6I64ukXHJcbiAgICBlbmFibGVCbG9jazogICAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgZW5hYmxlTWFwQ29sbGlzaW9uVG9wOiAgICBmYWxzZSxcclxuICAgIGVuYWJsZU1hcENvbGxpc2lvbkJvdHRvbTogZmFsc2UsXHJcbiAgICBlbmFibGVNYXBDb2xsaXNpb25MZWZ0OiAgIGZhbHNlLFxyXG4gICAgZW5hYmxlTWFwQ29sbGlzaW9uUmlnaHQ6ICBmYWxzZSxcclxuICAgIGVuYWJsZUhpZGVNZXNoOiAgICAgICAgICAgZmFsc2UsXHJcbiAgICBlbmFibGVGbGlja2VyOiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgaXNTY3JlZW5Db29yZGluYXRlOiAgICAgICBmYWxzZSxcclxuICAgIGRza2lwOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsICAgICAgICAvLyA/P1xyXG4gICAgZW5hYmxlRGVidWc6ICAgICAgICAgICAgICBmYWxzZSxcclxufTtcclxuXHJcbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZShcclxuLy8gICAgICgpPT57XHJcbi8vICAgICAgICAgY29uc29sZS5hc3NlcnQoIHZzU3RhZ2UsYHZzU3RhZ2XqsIAg7LSI6riw7ZmU65CY7KeAIOyViuyVmOyKteuLiOuLpC5gICk7XHJcbi8vICAgICAgICAgVnNTdGFnZS5pbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKCBFdmVudC5FTlRFUl9GUkFNRSxWc1Nwcml0ZS5wcm9jZXNzQWxsU3ByaXRlcyApO1xyXG4vLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBgdnNTcHJpdGU6IHByb2Nlc3NBbGzsnYQg65Ox66Gd7ZaI7Iq164uI64ukLmAgKTtcclxuLy8gICAgIH1cclxuLy8gKTtcclxuXHJcblxyXG5cclxuLy8gR0xPQkFMLlZzU3ByaXRlID0gVnNTcHJpdGU7XHJcbi8vIG1vZHVsZS5leHBvcnRzID0gVnNTcHJpdGU7XHJcbiIsImltcG9ydCB7IHN0YWdlLFNwaW5lLCBDb21wb25lbnQsIENvbXBvbmVudEhvbGRlciwgU2NlbmVNYW5hZ2VyLCBhcHBsaWNhdGlvbiwgU3RvcmFnZSwgVHdlZW4sIEZvbnQsIFBvaW50LCBSZWN0LCBUaWxlTWFwLE1vdmllQ2xpcCxSZW5kZXJUYXJnZXQsIFBpeGVsLGVhc2luZywgTWVzaCwgVGV4dHVyZVBhY2ssIFV0aWxzLCBNYXRyaXgsIFNoYXBlLCBUaW1lciwgVGV4dEZpZWxkLCBFdmVudCwgRXZlbnREaXNwYXRjaGVyLFxyXG4gICAgICAgICBTcHJpdGUsIFN0YWdlLCBCaXRtYXAsIFRleHR1cmUsIFRleHR1cmVCYXNlLCBBcHBsaWNhdGlvbiwgU2hhZGVyIH0gZnJvbSBcIkBlbmdpbmUvZmxhdGZhc3RcIjtcclxuXHJcbmltcG9ydCBWc1BhbGV0dGUgZnJvbSBcIi4vdnNQYWxldHRlXCI7XHJcbmltcG9ydCBWc1Nwcml0ZSBmcm9tIFwiLi92c1Nwcml0ZVwiO1xyXG5pbXBvcnQgVnNXb3JsZCBmcm9tIFwiLi92c1dvcmxkXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZzU3RhZ2UgZXh0ZW5kcyBTcHJpdGUge1xyXG4gICAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLmluc3RhbmNlc1twcm9jZXNzLmVudi5BUFBMSUNBVElPTl9OQU1FXSA9IHRoaXMuaW5zdGFuY2VzW3Byb2Nlc3MuZW52LkFQUExJQ0FUSU9OX05BTUVdIHx8IG5ldyBTcHJpdGUoKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKCB0aGlzLmluc3RhbmNlc1twcm9jZXNzLmVudi5BUFBMSUNBVElPTl9OQU1FXSwgdGhpcy5wcm90b3R5cGUgKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaW5pdCggd2lkdGgsIGhlaWdodCApIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZzU3RhZ2UoIHdpZHRoLGhlaWdodCApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCB3aWR0aCxoZWlnaHQgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBjb25zdCBfdGhpcyA9IFZzU3RhZ2UuaW5zdGFuY2U7XHJcblxyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGggfCBhcHBsaWNhdGlvbi5sb2dpY2FsVmlld3BvcnQud2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0IHx8IGFwcGxpY2F0aW9uLmxvZ2ljYWxWaWV3cG9ydC5oZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMjU1O1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQgPSBudWxsO1xyXG5cclxuICAgICAgICAvL1RPRE86IOuUlOuyhOq3uCDtjJTroIjtirjrpbwg6riw67O47Jy866GcIOuEo+yWtOykmOyVvO2VqFxyXG4gICAgICAgIC8qKiBAdHlwZSB7VnNQYWxldHRlfG51bGx9ICovXHJcbiAgICAgICAgdGhpcy5wYWxldHRlID0gbnVsbDtcclxuICAgICAgICAvKiogQHR5cGUge1ZzV29ybGR8bnVsbH0gKi9cclxuICAgICAgICB0aGlzLndvcmxkID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRDbGlwKCAwLDAsdGhpcy5fd2lkdGgsdGhpcy5faGVpZ2h0ICk7XHJcbiAgICAgICAgc3RhZ2Uub24oIEV2ZW50LlJFU0laRSxmdW5jdGlvbiggZSApIHtcclxuICAgICAgICAgICAgX3RoaXMuc2V0Q2xpcCggMCwwLF90aGlzLl93aWR0aCxfdGhpcy5faGVpZ2h0ICk7XHJcbiAgICAgICAgfSApO1xyXG5cclxuXHJcbiAgICAgICAgX3RoaXMub25TdGFnZSggRXZlbnQuRU5URVJfRlJBTUUsZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICggVnNTdGFnZS5pbnN0YW5jZS5wYWxldHRlICkgVnNTdGFnZS5pbnN0YW5jZS5wYWxldHRlLnByb2Nlc3MoKTtcclxuICAgICAgICAgICAgVnNTcHJpdGUucHJvY2Vzc0FsbFNwcml0ZXMoKTtcclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIC8vIOyVseydtCDquLDrj5ntlZjquLAg7KCE7JeQIGFwcGxpY2F0aW9u7JeQIOqxuOumsCDsnbTrsqTtirjrpbwg67O07KG07ZWc64ukXHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbiggdGhpcy5ldmVudEVtaXR0ZXIuX2V2ZW50cyxfdGhpcy5ldmVudEVtaXR0ZXIuX2V2ZW50cyApO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oIF90aGlzLHRoaXMgKTtcclxuICAgICAgICBzdGFnZS5hZGRDaGlsZCggX3RoaXMgKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCggdGhpcy53aWR0aCx0aGlzLmhlaWdodCApO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCByZWN0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCggMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQgKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRQYWxldHRlKCBwYWwgKSB7XHJcbiAgICAgICAgdGhpcy5wYWxldHRlID0gcGFsO1xyXG4gICAgICAgIGlmICggdGhpcy5fYmFja2dyb3VuZCApIHRoaXMuX2JhY2tncm91bmQuc2V0U2hhZGVyKCBwYWwuY3JlYXRlU2hhZGVyKCkgKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYmFja2dyb3VuZENvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNldCBiYWNrZ3JvdW5kQ29sb3IoIGluZGV4ICkge1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IGluZGV4O1xyXG4gICAgICAgIGlmICggdGhpcy5fYmFja2dyb3VuZCApIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5yZW1vdmVGcm9tUGFyZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIGluZGV4IDwgMjU1ICkge1xyXG4gICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gbmV3IFBpeGVsKCBWc1BhbGV0dGUuaW5kZXhUb0NvbG9yKCBpbmRleCApLDEsIHRoaXMud2lkdGgsdGhpcy5oZWlnaHQgKTtcclxuICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zZXRTaGFkZXIoIHRoaXMucGFsZXR0ZS5jcmVhdGVTaGFkZXIoKSApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkQXQoIHRoaXMuX2JhY2tncm91bmQsMCApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRXb3JsZCggd29ybGQsIGtlZXBTcHJpdGVzICkge1xyXG4gICAgICAgIGxldCBvbGRXb3JsZCA9IHRoaXMud29ybGQ7XHJcbiAgICAgICAgbGV0IHdvcmxkSW5kZXg7XHJcblxyXG4gICAgICAgIGlmICggb2xkV29ybGQgKSB7XHJcbiAgICAgICAgICAgIGlmICggb2xkV29ybGQuZ2V0UGFyZW50KCkgPT0gdGhpcyApIHtcclxuICAgICAgICAgICAgICAgIHdvcmxkSW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoIG9sZFdvcmxkICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3b3JsZEluZGV4ID0gMDsgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2xkV29ybGQucmVtb3ZlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcbiAgICAgICAgaWYgKCB0aGlzLndvcmxkICkge1xyXG4gICAgICAgICAgICBpZiAoIG9sZFdvcmxkICYmIGtlZXBTcHJpdGVzICkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbGVNYXAgPSB0aGlzLndvcmxkLnRpbGVNYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZC5jbGVhckNoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICAgICBvbGRXb3JsZC5sYXllcjAucmVtb3ZlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZC5hZGRDaGlsZCggb2xkV29ybGQubGF5ZXIwICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkLmFkZENoaWxkKCB0aWxlTWFwICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkLmFkZENoaWxkKCBvbGRXb3JsZC5sYXllcjEgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ybGQuYWRkQ2hpbGQoIG9sZFdvcmxkLmxheWVyMiApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZC5hZGRDaGlsZCggb2xkV29ybGQubGF5ZXIzICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkLmFkZENoaWxkKCBvbGRXb3JsZC5sYXllcjQgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ybGQuYWRkQ2hpbGQoIG9sZFdvcmxkLmxheWVyNSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZC5sYXllcjAgPSBvbGRXb3JsZC5sYXllcjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkLmxheWVyMSA9IG9sZFdvcmxkLmxheWVyMTtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ybGQubGF5ZXIyID0gb2xkV29ybGQubGF5ZXIyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZC5sYXllcjMgPSBvbGRXb3JsZC5sYXllcjM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkLmxheWVyNCA9IG9sZFdvcmxkLmxheWVyNDtcclxuICAgICAgICAgICAgICAgIHRoaXMud29ybGQubGF5ZXI1ID0gb2xkV29ybGQubGF5ZXI1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZC5zY3JvbGxUYXJnZXQgPSBvbGRXb3JsZC5zY3JvbGxUYXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkLmV2ZW50VGFyZ2V0ID0gb2xkV29ybGQuZXZlbnRUYXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZEF0KCB0aGlzLndvcmxkLHdvcmxkSW5kZXggKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5hZGRDaGlsZCggdGhpcy53b3JsZCApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxWc1N0YWdlPn19ICovXHJcblZzU3RhZ2UuaW5zdGFuY2VzID0ge307XHJcbiIsImltcG9ydCB7IFNwaW5lLCBDb21wb25lbnQsIENvbXBvbmVudEhvbGRlciwgU2NlbmVNYW5hZ2VyLCBTdG9yYWdlLCBUd2VlbiwgRm9udCwgUG9pbnQsIFJlY3QsIFRpbGVNYXAsTW92aWVDbGlwLFJlbmRlclRhcmdldCwgUGl4ZWwsZWFzaW5nLCBNZXNoLCBUZXh0dXJlUGFjaywgVXRpbHMsIE1hdHJpeCwgU2hhcGUsIFRpbWVyLCBUZXh0RmllbGQsIEV2ZW50LCBLZXlDb2RlLCBFdmVudERpc3BhdGNoZXIsXHJcbiAgICAgICAgIFNwcml0ZSwgU3RhZ2UsIEJpdG1hcCwgVGV4dHVyZSwgVGV4dHVyZUJhc2UsIEFwcGxpY2F0aW9uLCBTaGFkZXIsIFNvdW5kIH0gZnJvbSBcIkBlbmdpbmUvZmxhdGZhc3RcIjtcclxuXHJcbmltcG9ydCBWc1N0YWdlIGZyb20gXCIuL3ZzU3RhZ2VcIjtcclxuaW1wb3J0IFZzUGFsZXR0ZSBmcm9tIFwiLi92c1BhbGV0dGVcIjtcclxuXHJcblxyXG5jb25zdCBzeXN0ZW1Gb250V2lkdGhzID0gW1xyXG5cclxuICAgIC8vIDUgKiA1IGZvbnQgbGVuZ3RoIHRhYmxlXHJcbiAgICA2LDIsNCw2LDYsNiw2LDMsMywzLDUsNiwzLDYsMiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsMiwzLDQsNSw0LDQsXHJcbiAgICA2LDYsNiw2LDYsNiw2LDYsNiw0LDUsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiwzLDYsMyw0LDQsXHJcbiAgICA0LDUsNSw1LDUsNSw1LDUsNSwyLDMsNSwyLDYsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSwzLDIsMyw1LDUsXHJcblxyXG4gICAgLy8gMyAqIDUgZm9udCBsZW5ndGggdGFibGVcclxuICAgIDQsMiw0LDQsNCw0LDQsMywzLDMsNCw0LDMsNCwyLDQsNCw0LDQsNCw0LDQsNCw0LDQsNCwyLDMsNCw0LDQsNCxcclxuICAgIDYsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDMsNCwzLDQsNCxcclxuICAgIDMsNCw0LDQsNCw0LDQsNCw0LDIsMyw0LDIsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDMsMiwzLDQsNCxcclxuXHJcbiAgICAvLyBzeW1ib2wgZm9udCBsZW5ndGggdGFibGVcclxuICAgIDYsMiw0LDYsNiw2LDYsMywzLDMsNSw2LDMsNiwyLDYsNiw2LDYsNiw2LDYsNiw2LDYsNiwyLDMsNCw1LDQsNCxcclxuICAgIDYsNiw2LDYsNiw1LDUsNSw0LDQsNiw2LDYsNiw2LDYsNiw2LDYsNCw0LDMsNiw2LDYsNiw2LDMsNiwzLDQsNCxcclxuICAgIDQsNSw1LDUsNSw1LDUsNSw1LDIsMyw1LDIsNiw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDMsMiwzLDUsNVxyXG5cclxuICAgICAgICBcclxuXTtcclxuXHJcblxyXG4vLyA3IOuwlOydtO2KuOyUqSDsnbjsvZTrlKkgeCx5LHcsaCxzeCxzeSxyb3RcclxuLy8g7Y+w7Yq466eI64ukIDk26rCcXHJcbmNvbnN0IHN5c3RlbUZvbnRGcmFtZXMgPSBuZXcgVWludDhBcnJheSggW1xyXG4gICAgOTksNTQsNiw4LDAsMCwwLDQ2LDExLDEsNSwwLDAsMCwyMSwxLDMsMiwwLDAsMCw2MSwxMiw1LDUsMCwwLDAsNjgsMTIsNSw1LDAsMCwwLDc1LDEyLDUsNSwwLDAsMCw4MiwxMiw1LDUsMCwwLDAsMjYsMSwyLDIsMCwwLDAsODksMTIsMiw1LDAsMCwwLDkzLDEyLDIsNSwwLDAsMCw5NywxMiw0LDUsMCwwLDAsMTAzLDEyLDUsNSwwLDAsMCwzMCwxLDIsMiwwLDMsMCwxLDEsNSwxLDAsMiwwLDgsMSwxLDEsMCw0LDAsMTEwLDEyLDUsNSwwLDAsMCwxMTcsMTIsNSw1LDAsMCwwLDEyNCwxMiwzLDUsMSwwLDAsNiwxNiw1LDUsMCwwLDAsMTMsMTYsNSw1LDAsMCwwLDIwLDE3LDUsNSwwLDAsMCwyNywxNyw1LDUsMCwwLDAsMzQsMTcsNSw1LDAsMCwwLDQ2LDE4LDUsNSwwLDAsMCw1MywxOCw1LDUsMCwwLDAsNjAsMTksNSw1LDAsMCwwLDUwLDEsMSwzLDAsMSwwLDYsNCwyLDQsMCwxLDAsMSwxNSwzLDUsMCwwLDAsNTMsMSw0LDMsMCwxLDAsNDEsMTcsMyw1LDAsMCwwLDY3LDE5LDMsNSwwLDAsMCw3MiwxOSw1LDUsMCwwLDAsNzksMTksNSw1LDAsMCwwLDg2LDE5LDUsNSwwLDAsMCw5MywxOSw1LDUsMCwwLDAsMTAwLDE5LDUsNSwwLDAsMCwxMDcsMTksNSw1LDAsMCwwLDExNCwxOSw1LDUsMCwwLDAsMTIxLDE5LDUsNSwwLDAsMCw2LDIzLDUsNSwwLDAsMCwxLDIyLDMsNSwwLDAsMCwxMywyMyw0LDUsMCwwLDAsMTksMjQsNSw1LDAsMCwwLDI2LDI0LDUsNSwwLDAsMCwzMywyNCw1LDUsMCwwLDAsNDQsMjUsNSw1LDAsMCwwLDExNywxMiw1LDUsMCwwLDAsNTEsMjUsNSw1LDAsMCwwLDU4LDI2LDUsNSwwLDAsMCw2NSwyNiw1LDUsMCwwLDAsNzIsMjYsNSw1LDAsMCwwLDc5LDI2LDUsNSwwLDAsMCw4NiwyNiw1LDUsMCwwLDAsOTMsMjYsNSw1LDAsMCwwLDEwMCwyNiw1LDUsMCwwLDAsMTA3LDI2LDUsNSwwLDAsMCwxMTQsMjYsNSw1LDAsMCwwLDEyMSwyNiw1LDUsMCwwLDAsNDAsMjQsMiw1LDAsMCwwLDUsMzAsNSw1LDAsMCwwLDEsMjksMiw1LDAsMCwwLDM0LDEsMywyLDAsMCwwLDExLDEsMywxLDAsNCwwLDEwLDQsMyw0LDAsMSwwLDE1LDQsNCw0LDAsMSwwLDEyLDMwLDQsNSwwLDAsMCwyMSw1LDQsNCwwLDEsMCwxOCwzMSw0LDUsMCwwLDAsMjcsNSw0LDQsMCwxLDAsMjQsMzEsNCw1LDAsMCwwLDMwLDMxLDQsNSwwLDEsMCwzNiwzMSw0LDUsMCwwLDAsNDIsMzIsMSw1LDAsMCwwLDEsMzYsMiw2LDAsMCwwLDQ1LDMyLDQsNSwwLDAsMCw1MSwzMiwxLDUsMCwwLDAsMzMsNSw1LDQsMCwxLDAsNDAsNSw0LDQsMCwxLDAsNTAsNiw0LDQsMCwxLDAsNTgsMzMsNCw1LDAsMSwwLDY0LDMzLDQsNSwwLDEsMCw1Niw2LDQsNCwwLDEsMCw2Miw2LDQsNCwwLDEsMCw3MCwzMyw0LDUsMCwwLDAsNjgsNiw0LDQsMCwxLDAsNzQsNiw0LDQsMCwxLDAsODAsNiw0LDQsMCwxLDAsODYsNiw0LDQsMCwxLDAsNzYsMzMsNCw1LDAsMSwwLDkyLDYsNCw0LDAsMSwwLDU0LDMyLDIsNSwwLDAsMCw4MiwzMywxLDUsMCwwLDAsODUsMzMsMiw1LDAsMCwwLDM5LDEsNCwyLDAsMCwwLDk4LDYsNCw0LDAsMSwwLDEyMyw0Nyw0LDgsMCwwLDAsNDYsMTEsMSw1LDAsMCwwLDIxLDEsMywyLDAsMCwwLDg5LDMzLDMsNSwwLDAsMCw5NCwzMywzLDUsMCwwLDAsOTksMzMsMyw1LDAsMCwwLDEwNCw2LDMsNCwwLDEsMCwyNiwxLDIsMiwwLDAsMCw4OSwxMiwyLDUsMCwwLDAsOTMsMTIsMiw1LDAsMCwwLDU5LDEsMywzLDAsMSwwLDY0LDEsMywzLDAsMSwwLDMwLDEsMiwyLDAsMywwLDE2LDEsMywxLDAsMiwwLDgsMSwxLDEsMCw0LDAsNjksMSwzLDMsMCwxLDAsMTA0LDMzLDMsNSwwLDAsMCwxMDksMzMsMSw1LDEsMCwwLDExMiwzMywzLDUsMCwwLDAsMTE3LDMzLDMsNSwwLDAsMCwxMjIsMzMsMyw1LDAsMCwwLDUsMzcsMyw1LDAsMCwwLDEwLDM3LDMsNSwwLDAsMCwxNSwzOCwzLDUsMCwwLDAsMjAsMzgsMyw1LDAsMCwwLDI1LDM4LDMsNSwwLDAsMCw1MCwxLDEsMywwLDEsMCw2LDQsMiw0LDAsMSwwLDEsMTUsMyw1LDAsMCwwLDc0LDEsMywzLDAsMSwwLDQxLDE3LDMsNSwwLDAsMCw2NywxOSwzLDUsMCwwLDAsNzIsMTksNSw1LDAsMCwwLDMwLDM4LDMsNSwwLDAsMCwzNSwzOCwzLDUsMCwwLDAsNDAsMzksMyw1LDAsMCwwLDQ1LDM5LDMsNSwwLDAsMCw1MCwzOSwzLDUsMCwwLDAsNTUsNDAsMyw1LDAsMCwwLDYwLDQwLDMsNSwwLDAsMCw2NSw0MCwzLDUsMCwwLDAsMSwyMiwzLDUsMCwwLDAsNzAsNDAsMyw1LDAsMCwwLDc1LDQwLDMsNSwwLDAsMCw4MCw0MCwzLDUsMCwwLDAsODUsNDAsMyw1LDAsMCwwLDkwLDQwLDMsNSwwLDAsMCw5NSw0MCwzLDUsMCwwLDAsMTAwLDQwLDMsNSwwLDAsMCwxMDUsNDAsMyw1LDAsMCwwLDExMCw0MCwzLDUsMCwwLDAsMTE1LDQwLDMsNSwwLDAsMCwxMjAsNDAsMyw1LDAsMCwwLDEsNDQsMyw1LDAsMCwwLDYsNDQsMyw1LDAsMCwwLDExLDQ1LDMsNSwwLDAsMCwxNiw0NSwzLDUsMCwwLDAsMjEsNDUsMyw1LDAsMCwwLDI2LDQ1LDMsNSwwLDAsMCw0MCwyNCwyLDUsMCwwLDAsNzksMSwzLDMsMCwxLDAsMSwyOSwyLDUsMCwwLDAsMzQsMSwzLDIsMCwwLDAsMTEsMSwzLDEsMCw0LDAsNDYsNSwyLDQsMCwxLDAsMTA5LDYsMyw0LDAsMSwwLDMxLDQ1LDMsNSwwLDAsMCwxMTQsNiwzLDQsMCwxLDAsMzYsNDYsMyw1LDAsMCwwLDExOSw2LDMsNCwwLDEsMCw0MSw0NiwzLDUsMCwwLDAsNDYsNDYsMyw1LDAsMSwwLDUxLDQ3LDMsNSwwLDAsMCw0MiwzMiwxLDUsMCwwLDAsMSwzNiwyLDYsMCwwLDAsNTYsNDcsMyw1LDAsMCwwLDUxLDMyLDEsNSwwLDAsMCwxMjQsNiwzLDQsMCwxLDAsMSw5LDMsNCwwLDEsMCw2LDEwLDMsNCwwLDEsMCw2MSw0NywzLDUsMCwxLDAsNjYsNDcsMyw1LDAsMSwwLDExLDEwLDMsNCwwLDEsMCwxNiwxMCwzLDQsMCwxLDAsNzEsNDcsMyw1LDAsMCwwLDIxLDExLDMsNCwwLDEsMCwyNiwxMSwzLDQsMCwxLDAsMzEsMTEsMyw0LDAsMSwwLDM2LDExLDMsNCwwLDEsMCw3Niw0NywzLDUsMCwxLDAsNDEsMTEsMyw0LDAsMSwwLDU0LDMyLDIsNSwwLDAsMCw4MiwzMywxLDUsMCwwLDAsODUsMzMsMiw1LDAsMCwwLDQ1LDEsMywyLDAsMCwwLDg0LDEsMywzLDAsMiwwLDk5LDU0LDYsOCwwLDAsMCw0NiwxMSwxLDUsMCwwLDAsMjEsMSwzLDIsMCwwLDAsNjEsMTIsNSw1LDAsMCwwLDY4LDEyLDUsNSwwLDAsMCw3NSwxMiw1LDUsMCwwLDAsODIsMTIsNSw1LDAsMCwwLDI2LDEsMiwyLDAsMCwwLDg5LDEyLDIsNSwwLDAsMCw5MywxMiwyLDUsMCwwLDAsOTcsMTIsNCw1LDAsMCwwLDEwMywxMiw1LDUsMCwwLDAsMzAsMSwyLDIsMCwzLDAsMSwxLDUsMSwwLDIsMCw4LDEsMSwxLDAsNCwwLDExMCwxMiw1LDUsMCwwLDAsODEsNDcsNSw1LDAsMCwwLDg4LDQ3LDUsNSwwLDAsMCw5NSw0Nyw1LDUsMCwwLDAsMTAyLDQ3LDUsNSwwLDAsMCwxMDksNDcsNSw1LDAsMCwwLDg5LDEsNSwzLDAsMiwwLDExNiw0Nyw1LDUsMCwwLDAsMSw1MSw1LDUsMCwwLDAsOCw1Miw1LDUsMCwwLDAsMTUsNTIsNSw1LDAsMCwwLDUwLDEsMSwzLDAsMSwwLDYsNCwyLDQsMCwxLDAsMSwxNSwzLDUsMCwwLDAsNTMsMSw0LDMsMCwxLDAsNDEsMTcsMyw1LDAsMCwwLDY3LDE5LDMsNSwwLDAsMCw3MiwxOSw1LDUsMCwwLDAsMjIsNTIsNSw1LDAsMCwwLDI5LDUyLDUsNSwwLDAsMCwxMTcsMTIsNSw1LDAsMCwwLDM2LDUzLDUsNSwwLDAsMCw5NiwxLDMsMywxLDEsMCw0OSwxMiw0LDQsMCwwLDAsNTUsMTIsNCw0LDAsMSwwLDEwMSwxLDMsMywwLDAsMCwxMDYsMSwzLDMsMCwyLDAsNDMsNTMsNSw1LDAsMCwwLDUwLDU0LDUsNSwwLDAsMCw1Nyw1NCw1LDUsMCwwLDAsNjQsNTQsNSw1LDAsMCwwLDcxLDU0LDUsNSwwLDAsMCw3OCw1NCw1LDUsMCwwLDAsODUsNTQsNSw1LDAsMCwwLDExMSwxLDUsMywwLDEsMCwxMTgsMSw1LDMsMCwxLDAsMSw0LDMsMywwLDEsMCw2NCwxLDMsMywwLDEsMCwxMjUsMSwyLDMsMCwxLDAsOTIsNTQsNSw1LDAsMCwwLDEwMCwyNiw1LDUsMCwwLDAsMTA3LDI2LDUsNSwwLDAsMCwxMTQsMjYsNSw1LDAsMCwwLDEyMSwyNiw1LDUsMCwwLDAsNDAsMjQsMiw1LDAsMCwwLDUsMzAsNSw1LDAsMCwwLDEsMjksMiw1LDAsMCwwLDM0LDEsMywyLDAsMCwwLDExLDEsMywxLDAsNCwwLDEwLDQsMyw0LDAsMSwwLDE1LDQsNCw0LDAsMSwwLDEyLDMwLDQsNSwwLDAsMCwyMSw1LDQsNCwwLDEsMCwxOCwzMSw0LDUsMCwwLDAsMjcsNSw0LDQsMCwxLDAsMjQsMzEsNCw1LDAsMCwwLDMwLDMxLDQsNSwwLDEsMCwzNiwzMSw0LDUsMCwwLDAsNDIsMzIsMSw1LDAsMCwwLDEsMzYsMiw2LDAsMCwwLDQ1LDMyLDQsNSwwLDAsMCw1MSwzMiwxLDUsMCwwLDAsMzMsNSw1LDQsMCwxLDAsNDAsNSw0LDQsMCwxLDAsNTAsNiw0LDQsMCwxLDAsNTgsMzMsNCw1LDAsMSwwLDY0LDMzLDQsNSwwLDEsMCw1Niw2LDQsNCwwLDEsMCw2Miw2LDQsNCwwLDEsMCw3MCwzMyw0LDUsMCwwLDAsNjgsNiw0LDQsMCwxLDAsNzQsNiw0LDQsMCwxLDAsODAsNiw0LDQsMCwxLDAsODYsNiw0LDQsMCwxLDAsNzYsMzMsNCw1LDAsMSwwLDkyLDYsNCw0LDAsMSwwLDU0LDMyLDIsNSwwLDAsMCw4MiwzMywxLDUsMCwwLDAsODUsMzMsMiw1LDAsMCwwLDM5LDEsNCwyLDAsMCwwLDk4LDYsNCw0LDAsMSwwXHJcbl0gKTtcclxuXHJcbmNvbnN0IHN5c3RlbUZvbnRJbWFnZSA9IG5ldyBUZXh0dXJlKCBgc3lzdGVtZm9udC5wbmdgICk7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVnNTeXN0ZW1UZXh0IGV4dGVuZHMgTWVzaCB7XHJcbiAgICAvKipcclxuICAgICAqQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBWc1N5c3RlbUZvbnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZm9udFNldFxyXG4gICAgICogQG1lbWJlcm9mIFZzU3lzdGVtVGV4dFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvciggcyxmb250U2V0ID0gVnNTeXN0ZW1UZXh0LkZPTlRfNVg1ICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY29sb3IxID0gMHgwMGYwMDA7XHJcbiAgICAgICAgdGhpcy5fY29sb3IyID0gMHgwMGYwMDA7XHJcbiAgICAgICAgdGhpcy5zZXRQYWxldHRlKCBWc1N0YWdlLmluc3RhbmNlLnBhbGV0dGUgKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyggVnNTdGFnZS5pbnN0YW5jZS5wYWxldHRlICk7XHJcbiAgICAgICAgdGhpcy5mb250U2V0ID0gZm9udFNldDtcclxuICAgICAgICB0aGlzLnNldFRleHR1cmUoIHN5c3RlbUZvbnRJbWFnZSApO1xyXG4gICAgICAgIGlmICggcyApIHRoaXMuc2V0VGV4dCggcyApO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBhbGV0dGUoIHBhbCApIHtcclxuICAgICAgICBsZXQgc2ggPSBwYWwuY3JlYXRlU2hhZGVyKCBzeXN0ZW1Gb250SW1hZ2UgKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRTaGFkZXIoIHNoICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleDFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gaW5kZXgyXHJcbiAgICAgKiBAbWVtYmVyb2YgVnNTeXN0ZW1UZXh0XHJcbiAgICAgKi9cclxuICAgIHNldENvbG9yKCBpbmRleDEsIGluZGV4MiApIHtcclxuICAgICAgICB0aGlzLl9jb2xvcjEgPSBWc1BhbGV0dGUuaW5kZXhUb0NvbG9yKCBpbmRleDEgKTtcclxuICAgICAgICBpZiAoIGluZGV4MiApIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3IyID0gVnNQYWxldHRlLmluZGV4VG9Db2xvciggaW5kZXgyICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3IyID0gdGhpcy5fY29sb3IxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBtZW1iZXJvZiBWc1N5c3RlbVRleHRcclxuICAgICAqL1xyXG4gICAgc2V0VGV4dCggcyApIHtcclxuICAgICAgICBsZXQgaWR4ID0gW107XHJcbiAgICAgICAgbGV0IHZ0eCA9IFtdO1xyXG4gICAgICAgIGxldCB1diA9IFtdO1xyXG4gICAgICAgIGxldCBjb2xvcnMgPSBbXTtcclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG5cclxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICBsZXQgY2ggPSBzLmNoYXJDb2RlQXQoIGkgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggY2ggPT0gMHgyMCApIHtcclxuICAgICAgICAgICAgICAgIC8vIOqzteuwsVxyXG4gICAgICAgICAgICAgICAgeCArPSBzeXN0ZW1Gb250V2lkdGhzW3RoaXMuZm9udFNldCAqIDk2XTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggY2ggPT0gMTAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDsl5TthLBcclxuICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgeSArPSA4O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaCA9PSAxICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb250U2V0ID0gVnNTeXN0ZW1UZXh0LkZPTlRfNVg1O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaCA9PSAyICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb250U2V0ID0gVnNTeXN0ZW1UZXh0LkZPTlRfM1g1O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaCA9PSAzICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb250U2V0ID0gVnNTeXN0ZW1UZXh0LkZPTlRfU1lNQk9MO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaCA9PSA0ICkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzog7Y+w7Yq47Lus65+sXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNoID4gMHgyMCAmJiBjaCA8PSAweDdmICkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFQb3MgPSB0aGlzLmZvbnRTZXQgKiAoIDk2ICogNyApICsgKCBjaCAtIDB4MjAgKSAqIDc7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHN5c3RlbUZvbnRGcmFtZXMuc2xpY2UoIGRhdGFQb3MsZGF0YVBvcyArIDcgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpcG9zID0gdnR4Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICBsZXQgW3Usdix3LGgsc3gsc3kscm90XSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlkeC5wdXNoKCBpcG9zLGlwb3MgKyAxLGlwb3MgKyAyLGlwb3MgKyAxLGlwb3MgKyAzLGlwb3MgKyAyICk7XHJcbiAgICAgICAgICAgICAgICB2dHgucHVzaCggeCArIHN4LHkgKyBzeSx4ICsgc3ggKyB3LHkgKyBzeSx4ICsgc3gseSArIHN5ICsgaCx4ICsgc3ggKyB3LHkgKyBzeSArIGggKTtcclxuICAgICAgICAgICAgICAgIGlmICggcm90ID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXYucHVzaCggdSx2LHUgKyB3LHYsdSx2ICsgaCx1ICsgdyx2ICsgaCApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1di5wdXNoKCB1ICsgaCx2LHUgKyBoLHYgKyB3LHUsdix1LHYgKyB3ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaCggdGhpcy5fY29sb3IxLDEsdGhpcy5fY29sb3IxLDEsdGhpcy5fY29sb3IyLDEsdGhpcy5fY29sb3IyLDEgKTtcclxuICAgICAgICAgICAgICAgIHggKz0gc3lzdGVtRm9udFdpZHRoc1t0aGlzLmZvbnRTZXQgKiA5NiArIGNoIC0gMHgyMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRWZXJ0ZXhBcnJheSggdnR4ICk7XHJcbiAgICAgICAgdGhpcy5zZXRJbmRleEFycmF5KCBpZHggKTtcclxuICAgICAgICB0aGlzLnNldENvbG9yQXJyYXkoIGNvbG9ycyApO1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZUNvb3JkaW5hdGVBcnJheSggdXYgKTtcclxuICAgIH1cclxufVxyXG5cclxuVnNTeXN0ZW1UZXh0LkZPTlRfNVg1ID0gMDtcclxuVnNTeXN0ZW1UZXh0LkZPTlRfM1g1ID0gMTtcclxuVnNTeXN0ZW1UZXh0LkZPTlRfU1lNQk9MID0gMjtcclxuXHJcbi8vbW9kdWxlLmV4cG9ydHMgPSBWc1N5c3RlbVRleHQ7XHJcbiIsImltcG9ydCB7IFNwaW5lLCBDb21wb25lbnQsIENvbXBvbmVudEhvbGRlciwgU2NlbmVNYW5hZ2VyLCBTZXJpYWxpemVyLCBTdG9yYWdlLCBUd2VlbiwgRm9udCwgUG9pbnQsIFJlY3QsIFRpbGVNYXAsTW92aWVDbGlwLFJlbmRlclRhcmdldCwgUGl4ZWwsZWFzaW5nLCBNZXNoLCBUZXh0dXJlUGFjaywgVXRpbHMsIE1hdHJpeCwgU2hhcGUsIFRpbWVyLCBUZXh0RmllbGQsIEV2ZW50LCBLZXlDb2RlLCBFdmVudERpc3BhdGNoZXIsXHJcbiAgICAgICAgIFNwcml0ZSwgU3RhZ2UsIEJpdG1hcCwgVGV4dHVyZSwgVGV4dHVyZUJhc2UsIEFwcGxpY2F0aW9uLCBTaGFkZXIsIFNvdW5kIH0gZnJvbSBcIkBlbmdpbmUvZmxhdGZhc3RcIjtcclxuXHJcbmltcG9ydCBWc1N0YWdlIGZyb20gXCIuL3ZzU3RhZ2VcIjtcclxuaW1wb3J0IFZzUGFsZXR0ZSBmcm9tIFwiLi92c1BhbGV0dGVcIjtcclxuaW1wb3J0IFZzU3ByaXRlIGZyb20gXCIuL3ZzU3ByaXRlXCI7XHJcbiAgICAgICAgXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWc1dvcmxkIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCBtYXBOYW1lICkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgY29uc3QgbWFwRGF0YSA9IEpTT04ucGFyc2UoIFV0aWxzLmdldEVtYmVkZGVkRmlsZSggYG1hcF8ke21hcE5hbWV9Lmpzb25gICkgKTtcclxuICAgICAgICBjb25zdCB0aWxlSW1hZ2VOYW1lID0gYHBhdF8ke21hcE5hbWV9LnBuZ2A7XHJcblxyXG4gICAgICAgIHRoaXMubWFwV2lkdGggPSBtYXBEYXRhWzBdLmxlbmd0aDtcclxuICAgICAgICB0aGlzLm1hcEhlaWdodCA9IG1hcERhdGEubGVuZ3RoO1xyXG5cclxuICAgICAgICB0aGlzLnRpbGVNYXAgPSBuZXcgVGlsZU1hcCggdGhpcy5tYXBXaWR0aCx0aGlzLm1hcEhlaWdodCxuZXcgVGV4dHVyZSggdGlsZUltYWdlTmFtZSApLDE2LDE2LDIsMiwxLDEgKTtcclxuICAgICAgICB0aGlzLnNldFBhbGV0dGUoIFZzU3RhZ2UuaW5zdGFuY2UucGFsZXR0ZSApO1xyXG5cclxuICAgICAgICBsZXQgZXZuRGF0YSA9IEpTT04ucGFyc2UoIFV0aWxzLmdldEVtYmVkZGVkRmlsZSggYGV2bl8ke21hcE5hbWV9Lmpzb25gICkgKTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXBCYXNlID0gbmV3IFBvaW50KCBldm5EYXRhLm1hcEJhc2VYLGV2bkRhdGEubWFwQmFzZVkgKTtcclxuICAgICAgICB0aGlzLmV2ZW50RGF0YSA9IGV2bkRhdGE7XHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgMjU2OyBpKysgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREYXRhLmV2ZW50VmFyc1tpXS5mbGFnID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHRpbGVBdHRyaWJzID0gSlNPTi5wYXJzZSggVXRpbHMuZ2V0RW1iZWRkZWRGaWxlKCBgcGF0XyR7bWFwTmFtZX0uanNvbmAgKSApO1xyXG5cclxuICAgICAgICB0aGlzLnRpbGVBdHRyaWJzID0gbmV3IFVpbnQ4QXJyYXkoIHRpbGVBdHRyaWJzICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tYXBEYXRhID0gW107XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coIGDrp7XshKTsoJVgICk7XHJcbiAgICAgICAgZm9yICggbGV0IHkgPSAwOyB5IDwgdGhpcy5tYXBIZWlnaHQ7IHkrKyApIHtcclxuICAgICAgICAgICAgdGhpcy5tYXBEYXRhW3ldID0gbmV3IFVpbnQxNkFycmF5KCB0aGlzLm1hcFdpZHRoICk7XHJcbiAgICAgICAgICAgIGZvciAoIGxldCB4ID0gMDsgeCA8IHRoaXMubWFwV2lkdGg7IHgrKyApIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ID0gbWFwRGF0YVt5XVt4XTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVNYXAuc2V0VGlsZSggeCx5LHQgJSAxNCxNYXRoLmZsb29yKCB0IC8gMTQgKSApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBEYXRhW3ldW3hdID0gdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coIGDrp7XshKTsoJXrgZ1gICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5sYXllcjAgPSBuZXcgU3ByaXRlKCk7XHJcbiAgICAgICAgdGhpcy5sYXllcjEgPSBuZXcgU3ByaXRlKCk7XHJcbiAgICAgICAgdGhpcy5sYXllcjIgPSBuZXcgU3ByaXRlKCk7XHJcbiAgICAgICAgdGhpcy5sYXllcjMgPSBuZXcgU3ByaXRlKCk7XHJcbiAgICAgICAgdGhpcy5sYXllcjQgPSBuZXcgU3ByaXRlKCk7XHJcbiAgICAgICAgdGhpcy5sYXllcjUgPSBuZXcgU3ByaXRlKCk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCggdGhpcy5sYXllcjAgKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKCB0aGlzLnRpbGVNYXAgKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKCB0aGlzLmxheWVyMSApO1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoIHRoaXMubGF5ZXIyICk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCggdGhpcy5sYXllcjMgKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKCB0aGlzLmxheWVyNCApO1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoIHRoaXMubGF5ZXI1ICk7XHJcblxyXG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0UG9zaXRpb24gPSBuZXcgUG9pbnQoIDAsMCApO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjcm9sbFBvc2l0aW9uID0gbmV3IFBvaW50KCAwLCAwICk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxSZWN0ID0gbmV3IFJlY3QoIC0xLC0xLDIsMiApO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNhZmVCb3JkZXIgPSAwO1xyXG4gICAgICAgIHRoaXMuZ3Jhdml0eSA9IG5ldyBQb2ludCggMCwwICk7XHJcbiAgICAgICAgdGhpcy5jb25zdGFudFZlbG9jaXR5ID0gbmV3IFBvaW50KCAwLDAgKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm9uU3RhZ2UoIEV2ZW50LkVOVEVSX0ZSQU1FLHRoaXMucHJvY2Vzc1Njcm9sbCApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHRoaXMucHJvY2Vzc1Njcm9sbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBhbGV0dGUoIHBhbCApIHtcclxuICAgICAgICBsZXQgc2ggPSBwYWwuY3JlYXRlU2hhZGVyKCB0aGlzLnRpbGVNYXAuX190ZXh0dXJlICk7XHJcblxyXG4gICAgICAgIHRoaXMudGlsZU1hcC5zZXRTaGFkZXIoIHNoICk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2FmZUJvcmRlciggcHhXaWR0aCApIHtcclxuICAgICAgICAvL3NldEV4dHJhTWFwXHJcbiAgICAgICAgdGhpcy5zYWZlQm9yZGVyID0gcHhXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTY3JvbGxUYXJnZXQoIHNwciApIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHNwcjtcclxuICAgIH1cclxuXHJcbiAgICBwcm9jZXNzU2Nyb2xsKCkge1xyXG4gICAgICAgIC8vIFRPRE86IOyKpO2BrOuhpCDslYjtlZjripQg7JiB7JetIOyymOumrCDtlYTsmpQgXHJcbiAgICAgICAgLy8gKDEyNyw5OSktKDI1NS0xMjcsMTk5LTk5KVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMuc2Nyb2xsVGFyZ2V0ICkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldFBvc2l0aW9uID0gdGhpcy5zY3JvbGxUYXJnZXQucG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxldCB4ID0gVXRpbHMuY2xhbXAoIHRoaXMuc2Nyb2xsVGFyZ2V0UG9zaXRpb24ueCwgdGhpcy5zYWZlQm9yZGVyLCB0aGlzLm1hcFdpZHRoICogMTYgLSBWc1N0YWdlLmluc3RhbmNlLndpZHRoIC0gdGhpcy5zYWZlQm9yZGVyICogMiApO1xyXG4gICAgICAgIC8vIGxldCB5ID0gVXRpbHMuY2xhbXAoIHRoaXMuc2Nyb2xsVGFyZ2V0UG9zaXRpb24ueSwgdGhpcy5zYWZlQm9yZGVyLCB0aGlzLm1hcEhlaWdodCAqIDE2IC0gVnNTdGFnZS5pbnN0YW5jZS5oZWlnaHQgLSB0aGlzLnNhZmVCb3JkZXIgKiAyICk7XHJcbiAgICAgICAgbGV0IHggPSB0aGlzLmN1cnJlbnRTY3JvbGxQb3NpdGlvbi54O1xyXG4gICAgICAgIGxldCB5ID0gdGhpcy5jdXJyZW50U2Nyb2xsUG9zaXRpb24ueTtcclxuICAgICAgICBsZXQgbnggPSB0aGlzLnNjcm9sbFRhcmdldFBvc2l0aW9uLng7XHJcbiAgICAgICAgbGV0IG55ID0gdGhpcy5zY3JvbGxUYXJnZXRQb3NpdGlvbi55O1xyXG4gICAgICAgIGxldCBwb3MxID0gdGhpcy5nZXRXb3JsZENvb3JkaW5hdGUoIHRoaXMuc2Nyb2xsUmVjdC5sZWZ0LHRoaXMuc2Nyb2xsUmVjdC50b3AgKTtcclxuICAgICAgICBsZXQgcG9zMiA9IHRoaXMuZ2V0V29ybGRDb29yZGluYXRlKCB0aGlzLnNjcm9sbFJlY3QucmlnaHQsdGhpcy5zY3JvbGxSZWN0LmJvdHRvbSApO1xyXG5cclxuICAgICAgICBpZiAoIG54IDwgcG9zMS54IHx8IG54ID49IHBvczIueCApIHtcclxuICAgICAgICAgICAgeCA9IG54OyAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIG55IDwgcG9zMS55IHx8IG55ID49IHBvczIueSApIHtcclxuICAgICAgICAgICAgeSA9IG55O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB5PTE2MDtcclxuICAgICAgICAvLyDsm5DsnpHqs7wg6rCZ6rKMIO2VmOugpOuptCDsoJXsiJjtmZTqsIAg7ZWE7JqU7ZWoXHJcbiAgICAgICAgdGhpcy5zZXRTY3JvbGwoIHgseSApO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjcm9sbFBvc2l0aW9uLnggPSB4O1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjcm9sbFBvc2l0aW9uLnkgPSB5O1xyXG4gICAgfVxyXG5cclxuICAgIGdldE1hcCggdGlsZVgsdGlsZVkgKSB7XHJcbiAgICAgICAgaWYgKCB0aWxlWCA8IDAgfHwgdGlsZVggPj0gdGhpcy5tYXBXaWR0aCB8fCB0aWxlWSA8IDAgfHwgdGlsZVkgPj0gdGhpcy5tYXBIZWlnaHQgKSByZXR1cm4gMDtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXBEYXRhW3RpbGVZXVt0aWxlWF07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TWFwKCB0aWxlWCx0aWxlWSx0aWxlTnVtICkge1xyXG4gICAgICAgIGlmICggdGlsZVggPCAwIHx8IHRpbGVYID49IHRoaXMubWFwV2lkdGggfHwgdGlsZVkgPCAwIHx8IHRpbGVZID49IHRoaXMubWFwSGVpZ2h0ICkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMudGlsZU1hcC5zZXRUaWxlKCB0aWxlWCx0aWxlWSx0aWxlTnVtICUgMTQsTWF0aC5mbG9vciggdGlsZU51bSAvIDE0ICkgKTtcclxuICAgICAgICB0aGlzLm1hcERhdGFbdGlsZVldW3RpbGVYXSA9IHRpbGVOdW07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TWFwQXR0cmliKCB0aWxlWCx0aWxlWSApIHtcclxuICAgICAgICBpZiAoIHRpbGVYIDwgMCB8fCB0aWxlWCA+PSB0aGlzLm1hcFdpZHRoIHx8IHRpbGVZIDwgMCB8fCB0aWxlWSA+PSB0aGlzLm1hcEhlaWdodCApIHJldHVybiAwO1xyXG4gICAgICAgIGNvbnN0IHRpbGVOdW0gPSB0aGlzLm1hcERhdGFbdGlsZVldW3RpbGVYXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZUF0dHJpYnNbdGlsZU51bV07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2Nyb2xsKCB4LHkgKSB7XHJcbiAgICAgICAgLy8gdGhpcy54ID0gMTI4LVV0aWxzLmNsYW1wKHgsdGhpcy5zYWZlQm9yZGVyICsgMTI4LCB0aGlzLm1hcFdpZHRoICogMTYgLSBWc1N0YWdlLmluc3RhbmNlLndpZHRoIC0gdGhpcy5zYWZlQm9yZGVyICogMiArMTI4KTtcclxuICAgICAgICAvLyB0aGlzLnkgPSAxMDAtVXRpbHMuY2xhbXAoeSwgdGhpcy5zYWZlQm9yZGVyICsgMTAwLCB0aGlzLm1hcEhlaWdodCAqIDE2IC0gVnNTdGFnZS5pbnN0YW5jZS5oZWlnaHQgLSB0aGlzLnNhZmVCb3JkZXIgKiAyICsxMDApO1xyXG4gICAgICAgIHRoaXMueCA9IDEyOCAtIHg7XHJcbiAgICAgICAgdGhpcy55ID0gMTAwIC0geTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRNYXBFdmVudE51bWJlciggeCwgeSApIHtcclxuICAgICAgICBsZXQgdHggPSBVdGlscy5jbGFtcCggTWF0aC5mbG9vciggeCAvIDE2ICksMCx0aGlzLm1hcFdpZHRoIC0gMSApO1xyXG4gICAgICAgIGxldCB0eSA9IFV0aWxzLmNsYW1wKCBNYXRoLmZsb29yKCB5IC8gMTYgKSwwLHRoaXMubWFwSGVpZ2h0IC0gMSApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudERhdGEuZXZlbnRNYXBbdHldW3R4XTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRXb3JsZENvb3JkaW5hdGUoIHgseSApIHtcclxuICAgICAgICBsZXQgcCA9IG5ldyBQb2ludCggeCAtIHRoaXMueCx5IC0gdGhpcy55ICk7XHJcblxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFN0YWdlQ29vcmRpbmF0ZSggeCx5ICkge1xyXG4gICAgICAgIGxldCBwID0gbmV3IFBvaW50KCAgeCArIHRoaXMueCx5ICsgdGhpcy55ICk7XHJcblxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFdvcmxkWCggeCApIHtcclxuICAgICAgICByZXR1cm4geCAtIHRoaXMueDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRXb3JsZFkoIHkgKSB7XHJcbiAgICAgICAgcmV0dXJuIHkgLSB0aGlzLnk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3RhZ2VYKCB4ICkge1xyXG4gICAgICAgIHJldHVybiB4ICsgdGhpcy54O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFN0YWdlWSggeSApIHtcclxuICAgICAgICByZXR1cm4geSArIHRoaXMueTtcclxuICAgIH1cclxufVxyXG5cclxuVnNXb3JsZC5USUxFQVRUUklCX0ZMT09SID0gMHg4MDtcclxuVnNXb3JsZC5USUxFQVRUUklCX0NFSUwgPSAweDQwO1xyXG5Wc1dvcmxkLlRJTEVBVFRSSUJfTFdBTEwgPSAweDIwO1xyXG5Wc1dvcmxkLlRJTEVBVFRSSUJfUldBTEwgPSAweDEwO1xyXG5Wc1dvcmxkLlRJTEVBVFRSSUJfTFNMT1BFID0gMHgwODtcclxuVnNXb3JsZC5USUxFQVRUUklCX1JTTE9QRSA9IDB4MDQ7XHJcblxyXG4vLyBHTE9CQUwuVnNXb3JsZCA9IFZzV29ybGQ7XHJcbi8vIG1vZHVsZS5leHBvcnRzID0gVnNXb3JsZDtcclxuIiwiaW1wb3J0IHsgYXBwbGljYXRpb24sUG9pbnQsIFV0aWxzLCBFdmVudCwgU291bmQgfSBmcm9tIFwiQGVuZ2luZS9mbGF0ZmFzdFwiO1xyXG5pbXBvcnQgR0xPQkFMIGZyb20gXCIuL2dsb2JhbFwiO1xyXG5pbXBvcnQgeyB2c1N0YWdlLCBWc1Nwcml0ZSB9IGZyb20gXCIuL3ZzV3JhcHBlci92c1wiO1xyXG5cclxuXHJcbi8vIFRPRE86IGxpZmUsbGV2ZWwg65Ox7Jy866GcIOygleydmOuQnCDrtoDrtoTsnYQg66qF7Iuc7KCB7Jy866GcIOuwlOq/lOyjvOyWtOyVvCDtlZzri6QuIFxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gYW5nbGVUb1hZKCBhbmdsZSxzcGVlZCApIHtcclxuICAgIGxldCByYWQgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XHJcblxyXG4gICAgcmV0dXJuIFtNYXRoLmNvcyggcmFkICkgKiBzcGVlZCwtTWF0aC5zaW4oIHJhZCApICogc3BlZWRdO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKlxyXG4gKiBAY2xhc3MgWmFrb1xyXG4gKiBAZXh0ZW5kcyB7VnNTcHJpdGV9XHJcbiAqL1xyXG5jbGFzcyBaYWtvIGV4dGVuZHMgVnNTcHJpdGUge1xyXG4gICAgY29uc3RydWN0b3IoIGUgKSB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCB4LHksaHAsbGV2ZWwsc3ViVHlwZSx0aW1lciB9ID0gZTtcclxuXHJcbiAgICAgICAgc3dpdGNoICggdHlwZSApIHtcclxuICAgICAgICBjYXNlIFwiemFrbzFcIjogLy/rlJTsiqTsvJPqs7wgQ0RcclxuICAgICAgICAgICAgc3VwZXIoIFwiemFrb1wiLHsgeDogICAgICAgICAgICAgICAgICAgICAgeCwgeTogICAgICAgICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogICAgICAgICAgICAgICAgIHN1YlR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWZlOiAgICAgICAgICAgICAgICAgICBocCAqIDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6ICAgICAgICAgICAgICAgICAgbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25Qb3dlcjogICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUGFydGljbGVDb3VudDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcFBvd2VyVXA6ICAgICAgICAgIHN1YlR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAgICAgICAgICAgICAyMDAgKyBzdWJUeXBlICogMzAwXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmRpc2FibGVHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uTGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvblJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5BSSA9IHRoaXMuQUlfemFrbzE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ6YWtvMlwiOiAvLyDso7zrqLlcclxuICAgICAgICAgICAgc3VwZXIoIFwiemFrb1wiLHsgeDogICAgICAgICAgICAgICAgICAgICAgeCwgeTogICAgICAgICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogICAgICAgICAgICAgICAgIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWZlOiAgICAgICAgICAgICAgICAgICBocCAqIDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQbGF5ZXJOdW1iZXI6ICAgICBVdGlscy5yYW5kb20oIDAsMSApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXI6ICAgICAgICAgICAgICAgICAgdGltZXIgKiAxMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJvc2lvblBvd2VyOiAgICAgICAgIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25QYXJ0aWNsZUNvdW50OiA1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEcm9wUG93ZXJVcDogICAgICAgICAgKCBVdGlscy5yYW5kb20oIDAsNiApID09IDAgKSA/IDIwIDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlQm9udXM6ICAgICAgICAgICAgIDEwMDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMC4yNTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25Ub3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25Cb3R0b20gPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25MZWZ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uUmlnaHQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIEdMT0JBTC5wbGF5ZXJzW3RoaXMudGFyZ2V0UGxheWVyTnVtYmVyICsgMV0gPT0gbnVsbCB8fCBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdLmdhbWVPdmVyICkgdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgPSAxIC0gdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXI7XHJcbiAgICAgICAgICAgIHRoaXMuQUkgPSB0aGlzLkFJX3pha28yO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiemFrbzNcIjogLy8g7LSd7JWM66eJ64qUIOyLoOuwnFxyXG4gICAgICAgICAgICBzdXBlciggXCJ6YWtvXCIseyB4OiAgICAgICAgICAgICAgICAgICAgICB4LCB5OiAgICAgICAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAgICAgICAgICAgICAgICAgMyArIHN1YlR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWZlOiAgICAgICAgICAgICAgICAgICBocCAqIDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQbGF5ZXJOdW1iZXI6ICAgICBVdGlscy5yYW5kb20oIDAsMSApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlZWQ6ICAgICAgICAgICAgICAgICAgc3ViVHlwZSArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25Qb3dlcjogICAgICAgICAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUGFydGljbGVDb3VudDogNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcFBvd2VyVXA6ICAgICAgICAgIDIwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVCb251czogICAgICAgICAgICAgMTUwMCxcclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICBpZiAoIEdMT0JBTC5wbGF5ZXJzW3RoaXMudGFyZ2V0UGxheWVyTnVtYmVyICsgMV0gPT0gbnVsbCB8fCBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdLmdhbWVPdmVyICkgdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgPSAxIC0gdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXI7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmRpc2FibGVHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5BSSA9IHRoaXMuQUlfemFrbzM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ6YWtvNFwiOiAvLyDtg4Tsj5jripQg67CY6rWsXHJcbiAgICAgICAgICAgIHN1cGVyKCBcInpha29cIix7IHg6ICAgICAgICAgICAgICAgICAgICAgIHgsIHk6ICAgICAgICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICAgICAgICAgICAgICAgICA1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmZTogICAgICAgICAgICAgICAgICAgaHAgKiAxMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiAgICAgICAgICAgICAgICAgIGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UGxheWVyTnVtYmVyOiAgICAgVXRpbHMucmFuZG9tKCAwLDEgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyOiAgICAgICAgICAgICAgICAgIHRpbWVyICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25Qb3dlcjogICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUGFydGljbGVDb3VudDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcFBvd2VyVXA6ICAgICAgICAgICggVXRpbHMucmFuZG9tKCAwLDkgKSA9PSAwICkgPyAyMCA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAgICAgICAgICAgICA2MDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMxID0gMTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uTGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvblJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uQm90dG9tID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5BSSA9IHRoaXMuQUlfemFrbzQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ6YWtvNVwiOiAvLyDsm5DsnpDtg4RcclxuICAgICAgICAgICAgc3VwZXIoIFwiemFrb1wiLHsgeDogICAgICAgICAgICAgICAgICAgICAgeCwgeTogICAgICAgICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogICAgICAgICAgICAgICAgIDYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWZlOiAgICAgICAgICAgICAgICAgICBocCAqIDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTaG9vdFdoZW5EaWU6ICAgICAgICAgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJvc2lvblBvd2VyOiAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25QYXJ0aWNsZUNvdW50OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEcm9wUG93ZXJVcDogICAgICAgICAgNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlQm9udXM6ICAgICAgICAgICAgIDUwMCxcclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSAwLjQ7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmRpc2FibGVHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uVG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uQm90dG9tID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uTGVmdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvblJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInpha282XCI6IC8vIOqwgOychFxyXG4gICAgICAgICAgICBzdXBlciggXCJ6YWtvXCIseyB4OiAgICAgICAgICAgICAgICAgICAgICB4LCB5OiAgICAgICAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAgICAgICAgICAgICAgICAgNyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZmU6ICAgICAgICAgICAgICAgICAgIGhwICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25Qb3dlcjogICAgICAgICAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUGFydGljbGVDb3VudDogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcFBvd2VyVXA6ICAgICAgICAgICggVXRpbHMucmFuZG9tKCAwLDkgKSA9PSAwICkgPyAyMCA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAgICAgICAgICAgICA1MDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gLTM7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmRpc2FibGVHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInpha283XCI6IC8vIO2VmOujqOuwqVxyXG4gICAgICAgICAgICBzdXBlciggXCJ6YWtvXCIseyB4OiAgICAgICAgICAgICAgICAgICAgICB4LCB5OiAgICAgICAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAgICAgICAgICAgICAgICAgOCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZmU6ICAgICAgICAgICAgICAgICAgIGhwICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogICAgICAgICAgICAgICAgICBsZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyOiAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQbGF5ZXJOdW1iZXI6ICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUG93ZXI6ICAgICAgICAgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJvc2lvblBhcnRpY2xlQ291bnQ6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Ryb3BQb3dlclVwOiAgICAgICAgICBVdGlscy5yYW5kb20oIDAsMSApICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAgICAgICAgICAgICA1MDAwLFxyXG4gICAgICAgICAgICB9ICk7XHJcbiAgICAgICAgICAgIGlmICggbGV2ZWwgPCA0ICkgZS5zdGF0dXMxID0gMTtcclxuICAgICAgICAgICAgdGhpcy5mbGlwWCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvbkJvdHRvbSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzMiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWFwQ29sbGlzaW9uUGhhc2VDYWxsYmFjayggKCBmbGFnICk9PntcclxuICAgICAgICAgICAgICAgIGlmICggZmxhZyApIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLnN0YXR1czIgPT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLmFjdGlvbiA9PSA4ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRRdWFrZSggNSwzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNheVZvaWNlKCAzICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMyID0gMTsgLy8g67CU64ul7JeQIOuLv+ydjFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB0aGlzLkFJID0gdGhpcy5BSV96YWtvNztcclxuICAgICAgICAgICAgdGhpcy5icmVha0ZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiemFrbzhcIjogLy8g7ZmU7Yis7J6lXHJcbiAgICAgICAgICAgIHN1cGVyKCBcInpha29cIix7IHg6ICAgICAgICAgICAgICAgICAgICAgIHgsIHk6ICAgICAgICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICAgICAgICAgICAgICAgICA5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmZTogICAgICAgICAgICAgICAgICAgaHAgKiA1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6ICAgICAgICAgICAgICAgICAgbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQbGF5ZXJOdW1iZXI6ICAgICBVdGlscy5yYW5kb20oIDAsMSApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUG93ZXI6ICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJvc2lvblBhcnRpY2xlQ291bnQ6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Ryb3BQb3dlclVwOiAgICAgICAgICBVdGlscy5yYW5kb20oIDAsMSApICogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAgICAgICAgICAgICA3MDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgaWYgKCBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdID09IG51bGwgfHwgR0xPQkFMLnBsYXllcnNbdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgKyAxXS5nYW1lT3ZlciApIHRoaXMudGFyZ2V0UGxheWVyTnVtYmVyID0gMSAtIHRoaXMudGFyZ2V0UGxheWVyTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZUZsaWNrZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkFJID0gdGhpcy5BSV96YWtvODtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIm1pbmlEdWNrXCI6IC8vIOyekeydgCDsmKTrpqxcclxuICAgICAgICAgICAgc3VwZXIoIFwiemFrb1wiLHsgeDogICAgICAgICAgICAgICAgICAgICAgeCwgeTogICAgICAgICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogICAgICAgICAgICAgICAgIDIxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmZTogICAgICAgICAgICAgICAgICAgNTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogICAgICAgICAgICAgICAgICAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UGxheWVyTnVtYmVyOiAgICAgVXRpbHMucmFuZG9tKCAwLDEgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJvc2lvblBvd2VyOiAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25QYXJ0aWNsZUNvdW50OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEcm9wUG93ZXJVcDogICAgICAgICAgVXRpbHMucmFuZG9tKCAwLDEgKSAqIDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAgICAgICAgICAgICAyMDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgaWYgKCBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdID09IG51bGwgfHwgR0xPQkFMLnBsYXllcnNbdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgKyAxXS5nYW1lT3ZlciApIHRoaXMudGFyZ2V0UGxheWVyTnVtYmVyID0gMSAtIHRoaXMudGFyZ2V0UGxheWVyTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmliLmVuYWJsZUZsaWNrZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkFJID0gdGhpcy5BSV96YWtvODtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInpha285XCI6IC8vIOyYpOumrCDrs7TsiqRcclxuICAgICAgICAgICAgc3VwZXIoIFwiemFrb1wiLHsgeDogICAgICAgICAgICAgICAgICAgICAgeCwgeTogICAgICAgICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogICAgICAgICAgICAgICAgIDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmZTogICAgICAgICAgICAgICAgICAgaHAgKiAxMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJvc2lvblBvd2VyOiAgICAgICAgIDQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25QYXJ0aWNsZUNvdW50OiAxNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlQm9udXM6ICAgICAgICAgICAgIDUwMDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS55ID0gMTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkFJID0gdGhpcy5BSV96YWtvOTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInpha28xMFwiOiAvL+2SjeyEoFxyXG4gICAgICAgICAgICBzdXBlciggXCJ6YWtvXCIseyB4OiAgICAgICAgICAgICAgICAgICAgICB4LCB5OiAgICAgICAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAgICAgICAgICAgICAgICAgMTEgKyBzdWJUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmZTogICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2hvb3RXaGVuRGllOiAgICAgICAgIHN1YlR5cGUgPT0gMiA/IDEgOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUG93ZXI6ICAgICAgICAgNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJvc2lvblBhcnRpY2xlQ291bnQ6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Ryb3BQb3dlclVwOiAgICAgICAgICBzdWJUeXBlID09IDAgPyAxMCA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAgICAgICAgICAgICAxMDAgKyBzdWJUeXBlICogMTAwLFxyXG4gICAgICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSBVdGlscy5yYW5kb20oIC0yLDUgKSAqIDAuMDU7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkueSA9IC1VdGlscy5yYW5kb20oIDEsMTIgKSAqIDAuMDU7XHJcbiAgICAgICAgICAgIC8vIGlmIChnYW1lT3ZlcltzcHJpdGVbbmV3U3ByXS52YXJbMl1dKSBzcHJpdGVbbmV3U3ByXS52YXJbMl09MS1zcHJpdGVbbmV3U3ByXS52YXJbMl07XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sbGlzaW9uUGhhc2VDYWxsYmFjayggdGhpcy5jb2xsaXNpb24uYmluZCggdGhpcywwICkgKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiemFrbzExXCI6IC8v67aI6riw65GlXHJcbiAgICAgICAgICAgIHN1cGVyKCBcInpha29cIix7IHg6ICAgICAgICAgICAgICAgICAgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFgoIDI3MCArIDEwMCApLCB5OiAgICAgICAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRZKCAzMCApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAgICAgICAgICAgICAxNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZmU6ICAgICAgICAgICAgICAgaHAgKiAxMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFBsYXllck51bWJlcjogVXRpbHMucmFuZG9tKCAwLDEgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlQm9udXM6ICAgICAgICAgNTAwMCxcclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0b3BDb3VudGVyID0gMzAwO1xyXG4gICAgICAgICAgICAvLyBzLnZlbG9jaXR5Lnk9MTtcclxuICAgICAgICAgICAgaWYgKCBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdID09IG51bGwgfHwgR0xPQkFMLnBsYXllcnNbdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgKyAxXS5nYW1lT3ZlciApIHRoaXMudGFyZ2V0UGxheWVyTnVtYmVyID0gMSAtIHRoaXMudGFyZ2V0UGxheWVyTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuQUkgPSB0aGlzLkFJX3pha28xMTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIm1vbml0b3JcIjpcclxuICAgICAgICAgICAgc3VwZXIoIFwiemFrb1wiLHsgeDogICAgICAgICAgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFgoIDI3MCApLCB5OiAgICAgICAgICB2c1N0YWdlLndvcmxkLmdldFdvcmxkWSggLTMwICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICAgICAxNyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZmU6ICAgICAgIDEyMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlQm9udXM6IDUwMDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSAtMTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS55ID0gMTtcclxuICAgICAgICAgICAgdGhpcy5BSSA9IHRoaXMuQUlfbW9uaXRvcjtcclxuICAgICAgICAgICAgLy8gVE9ETzog64yA7IKsIOyymOumrCDtlbTslbztlahcclxuICAgICAgICAgICAgLy8gc2hvd01lc3NhZ2UoMTE5KTtcclxuICAgICAgICAgICAgLy8gY3VycmVudE1lc3NhZ2U9MTE5O1xyXG4gICAgICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBuZXcgRXZlbnQoIFwiZGlhbG9nXCIseyBtc2c6IFwibW9uaXRvclwiIH0gKSApOyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ6YWtvMTJcIjogLy/soJzrqqnrs7TsiqRcclxuICAgICAgICAgICAgc3VwZXIoIFwiZWZmZWN0XCIseyB4OiAgICAgICAgICAgICAgICAgICAgICB4LCB5OiAgICAgICAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICAgICAgICAgICAgICAgICAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWZlOiAgICAgICAgICAgICAgICAgICBocCAqIDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25Qb3dlcjogICAgICAgICA0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25QYXJ0aWNsZUNvdW50OiAxNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVCb251czogICAgICAgICAgICAgMTAwMDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkFJID0gdGhpcy5BSV96YWtvMTI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ6YWtvMTItMVwiOiAvL+ygnOuqqeuztOyKpFxyXG4gICAgICAgICAgICBzdXBlciggXCJlZmZlY3RcIix7IHg6ICAgICAgeCwgeTogICAgICB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpZmU6ICAgaHAgKiAxMCxcclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ6YWtvMTNcIjogLy8g7ZW06rOo67iM6528XHJcbiAgICAgICAgICAgIHN1cGVyKCBcInpha29cIix7IHg6ICAgICAgICAgICAgICAgICAgICAgIHggKyAyMSwgeTogICAgICAgICAgICAgICAgICAgICAgeSAtIDU3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAgICAgICAgICAgICAgICAgMTgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWZlOiAgICAgICAgICAgICAgICAgICBocCAqIDEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUG93ZXI6ICAgICAgICAgNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJvc2lvblBhcnRpY2xlQ291bnQ6IDE1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVCb251czogICAgICAgICAgICAgMTAwMDAsXHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMzID0gMTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyDslrzqtbTsnYQg6rmU7JWE64aT64qU64ukXHJcbiAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIxLmFkZENoaWxkKCBuZXcgWmFrbyggeyB0eXBlOiBcImZhY2VcIix4OiB4LCB5OiB5IH0gKSApO1xyXG4gICAgICAgICAgICB0aGlzLkFJID0gdGhpcy5BSV96YWtvMTM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJmYWNlXCI6IC8vIOyWvOq1tFxyXG4gICAgICAgICAgICBzdXBlciggXCJ6YWtvXCIseyB4OiAgICAgICAgICAgICAgICAgICAgICB4ICsgMjEsIHk6ICAgICAgICAgICAgICAgICAgICAgIHkgLSA1OSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogICAgICAgICAgICAgICAgIDE5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmZTogICAgICAgICAgICAgICAgICAgMTAwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByb3Npb25Qb3dlcjogICAgICAgICA0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcm9zaW9uUGFydGljbGVDb3VudDogMTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAgICAgICAgICAgICAxMDAwMCxcclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1czMgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJzd29yZHRyYWlsXCI6IC8vIOu2iOq4sOuRpSDqsoDqtJFcclxuICAgICAgICAgICAgc3VwZXIoIFwiemFrb1wiLHsgeDogICAgICAgICAgeCwgeTogICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogICAgIDE2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlmZTogICAgICAgMTAwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZUJvbnVzOiAyMDAwMCxcclxuICAgICAgICAgICAgfSApO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5kaXNhYmxlR3Jhdml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN1cGVyKCBcInpha29cIiApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5saWZlID0gdGhpcy5saWZlO1xyXG4gICAgICAgIHRoaXMubGV2ZWwgPSB0aGlzLmxldmVsO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0UGxheWVyTnVtYmVyID0gdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5zY29yZUJvbnVzID0gdGhpcy5zY29yZUJvbnVzO1xyXG4gICAgICAgIHRoaXMuZXhwbG9zaW9uUGFydGljbGVDb3VudCA9IHRoaXMuZXhwbG9zaW9uUGFydGljbGVDb3VudDtcclxuICAgICAgICB0aGlzLmV4cGxvc2lvblBvd2VyID0gdGhpcy5leHBsb3Npb25Qb3dlcjtcclxuICAgICAgICB0aGlzLmlzRHJvcFBvd2VyVXAgPSB0aGlzLmlzRHJvcFBvd2VyVXA7XHJcbiAgICAgICAgdGhpcy5pc1Nob290V2hlbkRpZSA9IHRoaXMuaXNTaG9vdFdoZW5EaWU7XHJcbiAgICAgICAgdGhpcy5zcGVlZCA9IHRoaXMuc3BlZWQ7XHJcbiAgICAgICAgLy8gbGV0IHQgPSBuZXcgVnNTeXN0ZW1UZXh0KCBlLnR5cGUgKTtcclxuICAgICAgICAvLyBzLmFkZENoaWxkKCB0ICk7XHJcbiAgICAgICAgdGhpcy5pc0VuZW15ID0gdHJ1ZTtcclxuICAgICAgICAvLyB0aGlzLnNob290KCB0aGlzLngsdGhpcy55LC0xLDAgKTtcclxuICAgICAgICB0aGlzLnNldFVwZGF0ZVBoYXNlQ2FsbGJhY2soIHRoaXMudXBkYXRlICk7XHJcbiAgICAgICAgaWYgKCB0aGlzLmNvbGxpc2lvbkNhbGxiYWNrID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sbGlzaW9uUGhhc2VDYWxsYmFjayggdGhpcy5jb2xsaXNpb24uYmluZCggdGhpcywxMDAgKSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzLmF0dHJpYi5lbmFibGVEZWJ1ZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vbiggXCJoaXRcIix0aGlzLm9uSGl0ICk7XHJcbiAgICAgICAgdGhpcy5zdGF0dXM0ID0gMDtcclxuICAgICAgICB0aGlzLm9uKCBcImNsZWFuVXBcIix0aGlzLm9uSGl0ICk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMud2hpdGUgPSAwO1xyXG4gICAgICAgIC8vIGlmICggdGhpcy5icmVha0ZsYWcgKSB7XHJcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCB2c1N0YWdlLndvcmxkLmdldFN0YWdlWCggdGhpcy54ICksdnNTdGFnZS53b3JsZC5nZXRTdGFnZVkoIHRoaXMueSApICk7XHJcbiAgICAgICAgLy8gICAgIGNvbnNvbGUuYXNzZXJ0KCk7ICAgXHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGlmICggdnNTdGFnZS53b3JsZC5nZXRTdGFnZVgoIHRoaXMueCApIDwgLXRoaXMuZ2V0V2lkdGgoKSAqIDAuNVxyXG4gICAgICAgICAgICB8fCB2c1N0YWdlLndvcmxkLmdldFN0YWdlWCggdGhpcy54ICkgPiBhcHBsaWNhdGlvbi5sb2dpY2FsVmlld3BvcnQud2lkdGggKiAxLjUgXHJcbiAgICAgICAgICAgIHx8IHZzU3RhZ2Uud29ybGQuZ2V0U3RhZ2VZKCB0aGlzLnkgKSA8IC10aGlzLmdldEhlaWdodCgpICkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSggXCJhdXRvUmVtb3ZlQ29tcG9uZW50XCIgKTtcclxuICAgICAgICAgICAgLy8gXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggdGhpcy5BSSApIHRoaXMuQUkoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb2xsaXNpb24oIGRhbWFnZSApIHtcclxuICAgICAgICBjb25zdCBjaGVja1BsYXllciA9ICggcCApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGxheWVyID0gR0xPQkFMLnBsYXllcnNbcF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIHBsYXllciAmJiBwbGF5ZXIucmVhZHlUaW1lciA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCBwbGF5ZXIuc2hpZWxkICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOyJtOuTnOyXkCDstqnrj4ztlojripTqsIBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuY2hlY2tSYW5nZSggcGxheWVyLnNoaWVsZCwwLDAgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkYW1hZ2UgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyLnNoaWVsZC5kaXNwYXRjaEV2ZW50KCBcImhpdFwiLHsgdHlwZTogXCJjb2xsaXNpb25cIiwgZGFtYWdlOiBkYW1hZ2UgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggXCJoaXRcIix7IHR5cGU6IFwiY29sbGlzaW9uXCIsZGFtYWdlOiAxMDAsb3duZXI6IHBsYXllciB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmxpZmUgPj0gMCAmJiB0aGlzLmNoZWNrUmFuZ2UoIHBsYXllciwwLDAgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhbWFnZSA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllci5kaXNwYXRjaEV2ZW50KCBcImhpdFwiLHsgdHlwZTogXCJjb2xsaXNpb25cIiwgZGFtYWdlOiBkYW1hZ2UgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIFwiaGl0XCIseyB0eXBlOiBcImNvbGxpc2lvblwiLGRhbWFnZTogMTAwLG93bmVyOiBwbGF5ZXIgfSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY2hlY2tQbGF5ZXIoIDEgKTtcclxuICAgICAgICBjaGVja1BsYXllciggMiApO1xyXG4gICAgfVxyXG5cclxuICAgIG9uSGl0KCBlICkge1xyXG4gICAgICAgIGxldCB7IGRhbWFnZSxvd25lciB9ID0gZTtcclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLmFjdGlvbiA9PSAxOSApIHtcclxuICAgICAgICAgICAgZGFtYWdlICs9IDEwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saWZlIC09IGRhbWFnZTtcclxuICAgICAgICB0aGlzLndoaXRlID0gMTtcclxuICAgICAgICBvd25lci5zY29yZSArPSB0aGlzLnNjb3JlQm9udXM7XHJcbiAgICAgICAgaWYgKCB0aGlzLmxpZmUgPD0gMCApIHtcclxuICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJleHBsb3Npb25cIiwgeyB4OiB0aGlzLngseTogdGhpcy55LGNvdW50OiB0aGlzLmV4cGxvc2lvblBhcnRpY2xlQ291bnQgfHwgMCAscG93ZXI6IHRoaXMuZXhwbG9zaW9uUG93ZXIgfHwgMCB9ICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuaXNEcm9wUG93ZXJVcCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BQb3dlclVwKCB0aGlzLnggKyBVdGlscy5yYW5kb20oIDAsIDAgKSx0aGlzLnksVXRpbHMucmFuZG9tKCAwLDcgKSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCBcImRpZVwiICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuc2NvcmVCb251cyA+PSA1MDAwICkge1xyXG4gICAgICAgICAgICAgICAgLy8g67O07IqkP1xyXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmFjdGlvbiA9PSAxNSApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDrtojquLDrkaVcclxuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBuZXcgRXZlbnQoIFwiZGlhbG9nXCIseyBtc2c6IFwiZW5kaW5nXCIgfSApICk7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHRoaXMuYWN0aW9uID09IDE3ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOuqqOuLiO2EsFxyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIG5ldyBFdmVudCggXCJkaWFsb2dcIix7IG1zZzogXCJtb25pdG9yQnJva2VuXCIgfSApICk7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcImdhbWVPdmVyXCIgKTsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5hY3Rpb24gIT0gMTUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g67aI6riw65GlIO2EsOyniCDrlYwg7YG066aw7JeFIOyymOumrO2VmOuptCDrqqjri4jthLDqsIAg7YSw7KC47IScIOyViOuQqFxyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwiY2xlYW5VcFwiLCB7IHR5cGU6IFwiY2xlYW5VcFwiLGRhbWFnZTogMjAwMCB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2c1N0YWdlLndvcmxkLnNjcm9sbFRhcmdldC52ZWxvY2l0eS54ID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwiYmdtXCIseyBmaWxlbmFtZTogYHNwYWNlYCB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQuc2Nyb2xsVGFyZ2V0LnZlbG9jaXR5LnggPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQuZXZlbnRUYXJnZXQudmVsb2NpdHkueCA9IDAuNTsgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZzU3RhZ2UucGFsZXR0ZS5mYWRlKCB7IHN0YXJ0OiAxLGVuZDogMCwgZHVyYXRpb246IDQwLCByYW5nZTogWzAsMjU0XSB9ICk7XHJcbiAgICAgICAgICAgICAgICBTb3VuZC5wbGF5U291bmQoIGBiYW5nLndhdmAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFNvdW5kLnBsYXlTb3VuZCggYHpha28ud2F2YCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiAoIHRoaXMuYWN0aW9uID09IDE4ICkge1xyXG4gICAgICAgICAgICAvLyAgICAgLy8g7ZW06rOo67iM6528XHJcbiAgICAgICAgICAgIC8vICAgICBsZXQgc3ByID0gbmV3IFZzU3ByaXRlKCBcInpha29cIix7IHg6IHRoaXMueCx5OiB0aGlzLnksYWN0aW9uOiAxOSB9ICk7XHJcbiAgICAgICAgICAgIC8vICAgICBzcHIuYXR0cmliLmVuYWJsZUF1dG9SZW1vdmVTdGFnZU91dCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vICAgICBzcHIubGlmZSA9IDMwMDA7XHJcbiAgICAgICAgICAgIC8vICAgICBzcHIuc2NvcmVCb251cyA9IDUwMDA7XHJcbiAgICAgICAgICAgIC8vICAgICBzcHIuc3RhdHVzID0gMTtcclxuICAgICAgICAgICAgLy8gICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIxLmFkZENoaWxkKCBzcHIgKTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAvLyBpZiAoIHRoaXMuYWN0aW9uID09IDE5ICkge1xyXG4gICAgICAgICAgICAvLyAgICAgLy8g66+47JWI67iM6528XHJcbiAgICAgICAgICAgIC8vICAgICBsZXQgc3ByID0gbmV3IFZzU3ByaXRlKCBcInpha29cIix7IHg6IHRoaXMueCx5OiB0aGlzLnksYWN0aW9uOiAyMCB9ICk7XHJcbiAgICAgICAgICAgIC8vICAgICBzcHIuYXR0cmliLmVuYWJsZUF1dG9SZW1vdmVTdGFnZU91dCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vICAgICBzcHIubGlmZSA9IDUwMDA7XHJcbiAgICAgICAgICAgIC8vICAgICBzcHIuc3RhdHVzID0gMTtcclxuICAgICAgICAgICAgLy8gICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIxLmFkZENoaWxkKCBzcHIgKTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuYWN0aW9uID09IDE3ICkge1xyXG4gICAgICAgICAgICAgICAgLy8g66qo64uI7YSwXHJcbiAgICAgICAgICAgICAgICBTb3VuZC5wbGF5U291bmQoIGBiYW5nLndhdmAgKTtcclxuICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwiZXhwbG9zaW9uXCIseyB4OiB0aGlzLngseTogdGhpcy55LGNvdW50OiAyMCxwb3dlcjogNCB9ICk7XHJcbiAgICAgICAgICAgICAgICBHTE9CQUwucmVzdENvaW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzdFswXT0wO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzdFsxXT0wO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVhZHlUaW1lclswXT0wO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVhZHlUaW1lclsxXT0wO1xyXG4gICAgICAgICAgICAgICAgLy8gcGxheWVyRGllKDApO1xyXG4gICAgICAgICAgICAgICAgLy8gcGxheWVyRGllKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5hY3Rpb24gPT0gMTUgKSB7XHJcbiAgICAgICAgICAgICAgICBvd25lci5zY29yZSArPSAzMDAwMDtcclxuICAgICAgICAgICAgICAgIFNvdW5kLnBsYXlTb3VuZCggYGJhbmcud2F2YCApO1xyXG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJleHBsb3Npb25cIix7IHg6IHRoaXMueCx5OiB0aGlzLnksY291bnQ6IDIwLHBvd2VyOiA0IH0gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIHRoaXMuaXNTaG9vdFdoZW5EaWUgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgMzYwOyBpICs9IDIyLjUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG9vdCggdGhpcy54LHRoaXMueSwgLi4uYW5nbGVUb1hZKCBpLDEuNSApICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBTb3VuZC5wbGF5U291bmQoIGBiYW5nLndhdmAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIC8vIOyKpOy9lOyWtCDrpqztlITrnpjsi5xcclxuICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggXCJyZWZyZXNoVUlcIix7IHBsYXllcjogb3duZXIucGxheWVyIH0gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDtg4Qg66ee6rOgIOyViOyjveyXiOydhCDrlYxcclxuICAgICAgICAgICAgU291bmQucGxheVNvdW5kKCBgemFrby53YXZgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNob290KCB4LHksdngsdnkgKSB7XHJcbiAgICAgICAgbGV0IHNwciA9IG5ldyBWc1Nwcml0ZSggXCJlZmZlY3RcIix7XHJcbiAgICAgICAgICAgIHg6ICAgICAgeCxcclxuICAgICAgICAgICAgeTogICAgICB5LFxyXG4gICAgICAgICAgICBhY3Rpb246IDZcclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIHNwci52ZWxvY2l0eS54ID0gdng7XHJcbiAgICAgICAgc3ByLnZlbG9jaXR5LnkgPSB2eTtcclxuICAgICAgICBzcHIuYXV0b1JlbW92ZVRpbWVyID0gNjAgKiAxMDA7XHJcbiAgICAgICAgc3ByLmF0dHJpYi5lbmFibGVBdXRvUmVtb3ZlU3RhZ2VPdXQgPSB0cnVlO1xyXG4gICAgICAgIHNwci5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIHNwci5hdHRyaWIuZW5hYmxlTWFwQ29sbGlzaW9uVG9wID0gdHJ1ZTtcclxuICAgICAgICBzcHIuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvbkJvdHRvbSA9IHRydWU7XHJcbiAgICAgICAgc3ByLmF0dHJpYi5lbmFibGVNYXBDb2xsaXNpb25MZWZ0ID0gdHJ1ZTtcclxuICAgICAgICBzcHIuYXR0cmliLmVuYWJsZU1hcENvbGxpc2lvblJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICBzcHIubGlmZSA9IDE7XHJcbiAgICAgICAgc3ByLnNldENvbGxpc2lvblBoYXNlQ2FsbGJhY2soIHRoaXMuY29sbGlzaW9uLmJpbmQoIHNwciwxMCApICk7XHJcbiAgICAgICAgc3ByLnNldE1hcENvbGxpc2lvblBoYXNlQ2FsbGJhY2soICggdG91Y2hlZE1hcEF0dHJpYiApPT57XHJcbiAgICAgICAgICAgIGlmICggdG91Y2hlZE1hcEF0dHJpYiApIHNwci5yZW1vdmUoIFwiYmxvY2tcIiApO1xyXG4gICAgICAgIH0gKTtcclxuICAgICAgICBzcHIub24oIFwiaGl0XCIsKCApPT57XHJcbiAgICAgICAgICAgIHNwci5yZW1vdmUoIFwiZGFtYWdlXCIgKTtcclxuICAgICAgICB9ICk7XHJcbiAgICAgICAgc3ByLm9uKCBcImNsZWFuVXBcIiwoICk9PntcclxuICAgICAgICAgICAgc3ByLnJlbW92ZSggXCJjbGVhblVwXCIgKTtcclxuICAgICAgICB9ICk7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgc3ByLnN0YXR1czEgPSA0NDsgLy8gP1xyXG4gICAgICAgIHZzU3RhZ2Uud29ybGQubGF5ZXI0LmFkZENoaWxkKCBzcHIgKTtcclxuICAgIH1cclxuXHJcbiAgICBkcm9wUG93ZXJVcCggeCx5LHR5cGUgKSB7XHJcbiAgICAgICAgbGV0IHNwciA9IG5ldyBWc1Nwcml0ZSggXCJwX2hhbFwiLHsgeCx5LGFjdGlvbjogdHlwZSA+IDAgPyA5IDogMTAgfSApO1xyXG5cclxuICAgICAgICBzcHIuYXR0cmliLmRpc2FibGVHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICBsZXQgcGxheWVycyA9IEdMT0JBTC5wbGF5ZXJzO1xyXG5cclxuICAgICAgICBzcHIuc2V0Q29sbGlzaW9uUGhhc2VDYWxsYmFjayggKCk9PntcclxuICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tQbGF5ZXIoIHAgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHBsYXllcnNbcF0gJiYgc3ByLmNoZWNrUmFuZ2UoIHBsYXllcnNbcF0sMCwwICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzcHIuYWN0aW9uID09IDEwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDsoITshoztj63tg4RcclxuICAgICAgICAgICAgICAgICAgICAgICAgU291bmQucGxheVNvdW5kKCBgY2xlYXIud2F2YCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHIucmVtb3ZlKCBcImNsZWFuVXBcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2c1N0YWdlLndvcmxkLmRpc3BhdGNoRXZlbnRXaXRoQ2hpbGRyZW4oIFwiY2xlYW5VcFwiLCB7IHR5cGU6IFwiY2xlYW5VcFwiLGRhbWFnZTogMTAwLCBvd25lcjogcGxheWVyc1twXSB9ICk7ICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g7J2867CYIO2MjOybjOyXhVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzW3BdLnBvd2VyID0gKCBwbGF5ZXJzW3BdLnBvd2VyICsgMSApICUgNztcclxuICAgICAgICAgICAgICAgICAgICAgICAgU291bmQucGxheVNvdW5kKCBgaXRlbS53YXZgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmRpc3BhdGNoRXZlbnQoIFwicmVmcmVzaFVJXCIseyBwbGF5ZXI6IHAgfSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHIucmVtb3ZlKCBcInBvd2VyVXBcIiApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGVja1BsYXllciggMSApO1xyXG4gICAgICAgICAgICBjaGVja1BsYXllciggMiApO1xyXG4gICAgICAgIH0gKTtcclxuICAgICAgICBzcHIuc2V0VXBkYXRlUGhhc2VDYWxsYmFjayggKCk9PntcclxuICAgICAgICAgICAgaWYgKCB2c1N0YWdlLndvcmxkLmdldFN0YWdlWCggc3ByLnggKSA8IC10aGlzLmdldFdpZHRoKCkgKSB7XHJcbiAgICAgICAgICAgICAgICBzcHIucmVtb3ZlKCBcImF1dG9SZW1vdmVDb21wb25lbnRcIiApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSApO1xyXG4gICAgICAgIHZzU3RhZ2Uud29ybGQubGF5ZXI0LmFkZENoaWxkKCBzcHIgKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgQUlfemFrbzEoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0dXM0ICs9IDI7XHJcbiAgICAgICAgaWYgKCB0aGlzLnN0YXR1czQgPiAxODAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzNCAtPSAzNjA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHRoaXMubGV2ZWwgPiAxICkge1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSBNYXRoLnNpbiggdGhpcy5zdGF0dXM0ICogTWF0aC5QSSAvIDE4MCApICogMC41O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIFV0aWxzLnJhbmRvbSggMCwoIDUgLSB0aGlzLmxldmVsICkgKiAxMDAgKyA1MCApID09IDAgKSB7XHJcbiAgICAgICAgICAgIGxldCBhID0gVXRpbHMucmFuZG9tKCAwLDM1OSApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zaG9vdCggdGhpcy54LHRoaXMueSwuLi5hbmdsZVRvWFkoIGEsMC40ICkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggdGhpcy54IDwgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFgoIDI1ICkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkueCA9IEdMT0JBTC5zY3JvbGxTcGVlZCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEFJX3pha28yKCkge1xyXG4gICAgICAgIGlmICggR0xPQkFMLnBsYXllcnNbdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgKyAxXSA9PSBudWxsICkgcmV0dXJuO1xyXG4gICAgICAgIGxldCB0YXJnZXRZID0gR0xPQkFMLnBsYXllcnNbdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgKyAxXS55O1xyXG5cclxuICAgICAgICB0aGlzLnRpbWVyLS07XHJcbiAgICAgICAgaWYgKCB0aGlzLnRpbWVyID09IDAgfHwgdGhpcy50aW1lciA8IC0yNTUgKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkueCA9IC01O1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLkFJID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIHRoaXMueSA8IHRhcmdldFkgLSA1ICkgdGhpcy52ZWxvY2l0eS55ID0gMTtcclxuICAgICAgICBlbHNlIGlmICggdGhpcy55ID4gdGFyZ2V0WSArIDUgKSB0aGlzLnZlbG9jaXR5LnkgPSAtMTtcclxuICAgICAgICBpZiAoIHRoaXMueCA8IHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRYKCAyMzUgKSApIHtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcclxuICAgICAgICAgICAgLy9cdFx0Y3Nwci54PVdPUkxEX1goMjM1KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQUlfemFrbzMoKSB7XHJcbiAgICAgICAgaWYgKCBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdID09IG51bGwgKSByZXR1cm47XHJcbiAgICAgICAgbGV0IHRhcmdldFggPSBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdLng7XHJcbiAgICAgICAgbGV0IHRhcmdldFkgPSBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdLnk7XHJcbiAgICBcclxuICAgICAgICBpZiAoIHRoaXMueSA8IHRhcmdldFkgLSA1ICkgdGhpcy52ZWxvY2l0eS55ID0gdGhpcy5zcGVlZDtcclxuICAgICAgICBlbHNlIGlmICggdGhpcy55ID4gdGFyZ2V0WSArIDUgKSB0aGlzLnZlbG9jaXR5LnkgPSAtIHRoaXMuc3BlZWQ7XHJcbiAgICAgICAgaWYgKCB0aGlzLnggPCB0YXJnZXRYICsgNDUgKSB0aGlzLnZlbG9jaXR5LnggPSAyO1xyXG4gICAgICAgIGVsc2UgaWYgKCB0aGlzLnggPiB0YXJnZXRYICsgNTAgKSB0aGlzLnZlbG9jaXR5LnggPSAtMjtcclxuICAgIH1cclxuXHJcbiAgICBBSV96YWtvNCgpIHtcclxuICAgICAgICBpZiAoIEdMT0JBTC5wbGF5ZXJzW3RoaXMudGFyZ2V0UGxheWVyTnVtYmVyICsgMV0gPT0gbnVsbCApIHJldHVybjtcclxuICAgICAgICBsZXQgdGFyZ2V0WCA9IEdMT0JBTC5wbGF5ZXJzW3RoaXMudGFyZ2V0UGxheWVyTnVtYmVyICsgMV0ueDtcclxuICAgICAgICBsZXQgdGFyZ2V0WSA9IEdMT0JBTC5wbGF5ZXJzW3RoaXMudGFyZ2V0UGxheWVyTnVtYmVyICsgMV0ueTtcclxuXHJcbiAgICAgICAgaWYgKCBVdGlscy5yYW5kb20oIDAsNTAgKSA9PSAwICkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldFBsYXllck51bWJlciA9IFV0aWxzLnJhbmRvbSggMCwxICk7XHJcbiAgICAgICAgICAgIGlmICggR0xPQkFMLnBsYXllcnNbdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgKyAxXSA9PSBudWxsIHx8IEdMT0JBTC5wbGF5ZXJzW3RoaXMudGFyZ2V0UGxheWVyTnVtYmVyICsgMV0uZ2FtZU92ZXIgKSB0aGlzLnRhcmdldFBsYXllck51bWJlciA9IDEgLSB0aGlzLnRhcmdldFBsYXllck51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB0YXJnZXRZIDwgdGhpcy55ICkge1xyXG4gICAgICAgICAgICBpZiAoIFV0aWxzLnJhbmRvbSggMCwxNTAgLSB0aGlzLmxldmVsICogMTAgKSA9PSAwICkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGEgPSBVdGlscy5yYW5kb20oIDAsOTAgKSAqIE1hdGguUEkgLyAxODA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCB0YXJnZXRYIDwgdGhpcy54ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvb3QoIHRoaXMueCx0aGlzLnkgLSA0LE1hdGguY29zKCBhICsgOTAgKiBNYXRoLlBJIC8gMTgwICkgKiAwLjUsLU1hdGguc2luKCBhICsgOTAgKiBNYXRoLlBJIC8gMTgwICkgKiAwLjUgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG9vdCggdGhpcy54LHRoaXMueSAtIDQsTWF0aC5jb3MoIGEgKSAqIDAuNSwtTWF0aC5zaW4oIGEgKSAqIDAuNSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEFJX3pha283KCkge1xyXG4gICAgICAgIHRoaXMudGltZXIrKztcclxuICAgICAgICBpZiAoIHRoaXMudGltZXIgPiAyNDAgKyB0aGlzLmxldmVsICogMjAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBYID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLnRpbWVyID4gMjAwICYmICggdGhpcy50aW1lciAmIDcgKSA9PSAwICkge1xyXG4gICAgICAgICAgICB0aGlzLnNob290KCB0aGlzLngsdGhpcy55LC00LDAgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLnRpbWVyID4gMTUwICkge1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBYID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaWYgKCB0aGlzLmxldmVsICE9IDAgKSB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5zdGF0dXMyID09IDEgJiYgVXRpbHMucmFuZG9tKCAwLDEwMCAtIHRoaXMubGV2ZWwgKiAxMCApID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSAtdGhpcy5sZXZlbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzMiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQUlfemFrbzgoKSB7XHJcbiAgICAgICAgaWYgKCBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdID09IG51bGwgKSByZXR1cm47XHJcbiAgICAgICAgbGV0IHRhcmdldFggPSBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdLng7XHJcbiAgICAgICAgbGV0IHRhcmdldFkgPSBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdLnk7XHJcbiAgICBcclxuICAgICAgICB0aGlzLnN0YXR1czQrKztcclxuICAgICAgICBpZiAoIHRoaXMuc3RhdHVzNCA+IDEyMCApIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlRmxpY2tlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNldENvbGxpc2lvblBoYXNlQ2FsbGJhY2soIHRoaXMuY29sbGlzaW9uLmJpbmQoIHRoaXMsMTAwICkgKTtcclxuICAgIFxyXG4gICAgICAgICAgICBpZiAoIHRoaXMueSA8IHRhcmdldFkgLSA1ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS55ID0gKCB0aGlzLmxldmVsICsgMSApICogMC4yNSAqIDAuNTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy55ID4gdGFyZ2V0WSArIDUgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSAtKCB0aGlzLmxldmVsICsgMSApICogMC4yNSAqIDAuNTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkueSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICBpZiAoIHRoaXMueCA8IHRhcmdldFggLSA1ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gKCB0aGlzLmxldmVsICsgMSApICogMC4yNSAqIDAuNSArIHZzU3RhZ2Uud29ybGQuc2Nyb2xsVGFyZ2V0LnZlbG9jaXR5Lng7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHRoaXMueCA+IHRhcmdldFggKyA1ICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gLSggdGhpcy5sZXZlbCArIDEgKSAqIDAuMjUgKiAwLjUgKyB2c1N0YWdlLndvcmxkLnNjcm9sbFRhcmdldC52ZWxvY2l0eS54O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gdnNTdGFnZS53b3JsZC5zY3JvbGxUYXJnZXQudmVsb2NpdHkueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7IFxyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSAwOyBcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDsgXHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sbGlzaW9uUGhhc2VDYWxsYmFjayggbnVsbCApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBBSV96YWtvOSgpIHtcclxuICAgICAgICBpZiAoIHRoaXMuc3RhdHVzNCsrID4gMTIwICkge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYi5lbmFibGVGbGlja2VyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sbGlzaW9uUGhhc2VDYWxsYmFjayggdGhpcy5jb2xsaXNpb24uYmluZCggdGhpcywxMDAgKSApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sbGlzaW9uUGhhc2VDYWxsYmFjayggbnVsbCApO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGlmICggdGhpcy55IDwgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFkoIDEwICkgKSB0aGlzLnZlbG9jaXR5LnkgPSAxO1xyXG4gICAgICAgIGlmICggdGhpcy55ID4gdnNTdGFnZS53b3JsZC5nZXRXb3JsZFkoIDE5NSApICkgdGhpcy52ZWxvY2l0eS55ID0gLTE7XHJcbiAgICAgICAgaWYgKCBVdGlscy5yYW5kb20oIDAsOTkgKSA9PSAwICkge1xyXG4gICAgICAgICAgICB0aGlzLnNob290KCB0aGlzLngsdGhpcy55LC4uLmFuZ2xlVG9YWSggMTcwLDIgKSApO1xyXG4gICAgICAgICAgICB0aGlzLnNob290KCB0aGlzLngsdGhpcy55LC4uLmFuZ2xlVG9YWSggMTgwLDIgKSApO1xyXG4gICAgICAgICAgICB0aGlzLnNob290KCB0aGlzLngsdGhpcy55LC4uLmFuZ2xlVG9YWSggMTkwLDIgKSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIFV0aWxzLnJhbmRvbSggMCw5OSApID09IDAgKSB7XHJcbiAgICAgICAgICAgIGxldCBzcHIgPSBuZXcgWmFrbyggeyB0eXBlOiBcIm1pbmlEdWNrXCIseDogdGhpcy54LHk6IHRoaXMueSB9ICk7XHJcblxyXG4gICAgICAgICAgICB2c1N0YWdlLndvcmxkLmxheWVyMy5hZGRDaGlsZCggc3ByICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBBSV9tb25pdG9yKCkge1xyXG4gICAgICAgIGlmICggdGhpcy54IDwgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFgoIDEwICkgKSB0aGlzLnZlbG9jaXR5LnggPSAxO1xyXG4gICAgICAgIGlmICggdGhpcy54ID4gdnNTdGFnZS53b3JsZC5nZXRXb3JsZFgoIDI0NSApICkgdGhpcy52ZWxvY2l0eS54ID0gLTE7XHJcbiAgICAgICAgaWYgKCB0aGlzLnkgPCB2c1N0YWdlLndvcmxkLmdldFdvcmxkWSggMTAgKSApIHRoaXMudmVsb2NpdHkueSA9IDE7XHJcbiAgICAgICAgaWYgKCB0aGlzLnkgPiB2c1N0YWdlLndvcmxkLmdldFdvcmxkWSggMTk1ICkgKSB0aGlzLnZlbG9jaXR5LnkgPSAtMTtcclxuICAgIH1cclxuXHJcbiAgICBBSV96YWtvMTEoKSB7XHJcbiAgICAgICAgbGV0IHRhcmdldFk7XHJcbiAgICAgICAgbGV0IHRhcmdldFg7XHJcblxyXG4gICAgICAgIC8vVE9ETzog67aI6riw65GlIEFJ7J24642wIO2UjOugiOydtOyWtOqwgCDri6Qg7KO97Jy866m0IO2ZlOuptCDrsJbsnLzroZwg64KY6rCA64qUIOusuOygnOqwgCDsnojri6RcclxuICAgICAgICBpZiAoIFV0aWxzLnJhbmRvbSggMCw0OSApID09IDAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UGxheWVyTnVtYmVyID0gVXRpbHMucmFuZG9tKCAwLDEgKTtcclxuICAgICAgICAgICAgaWYgKCBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdID09IG51bGwgKSByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggdGhpcy5saWZlIDwgMzAwICYmIHRoaXMucmVmU3ByID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIGxldCBzcHIgPSBuZXcgWmFrbygge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJtb25pdG9yXCIsXHJcbiAgICAgICAgICAgICAgICB4OiAgICB2c1N0YWdlLndvcmxkLmdldFdvcmxkWCggMjcwICksXHJcbiAgICAgICAgICAgICAgICB5OiAgICB2c1N0YWdlLndvcmxkLmdldFdvcmxkWSggLTMwICksXHJcbiAgICAgICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIzLmFkZENoaWxkQXQoIHNwciApO1xyXG4gICAgICAgICAgICB0aGlzLnJlZlNwciA9IHNwcjtcclxuICAgICAgICAgICAgYXBwbGljYXRpb24uZGlzcGF0Y2hFdmVudCggbmV3IEV2ZW50KCBcImRpYWxvZ1wiLHsgbXNnOiBcIm1vbml0b3JcIiB9ICkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCB0aGlzLnN0YXR1czQgIT0gMCB8fCB0aGlzLnJlZlNwciA9PSBudWxsICkge1xyXG4gICAgICAgICAgICBpZiAoIEdMT0JBTC5wbGF5ZXJzW3RoaXMudGFyZ2V0UGxheWVyTnVtYmVyICsgMV0gIT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFggPSBHTE9CQUwucGxheWVyc1t0aGlzLnRhcmdldFBsYXllck51bWJlciArIDFdLng7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRZID0gR0xPQkFMLnBsYXllcnNbdGhpcy50YXJnZXRQbGF5ZXJOdW1iZXIgKyAxXS55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICggVXRpbHMucmFuZG9tKCAwLDk5ICkgPT0gMCApIHRoaXMuc3RhdHVzNCA9IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8g66qo64uI7YSwIOuSpOyXkCDsiKjquLBcclxuICAgICAgICAgICAgdGFyZ2V0WSA9IHRoaXMucmVmU3ByLnk7XHJcbiAgICAgICAgICAgIHRhcmdldFggPSB0aGlzLnJlZlNwci54IC0gIDQwO1xyXG4gICAgICAgICAgICBpZiAoIFV0aWxzLnJhbmRvbSggMCwxOTkgKSA9PSAwICkgdGhpcy5zdGF0dXM0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBpZiAoIFV0aWxzLnJhbmRvbSggMCw1MCApID09IDAgKSB7XHJcbiAgICAgICAgICAgIC8vIOygleyngO2WiOuLpOqwgCDsnbTrj5ntlojri6TqsIBcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXM0ID0gMSAtIHRoaXMuc3RhdHVzNDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBpZiAoIHRoaXMueSA8IHRhcmdldFkgLSAgNSApIHRoaXMudmVsb2NpdHkueSA9IDEgKyB0aGlzLnN0YXR1czQ7XHJcbiAgICAgICAgZWxzZSBpZiAoIHRoaXMueSA+IHRhcmdldFkgKyAgNSApICB0aGlzLnZlbG9jaXR5LnkgPSAtKCAxICsgdGhpcy5zdGF0dXM0ICk7XHJcbiAgICAgICAgZWxzZSB0aGlzLnZlbG9jaXR5LnkgPSAwO1xyXG4gICAgXHJcbiAgICAgICAgaWYgKCB0aGlzLnggPCB0YXJnZXRYICsgMTAwICYmIHRoaXMueCA8IHZzU3RhZ2Uud29ybGQuZ2V0V29ybGRYKCAyMzUgKSApIHtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gIDEgKyB0aGlzLnN0YXR1czQ7XHJcbiAgICAgICAgfSBlbHNlIGlmICggdGhpcy54ID4gdGFyZ2V0WCArICAyMTAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkueCA9IC0gKCAxICsgdGhpcy5zdGF0dXM0ICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICggVXRpbHMucmFuZG9tKCAwLDEwMCApID09IDAgKSB7XHJcbiAgICAgICAgICAgIC8vIOqygOq0kSDrsJzsgqxcclxuICAgICAgICAgICAgbGV0IHNwciA9IG5ldyBaYWtvKCB7IHR5cGU6IFwic3dvcmR0cmFpbFwiLHg6IHRoaXMueCx5OiB0aGlzLnkgLGhwOiAxMDAwMDAgfSApO1xyXG5cclxuICAgICAgICAgICAgc3ByLnZlbG9jaXR5LnggPSAtMTtcclxuICAgICAgICAgICAgc3ByLmFjY2VsZXJhdGlvbi54ID0gLTAuMDU7XHJcbiAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIzLmFkZENoaWxkKCBzcHIgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBVdGlscy5yYW5kb20oIDAsMTE5ICkgPT0gMCApIHtcclxuICAgICAgICAgICAgbGV0IGEgPSBVdGlscy5yYW5kb20oIDAsMzU5ICk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNob290KCB0aGlzLngsdGhpcy55IC0gIDQgLC4uLmFuZ2xlVG9YWSggYSwwLjUgKSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBBSV96YWtvMTIoKSB7XHJcbiAgICAgICAgaWYgKCB0aGlzLnN0YXR1czQrKyA+IDEyMCApIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWIuZW5hYmxlRmxpY2tlciA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCB0aGlzLnkgPCB2c1N0YWdlLndvcmxkLmdldFdvcmxkWSggMTAgKSApIHRoaXMudmVsb2NpdHkueSA9IDE7XHJcbiAgICAgICAgaWYgKCB0aGlzLnkgPiAgdnNTdGFnZS53b3JsZC5nZXRXb3JsZFkoIDE5NSApICkgdGhpcy52ZWxvY2l0eS55ID0gLTE7XHJcbiAgICAgICAgaWYgKCBVdGlscy5yYW5kb20oIDAsNzAgKSA9PSAwICkge1xyXG4gICAgICAgICAgICBsZXQgc3ByID0gbmV3IFpha28oIHsgdHlwZTogXCJ6YWtvMlwiLHg6IHRoaXMueCx5OiB0aGlzLnkgLGhwOiAyLHRpbWVyOiAxMCB9ICk7XHJcblxyXG4gICAgICAgICAgICB2c1N0YWdlLndvcmxkLmxheWVyMy5hZGRDaGlsZCggc3ByICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggVXRpbHMucmFuZG9tKCAwLDEyMCApID09IDAgKSB7XHJcbiAgICAgICAgICAgIGxldCBzcHIgPSBuZXcgWmFrbyggeyB0eXBlOiBcInpha28xMi0xXCIseDogdGhpcy54LHk6IHRoaXMueSAsaHA6IDIwIH0gKTtcclxuXHJcbiAgICAgICAgICAgIHNwci52ZWxvY2l0eSA9IG5ldyBQb2ludCggLi4uYW5nbGVUb1hZKCAxNzAsMiApICk7XHJcbiAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIzLmFkZENoaWxkKCBzcHIgKTtcclxuICAgICAgICAgICAgc3ByID0gbmV3IFpha28oIHsgdHlwZTogXCJ6YWtvMTItMVwiLHg6IHRoaXMueCx5OiB0aGlzLnkgLGhwOiAyMCB9ICk7XHJcbiAgICAgICAgICAgIHNwci52ZWxvY2l0eSA9IG5ldyBQb2ludCggLi4uYW5nbGVUb1hZKCAxOTAsMiApICk7XHJcbiAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIzLmFkZENoaWxkKCBzcHIgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQUlfemFrbzEzKCkge1xyXG4gICAgICAgIGlmICggVXRpbHMucmFuZG9tKCAwLDIwMCApID09IDAgKSB7XHJcbiAgICAgICAgICAgIGxldCBzcHIgPSBuZXcgWmFrbyggeyB0eXBlOiBcInpha280XCIseDogdGhpcy54LHk6IHRoaXMueSxocDogNSxzdWJUeXBlOiAxIH0gKTtcclxuXHJcbiAgICAgICAgICAgIHZzU3RhZ2Uud29ybGQubGF5ZXIzLmFkZENoaWxkKCBzcHIgKTtcclxuICAgICAgICAgICAgc3ByLmxldmVsID0gMTM7XHJcbiAgICAgICAgICAgIHNwci52ZWxvY2l0eS55ID0gLTE7XHJcbiAgICAgICAgICAgIHNwci52ZWxvY2l0eS54ID0gVXRpbHMucmFuZG9tKCAtNCwxICkgKiAwLjE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggVXRpbHMucmFuZG9tKCAwLDMwMCApID09IDAgKSB7XHJcbiAgICAgICAgICAgIGxldCBzcHIgPSBuZXcgWmFrbyggeyB0eXBlOiBcInpha28zXCIseDogdnNTdGFnZS53b3JsZC5nZXRTdGFnZVgoIDI2MCApLHk6IHRoaXMueSxocDogMjAsc3ViVHlwZTogMSB9ICk7XHJcblxyXG4gICAgICAgICAgICB2c1N0YWdlLndvcmxkLmxheWVyMy5hZGRDaGlsZCggc3ByICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggVXRpbHMucmFuZG9tKCAwLDkwICkgPT0gMCApIHtcclxuICAgICAgICAgICAgbGV0IGEgPSBVdGlscy5yYW5kb20oIDE0MCwyMjAgKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2hvb3QoIHRoaXMueCx0aGlzLnksLi4uYW5nbGVUb1hZKCBhIC0gMzAsMSApICk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvb3QoIHRoaXMueCx0aGlzLnksLi4uYW5nbGVUb1hZKCBhIC0gMjAsMSApICk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvb3QoIHRoaXMueCx0aGlzLnksLi4uYW5nbGVUb1hZKCBhIC0gMTAsMSApICk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvb3QoIHRoaXMueCx0aGlzLnksLi4uYW5nbGVUb1hZKCBhLDEgKSApO1xyXG4gICAgICAgICAgICB0aGlzLnNob290KCB0aGlzLngsdGhpcy55LC4uLmFuZ2xlVG9YWSggYSArIDEwLDEgKSApO1xyXG4gICAgICAgICAgICB0aGlzLnNob290KCB0aGlzLngsdGhpcy55LC4uLmFuZ2xlVG9YWSggYSArIDIwLDEgKSApO1xyXG4gICAgICAgICAgICB0aGlzLnNob290KCB0aGlzLngsdGhpcy55LC4uLmFuZ2xlVG9YWSggYSArIDMwLDEgKSApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3Bhd25aYWtvKCBlICkge1xyXG4gICAgbGV0IHNwciA9IG5ldyBaYWtvKCBlICk7XHJcblxyXG4gICAgdnNTdGFnZS53b3JsZC5sYXllcjMuYWRkQ2hpbGQoIHNwciApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBsb3Npb24oIGUgKSB7XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAoIGUuY291bnQgfHwgMSApOyBpKysgKSB7XHJcbiAgICAgICAgbGV0IHMgPSBuZXcgVnNTcHJpdGUoIFwiZWZmZWN0XCIseyB4OiBlLngseTogZS55IH0gKTtcclxuXHJcbiAgICAgICAgcy5hbmltYXRpb25TdG9wQ291bnRlciA9IFV0aWxzLnJhbmRvbSggMCxlLmNvdW50ICk7XHJcbiAgICAgICAgcy5hdHRyaWIuZGlzYWJsZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIHMuYXR0cmliLmVuYWJsZUF1dG9SZW1vdmVTdGFnZU91dCA9IHRydWU7XHJcbiAgICAgICAgbGV0IHJhZCA9IFV0aWxzLnJhbmRvbSggMCwzNTkgKSAqIE1hdGguUEkgLyAxODA7XHJcblxyXG4gICAgICAgIHMudmVsb2NpdHkueCA9IE1hdGguY29zKCByYWQgKSAqIFV0aWxzLnJhbmRvbSggMCxlLnBvd2VyICogMTAwICkgLyAxMDA7XHJcbiAgICAgICAgcy52ZWxvY2l0eS55ID0gTWF0aC5zaW4oIHJhZCApICogVXRpbHMucmFuZG9tKCAwLGUucG93ZXIgKiAxMDAgKSAvIDEwMDtcclxuICAgICAgICB2c1N0YWdlLndvcmxkLmxheWVyNC5hZGRDaGlsZCggcyApO1xyXG4gICAgfVxyXG59XHJcblxyXG5hcHBsaWNhdGlvbi5vbiggXCJzcGF3bjp6YWtvXCIsIHNwYXduWmFrbyApO1xyXG5hcHBsaWNhdGlvbi5vbiggXCJleHBsb3Npb25cIiwgZXhwbG9zaW9uICk7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIi8qIEBsaWNlbnNlIHR3Z2wuanMgNC4yMS4yIENvcHlyaWdodCAoYykgMjAxNSwgR3JlZ2cgVGF2YXJlcyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuQXZhaWxhYmxlIHZpYSB0aGUgTUlUIGxpY2Vuc2UuXG5zZWU6IGh0dHA6Ly9naXRodWIuY29tL2dyZWdnbWFuL3R3Z2wuanMgZm9yIGRldGFpbHMgKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKlxuICogVmVjMyBtYXRoIG1hdGggZnVuY3Rpb25zLlxuICpcbiAqIEFsbW9zdCBhbGwgZnVuY3Rpb25zIHRha2UgYW4gb3B0aW9uYWwgYGRzdGAgYXJndW1lbnQuIElmIGl0IGlzIG5vdCBwYXNzZWQgaW4gdGhlXG4gKiBmdW5jdGlvbnMgd2lsbCBjcmVhdGUgYSBuZXcgVmVjMy4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gKlxuICogICAgIHZhciB2ID0gdjMuY3Jvc3ModjEsIHYyKTsgIC8vIENyZWF0ZXMgYSBuZXcgVmVjMyB3aXRoIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIuXG4gKlxuICogb3JcbiAqXG4gKiAgICAgdmFyIHYgPSB2My5jcmVhdGUoKTtcbiAqICAgICB2My5jcm9zcyh2MSwgdjIsIHYpOyAgLy8gUHV0cyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2MSB4IHYyIGluIHZcbiAqXG4gKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gKiBhcyB0aGVyZSBpcyBhbG1vc3QgbmV2ZXIgYWxsb2NhdGlvbiB3aXRoIHRoZSBzZWNvbmQgc3R5bGUuXG4gKlxuICogSXQgaXMgYWx3YXlzIHNhdmUgdG8gcGFzcyBhbnkgdmVjdG9yIGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgdjMuY3Jvc3ModjEsIHYyLCB2MSk7ICAvLyBQdXRzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIgaW4gdjFcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvdjNcbiAqL1xuXG5sZXQgVmVjVHlwZSA9IEZsb2F0MzJBcnJheTtcblxuLyoqXG4gKiBBIEphdmFTY3JpcHQgYXJyYXkgd2l0aCAzIHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheSB3aXRoIDMgdmFsdWVzLlxuICogV2hlbiBjcmVhdGVkIGJ5IHRoZSBsaWJyYXJ5IHdpbGwgY3JlYXRlIHRoZSBkZWZhdWx0IHR5cGUgd2hpY2ggaXMgYEZsb2F0MzJBcnJheWBcbiAqIGJ1dCBjYW4gYmUgc2V0IGJ5IGNhbGxpbmcge0BsaW5rIG1vZHVsZTp0d2dsL3YzLnNldERlZmF1bHRUeXBlfS5cbiAqIEB0eXBlZGVmIHsobnVtYmVyW118RmxvYXQzMkFycmF5KX0gVmVjM1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIHRoaXMgbGlicmFyeSBjcmVhdGVzIGZvciBhIFZlYzNcbiAqIEBwYXJhbSB7Y29uc3RydWN0b3J9IGN0b3IgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZS4gRWl0aGVyIGBGbG9hdDMyQXJyYXlgIG9yIGBBcnJheWBcbiAqIEByZXR1cm4ge2NvbnN0cnVjdG9yfSBwcmV2aW91cyBjb25zdHJ1Y3RvciBmb3IgVmVjM1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRUeXBlKGN0b3IpIHtcbiAgY29uc3Qgb2xkVHlwZSA9IFZlY1R5cGU7XG4gIFZlY1R5cGUgPSBjdG9yO1xuICByZXR1cm4gb2xkVHlwZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdmVjMzsgbWF5IGJlIGNhbGxlZCB3aXRoIHgsIHksIHogdG8gc2V0IGluaXRpYWwgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFt4XSBJbml0aWFsIHggdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIEluaXRpYWwgeSB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbel0gSW5pdGlhbCB6IHZhbHVlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdGhlIGNyZWF0ZWQgdmVjdG9yXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHgsIHksIHopIHtcbiAgY29uc3QgZHN0ID0gbmV3IFZlY1R5cGUoMyk7XG4gIGlmICh4KSB7XG4gICAgZHN0WzBdID0geDtcbiAgfVxuICBpZiAoeSkge1xuICAgIGRzdFsxXSA9IHk7XG4gIH1cbiAgaWYgKHopIHtcbiAgICBkc3RbMl0gPSB6O1xuICB9XG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQWRkcyB0d28gdmVjdG9yczsgYXNzdW1lcyBhIGFuZCBiIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBBIHZlY3RvciB0aGEgdGlzIHRoZSBzdW0gb2YgYSBhbmQgYi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBhZGQoYSwgYiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSBhWzBdICsgYlswXTtcbiAgZHN0WzFdID0gYVsxXSArIGJbMV07XG4gIGRzdFsyXSA9IGFbMl0gKyBiWzJdO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHR3byB2ZWN0b3JzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBBIHZlY3RvciB0aGF0IGlzIHRoZSBkaWZmZXJlbmNlIG9mIGEgYW5kIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSBhWzBdIC0gYlswXTtcbiAgZHN0WzFdID0gYVsxXSAtIGJbMV07XG4gIGRzdFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICogYSArIHQgKiAoYiAtIGEpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSBhWzBdICsgdCAqIChiWzBdIC0gYVswXSk7XG4gIGRzdFsxXSA9IGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKTtcbiAgZHN0WzJdID0gYVsyXSArIHQgKiAoYlsyXSAtIGFbMl0pO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdmVjdG9yIHQsIHJldHVybnNcbiAqIGEgKyB0ICogKGIgLSBhKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdCBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50cyB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHRoZSBsaW5lYXIgaW50ZXJwb2xhdGVkIHJlc3VsdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBsZXJwVihhLCBiLCB0LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGRzdFswXSA9IGFbMF0gKyB0WzBdICogKGJbMF0gLSBhWzBdKTtcbiAgZHN0WzFdID0gYVsxXSArIHRbMV0gKiAoYlsxXSAtIGFbMV0pO1xuICBkc3RbMl0gPSBhWzJdICsgdFsyXSAqIChiWzJdIC0gYVsyXSk7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gbWF4IHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gKiBbbWF4KGFbMF0sIGJbMF0pLCBtYXgoYVsxXSwgYlsxXSksIG1heChhWzJdLCBiWzJdKV0uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGEgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgT3BlcmFuZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBtYXggY29tcG9uZW50cyB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gbWF4KGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgZHN0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIGRzdFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBkc3RbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFJldHVybiBtaW4gdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAqIFttaW4oYVswXSwgYlswXSksIG1pbihhWzFdLCBiWzFdKSwgbWluKGFbMl0sIGJbMl0pXS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIG1pbiBjb21wb25lbnRzIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBtaW4oYSwgYiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgZHN0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIGRzdFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGsgVGhlIHNjYWxhci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHNjYWxlZCB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gbXVsU2NhbGFyKHYsIGssIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgZHN0WzBdID0gdlswXSAqIGs7XG4gIGRzdFsxXSA9IHZbMV0gKiBrO1xuICBkc3RbMl0gPSB2WzJdICogaztcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBzY2FsYXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBzY2FsZWQgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGRpdlNjYWxhcih2LCBrLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBWZWNUeXBlKDMpO1xuXG4gIGRzdFswXSA9IHZbMF0gLyBrO1xuICBkc3RbMV0gPSB2WzFdIC8gaztcbiAgZHN0WzJdID0gdlsyXSAvIGs7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9yczsgYXNzdW1lcyBib3RoIHZlY3RvcnMgaGF2ZVxuICogdGhyZWUgZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHZlY3RvciBvZiBhIGNyb3NzIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gY3Jvc3MoYSwgYiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBjb25zdCB0MSA9IGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl07XG4gIGNvbnN0IHQyID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgZHN0WzBdID0gYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXTtcbiAgZHN0WzFdID0gdDE7XG4gIGRzdFsyXSA9IHQyO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gKiB0aHJlZSBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBkb3QgcHJvZHVjdFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiAoYVswXSAqIGJbMF0pICsgKGFbMV0gKiBiWzFdKSArIChhWzJdICogYlsyXSk7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGxlbmd0aCBvZiB2ZWN0b3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGxlbmd0aCBvZiB2ZWN0b3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoJDEodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXSk7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IHZlY3Rvci5cbiAqIEByZXR1cm4ge251bWJlcn0gc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aFNxKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgY29uc3QgZHggPSBhWzBdIC0gYlswXTtcbiAgY29uc3QgZHkgPSBhWzFdIC0gYlsxXTtcbiAgY29uc3QgZHogPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGIgdmVjdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlU3EoYSwgYikge1xuICBjb25zdCBkeCA9IGFbMF0gLSBiWzBdO1xuICBjb25zdCBkeSA9IGFbMV0gLSBiWzFdO1xuICBjb25zdCBkeiA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xufVxuXG4vKipcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIEV1Y2xpZGVhbiBsZW5ndGggYW5kIHJldHVybnMgdGhlIHF1b3RpZW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSBub3JtYWxpemVkIHZlY3Rvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYSwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBjb25zdCBsZW5TcSA9IGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV0gKyBhWzJdICogYVsyXTtcbiAgY29uc3QgbGVuID0gTWF0aC5zcXJ0KGxlblNxKTtcbiAgaWYgKGxlbiA+IDAuMDAwMDEpIHtcbiAgICBkc3RbMF0gPSBhWzBdIC8gbGVuO1xuICAgIGRzdFsxXSA9IGFbMV0gLyBsZW47XG4gICAgZHN0WzJdID0gYVsyXSAvIGxlbjtcbiAgfSBlbHNlIHtcbiAgICBkc3RbMF0gPSAwO1xuICAgIGRzdFsxXSA9IDA7XG4gICAgZHN0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogTmVnYXRlcyBhIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSAtdi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC92M1xuICovXG5mdW5jdGlvbiBuZWdhdGUodiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSAtdlswXTtcbiAgZHN0WzFdID0gLXZbMV07XG4gIGRzdFsyXSA9IC12WzJdO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ29waWVzIGEgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IEEgY29weSBvZiB2LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIGNvcHkodiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgVmVjVHlwZSgzKTtcblxuICBkc3RbMF0gPSB2WzBdO1xuICBkc3RbMV0gPSB2WzFdO1xuICBkc3RbMl0gPSB2WzJdO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBhIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBiIE9wZXJhbmQgdmVjdG9yLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC92My5WZWMzfSBUaGUgdmVjdG9yIG9mIHByb2R1Y3RzIG9mIGVudHJpZXMgb2YgYSBhbmRcbiAqICAgICBiLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3YzXG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgZHN0WzBdID0gYVswXSAqIGJbMF07XG4gIGRzdFsxXSA9IGFbMV0gKiBiWzFdO1xuICBkc3RbMl0gPSBhWzJdICogYlsyXTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYSBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYiBPcGVyYW5kIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZFxuICogICAgIGIuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdjNcbiAqL1xuZnVuY3Rpb24gZGl2aWRlKGEsIGIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IFZlY1R5cGUoMyk7XG5cbiAgZHN0WzBdID0gYVswXSAvIGJbMF07XG4gIGRzdFsxXSA9IGFbMV0gLyBiWzFdO1xuICBkc3RbMl0gPSBhWzJdIC8gYlsyXTtcblxuICByZXR1cm4gZHN0O1xufVxuXG52YXIgdjMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWRkOiBhZGQsXG4gIGNvcHk6IGNvcHksXG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjcm9zczogY3Jvc3MsXG4gIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgZGlzdGFuY2VTcTogZGlzdGFuY2VTcSxcbiAgZGl2aWRlOiBkaXZpZGUsXG4gIGRpdlNjYWxhcjogZGl2U2NhbGFyLFxuICBkb3Q6IGRvdCxcbiAgbGVycDogbGVycCxcbiAgbGVycFY6IGxlcnBWLFxuICBsZW5ndGg6IGxlbmd0aCQxLFxuICBsZW5ndGhTcTogbGVuZ3RoU3EsXG4gIG1heDogbWF4LFxuICBtaW46IG1pbixcbiAgbXVsU2NhbGFyOiBtdWxTY2FsYXIsXG4gIG11bHRpcGx5OiBtdWx0aXBseSxcbiAgbmVnYXRlOiBuZWdhdGUsXG4gIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICBzZXREZWZhdWx0VHlwZTogc2V0RGVmYXVsdFR5cGUsXG4gIHN1YnRyYWN0OiBzdWJ0cmFjdFxufSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiA0eDQgTWF0cml4IG1hdGggbWF0aCBmdW5jdGlvbnMuXG4gKlxuICogQWxtb3N0IGFsbCBmdW5jdGlvbnMgdGFrZSBhbiBvcHRpb25hbCBgZHN0YCBhcmd1bWVudC4gSWYgaXQgaXMgbm90IHBhc3NlZCBpbiB0aGVcbiAqIGZ1bmN0aW9ucyB3aWxsIGNyZWF0ZSBhIG5ldyBtYXRyaXguIEluIG90aGVyIHdvcmRzIHlvdSBjYW4gZG8gdGhpc1xuICpcbiAqICAgICBjb25zdCBtYXQgPSBtNC50cmFuc2xhdGlvbihbMSwgMiwgM10pOyAgLy8gQ3JlYXRlcyBhIG5ldyB0cmFuc2xhdGlvbiBtYXRyaXhcbiAqXG4gKiBvclxuICpcbiAqICAgICBjb25zdCBtYXQgPSBtNC5jcmVhdGUoKTtcbiAqICAgICBtNC50cmFuc2xhdGlvbihbMSwgMiwgM10sIG1hdCk7ICAvLyBQdXRzIHRyYW5zbGF0aW9uIG1hdHJpeCBpbiBtYXQuXG4gKlxuICogVGhlIGZpcnN0IHN0eWxlIGlzIG9mdGVuIGVhc2llciBidXQgZGVwZW5kaW5nIG9uIHdoZXJlIGl0J3MgdXNlZCBpdCBnZW5lcmF0ZXMgZ2FyYmFnZSB3aGVyZVxuICogYXMgdGhlcmUgaXMgYWxtb3N0IG5ldmVyIGFsbG9jYXRpb24gd2l0aCB0aGUgc2Vjb25kIHN0eWxlLlxuICpcbiAqIEl0IGlzIGFsd2F5cyBzYXZlIHRvIHBhc3MgYW55IG1hdHJpeCBhcyB0aGUgZGVzdGluYXRpb24uIFNvIGZvciBleGFtcGxlXG4gKlxuICogICAgIGNvbnN0IG1hdCA9IG00LmlkZW50aXR5KCk7XG4gKiAgICAgY29uc3QgdHJhbnMgPSBtNC50cmFuc2xhdGlvbihbMSwgMiwgM10pO1xuICogICAgIG00Lm11bHRpcGx5KG1hdCwgdHJhbnMsIG1hdCk7ICAvLyBNdWx0aXBsaWVzIG1hdCAqIHRyYW5zIGFuZCBwdXRzIHJlc3VsdCBpbiBtYXQuXG4gKlxuICogQG1vZHVsZSB0d2dsL200XG4gKi9cbmxldCBNYXRUeXBlID0gRmxvYXQzMkFycmF5O1xuXG4vKipcbiAqIEEgSmF2YVNjcmlwdCBhcnJheSB3aXRoIDE2IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheSB3aXRoIDE2IHZhbHVlcy5cbiAqIFdoZW4gY3JlYXRlZCBieSB0aGUgbGlicmFyeSB3aWxsIGNyZWF0ZSB0aGUgZGVmYXVsdCB0eXBlIHdoaWNoIGlzIGBGbG9hdDMyQXJyYXlgXG4gKiBidXQgY2FuIGJlIHNldCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC9tNC5zZXREZWZhdWx0VHlwZX0uXG4gKiBAdHlwZWRlZiB7KG51bWJlcltdfEZsb2F0MzJBcnJheSl9IE1hdDRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSB0aGlzIGxpYnJhcnkgY3JlYXRlcyBmb3IgYSBNYXQ0XG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBjdG9yIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuIEVpdGhlciBgRmxvYXQzMkFycmF5YCBvciBgQXJyYXlgXG4gKiBAcmV0dXJuIHtjb25zdHJ1Y3Rvcn0gcHJldmlvdXMgY29uc3RydWN0b3IgZm9yIE1hdDRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBzZXREZWZhdWx0VHlwZSQxKGN0b3IpIHtcbiAgY29uc3Qgb2xkVHlwZSA9IE1hdFR5cGU7XG4gIE1hdFR5cGUgPSBjdG9yO1xuICByZXR1cm4gb2xkVHlwZTtcbn1cblxuLyoqXG4gKiBOZWdhdGVzIGEgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IC1tLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZSQxKG0sIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGRzdFsgMF0gPSAtbVsgMF07XG4gIGRzdFsgMV0gPSAtbVsgMV07XG4gIGRzdFsgMl0gPSAtbVsgMl07XG4gIGRzdFsgM10gPSAtbVsgM107XG4gIGRzdFsgNF0gPSAtbVsgNF07XG4gIGRzdFsgNV0gPSAtbVsgNV07XG4gIGRzdFsgNl0gPSAtbVsgNl07XG4gIGRzdFsgN10gPSAtbVsgN107XG4gIGRzdFsgOF0gPSAtbVsgOF07XG4gIGRzdFsgOV0gPSAtbVsgOV07XG4gIGRzdFsxMF0gPSAtbVsxMF07XG4gIGRzdFsxMV0gPSAtbVsxMV07XG4gIGRzdFsxMl0gPSAtbVsxMl07XG4gIGRzdFsxM10gPSAtbVsxM107XG4gIGRzdFsxNF0gPSAtbVsxNF07XG4gIGRzdFsxNV0gPSAtbVsxNV07XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgYSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gVGhlIG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IEEgY29weSBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIGNvcHkkMShtLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBkc3RbIDBdID0gbVsgMF07XG4gIGRzdFsgMV0gPSBtWyAxXTtcbiAgZHN0WyAyXSA9IG1bIDJdO1xuICBkc3RbIDNdID0gbVsgM107XG4gIGRzdFsgNF0gPSBtWyA0XTtcbiAgZHN0WyA1XSA9IG1bIDVdO1xuICBkc3RbIDZdID0gbVsgNl07XG4gIGRzdFsgN10gPSBtWyA3XTtcbiAgZHN0WyA4XSA9IG1bIDhdO1xuICBkc3RbIDldID0gbVsgOV07XG4gIGRzdFsxMF0gPSBtWzEwXTtcbiAgZHN0WzExXSA9IG1bMTFdO1xuICBkc3RbMTJdID0gbVsxMl07XG4gIGRzdFsxM10gPSBtWzEzXTtcbiAgZHN0WzE0XSA9IG1bMTRdO1xuICBkc3RbMTVdID0gbVsxNV07XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG4tYnktbiBpZGVudGl0eSBtYXRyaXguXG4gKlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBBbiBuLWJ5LW4gaWRlbnRpdHkgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGRzdFsgMF0gPSAxO1xuICBkc3RbIDFdID0gMDtcbiAgZHN0WyAyXSA9IDA7XG4gIGRzdFsgM10gPSAwO1xuICBkc3RbIDRdID0gMDtcbiAgZHN0WyA1XSA9IDE7XG4gIGRzdFsgNl0gPSAwO1xuICBkc3RbIDddID0gMDtcbiAgZHN0WyA4XSA9IDA7XG4gIGRzdFsgOV0gPSAwO1xuICBkc3RbMTBdID0gMTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogVGFrZXMgdGhlIHRyYW5zcG9zZSBvZiBhIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgdHJhbnNwb3NlIG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuIGZ1bmN0aW9uIHRyYW5zcG9zZShtLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcbiAgaWYgKGRzdCA9PT0gbSkge1xuICAgIGxldCB0O1xuXG4gICAgdCA9IG1bMV07XG4gICAgbVsxXSA9IG1bNF07XG4gICAgbVs0XSA9IHQ7XG5cbiAgICB0ID0gbVsyXTtcbiAgICBtWzJdID0gbVs4XTtcbiAgICBtWzhdID0gdDtcblxuICAgIHQgPSBtWzNdO1xuICAgIG1bM10gPSBtWzEyXTtcbiAgICBtWzEyXSA9IHQ7XG5cbiAgICB0ID0gbVs2XTtcbiAgICBtWzZdID0gbVs5XTtcbiAgICBtWzldID0gdDtcblxuICAgIHQgPSBtWzddO1xuICAgIG1bN10gPSBtWzEzXTtcbiAgICBtWzEzXSA9IHQ7XG5cbiAgICB0ID0gbVsxMV07XG4gICAgbVsxMV0gPSBtWzE0XTtcbiAgICBtWzE0XSA9IHQ7XG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gIGNvbnN0IG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gIGNvbnN0IG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgY29uc3QgbTMxID0gbVszICogNCArIDFdO1xuICBjb25zdCBtMzIgPSBtWzMgKiA0ICsgMl07XG4gIGNvbnN0IG0zMyA9IG1bMyAqIDQgKyAzXTtcblxuICBkc3RbIDBdID0gbTAwO1xuICBkc3RbIDFdID0gbTEwO1xuICBkc3RbIDJdID0gbTIwO1xuICBkc3RbIDNdID0gbTMwO1xuICBkc3RbIDRdID0gbTAxO1xuICBkc3RbIDVdID0gbTExO1xuICBkc3RbIDZdID0gbTIxO1xuICBkc3RbIDddID0gbTMxO1xuICBkc3RbIDhdID0gbTAyO1xuICBkc3RbIDldID0gbTEyO1xuICBkc3RbMTBdID0gbTIyO1xuICBkc3RbMTFdID0gbTMyO1xuICBkc3RbMTJdID0gbTAzO1xuICBkc3RbMTNdID0gbTEzO1xuICBkc3RbMTRdID0gbTIzO1xuICBkc3RbMTVdID0gbTMzO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGludmVyc2Ugb2YgYSA0LWJ5LTQgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBpbnZlcnNlIG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShtLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICBjb25zdCBtMDMgPSBtWzAgKiA0ICsgM107XG4gIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gIGNvbnN0IG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgY29uc3QgbTIzID0gbVsyICogNCArIDNdO1xuICBjb25zdCBtMzAgPSBtWzMgKiA0ICsgMF07XG4gIGNvbnN0IG0zMSA9IG1bMyAqIDQgKyAxXTtcbiAgY29uc3QgbTMyID0gbVszICogNCArIDJdO1xuICBjb25zdCBtMzMgPSBtWzMgKiA0ICsgM107XG4gIGNvbnN0IHRtcF8wICA9IG0yMiAqIG0zMztcbiAgY29uc3QgdG1wXzEgID0gbTMyICogbTIzO1xuICBjb25zdCB0bXBfMiAgPSBtMTIgKiBtMzM7XG4gIGNvbnN0IHRtcF8zICA9IG0zMiAqIG0xMztcbiAgY29uc3QgdG1wXzQgID0gbTEyICogbTIzO1xuICBjb25zdCB0bXBfNSAgPSBtMjIgKiBtMTM7XG4gIGNvbnN0IHRtcF82ICA9IG0wMiAqIG0zMztcbiAgY29uc3QgdG1wXzcgID0gbTMyICogbTAzO1xuICBjb25zdCB0bXBfOCAgPSBtMDIgKiBtMjM7XG4gIGNvbnN0IHRtcF85ICA9IG0yMiAqIG0wMztcbiAgY29uc3QgdG1wXzEwID0gbTAyICogbTEzO1xuICBjb25zdCB0bXBfMTEgPSBtMTIgKiBtMDM7XG4gIGNvbnN0IHRtcF8xMiA9IG0yMCAqIG0zMTtcbiAgY29uc3QgdG1wXzEzID0gbTMwICogbTIxO1xuICBjb25zdCB0bXBfMTQgPSBtMTAgKiBtMzE7XG4gIGNvbnN0IHRtcF8xNSA9IG0zMCAqIG0xMTtcbiAgY29uc3QgdG1wXzE2ID0gbTEwICogbTIxO1xuICBjb25zdCB0bXBfMTcgPSBtMjAgKiBtMTE7XG4gIGNvbnN0IHRtcF8xOCA9IG0wMCAqIG0zMTtcbiAgY29uc3QgdG1wXzE5ID0gbTMwICogbTAxO1xuICBjb25zdCB0bXBfMjAgPSBtMDAgKiBtMjE7XG4gIGNvbnN0IHRtcF8yMSA9IG0yMCAqIG0wMTtcbiAgY29uc3QgdG1wXzIyID0gbTAwICogbTExO1xuICBjb25zdCB0bXBfMjMgPSBtMTAgKiBtMDE7XG5cbiAgY29uc3QgdDAgPSAodG1wXzAgKiBtMTEgKyB0bXBfMyAqIG0yMSArIHRtcF80ICogbTMxKSAtXG4gICAgICAodG1wXzEgKiBtMTEgKyB0bXBfMiAqIG0yMSArIHRtcF81ICogbTMxKTtcbiAgY29uc3QgdDEgPSAodG1wXzEgKiBtMDEgKyB0bXBfNiAqIG0yMSArIHRtcF85ICogbTMxKSAtXG4gICAgICAodG1wXzAgKiBtMDEgKyB0bXBfNyAqIG0yMSArIHRtcF84ICogbTMxKTtcbiAgY29uc3QgdDIgPSAodG1wXzIgKiBtMDEgKyB0bXBfNyAqIG0xMSArIHRtcF8xMCAqIG0zMSkgLVxuICAgICAgKHRtcF8zICogbTAxICsgdG1wXzYgKiBtMTEgKyB0bXBfMTEgKiBtMzEpO1xuICBjb25zdCB0MyA9ICh0bXBfNSAqIG0wMSArIHRtcF84ICogbTExICsgdG1wXzExICogbTIxKSAtXG4gICAgICAodG1wXzQgKiBtMDEgKyB0bXBfOSAqIG0xMSArIHRtcF8xMCAqIG0yMSk7XG5cbiAgY29uc3QgZCA9IDEuMCAvIChtMDAgKiB0MCArIG0xMCAqIHQxICsgbTIwICogdDIgKyBtMzAgKiB0Myk7XG5cbiAgZHN0WyAwXSA9IGQgKiB0MDtcbiAgZHN0WyAxXSA9IGQgKiB0MTtcbiAgZHN0WyAyXSA9IGQgKiB0MjtcbiAgZHN0WyAzXSA9IGQgKiB0MztcbiAgZHN0WyA0XSA9IGQgKiAoKHRtcF8xICogbTEwICsgdG1wXzIgKiBtMjAgKyB0bXBfNSAqIG0zMCkgLVxuICAgICAgICAgICh0bXBfMCAqIG0xMCArIHRtcF8zICogbTIwICsgdG1wXzQgKiBtMzApKTtcbiAgZHN0WyA1XSA9IGQgKiAoKHRtcF8wICogbTAwICsgdG1wXzcgKiBtMjAgKyB0bXBfOCAqIG0zMCkgLVxuICAgICAgICAgICh0bXBfMSAqIG0wMCArIHRtcF82ICogbTIwICsgdG1wXzkgKiBtMzApKTtcbiAgZHN0WyA2XSA9IGQgKiAoKHRtcF8zICogbTAwICsgdG1wXzYgKiBtMTAgKyB0bXBfMTEgKiBtMzApIC1cbiAgICAgICAgICAodG1wXzIgKiBtMDAgKyB0bXBfNyAqIG0xMCArIHRtcF8xMCAqIG0zMCkpO1xuICBkc3RbIDddID0gZCAqICgodG1wXzQgKiBtMDAgKyB0bXBfOSAqIG0xMCArIHRtcF8xMCAqIG0yMCkgLVxuICAgICAgICAgICh0bXBfNSAqIG0wMCArIHRtcF84ICogbTEwICsgdG1wXzExICogbTIwKSk7XG4gIGRzdFsgOF0gPSBkICogKCh0bXBfMTIgKiBtMTMgKyB0bXBfMTUgKiBtMjMgKyB0bXBfMTYgKiBtMzMpIC1cbiAgICAgICAgICAodG1wXzEzICogbTEzICsgdG1wXzE0ICogbTIzICsgdG1wXzE3ICogbTMzKSk7XG4gIGRzdFsgOV0gPSBkICogKCh0bXBfMTMgKiBtMDMgKyB0bXBfMTggKiBtMjMgKyB0bXBfMjEgKiBtMzMpIC1cbiAgICAgICAgICAodG1wXzEyICogbTAzICsgdG1wXzE5ICogbTIzICsgdG1wXzIwICogbTMzKSk7XG4gIGRzdFsxMF0gPSBkICogKCh0bXBfMTQgKiBtMDMgKyB0bXBfMTkgKiBtMTMgKyB0bXBfMjIgKiBtMzMpIC1cbiAgICAgICAgICAodG1wXzE1ICogbTAzICsgdG1wXzE4ICogbTEzICsgdG1wXzIzICogbTMzKSk7XG4gIGRzdFsxMV0gPSBkICogKCh0bXBfMTcgKiBtMDMgKyB0bXBfMjAgKiBtMTMgKyB0bXBfMjMgKiBtMjMpIC1cbiAgICAgICAgICAodG1wXzE2ICogbTAzICsgdG1wXzIxICogbTEzICsgdG1wXzIyICogbTIzKSk7XG4gIGRzdFsxMl0gPSBkICogKCh0bXBfMTQgKiBtMjIgKyB0bXBfMTcgKiBtMzIgKyB0bXBfMTMgKiBtMTIpIC1cbiAgICAgICAgICAodG1wXzE2ICogbTMyICsgdG1wXzEyICogbTEyICsgdG1wXzE1ICogbTIyKSk7XG4gIGRzdFsxM10gPSBkICogKCh0bXBfMjAgKiBtMzIgKyB0bXBfMTIgKiBtMDIgKyB0bXBfMTkgKiBtMjIpIC1cbiAgICAgICAgICAodG1wXzE4ICogbTIyICsgdG1wXzIxICogbTMyICsgdG1wXzEzICogbTAyKSk7XG4gIGRzdFsxNF0gPSBkICogKCh0bXBfMTggKiBtMTIgKyB0bXBfMjMgKiBtMzIgKyB0bXBfMTUgKiBtMDIpIC1cbiAgICAgICAgICAodG1wXzIyICogbTMyICsgdG1wXzE0ICogbTAyICsgdG1wXzE5ICogbTEyKSk7XG4gIGRzdFsxNV0gPSBkICogKCh0bXBfMjIgKiBtMjIgKyB0bXBfMTYgKiBtMDIgKyB0bXBfMjEgKiBtMTIpIC1cbiAgICAgICAgICAodG1wXzIwICogbTEyICsgdG1wXzIzICogbTIyICsgdG1wXzE3ICogbTAyKSk7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byA0LWJ5LTQgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBhIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IGIgVGhlIG1hdHJpeCBvbiB0aGUgcmlnaHQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5JDEoYSwgYiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgYTAwID0gYVswXTtcbiAgY29uc3QgYTAxID0gYVsxXTtcbiAgY29uc3QgYTAyID0gYVsyXTtcbiAgY29uc3QgYTAzID0gYVszXTtcbiAgY29uc3QgYTEwID0gYVsgNCArIDBdO1xuICBjb25zdCBhMTEgPSBhWyA0ICsgMV07XG4gIGNvbnN0IGExMiA9IGFbIDQgKyAyXTtcbiAgY29uc3QgYTEzID0gYVsgNCArIDNdO1xuICBjb25zdCBhMjAgPSBhWyA4ICsgMF07XG4gIGNvbnN0IGEyMSA9IGFbIDggKyAxXTtcbiAgY29uc3QgYTIyID0gYVsgOCArIDJdO1xuICBjb25zdCBhMjMgPSBhWyA4ICsgM107XG4gIGNvbnN0IGEzMCA9IGFbMTIgKyAwXTtcbiAgY29uc3QgYTMxID0gYVsxMiArIDFdO1xuICBjb25zdCBhMzIgPSBhWzEyICsgMl07XG4gIGNvbnN0IGEzMyA9IGFbMTIgKyAzXTtcbiAgY29uc3QgYjAwID0gYlswXTtcbiAgY29uc3QgYjAxID0gYlsxXTtcbiAgY29uc3QgYjAyID0gYlsyXTtcbiAgY29uc3QgYjAzID0gYlszXTtcbiAgY29uc3QgYjEwID0gYlsgNCArIDBdO1xuICBjb25zdCBiMTEgPSBiWyA0ICsgMV07XG4gIGNvbnN0IGIxMiA9IGJbIDQgKyAyXTtcbiAgY29uc3QgYjEzID0gYlsgNCArIDNdO1xuICBjb25zdCBiMjAgPSBiWyA4ICsgMF07XG4gIGNvbnN0IGIyMSA9IGJbIDggKyAxXTtcbiAgY29uc3QgYjIyID0gYlsgOCArIDJdO1xuICBjb25zdCBiMjMgPSBiWyA4ICsgM107XG4gIGNvbnN0IGIzMCA9IGJbMTIgKyAwXTtcbiAgY29uc3QgYjMxID0gYlsxMiArIDFdO1xuICBjb25zdCBiMzIgPSBiWzEyICsgMl07XG4gIGNvbnN0IGIzMyA9IGJbMTIgKyAzXTtcblxuICBkc3RbIDBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyICsgYTMwICogYjAzO1xuICBkc3RbIDFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyICsgYTMxICogYjAzO1xuICBkc3RbIDJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyICsgYTMyICogYjAzO1xuICBkc3RbIDNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyICsgYTMzICogYjAzO1xuICBkc3RbIDRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyICsgYTMwICogYjEzO1xuICBkc3RbIDVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyICsgYTMxICogYjEzO1xuICBkc3RbIDZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyICsgYTMyICogYjEzO1xuICBkc3RbIDddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyICsgYTMzICogYjEzO1xuICBkc3RbIDhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyICsgYTMwICogYjIzO1xuICBkc3RbIDldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyICsgYTMxICogYjIzO1xuICBkc3RbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyICsgYTMyICogYjIzO1xuICBkc3RbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyICsgYTMzICogYjIzO1xuICBkc3RbMTJdID0gYTAwICogYjMwICsgYTEwICogYjMxICsgYTIwICogYjMyICsgYTMwICogYjMzO1xuICBkc3RbMTNdID0gYTAxICogYjMwICsgYTExICogYjMxICsgYTIxICogYjMyICsgYTMxICogYjMzO1xuICBkc3RbMTRdID0gYTAyICogYjMwICsgYTEyICogYjMxICsgYTIyICogYjMyICsgYTMyICogYjMzO1xuICBkc3RbMTVdID0gYTAzICogYjMwICsgYTEzICogYjMxICsgYTIzICogYjMyICsgYTMzICogYjMzO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgNC1ieS00IG1hdHJpeCB0byB0aGUgZ2l2ZW5cbiAqIHZlY3Rvci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gYSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggd2l0aCB0cmFuc2xhdGlvbiBzZXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gc2V0VHJhbnNsYXRpb24oYSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBpZGVudGl0eSgpO1xuICBpZiAoYSAhPT0gZHN0KSB7XG4gICAgZHN0WyAwXSA9IGFbIDBdO1xuICAgIGRzdFsgMV0gPSBhWyAxXTtcbiAgICBkc3RbIDJdID0gYVsgMl07XG4gICAgZHN0WyAzXSA9IGFbIDNdO1xuICAgIGRzdFsgNF0gPSBhWyA0XTtcbiAgICBkc3RbIDVdID0gYVsgNV07XG4gICAgZHN0WyA2XSA9IGFbIDZdO1xuICAgIGRzdFsgN10gPSBhWyA3XTtcbiAgICBkc3RbIDhdID0gYVsgOF07XG4gICAgZHN0WyA5XSA9IGFbIDldO1xuICAgIGRzdFsxMF0gPSBhWzEwXTtcbiAgICBkc3RbMTFdID0gYVsxMV07XG4gIH1cbiAgZHN0WzEyXSA9IHZbMF07XG4gIGRzdFsxM10gPSB2WzFdO1xuICBkc3RbMTRdID0gdlsyXTtcbiAgZHN0WzE1XSA9IDE7XG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgNC1ieS00IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDNcbiAqIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBtLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG0sIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgY3JlYXRlKCk7XG4gIGRzdFswXSA9IG1bMTJdO1xuICBkc3RbMV0gPSBtWzEzXTtcbiAgZHN0WzJdID0gbVsxNF07XG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBheGlzIG9mIGEgNHg0IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDMgZW50cmllc1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYXhpcyBUaGUgYXhpcyAwID0geCwgMSA9IHksIDIgPSB6O1xuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gW2RzdF0gdmVjdG9yLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIGF4aXMgY29tcG9uZW50IG9mIG0uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gZ2V0QXhpcyhtLCBheGlzLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IGNyZWF0ZSgpO1xuICBjb25zdCBvZmYgPSBheGlzICogNDtcbiAgZHN0WzBdID0gbVtvZmYgKyAwXTtcbiAgZHN0WzFdID0gbVtvZmYgKyAxXTtcbiAgZHN0WzJdID0gbVtvZmYgKyAyXTtcbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBTZXRzIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiB0aGUgYXhpcyB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzIFRoZSBheGlzICAwID0geCwgMSA9IHksIDIgPSB6O1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBUaGUgbWF0cml4IHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBtYXRyaXggd2l0aCBheGlzIHNldC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBzZXRBeGlzKGEsIHYsIGF4aXMsIGRzdCkge1xuICBpZiAoZHN0ICE9PSBhKSB7XG4gICAgZHN0ID0gY29weSQxKGEsIGRzdCk7XG4gIH1cbiAgY29uc3Qgb2ZmID0gYXhpcyAqIDQ7XG4gIGRzdFtvZmYgKyAwXSA9IHZbMF07XG4gIGRzdFtvZmYgKyAxXSA9IHZbMV07XG4gIGRzdFtvZmYgKyAyXSA9IHZbMl07XG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBhbmd1bGFyIGhlaWdodFxuICogb2YgdGhlIGZydXN0dW0sIHRoZSBhc3BlY3QgcmF0aW8sIGFuZCB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIFRoZVxuICogYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW0gZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gIFRoZSBnaXZlblxuICogYW5nbGUgaXMgdGhlIHZlcnRpY2FsIGFuZ2xlIG9mIHRoZSBmcnVzdHVtLCBhbmQgdGhlIGhvcml6b250YWwgYW5nbGUgaXNcbiAqIGRldGVybWluZWQgdG8gcHJvZHVjZSB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLiAgVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlXG4gKiB0aGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgTm90ZSB0aGF0IG5lYXIgYW5kIGZhclxuICogYXJlIG5vdCB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmVcbiAqIHotYXhpcy4gIFRoZSBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LlxuICogV2UgYXNzdW1lIGEgdW5pdCBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZFxuICogZnJvbSAwIHRvIDEgaW4gdGhlIHogZGltZW5zaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkT2ZWaWV3WUluUmFkaWFucyBUaGUgY2FtZXJhIGFuZ2xlIGZyb20gdG9wIHRvIGJvdHRvbSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gd2lkdGggLyBoZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gek5lYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gekZhciBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcGVyc3BlY3RpdmUgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlKGZpZWxkT2ZWaWV3WUluUmFkaWFucywgYXNwZWN0LCB6TmVhciwgekZhciwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgZiA9IE1hdGgudGFuKE1hdGguUEkgKiAwLjUgLSAwLjUgKiBmaWVsZE9mVmlld1lJblJhZGlhbnMpO1xuICBjb25zdCByYW5nZUludiA9IDEuMCAvICh6TmVhciAtIHpGYXIpO1xuXG4gIGRzdFswXSAgPSBmIC8gYXNwZWN0O1xuICBkc3RbMV0gID0gMDtcbiAgZHN0WzJdICA9IDA7XG4gIGRzdFszXSAgPSAwO1xuXG4gIGRzdFs0XSAgPSAwO1xuICBkc3RbNV0gID0gZjtcbiAgZHN0WzZdICA9IDA7XG4gIGRzdFs3XSAgPSAwO1xuXG4gIGRzdFs4XSAgPSAwO1xuICBkc3RbOV0gID0gMDtcbiAgZHN0WzEwXSA9ICh6TmVhciArIHpGYXIpICogcmFuZ2VJbnY7XG4gIGRzdFsxMV0gPSAtMTtcblxuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSB6TmVhciAqIHpGYXIgKiByYW5nZUludiAqIDI7XG4gIGRzdFsxNV0gPSAwO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgb3J0aG9nb25hbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LFxuICogYm90dG9tLCBhbmQgdG9wIGRpbWVuc2lvbnMgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgYXMgd2VsbCBhcyB0aGVcbiAqIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZSBkaXN0YW5jZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IHNpZGUgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgc2lkZSBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3Agb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAqICAgICBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gKiAgICAgb2YgdGhlIGZhciBjbGlwcGluZyBwbGFuZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gT3V0cHV0IG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBwZXJzcGVjdGl2ZSBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gb3J0aG8obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGRzdFswXSAgPSAyIC8gKHJpZ2h0IC0gbGVmdCk7XG4gIGRzdFsxXSAgPSAwO1xuICBkc3RbMl0gID0gMDtcbiAgZHN0WzNdICA9IDA7XG5cbiAgZHN0WzRdICA9IDA7XG4gIGRzdFs1XSAgPSAyIC8gKHRvcCAtIGJvdHRvbSk7XG4gIGRzdFs2XSAgPSAwO1xuICBkc3RbN10gID0gMDtcblxuICBkc3RbOF0gID0gMDtcbiAgZHN0WzldICA9IDA7XG4gIGRzdFsxMF0gPSAyIC8gKG5lYXIgLSBmYXIpO1xuICBkc3RbMTFdID0gMDtcblxuICBkc3RbMTJdID0gKHJpZ2h0ICsgbGVmdCkgLyAobGVmdCAtIHJpZ2h0KTtcbiAgZHN0WzEzXSA9ICh0b3AgKyBib3R0b20pIC8gKGJvdHRvbSAtIHRvcCk7XG4gIGRzdFsxNF0gPSAoZmFyICsgbmVhcikgLyAobmVhciAtIGZhcik7XG4gIGRzdFsxNV0gPSAxO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBsZWZ0LCByaWdodCxcbiAqIHRvcCwgYm90dG9tLCBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBUaGUgYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW1cbiAqIGV4dGVuZGluZyBpbiB0aGUgbmVnYXRpdmUgeiBkaXJlY3Rpb24uIFRoZSBhcmd1bWVudHMgbmVhciBhbmQgZmFyIGFyZSB0aGVcbiAqIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gTm90ZSB0aGF0IG5lYXIgYW5kIGZhciBhcmUgbm90XG4gKiB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmUgei1heGlzLiBUaGVcbiAqIG1hdHJpeCBnZW5lcmF0ZWQgc2VuZHMgdGhlIHZpZXdpbmcgZnJ1c3R1bSB0byB0aGUgdW5pdCBib3guIFdlIGFzc3VtZSBhIHVuaXRcbiAqIGJveCBleHRlbmRpbmcgZnJvbSAtMSB0byAxIGluIHRoZSB4IGFuZCB5IGRpbWVuc2lvbnMgYW5kIGZyb20gMCB0byAxIGluIHRoZSB6XG4gKiBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcGxhbmUgb2YgdGhlIGJveC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBuZWFyIHBsYW5lIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIFRoZSBuZWdhdGl2ZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGZhciBwbGFuZSBvZiB0aGUgYm94LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIGZydXN0dW0obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGNvbnN0IGR4ID0gKHJpZ2h0IC0gbGVmdCk7XG4gIGNvbnN0IGR5ID0gKHRvcCAtIGJvdHRvbSk7XG4gIGNvbnN0IGR6ID0gKG5lYXIgLSBmYXIpO1xuXG4gIGRzdFsgMF0gPSAyICogbmVhciAvIGR4O1xuICBkc3RbIDFdID0gMDtcbiAgZHN0WyAyXSA9IDA7XG4gIGRzdFsgM10gPSAwO1xuICBkc3RbIDRdID0gMDtcbiAgZHN0WyA1XSA9IDIgKiBuZWFyIC8gZHk7XG4gIGRzdFsgNl0gPSAwO1xuICBkc3RbIDddID0gMDtcbiAgZHN0WyA4XSA9IChsZWZ0ICsgcmlnaHQpIC8gZHg7XG4gIGRzdFsgOV0gPSAodG9wICsgYm90dG9tKSAvIGR5O1xuICBkc3RbMTBdID0gZmFyIC8gZHo7XG4gIGRzdFsxMV0gPSAtMTtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gbmVhciAqIGZhciAvIGR6O1xuICBkc3RbMTVdID0gMDtcblxuICByZXR1cm4gZHN0O1xufVxuXG5sZXQgeEF4aXM7XG5sZXQgeUF4aXM7XG5sZXQgekF4aXM7XG5cbi8qKlxuICogQ29tcHV0ZXMgYSA0LWJ5LTQgbG9vay1hdCB0cmFuc2Zvcm1hdGlvbi5cbiAqXG4gKiBUaGlzIGlzIGEgbWF0cml4IHdoaWNoIHBvc2l0aW9ucyB0aGUgY2FtZXJhIGl0c2VsZi4gSWYgeW91IHdhbnRcbiAqIGEgdmlldyBtYXRyaXggKGEgbWF0cml4IHdoaWNoIG1vdmVzIHRoaW5ncyBpbiBmcm9udCBvZiB0aGUgY2FtZXJhKVxuICogdGFrZSB0aGUgaW52ZXJzZSBvZiB0aGlzLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gZXllIFRoZSBwb3NpdGlvbiBvZiB0aGUgZXllLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB0YXJnZXQgVGhlIHBvc2l0aW9uIG1lYW50IHRvIGJlIHZpZXdlZC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdXAgQSB2ZWN0b3IgcG9pbnRpbmcgdXAuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSBsb29rLWF0IG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBsb29rQXQoZXllLCB0YXJnZXQsIHVwLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICB4QXhpcyA9IHhBeGlzIHx8IGNyZWF0ZSgpO1xuICB5QXhpcyA9IHlBeGlzIHx8IGNyZWF0ZSgpO1xuICB6QXhpcyA9IHpBeGlzIHx8IGNyZWF0ZSgpO1xuXG4gIG5vcm1hbGl6ZShcbiAgICAgIHN1YnRyYWN0KGV5ZSwgdGFyZ2V0LCB6QXhpcyksIHpBeGlzKTtcbiAgbm9ybWFsaXplKGNyb3NzKHVwLCB6QXhpcywgeEF4aXMpLCB4QXhpcyk7XG4gIG5vcm1hbGl6ZShjcm9zcyh6QXhpcywgeEF4aXMsIHlBeGlzKSwgeUF4aXMpO1xuXG4gIGRzdFsgMF0gPSB4QXhpc1swXTtcbiAgZHN0WyAxXSA9IHhBeGlzWzFdO1xuICBkc3RbIDJdID0geEF4aXNbMl07XG4gIGRzdFsgM10gPSAwO1xuICBkc3RbIDRdID0geUF4aXNbMF07XG4gIGRzdFsgNV0gPSB5QXhpc1sxXTtcbiAgZHN0WyA2XSA9IHlBeGlzWzJdO1xuICBkc3RbIDddID0gMDtcbiAgZHN0WyA4XSA9IHpBeGlzWzBdO1xuICBkc3RbIDldID0gekF4aXNbMV07XG4gIGRzdFsxMF0gPSB6QXhpc1syXTtcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSBleWVbMF07XG4gIGRzdFsxM10gPSBleWVbMV07XG4gIGRzdFsxNF0gPSBleWVbMl07XG4gIGRzdFsxNV0gPSAxO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggdHJhbnNsYXRlcyBieSB0aGUgZ2l2ZW4gdmVjdG9yIHYuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHZlY3RvciBieVxuICogICAgIHdoaWNoIHRvIHRyYW5zbGF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGlvbih2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBkc3RbIDBdID0gMTtcbiAgZHN0WyAxXSA9IDA7XG4gIGRzdFsgMl0gPSAwO1xuICBkc3RbIDNdID0gMDtcbiAgZHN0WyA0XSA9IDA7XG4gIGRzdFsgNV0gPSAxO1xuICBkc3RbIDZdID0gMDtcbiAgZHN0WyA3XSA9IDA7XG4gIGRzdFsgOF0gPSAwO1xuICBkc3RbIDldID0gMDtcbiAgZHN0WzEwXSA9IDE7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gdlswXTtcbiAgZHN0WzEzXSA9IHZbMV07XG4gIGRzdFsxNF0gPSB2WzJdO1xuICBkc3RbMTVdID0gMTtcbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGJ5IHRoZSBnaXZlbiB2ZWN0b3Igdi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSB2ZWN0b3IgYnlcbiAqICAgICB3aGljaCB0byB0cmFuc2xhdGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSB0cmFuc2xhdGVkIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUobSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgdjAgPSB2WzBdO1xuICBjb25zdCB2MSA9IHZbMV07XG4gIGNvbnN0IHYyID0gdlsyXTtcbiAgY29uc3QgbTAwID0gbVswXTtcbiAgY29uc3QgbTAxID0gbVsxXTtcbiAgY29uc3QgbTAyID0gbVsyXTtcbiAgY29uc3QgbTAzID0gbVszXTtcbiAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gIGNvbnN0IG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgY29uc3QgbTMxID0gbVszICogNCArIDFdO1xuICBjb25zdCBtMzIgPSBtWzMgKiA0ICsgMl07XG4gIGNvbnN0IG0zMyA9IG1bMyAqIDQgKyAzXTtcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WyAwXSA9IG0wMDtcbiAgICBkc3RbIDFdID0gbTAxO1xuICAgIGRzdFsgMl0gPSBtMDI7XG4gICAgZHN0WyAzXSA9IG0wMztcbiAgICBkc3RbIDRdID0gbTEwO1xuICAgIGRzdFsgNV0gPSBtMTE7XG4gICAgZHN0WyA2XSA9IG0xMjtcbiAgICBkc3RbIDddID0gbTEzO1xuICAgIGRzdFsgOF0gPSBtMjA7XG4gICAgZHN0WyA5XSA9IG0yMTtcbiAgICBkc3RbMTBdID0gbTIyO1xuICAgIGRzdFsxMV0gPSBtMjM7XG4gIH1cblxuICBkc3RbMTJdID0gbTAwICogdjAgKyBtMTAgKiB2MSArIG0yMCAqIHYyICsgbTMwO1xuICBkc3RbMTNdID0gbTAxICogdjAgKyBtMTEgKiB2MSArIG0yMSAqIHYyICsgbTMxO1xuICBkc3RbMTRdID0gbTAyICogdjAgKyBtMTIgKiB2MSArIG0yMiAqIHYyICsgbTMyO1xuICBkc3RbMTVdID0gbTAzICogdjAgKyBtMTMgKiB2MSArIG0yMyAqIHYyICsgbTMzO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggcm90YXRlcyBhcm91bmQgdGhlIHgtYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGlvbiBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gcm90YXRpb25YKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuXG4gIGRzdFsgMF0gPSAxO1xuICBkc3RbIDFdID0gMDtcbiAgZHN0WyAyXSA9IDA7XG4gIGRzdFsgM10gPSAwO1xuICBkc3RbIDRdID0gMDtcbiAgZHN0WyA1XSA9IGM7XG4gIGRzdFsgNl0gPSBzO1xuICBkc3RbIDddID0gMDtcbiAgZHN0WyA4XSA9IDA7XG4gIGRzdFsgOV0gPSAtcztcbiAgZHN0WzEwXSA9IGM7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSB4LWF4aXMgYnkgdGhlIGdpdmVuXG4gKiBhbmdsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcm90YXRlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgbTEwID0gbVs0XTtcbiAgY29uc3QgbTExID0gbVs1XTtcbiAgY29uc3QgbTEyID0gbVs2XTtcbiAgY29uc3QgbTEzID0gbVs3XTtcbiAgY29uc3QgbTIwID0gbVs4XTtcbiAgY29uc3QgbTIxID0gbVs5XTtcbiAgY29uc3QgbTIyID0gbVsxMF07XG4gIGNvbnN0IG0yMyA9IG1bMTFdO1xuICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuXG4gIGRzdFs0XSAgPSBjICogbTEwICsgcyAqIG0yMDtcbiAgZHN0WzVdICA9IGMgKiBtMTEgKyBzICogbTIxO1xuICBkc3RbNl0gID0gYyAqIG0xMiArIHMgKiBtMjI7XG4gIGRzdFs3XSAgPSBjICogbTEzICsgcyAqIG0yMztcbiAgZHN0WzhdICA9IGMgKiBtMjAgLSBzICogbTEwO1xuICBkc3RbOV0gID0gYyAqIG0yMSAtIHMgKiBtMTE7XG4gIGRzdFsxMF0gPSBjICogbTIyIC0gcyAqIG0xMjtcbiAgZHN0WzExXSA9IGMgKiBtMjMgLSBzICogbTEzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbIDBdID0gbVsgMF07XG4gICAgZHN0WyAxXSA9IG1bIDFdO1xuICAgIGRzdFsgMl0gPSBtWyAyXTtcbiAgICBkc3RbIDNdID0gbVsgM107XG4gICAgZHN0WzEyXSA9IG1bMTJdO1xuICAgIGRzdFsxM10gPSBtWzEzXTtcbiAgICBkc3RbMTRdID0gbVsxNF07XG4gICAgZHN0WzE1XSA9IG1bMTVdO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgeS1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiByb3RhdGlvblkoYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG5cbiAgZHN0WyAwXSA9IGM7XG4gIGRzdFsgMV0gPSAwO1xuICBkc3RbIDJdID0gLXM7XG4gIGRzdFsgM10gPSAwO1xuICBkc3RbIDRdID0gMDtcbiAgZHN0WyA1XSA9IDE7XG4gIGRzdFsgNl0gPSAwO1xuICBkc3RbIDddID0gMDtcbiAgZHN0WyA4XSA9IHM7XG4gIGRzdFsgOV0gPSAwO1xuICBkc3RbMTBdID0gYztcbiAgZHN0WzExXSA9IDA7XG4gIGRzdFsxMl0gPSAwO1xuICBkc3RbMTNdID0gMDtcbiAgZHN0WzE0XSA9IDA7XG4gIGRzdFsxNV0gPSAxO1xuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW5cbiAqIGFuZ2xlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGVkIG1hdHJpeC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiByb3RhdGVZKG0sIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICBjb25zdCBtMDMgPSBtWzAgKiA0ICsgM107XG4gIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gIGNvbnN0IG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcblxuICBkc3RbIDBdID0gYyAqIG0wMCAtIHMgKiBtMjA7XG4gIGRzdFsgMV0gPSBjICogbTAxIC0gcyAqIG0yMTtcbiAgZHN0WyAyXSA9IGMgKiBtMDIgLSBzICogbTIyO1xuICBkc3RbIDNdID0gYyAqIG0wMyAtIHMgKiBtMjM7XG4gIGRzdFsgOF0gPSBjICogbTIwICsgcyAqIG0wMDtcbiAgZHN0WyA5XSA9IGMgKiBtMjEgKyBzICogbTAxO1xuICBkc3RbMTBdID0gYyAqIG0yMiArIHMgKiBtMDI7XG4gIGRzdFsxMV0gPSBjICogbTIzICsgcyAqIG0wMztcblxuICBpZiAobSAhPT0gZHN0KSB7XG4gICAgZHN0WyA0XSA9IG1bIDRdO1xuICAgIGRzdFsgNV0gPSBtWyA1XTtcbiAgICBkc3RbIDZdID0gbVsgNl07XG4gICAgZHN0WyA3XSA9IG1bIDddO1xuICAgIGRzdFsxMl0gPSBtWzEyXTtcbiAgICBkc3RbMTNdID0gbVsxM107XG4gICAgZHN0WzE0XSA9IG1bMTRdO1xuICAgIGRzdFsxNV0gPSBtWzE1XTtcbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIDQtYnktNCBtYXRyaXggd2hpY2ggcm90YXRlcyBhcm91bmQgdGhlIHotYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IFRoZSByb3RhdGlvbiBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gcm90YXRpb25aKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IG5ldyBNYXRUeXBlKDE2KTtcblxuICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuXG4gIGRzdFsgMF0gPSBjO1xuICBkc3RbIDFdID0gcztcbiAgZHN0WyAyXSA9IDA7XG4gIGRzdFsgM10gPSAwO1xuICBkc3RbIDRdID0gLXM7XG4gIGRzdFsgNV0gPSBjO1xuICBkc3RbIDZdID0gMDtcbiAgZHN0WyA3XSA9IDA7XG4gIGRzdFsgOF0gPSAwO1xuICBkc3RbIDldID0gMDtcbiAgZHN0WzEwXSA9IDE7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuXG4gKiBhbmdsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbZHN0XSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBUaGUgcm90YXRlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWihtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgY29uc3QgbTAzID0gbVswICogNCArIDNdO1xuICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICBjb25zdCBtMTMgPSBtWzEgKiA0ICsgM107XG4gIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG5cbiAgZHN0WyAwXSA9IGMgKiBtMDAgKyBzICogbTEwO1xuICBkc3RbIDFdID0gYyAqIG0wMSArIHMgKiBtMTE7XG4gIGRzdFsgMl0gPSBjICogbTAyICsgcyAqIG0xMjtcbiAgZHN0WyAzXSA9IGMgKiBtMDMgKyBzICogbTEzO1xuICBkc3RbIDRdID0gYyAqIG0xMCAtIHMgKiBtMDA7XG4gIGRzdFsgNV0gPSBjICogbTExIC0gcyAqIG0wMTtcbiAgZHN0WyA2XSA9IGMgKiBtMTIgLSBzICogbTAyO1xuICBkc3RbIDddID0gYyAqIG0xMyAtIHMgKiBtMDM7XG5cbiAgaWYgKG0gIT09IGRzdCkge1xuICAgIGRzdFsgOF0gPSBtWyA4XTtcbiAgICBkc3RbIDldID0gbVsgOV07XG4gICAgZHN0WzEwXSA9IG1bMTBdO1xuICAgIGRzdFsxMV0gPSBtWzExXTtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZSBnaXZlblxuICogYW5nbGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IGF4aXMgVGhlIGF4aXNcbiAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IFtkc3RdIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL200Lk1hdDR9IEEgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYW5nbGUgcmFkaWFuc1xuICogICAgIGFyb3VuZCB0aGUgYXhpcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiBheGlzUm90YXRpb24oYXhpcywgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGxldCB4ID0gYXhpc1swXTtcbiAgbGV0IHkgPSBheGlzWzFdO1xuICBsZXQgeiA9IGF4aXNbMl07XG4gIGNvbnN0IG4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgeCAvPSBuO1xuICB5IC89IG47XG4gIHogLz0gbjtcbiAgY29uc3QgeHggPSB4ICogeDtcbiAgY29uc3QgeXkgPSB5ICogeTtcbiAgY29uc3QgenogPSB6ICogejtcbiAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgY29uc3Qgb25lTWludXNDb3NpbmUgPSAxIC0gYztcblxuICBkc3RbIDBdID0geHggKyAoMSAtIHh4KSAqIGM7XG4gIGRzdFsgMV0gPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lICsgeiAqIHM7XG4gIGRzdFsgMl0gPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geSAqIHM7XG4gIGRzdFsgM10gPSAwO1xuICBkc3RbIDRdID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICBkc3RbIDVdID0geXkgKyAoMSAtIHl5KSAqIGM7XG4gIGRzdFsgNl0gPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeCAqIHM7XG4gIGRzdFsgN10gPSAwO1xuICBkc3RbIDhdID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSArIHkgKiBzO1xuICBkc3RbIDldID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSAtIHggKiBzO1xuICBkc3RbMTBdID0genogKyAoMSAtIHp6KSAqIGM7XG4gIGRzdFsxMV0gPSAwO1xuICBkc3RbMTJdID0gMDtcbiAgZHN0WzEzXSA9IDA7XG4gIGRzdFsxNF0gPSAwO1xuICBkc3RbMTVdID0gMTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZVxuICogZ2l2ZW4gYW5nbGUuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gYXhpcyBUaGUgYXhpc1xuICogICAgIGFib3V0IHdoaWNoIHRvIHJvdGF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHJvdGF0ZWQgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIGF4aXNSb3RhdGUobSwgYXhpcywgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgbmV3IE1hdFR5cGUoMTYpO1xuXG4gIGxldCB4ID0gYXhpc1swXTtcbiAgbGV0IHkgPSBheGlzWzFdO1xuICBsZXQgeiA9IGF4aXNbMl07XG4gIGNvbnN0IG4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgeCAvPSBuO1xuICB5IC89IG47XG4gIHogLz0gbjtcbiAgY29uc3QgeHggPSB4ICogeDtcbiAgY29uc3QgeXkgPSB5ICogeTtcbiAgY29uc3QgenogPSB6ICogejtcbiAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgY29uc3Qgb25lTWludXNDb3NpbmUgPSAxIC0gYztcblxuICBjb25zdCByMDAgPSB4eCArICgxIC0geHgpICogYztcbiAgY29uc3QgcjAxID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSArIHogKiBzO1xuICBjb25zdCByMDIgPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geSAqIHM7XG4gIGNvbnN0IHIxMCA9IHggKiB5ICogb25lTWludXNDb3NpbmUgLSB6ICogcztcbiAgY29uc3QgcjExID0geXkgKyAoMSAtIHl5KSAqIGM7XG4gIGNvbnN0IHIxMiA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgKyB4ICogcztcbiAgY29uc3QgcjIwID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSArIHkgKiBzO1xuICBjb25zdCByMjEgPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geCAqIHM7XG4gIGNvbnN0IHIyMiA9IHp6ICsgKDEgLSB6eikgKiBjO1xuXG4gIGNvbnN0IG0wMCA9IG1bMF07XG4gIGNvbnN0IG0wMSA9IG1bMV07XG4gIGNvbnN0IG0wMiA9IG1bMl07XG4gIGNvbnN0IG0wMyA9IG1bM107XG4gIGNvbnN0IG0xMCA9IG1bNF07XG4gIGNvbnN0IG0xMSA9IG1bNV07XG4gIGNvbnN0IG0xMiA9IG1bNl07XG4gIGNvbnN0IG0xMyA9IG1bN107XG4gIGNvbnN0IG0yMCA9IG1bOF07XG4gIGNvbnN0IG0yMSA9IG1bOV07XG4gIGNvbnN0IG0yMiA9IG1bMTBdO1xuICBjb25zdCBtMjMgPSBtWzExXTtcblxuICBkc3RbIDBdID0gcjAwICogbTAwICsgcjAxICogbTEwICsgcjAyICogbTIwO1xuICBkc3RbIDFdID0gcjAwICogbTAxICsgcjAxICogbTExICsgcjAyICogbTIxO1xuICBkc3RbIDJdID0gcjAwICogbTAyICsgcjAxICogbTEyICsgcjAyICogbTIyO1xuICBkc3RbIDNdID0gcjAwICogbTAzICsgcjAxICogbTEzICsgcjAyICogbTIzO1xuICBkc3RbIDRdID0gcjEwICogbTAwICsgcjExICogbTEwICsgcjEyICogbTIwO1xuICBkc3RbIDVdID0gcjEwICogbTAxICsgcjExICogbTExICsgcjEyICogbTIxO1xuICBkc3RbIDZdID0gcjEwICogbTAyICsgcjExICogbTEyICsgcjEyICogbTIyO1xuICBkc3RbIDddID0gcjEwICogbTAzICsgcjExICogbTEzICsgcjEyICogbTIzO1xuICBkc3RbIDhdID0gcjIwICogbTAwICsgcjIxICogbTEwICsgcjIyICogbTIwO1xuICBkc3RbIDldID0gcjIwICogbTAxICsgcjIxICogbTExICsgcjIyICogbTIxO1xuICBkc3RbMTBdID0gcjIwICogbTAyICsgcjIxICogbTEyICsgcjIyICogbTIyO1xuICBkc3RbMTFdID0gcjIwICogbTAzICsgcjIxICogbTEzICsgcjIyICogbTIzO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHNjYWxlcyBpbiBlYWNoIGRpbWVuc2lvbiBieSBhbiBhbW91bnQgZ2l2ZW4gYnlcbiAqIHRoZSBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHRoZSBnaXZlbiB2ZWN0b3I7IGFzc3VtZXMgdGhlIHZlY3RvciBoYXMgdGhyZWVcbiAqIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgQSB2ZWN0b3Igb2ZcbiAqICAgICB0aHJlZSBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHNjYWxpbmcgbWF0cml4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL200XG4gKi9cbmZ1bmN0aW9uIHNjYWxpbmcodiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgZHN0WyAwXSA9IHZbMF07XG4gIGRzdFsgMV0gPSAwO1xuICBkc3RbIDJdID0gMDtcbiAgZHN0WyAzXSA9IDA7XG4gIGRzdFsgNF0gPSAwO1xuICBkc3RbIDVdID0gdlsxXTtcbiAgZHN0WyA2XSA9IDA7XG4gIGRzdFsgN10gPSAwO1xuICBkc3RbIDhdID0gMDtcbiAgZHN0WyA5XSA9IDA7XG4gIGRzdFsxMF0gPSB2WzJdO1xuICBkc3RbMTFdID0gMDtcbiAgZHN0WzEyXSA9IDA7XG4gIGRzdFsxM10gPSAwO1xuICBkc3RbMTRdID0gMDtcbiAgZHN0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50XG4gKiBnaXZlbiBieSB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzXG4gKiB0aHJlZSBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXggdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgQSB2ZWN0b3Igb2YgdGhyZWUgZW50cmllcyBzcGVjaWZ5aW5nIHRoZVxuICogICAgIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW2RzdF0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gVGhlIHNjYWxlZCBtYXRyaXguXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvbTRcbiAqL1xuZnVuY3Rpb24gc2NhbGUobSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBuZXcgTWF0VHlwZSgxNik7XG5cbiAgY29uc3QgdjAgPSB2WzBdO1xuICBjb25zdCB2MSA9IHZbMV07XG4gIGNvbnN0IHYyID0gdlsyXTtcblxuICBkc3RbIDBdID0gdjAgKiBtWzAgKiA0ICsgMF07XG4gIGRzdFsgMV0gPSB2MCAqIG1bMCAqIDQgKyAxXTtcbiAgZHN0WyAyXSA9IHYwICogbVswICogNCArIDJdO1xuICBkc3RbIDNdID0gdjAgKiBtWzAgKiA0ICsgM107XG4gIGRzdFsgNF0gPSB2MSAqIG1bMSAqIDQgKyAwXTtcbiAgZHN0WyA1XSA9IHYxICogbVsxICogNCArIDFdO1xuICBkc3RbIDZdID0gdjEgKiBtWzEgKiA0ICsgMl07XG4gIGRzdFsgN10gPSB2MSAqIG1bMSAqIDQgKyAzXTtcbiAgZHN0WyA4XSA9IHYyICogbVsyICogNCArIDBdO1xuICBkc3RbIDldID0gdjIgKiBtWzIgKiA0ICsgMV07XG4gIGRzdFsxMF0gPSB2MiAqIG1bMiAqIDQgKyAyXTtcbiAgZHN0WzExXSA9IHYyICogbVsyICogNCArIDNdO1xuXG4gIGlmIChtICE9PSBkc3QpIHtcbiAgICBkc3RbMTJdID0gbVsxMl07XG4gICAgZHN0WzEzXSA9IG1bMTNdO1xuICAgIGRzdFsxNF0gPSBtWzE0XTtcbiAgICBkc3RbMTVdID0gbVsxNV07XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFRha2VzIGEgNC1ieS00IG1hdHJpeCBhbmQgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXMsXG4gKiBpbnRlcnByZXRzIHRoZSB2ZWN0b3IgYXMgYSBwb2ludCwgdHJhbnNmb3JtcyB0aGF0IHBvaW50IGJ5IHRoZSBtYXRyaXgsIGFuZFxuICogcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtIFRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IHYgVGhlIHBvaW50LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSBvcHRpb25hbCB2ZWMzIHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChtLCB2LCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IGNyZWF0ZSgpO1xuICBjb25zdCB2MCA9IHZbMF07XG4gIGNvbnN0IHYxID0gdlsxXTtcbiAgY29uc3QgdjIgPSB2WzJdO1xuICBjb25zdCBkID0gdjAgKiBtWzAgKiA0ICsgM10gKyB2MSAqIG1bMSAqIDQgKyAzXSArIHYyICogbVsyICogNCArIDNdICsgbVszICogNCArIDNdO1xuXG4gIGRzdFswXSA9ICh2MCAqIG1bMCAqIDQgKyAwXSArIHYxICogbVsxICogNCArIDBdICsgdjIgKiBtWzIgKiA0ICsgMF0gKyBtWzMgKiA0ICsgMF0pIC8gZDtcbiAgZHN0WzFdID0gKHYwICogbVswICogNCArIDFdICsgdjEgKiBtWzEgKiA0ICsgMV0gKyB2MiAqIG1bMiAqIDQgKyAxXSArIG1bMyAqIDQgKyAxXSkgLyBkO1xuICBkc3RbMl0gPSAodjAgKiBtWzAgKiA0ICsgMl0gKyB2MSAqIG1bMSAqIDQgKyAyXSArIHYyICogbVsyICogNCArIDJdICsgbVszICogNCArIDJdKSAvIGQ7XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIDQtYnktNCBtYXRyaXggYW5kIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzLCBpbnRlcnByZXRzIHRoZSB2ZWN0b3IgYXMgYVxuICogZGlyZWN0aW9uLCB0cmFuc2Zvcm1zIHRoYXQgZGlyZWN0aW9uIGJ5IHRoZSBtYXRyaXgsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQ7XG4gKiBhc3N1bWVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvZiAzLWRpbWVuc2lvbmFsIHNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZSBtYXRyaXhcbiAqIGlzIHBhcmFsbGVsLXByZXNlcnZpbmcsIGkuZS4gYW55IGNvbWJpbmF0aW9uIG9mIHJvdGF0aW9uLCBzY2FsaW5nIGFuZFxuICogdHJhbnNsYXRpb24sIGJ1dCBub3QgYSBwZXJzcGVjdGl2ZSBkaXN0b3J0aW9uLiBSZXR1cm5zIGEgdmVjdG9yIHdpdGggM1xuICogZW50cmllcy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbSBUaGUgbWF0cml4LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSB2IFRoZSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL3YzLlZlYzN9IFtkc3RdIG9wdGlvbmFsIFZlYzMgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHRyYW5zZm9ybWVkIGRpcmVjdGlvbi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1EaXJlY3Rpb24obSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBjcmVhdGUoKTtcblxuICBjb25zdCB2MCA9IHZbMF07XG4gIGNvbnN0IHYxID0gdlsxXTtcbiAgY29uc3QgdjIgPSB2WzJdO1xuXG4gIGRzdFswXSA9IHYwICogbVswICogNCArIDBdICsgdjEgKiBtWzEgKiA0ICsgMF0gKyB2MiAqIG1bMiAqIDQgKyAwXTtcbiAgZHN0WzFdID0gdjAgKiBtWzAgKiA0ICsgMV0gKyB2MSAqIG1bMSAqIDQgKyAxXSArIHYyICogbVsyICogNCArIDFdO1xuICBkc3RbMl0gPSB2MCAqIG1bMCAqIDQgKyAyXSArIHYxICogbVsxICogNCArIDJdICsgdjIgKiBtWzIgKiA0ICsgMl07XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIDQtYnktNCBtYXRyaXggbSBhbmQgYSB2ZWN0b3IgdiB3aXRoIDMgZW50cmllcywgaW50ZXJwcmV0cyB0aGUgdmVjdG9yXG4gKiBhcyBhIG5vcm1hbCB0byBhIHN1cmZhY2UsIGFuZCBjb21wdXRlcyBhIHZlY3RvciB3aGljaCBpcyBub3JtYWwgdXBvblxuICogdHJhbnNmb3JtaW5nIHRoYXQgc3VyZmFjZSBieSB0aGUgbWF0cml4LiBUaGUgZWZmZWN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgdGhlXG4gKiBzYW1lIGFzIHRyYW5zZm9ybWluZyB2IChhcyBhIGRpcmVjdGlvbikgYnkgdGhlIGludmVyc2UtdHJhbnNwb3NlIG9mIG0uICBUaGlzXG4gKiBmdW5jdGlvbiBhc3N1bWVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvZiAzLWRpbWVuc2lvbmFsIHNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZVxuICogbWF0cml4IGlzIHBhcmFsbGVsLXByZXNlcnZpbmcsIGkuZS4gYW55IGNvbWJpbmF0aW9uIG9mIHJvdGF0aW9uLCBzY2FsaW5nIGFuZFxuICogdHJhbnNsYXRpb24sIGJ1dCBub3QgYSBwZXJzcGVjdGl2ZSBkaXN0b3J0aW9uLiAgUmV0dXJucyBhIHZlY3RvciB3aXRoIDNcbiAqIGVudHJpZXMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG0gVGhlIG1hdHJpeC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gdiBUaGUgbm9ybWFsLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC92My5WZWMzfSBbZHN0XSBUaGUgZGlyZWN0aW9uLiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wvdjMuVmVjM30gVGhlIHRyYW5zZm9ybWVkIG5vcm1hbC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9tNFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob3JtYWwobSwgdiwgZHN0KSB7XG4gIGRzdCA9IGRzdCB8fCBjcmVhdGUoKTtcbiAgY29uc3QgbWkgPSBpbnZlcnNlKG0pO1xuICBjb25zdCB2MCA9IHZbMF07XG4gIGNvbnN0IHYxID0gdlsxXTtcbiAgY29uc3QgdjIgPSB2WzJdO1xuXG4gIGRzdFswXSA9IHYwICogbWlbMCAqIDQgKyAwXSArIHYxICogbWlbMCAqIDQgKyAxXSArIHYyICogbWlbMCAqIDQgKyAyXTtcbiAgZHN0WzFdID0gdjAgKiBtaVsxICogNCArIDBdICsgdjEgKiBtaVsxICogNCArIDFdICsgdjIgKiBtaVsxICogNCArIDJdO1xuICBkc3RbMl0gPSB2MCAqIG1pWzIgKiA0ICsgMF0gKyB2MSAqIG1pWzIgKiA0ICsgMV0gKyB2MiAqIG1pWzIgKiA0ICsgMl07XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxudmFyIG00ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGF4aXNSb3RhdGU6IGF4aXNSb3RhdGUsXG4gIGF4aXNSb3RhdGlvbjogYXhpc1JvdGF0aW9uLFxuICBjb3B5OiBjb3B5JDEsXG4gIGZydXN0dW06IGZydXN0dW0sXG4gIGdldEF4aXM6IGdldEF4aXMsXG4gIGdldFRyYW5zbGF0aW9uOiBnZXRUcmFuc2xhdGlvbixcbiAgaWRlbnRpdHk6IGlkZW50aXR5LFxuICBpbnZlcnNlOiBpbnZlcnNlLFxuICBsb29rQXQ6IGxvb2tBdCxcbiAgbXVsdGlwbHk6IG11bHRpcGx5JDEsXG4gIG5lZ2F0ZTogbmVnYXRlJDEsXG4gIG9ydGhvOiBvcnRobyxcbiAgcGVyc3BlY3RpdmU6IHBlcnNwZWN0aXZlLFxuICByb3RhdGVYOiByb3RhdGVYLFxuICByb3RhdGVZOiByb3RhdGVZLFxuICByb3RhdGVaOiByb3RhdGVaLFxuICByb3RhdGlvblg6IHJvdGF0aW9uWCxcbiAgcm90YXRpb25ZOiByb3RhdGlvblksXG4gIHJvdGF0aW9uWjogcm90YXRpb25aLFxuICBzY2FsZTogc2NhbGUsXG4gIHNjYWxpbmc6IHNjYWxpbmcsXG4gIHNldEF4aXM6IHNldEF4aXMsXG4gIHNldERlZmF1bHRUeXBlOiBzZXREZWZhdWx0VHlwZSQxLFxuICBzZXRUcmFuc2xhdGlvbjogc2V0VHJhbnNsYXRpb24sXG4gIHRyYW5zZm9ybURpcmVjdGlvbjogdHJhbnNmb3JtRGlyZWN0aW9uLFxuICB0cmFuc2Zvcm1Ob3JtYWw6IHRyYW5zZm9ybU5vcm1hbCxcbiAgdHJhbnNmb3JtUG9pbnQ6IHRyYW5zZm9ybVBvaW50LFxuICB0cmFuc2xhdGU6IHRyYW5zbGF0ZSxcbiAgdHJhbnNsYXRpb246IHRyYW5zbGF0aW9uLFxuICB0cmFuc3Bvc2U6IHRyYW5zcG9zZVxufSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogRGF0YVR5cGUgKi9cbmNvbnN0IEJZVEUgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMDtcbmNvbnN0IFVOU0lHTkVEX0JZVEUgICAgICAgICAgICAgICAgICA9IDB4MTQwMTtcbmNvbnN0IFNIT1JUICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMjtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUICAgICAgICAgICAgICAgICA9IDB4MTQwMztcbmNvbnN0IElOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNDtcbmNvbnN0IFVOU0lHTkVEX0lOVCAgICAgICAgICAgICAgICAgICA9IDB4MTQwNTtcbmNvbnN0IEZMT0FUICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNjtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgICAgICAgPSAweDgwMzM7XG5jb25zdCBVTlNJR05FRF9TSE9SVF81XzVfNV8xICAgICAgID0gMHg4MDM0O1xuY29uc3QgVU5TSUdORURfU0hPUlRfNV82XzUgICAgICAgICA9IDB4ODM2MztcbmNvbnN0IEhBTEZfRkxPQVQgICAgICAgICAgICAgICAgICAgPSAweDE0MEI7XG5jb25zdCBVTlNJR05FRF9JTlRfMl8xMF8xMF8xMF9SRVYgID0gMHg4MzY4O1xuY29uc3QgVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFViA9IDB4OEMzQjtcbmNvbnN0IFVOU0lHTkVEX0lOVF81XzlfOV85X1JFViAgICAgPSAweDhDM0U7XG5jb25zdCBGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYgPSAweDhEQUQ7XG5jb25zdCBVTlNJR05FRF9JTlRfMjRfOCAgICAgICAgICAgID0gMHg4NEZBO1xuXG5jb25zdCBnbFR5cGVUb1R5cGVkQXJyYXkgPSB7fTtcbntcbiAgY29uc3QgdHQgPSBnbFR5cGVUb1R5cGVkQXJyYXk7XG4gIHR0W0JZVEVdICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBJbnQ4QXJyYXk7XG4gIHR0W1VOU0lHTkVEX0JZVEVdICAgICAgICAgICAgICAgICAgPSBVaW50OEFycmF5O1xuICB0dFtTSE9SVF0gICAgICAgICAgICAgICAgICAgICAgICAgID0gSW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRdICAgICAgICAgICAgICAgICA9IFVpbnQxNkFycmF5O1xuICB0dFtJTlRdICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gSW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXSAgICAgICAgICAgICAgICAgICA9IFVpbnQzMkFycmF5O1xuICB0dFtGTE9BVF0gICAgICAgICAgICAgICAgICAgICAgICAgID0gRmxvYXQzMkFycmF5O1xuICB0dFtVTlNJR05FRF9TSE9SVF80XzRfNF80XSAgICAgICAgID0gVWludDE2QXJyYXk7XG4gIHR0W1VOU0lHTkVEX1NIT1JUXzVfNV81XzFdICAgICAgICAgPSBVaW50MTZBcnJheTtcbiAgdHRbVU5TSUdORURfU0hPUlRfNV82XzVdICAgICAgICAgICA9IFVpbnQxNkFycmF5O1xuICB0dFtIQUxGX0ZMT0FUXSAgICAgICAgICAgICAgICAgICAgID0gVWludDE2QXJyYXk7XG4gIHR0W1VOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVl0gICAgPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFVl0gICA9IFVpbnQzMkFycmF5O1xuICB0dFtVTlNJR05FRF9JTlRfNV85XzlfOV9SRVZdICAgICAgID0gVWludDMyQXJyYXk7XG4gIHR0W0ZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFVl0gPSBVaW50MzJBcnJheTtcbiAgdHRbVU5TSUdORURfSU5UXzI0XzhdICAgICAgICAgICAgICA9IFVpbnQzMkFycmF5O1xufVxuXG4vKipcbiAqIEdldCB0aGUgR0wgdHlwZSBmb3IgYSB0eXBlZEFycmF5XG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gdHlwZWRBcnJheSBhIHR5cGVkQXJyYXlcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIEdMIHR5cGUgZm9yIGFycmF5LiBGb3IgZXhhbXBsZSBwYXNzIGluIGFuIGBJbnQ4QXJyYXlgIGFuZCBgZ2wuQllURWAgd2lsbFxuICogICBiZSByZXR1cm5lZC4gUGFzcyBpbiBhIGBVaW50MzJBcnJheWAgYW5kIGBnbC5VTlNJR05FRF9JTlRgIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90eXBlZEFycmF5XG4gKi9cbmZ1bmN0aW9uIGdldEdMVHlwZUZvclR5cGVkQXJyYXkodHlwZWRBcnJheSkge1xuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSkgICAgICAgICB7IHJldHVybiBCWVRFOyB9ICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkgICAgICAgIHsgcmV0dXJuIFVOU0lHTkVEX0JZVEU7IH0gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgeyByZXR1cm4gVU5TSUdORURfQllURTsgfSAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpICAgICAgICB7IHJldHVybiBTSE9SVDsgfSAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkpICAgICAgIHsgcmV0dXJuIFVOU0lHTkVEX1NIT1JUOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSAgICAgICAgeyByZXR1cm4gSU5UOyB9ICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSAgICAgICB7IHJldHVybiBVTlNJR05FRF9JTlQ7IH0gICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSAgICAgIHsgcmV0dXJuIEZMT0FUOyB9ICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCB0eXBlZCBhcnJheSB0eXBlJyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBHTCB0eXBlIGZvciBhIHR5cGVkQXJyYXkgdHlwZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IHR5cGVkQXJyYXlUeXBlIGEgdHlwZWRBcnJheSBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgR0wgdHlwZSBmb3IgdHlwZS4gRm9yIGV4YW1wbGUgcGFzcyBpbiBgSW50OEFycmF5YCBhbmQgYGdsLkJZVEVgIHdpbGxcbiAqICAgYmUgcmV0dXJuZWQuIFBhc3MgaW4gYFVpbnQzMkFycmF5YCBhbmQgYGdsLlVOU0lHTkVEX0lOVGAgd2lsbCBiZSByZXR1cm5lZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3R5cGVkQXJyYXlcbiAqL1xuZnVuY3Rpb24gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUodHlwZWRBcnJheVR5cGUpIHtcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQ4QXJyYXkpICAgICAgICAgeyByZXR1cm4gQllURTsgfSAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQ4QXJyYXkpICAgICAgICB7IHJldHVybiBVTlNJR05FRF9CWVRFOyB9ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gVWludDhDbGFtcGVkQXJyYXkpIHsgcmV0dXJuIFVOU0lHTkVEX0JZVEU7IH0gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQxNkFycmF5KSAgICAgICAgeyByZXR1cm4gU0hPUlQ7IH0gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IFVpbnQxNkFycmF5KSAgICAgICB7IHJldHVybiBVTlNJR05FRF9TSE9SVDsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5VHlwZSA9PT0gSW50MzJBcnJheSkgICAgICAgIHsgcmV0dXJuIElOVDsgfSAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBVaW50MzJBcnJheSkgICAgICAgeyByZXR1cm4gVU5TSUdORURfSU5UOyB9ICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZWRBcnJheVR5cGUgPT09IEZsb2F0MzJBcnJheSkgICAgICB7IHJldHVybiBGTE9BVDsgfSAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgdHlwZWQgYXJyYXkgdHlwZScpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IgZm9yIGEgZ2l2ZW4gR0wgdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgdGhlIEdMIHR5cGUuIChlZzogYGdsLlVOU0lHTkVEX0lOVGApXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gdGhlIGNvbnN0cnVjdG9yIGZvciBhIHRoZSBjb3JyZXNwb25kaW5nIHR5cGVkIGFycmF5LiAoZWcuIGBVaW50MzJBcnJheWApLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3R5cGVkQXJyYXlcbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheVR5cGVGb3JHTFR5cGUodHlwZSkge1xuICBjb25zdCBDVE9SID0gZ2xUeXBlVG9UeXBlZEFycmF5W3R5cGVdO1xuICBpZiAoIUNUT1IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZ2wgdHlwZScpO1xuICB9XG4gIHJldHVybiBDVE9SO1xufVxuXG5jb25zdCBpc0FycmF5QnVmZmVyID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuICA/IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJPclNoYXJlZEFycmF5QnVmZmVyKGEpIHtcbiAgICByZXR1cm4gYSAmJiBhLmJ1ZmZlciAmJiAoYS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBhLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKTtcbiAgfVxuICA6IGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIoYSkge1xuICAgIHJldHVybiBhICYmIGEuYnVmZmVyICYmIGEuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gIH07XG5cbnZhciB0eXBlZGFycmF5cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZXRHTFR5cGVGb3JUeXBlZEFycmF5OiBnZXRHTFR5cGVGb3JUeXBlZEFycmF5LFxuICBnZXRHTFR5cGVGb3JUeXBlZEFycmF5VHlwZTogZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUsXG4gIGdldFR5cGVkQXJyYXlUeXBlRm9yR0xUeXBlOiBnZXRUeXBlZEFycmF5VHlwZUZvckdMVHlwZSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlclxufSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLWNvbnNvbGU6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBDb3B5IG5hbWVkIHByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBuYW1lcyBuYW1lcyBvZiBwcm9wZXJ0aWVzIHRvIGNvcHlcbiAqIEBwYXJhbSB7b2JqZWN0fSBzcmMgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge29iamVjdH0gZHN0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvcHlOYW1lZFByb3BlcnRpZXMobmFtZXMsIHNyYywgZHN0KSB7XG4gIG5hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3JjW25hbWVdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkc3RbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIGRlc3Qgb25seSBpZiBhIG1hdGNoaW5nIGtleSBpcyBpbiBkZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IHNyYyB0aGUgc291cmNlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gZHN0IHRoZSBkZXN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb3B5RXhpc3RpbmdQcm9wZXJ0aWVzKHNyYywgZHN0KSB7XG4gIE9iamVjdC5rZXlzKGRzdCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoZHN0Lmhhc093blByb3BlcnR5KGtleSkgJiYgc3JjLmhhc093blByb3BlcnR5KGtleSkpIHsgIC8qIGVzbGludCBuby1wcm90b3R5cGUtYnVpbHRpbnM6IDAgKi9cbiAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZXJyb3IoLi4uYXJncykge1xuICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB3YXJuKC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlcihnbCwgdCkge1xuICByZXR1cm4gdHlwZW9mIFdlYkdMQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0IGluc3RhbmNlb2YgV2ViR0xCdWZmZXI7XG59XG5cbmZ1bmN0aW9uIGlzUmVuZGVyYnVmZmVyKGdsLCB0KSB7XG4gIHJldHVybiB0eXBlb2YgV2ViR0xSZW5kZXJidWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHQgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gaXNTaGFkZXIoZ2wsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBXZWJHTFNoYWRlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdCBpbnN0YW5jZW9mIFdlYkdMU2hhZGVyO1xufVxuXG5mdW5jdGlvbiBpc1RleHR1cmUoZ2wsIHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBXZWJHTFRleHR1cmUgIT09ICd1bmRlZmluZWQnICYmIHQgaW5zdGFuY2VvZiBXZWJHTFRleHR1cmU7XG59XG5cbmZ1bmN0aW9uIGlzU2FtcGxlcihnbCwgdCkge1xuICByZXR1cm4gdHlwZW9mIFdlYkdMU2FtcGxlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdCBpbnN0YW5jZW9mIFdlYkdMU2FtcGxlcjtcbn1cblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBTVEFUSUNfRFJBVyAgICAgICAgICAgICAgICAgID0gMHg4OGU0O1xuY29uc3QgQVJSQVlfQlVGRkVSICAgICAgICAgICAgICAgICA9IDB4ODg5MjtcbmNvbnN0IEVMRU1FTlRfQVJSQVlfQlVGRkVSICAgICAgICAgPSAweDg4OTM7XG5jb25zdCBCVUZGRVJfU0laRSAgICAgICAgICAgICAgICAgID0gMHg4NzY0O1xuXG5jb25zdCBCWVRFJDEgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDA7XG5jb25zdCBVTlNJR05FRF9CWVRFJDEgICAgICAgICAgICAgICAgPSAweDE0MDE7XG5jb25zdCBTSE9SVCQxICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDI7XG5jb25zdCBVTlNJR05FRF9TSE9SVCQxICAgICAgICAgICAgICAgPSAweDE0MDM7XG5jb25zdCBJTlQkMSAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDQ7XG5jb25zdCBVTlNJR05FRF9JTlQkMSAgICAgICAgICAgICAgICAgPSAweDE0MDU7XG5jb25zdCBGTE9BVCQxICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDY7XG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXR0cmliUHJlZml4OiBcIlwiLFxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IGF0dHJpYiBwcmVmaXhcbiAqXG4gKiBXaGVuIHdyaXRpbmcgc2hhZGVycyBJIHByZWZlciB0byBuYW1lIGF0dHJpYnV0ZXMgd2l0aCBgYV9gLCB1bmlmb3JtcyB3aXRoIGB1X2AgYW5kIHZhcnlpbmdzIHdpdGggYHZfYFxuICogYXMgaXQgbWFrZXMgaXQgY2xlYXIgd2hlcmUgdGhleSBjYW1lIGZyb20uIEJ1dCwgd2hlbiBidWlsZGluZyBnZW9tZXRyeSBJIHByZWZlciB1c2luZyB1bi1wcmVmaXhlZCBuYW1lcy5cbiAqXG4gKiBJbiBvdGhlciB3b3JkcyBJJ2xsIGNyZWF0ZSBhcnJheXMgb2YgZ2VvbWV0cnkgbGlrZSB0aGlzXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICBwb3NpdGlvbjogLi4uXG4gKiAgICAgICBub3JtYWw6IC4uLlxuICogICAgICAgdGV4Y29vcmQ6IC4uLlxuICogICAgIH07XG4gKlxuICogQnV0IG5lZWQgdGhvc2UgbWFwcGVkIHRvIGF0dHJpYnV0ZXMgYW5kIG15IGF0dHJpYnV0ZXMgc3RhcnQgd2l0aCBgYV9gLlxuICpcbiAqIEBkZXByZWNhdGVkIHNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0RGVmYXVsdHN9XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHByZWZpeCBmb3IgYXR0cmlic1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlUHJlZml4KHByZWZpeCkge1xuICBkZWZhdWx0cy5hdHRyaWJQcmVmaXggPSBwcmVmaXg7XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIGNvcHlFeGlzdGluZ1Byb3BlcnRpZXMobmV3RGVmYXVsdHMsIGRlZmF1bHRzKTtcbn1cblxuZnVuY3Rpb24gc2V0QnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGUsIGJ1ZmZlciwgYXJyYXksIGRyYXdUeXBlKSB7XG4gIGdsLmJpbmRCdWZmZXIodHlwZSwgYnVmZmVyKTtcbiAgZ2wuYnVmZmVyRGF0YSh0eXBlLCBhcnJheSwgZHJhd1R5cGUgfHwgU1RBVElDX0RSQVcpO1xufVxuXG4vKipcbiAqIEdpdmVuIHR5cGVkIGFycmF5IGNyZWF0ZXMgYSBXZWJHTEJ1ZmZlciBhbmQgY29waWVzIHRoZSB0eXBlZCBhcnJheVxuICogaW50byBpdC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8U2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fFdlYkdMQnVmZmVyfSB0eXBlZEFycmF5IHRoZSB0eXBlZCBhcnJheS4gTm90ZTogSWYgYSBXZWJHTEJ1ZmZlciBpcyBwYXNzZWQgaW4gaXQgd2lsbCBqdXN0IGJlIHJldHVybmVkLiBObyBhY3Rpb24gd2lsbCBiZSB0YWtlblxuICogQHBhcmFtIHtudW1iZXJ9IFt0eXBlXSB0aGUgR0wgYmluZCB0eXBlIGZvciB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gYGdsLkFSUkFZX0JVRkZFUmAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RyYXdUeXBlXSB0aGUgR0wgZHJhdyB0eXBlIGZvciB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gJ2dsLlNUQVRJQ19EUkFXYC5cbiAqIEByZXR1cm4ge1dlYkdMQnVmZmVyfSB0aGUgY3JlYXRlZCBXZWJHTEJ1ZmZlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXkoZ2wsIHR5cGVkQXJyYXksIHR5cGUsIGRyYXdUeXBlKSB7XG4gIGlmIChpc0J1ZmZlcihnbCwgdHlwZWRBcnJheSkpIHtcbiAgICByZXR1cm4gdHlwZWRBcnJheTtcbiAgfVxuICB0eXBlID0gdHlwZSB8fCBBUlJBWV9CVUZGRVI7XG4gIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBzZXRCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgdHlwZSwgYnVmZmVyLCB0eXBlZEFycmF5LCBkcmF3VHlwZSk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGlzSW5kaWNlcyhuYW1lKSB7XG4gIHJldHVybiBuYW1lID09PSBcImluZGljZXNcIjtcbn1cblxuLy8gVGhpcyBpcyByZWFsbHkganVzdCBhIGd1ZXNzLiBUaG91Z2ggSSBjYW4ndCByZWFsbHkgaW1hZ2luZSB1c2luZ1xuLy8gYW55dGhpbmcgZWxzZT8gTWF5YmUgZm9yIHNvbWUgY29tcHJlc3Npb24/XG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uRm9yVHlwZWRBcnJheSh0eXBlZEFycmF5KSB7XG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5KSAgICB7IHJldHVybiB0cnVlOyB9ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkgICB7IHJldHVybiB0cnVlOyB9ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gVGhpcyBpcyByZWFsbHkganVzdCBhIGd1ZXNzLiBUaG91Z2ggSSBjYW4ndCByZWFsbHkgaW1hZ2luZSB1c2luZ1xuLy8gYW55dGhpbmcgZWxzZT8gTWF5YmUgZm9yIHNvbWUgY29tcHJlc3Npb24/XG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uRm9yVHlwZWRBcnJheVR5cGUodHlwZWRBcnJheVR5cGUpIHtcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBJbnQ4QXJyYXkpICAgIHsgcmV0dXJuIHRydWU7IH0gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVkQXJyYXlUeXBlID09PSBVaW50OEFycmF5KSAgIHsgcmV0dXJuIHRydWU7IH0gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheShhcnJheSkge1xuICByZXR1cm4gYXJyYXkubGVuZ3RoID8gYXJyYXkgOiBhcnJheS5kYXRhO1xufVxuXG5jb25zdCB0ZXhjb29yZFJFID0gL2Nvb3JkfHRleHR1cmUvaTtcbmNvbnN0IGNvbG9yUkUgPSAvY29sb3J8Y29sb3VyL2k7XG5cbmZ1bmN0aW9uIGd1ZXNzTnVtQ29tcG9uZW50c0Zyb21OYW1lKG5hbWUsIGxlbmd0aCkge1xuICBsZXQgbnVtQ29tcG9uZW50cztcbiAgaWYgKHRleGNvb3JkUkUudGVzdChuYW1lKSkge1xuICAgIG51bUNvbXBvbmVudHMgPSAyO1xuICB9IGVsc2UgaWYgKGNvbG9yUkUudGVzdChuYW1lKSkge1xuICAgIG51bUNvbXBvbmVudHMgPSA0O1xuICB9IGVsc2Uge1xuICAgIG51bUNvbXBvbmVudHMgPSAzOyAgLy8gcG9zaXRpb24sIG5vcm1hbHMsIGluZGljZXMgLi4uXG4gIH1cblxuICBpZiAobGVuZ3RoICUgbnVtQ29tcG9uZW50cyA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgZ3Vlc3MgbnVtQ29tcG9uZW50cyBmb3IgYXR0cmlidXRlICcke25hbWV9Jy4gVHJpZWQgJHtudW1Db21wb25lbnRzfSBidXQgJHtsZW5ndGh9IHZhbHVlcyBpcyBub3QgZXZlbmx5IGRpdmlzaWJsZSBieSAke251bUNvbXBvbmVudHN9LiBZb3Ugc2hvdWxkIHNwZWNpZnkgaXQuYCk7XG4gIH1cblxuICByZXR1cm4gbnVtQ29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwgYXJyYXlOYW1lKSB7XG4gIHJldHVybiBhcnJheS5udW1Db21wb25lbnRzIHx8IGFycmF5LnNpemUgfHwgZ3Vlc3NOdW1Db21wb25lbnRzRnJvbU5hbWUoYXJyYXlOYW1lLCBnZXRBcnJheShhcnJheSkubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gbWFrZVR5cGVkQXJyYXkoYXJyYXksIG5hbWUpIHtcbiAgaWYgKGlzQXJyYXlCdWZmZXIoYXJyYXkpKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXIoYXJyYXkuZGF0YSkpIHtcbiAgICByZXR1cm4gYXJyYXkuZGF0YTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIGFycmF5ID0ge1xuICAgICAgZGF0YTogYXJyYXksXG4gICAgfTtcbiAgfVxuXG4gIGxldCBUeXBlID0gYXJyYXkudHlwZTtcbiAgaWYgKCFUeXBlKSB7XG4gICAgaWYgKGlzSW5kaWNlcyhuYW1lKSkge1xuICAgICAgVHlwZSA9IFVpbnQxNkFycmF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBUeXBlID0gRmxvYXQzMkFycmF5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFR5cGUoYXJyYXkuZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGluZm8gZm9yIGFuIGF0dHJpYnV0ZS4gVGhpcyBpcyBlZmZlY3RpdmVseSBqdXN0IHRoZSBhcmd1bWVudHMgdG8gYGdsLnZlcnRleEF0dHJpYlBvaW50ZXJgIHBsdXMgdGhlIFdlYkdMQnVmZmVyXG4gKiBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdHRyaWJJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcltdfEFycmF5QnVmZmVyVmlld30gW3ZhbHVlXSBhIGNvbnN0YW50IHZhbHVlIGZvciB0aGUgYXR0cmlidXRlLiBOb3RlOiBpZiB0aGlzIGlzIHNldCB0aGUgYXR0cmlidXRlIHdpbGwgYmVcbiAqICAgIGRpc2FibGVkIGFuZCBzZXQgdG8gdGhpcyBjb25zdGFudCB2YWx1ZSBhbmQgYWxsIG90aGVyIHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW251bUNvbXBvbmVudHNdIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBmb3IgdGhpcyBhdHRyaWJ1dGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NpemVdIHN5bm9ueW0gZm9yIGBudW1Db21wb25lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHlwZV0gdGhlIHR5cGUgb2YgdGhlIGF0dHJpYnV0ZSAoZWcuIGBnbC5GTE9BVGAsIGBnbC5VTlNJR05FRF9CWVRFYCwgZXRjLi4uKSBEZWZhdWx0ID0gYGdsLkZMT0FUYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbbm9ybWFsaXplXSB3aGV0aGVyIG9yIG5vdCB0byBub3JtYWxpemUgdGhlIGRhdGEuIERlZmF1bHQgPSBmYWxzZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRdIG9mZnNldCBpbnRvIGJ1ZmZlciBpbiBieXRlcy4gRGVmYXVsdCA9IDBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RyaWRlXSB0aGUgc3RyaWRlIGluIGJ5dGVzIHBlciBlbGVtZW50LiBEZWZhdWx0ID0gMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkaXZpc29yXSB0aGUgZGl2aXNvciBpbiBpbnN0YW5jZXMuIERlZmF1bHQgPSB1bmRlZmluZWQuIE5vdGU6IHVuZGVmaW5lZCA9IGRvbid0IGNhbGwgZ2wudmVydGV4QXR0cmliRGl2aXNvclxuICogICAgd2hlcmUgYXMgYW55dGhpbmcgZWxzZSA9IGRvIGNhbGwgaXQgd2l0aCB0aGlzIHZhbHVlXG4gKiBAcHJvcGVydHkge1dlYkdMQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIGZvciB0aGlzIGF0dHJpYnV0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkcmF3VHlwZV0gdGhlIGRyYXcgdHlwZSBwYXNzZWQgdG8gZ2wuYnVmZmVyRGF0YS4gRGVmYXVsdCA9IGdsLlNUQVRJQ19EUkFXXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIFVzZSB0aGlzIHR5cGUgb2YgYXJyYXkgc3BlYyB3aGVuIFRXR0wgY2FuJ3QgZ3Vlc3MgdGhlIHR5cGUgb3IgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgYW4gYXJyYXlcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZ1bGxBcnJheVNwZWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fSBbdmFsdWVdIGEgY29uc3RhbnQgdmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGUuIE5vdGU6IGlmIHRoaXMgaXMgc2V0IHRoZSBhdHRyaWJ1dGUgd2lsbCBiZVxuICogICAgZGlzYWJsZWQgYW5kIHNldCB0byB0aGlzIGNvbnN0YW50IHZhbHVlIGFuZCBhbGwgb3RoZXIgdmFsdWVzIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7KG51bWJlcnxudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXcpfSBkYXRhIFRoZSBkYXRhIG9mIHRoZSBhcnJheS4gQSBudW1iZXIgYWxvbmUgYmVjb21lcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIHR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW251bUNvbXBvbmVudHNdIG51bWJlciBvZiBjb21wb25lbnRzIGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIG5hbWUgb2YgdGhlIGFycmF5LlxuICogICAgSWYgYGNvb3JkYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gMmAuXG4gKiAgICBJZiBgY29sb3JgIGlzIGluIHRoZSBuYW1lIGFzc3VtZXMgYG51bUNvbXBvbmVudHMgPSA0YC5cbiAqICAgIG90aGVyd2lzZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gM2BcbiAqIEBwcm9wZXJ0eSB7Y29uc3RydWN0b3J9IFt0eXBlXSB0eXBlLiBUaGlzIGlzIG9ubHkgdXNlZCBpZiBgZGF0YWAgaXMgYSBKYXZhU2NyaXB0IGFycmF5LiBJdCBpcyB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlZGFycmF5LiAoZWcuIGBVaW50OEFycmF5YCkuXG4gKiBGb3IgZXhhbXBsZSBpZiB5b3Ugd2FudCBjb2xvcnMgaW4gYSBgVWludDhBcnJheWAgeW91IG1pZ2h0IGhhdmUgYSBgRnVsbEFycmF5U3BlY2AgbGlrZSBgeyB0eXBlOiBVaW50OEFycmF5LCBkYXRhOiBbMjU1LDAsMjU1LDI1NSwgLi4uXSwgfWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NpemVdIHN5bm9ueW0gZm9yIGBudW1Db21wb25lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25vcm1hbGl6ZV0gbm9ybWFsaXplIGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgaXMgdHJ1ZSBpZiB0eXBlIGlzIGBJbnQ4QXJyYXlgIG9yIGBVaW50OEFycmF5YCBvdGhlcndpc2UgZmFsc2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0cmlkZV0gc3RyaWRlIGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldF0gb2Zmc2V0IGZvciBgdmVydGV4QXR0cmliUG9pbnRlcmAuIERlZmF1bHQgPSAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Rpdmlzb3JdIGRpdmlzb3IgZm9yIGB2ZXJ0ZXhBdHRyaWJEaXZpc29yYC4gRGVmYXVsdCA9IHVuZGVmaW5lZC4gTm90ZTogdW5kZWZpbmVkID0gZG9uJ3QgY2FsbCBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yXG4gKiAgICB3aGVyZSBhcyBhbnl0aGluZyBlbHNlID0gZG8gY2FsbCBpdCB3aXRoIHRoaXMgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmliXSBuYW1lIG9mIGF0dHJpYnV0ZSB0aGlzIGFycmF5IG1hcHMgdG8uIERlZmF1bHRzIHRvIHNhbWUgbmFtZSBhcyBhcnJheSBwcmVmaXhlZCBieSB0aGUgZGVmYXVsdCBhdHRyaWJQcmVmaXguXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIHN5bm9ueW0gZm9yIGBhdHRyaWJgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJOYW1lXSBzeW5vbnltIGZvciBgYXR0cmliYC5cbiAqIEBwcm9wZXJ0eSB7V2ViR0xCdWZmZXJ9IFtidWZmZXJdIEJ1ZmZlciB0byB1c2UgZm9yIHRoaXMgYXR0cmlidXRlLiBUaGlzIGxldHMgeW91IHVzZSB5b3VyIG93biBidWZmZXJcbiAqICAgIGJ1dCB5b3Ugd2lsbCBuZWVkIHRvIHN1cHBseSBgbnVtQ29tcG9uZW50c2AgYW5kIGB0eXBlYC4gWW91IGNhbiBlZmZlY3RpdmVseSBwYXNzIGFuIGBBdHRyaWJJbmZvYFxuICogICAgdG8gcHJvdmlkZSB0aGlzLiBFeGFtcGxlOlxuICpcbiAqICAgICAgICAgY29uc3QgYnVmZmVySW5mbzEgPSB0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCB7XG4gKiAgICAgICAgICAgcG9zaXRpb246IFsxLCAyLCAzLCAuLi4gXSxcbiAqICAgICAgICAgfSk7XG4gKiAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8yID0gdHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwge1xuICogICAgICAgICAgIHBvc2l0aW9uOiBidWZmZXJJbmZvMS5hdHRyaWJzLnBvc2l0aW9uLCAgLy8gdXNlIHRoZSBzYW1lIGJ1ZmZlciBmcm9tIGJ1ZmZlckluZm8xXG4gKiAgICAgICAgIH0pO1xuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQW4gaW5kaXZpZHVhbCBhcnJheSBpbiB7QGxpbmsgbW9kdWxlOnR3Z2wuQXJyYXlzfVxuICpcbiAqIFdoZW4gcGFzc2VkIHRvIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5c30gaWYgYW4gQXJyYXlTcGVjIGlzIGBudW1iZXJbXWAgb3IgYEFycmF5QnVmZmVyVmlld2BcbiAqIHRoZSB0eXBlcyB3aWxsIGJlIGd1ZXNzZWQgYmFzZWQgb24gdGhlIG5hbWUuIGBpbmRpY2VzYCB3aWxsIGJlIGBVaW50MTZBcnJheWAsIGV2ZXJ5dGhpbmcgZWxzZSB3aWxsXG4gKiBiZSBgRmxvYXQzMkFycmF5YC4gSWYgYW4gQXJyYXlTcGVjIGlzIGEgbnVtYmVyIGl0J3MgdGhlIG51bWJlciBvZiBmbG9hdHMgZm9yIGFuIGVtcHR5ICh6ZXJvZWQpIGJ1ZmZlci5cbiAqXG4gKiBAdHlwZWRlZiB7KG51bWJlcnxudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXd8bW9kdWxlOnR3Z2wuRnVsbEFycmF5U3BlYyl9IEFycmF5U3BlY1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgSmF2YVNjcmlwdCBvYmplY3Qgb2YgYXJyYXlzIGJ5IG5hbWUuIFRoZSBuYW1lcyBzaG91bGQgbWF0Y2ggeW91ciBzaGFkZXIncyBhdHRyaWJ1dGVzLiBJZiB5b3VyXG4gKiBhdHRyaWJ1dGVzIGhhdmUgYSBjb21tb24gcHJlZml4IHlvdSBjYW4gc3BlY2lmeSBpdCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6dHdnbC5zZXRBdHRyaWJ1dGVQcmVmaXh9LlxuICpcbiAqICAgICBCYXJlIEphdmFTY3JpcHQgQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogWy0xLCAxLCAwXSxcbiAqICAgICAgICAgICAgbm9ybWFsOiBbMCwgMSwgMF0sXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogICAgIEJhcmUgVHlwZWRBcnJheXNcbiAqXG4gKiAgICAgICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgMF0pLFxuICogICAgICAgICAgICBjb2xvcjogbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMTI4LCA2NCwgMjU1XSksXG4gKiAgICAgICAgICAgIC4uLlxuICogICAgICAgICB9XG4gKlxuICogKiAgIFdpbGwgZ3Vlc3MgYXQgYG51bUNvbXBvbmVudHNgIGlmIG5vdCBzcGVjaWZpZWQgYmFzZWQgb24gbmFtZS5cbiAqXG4gKiAgICAgSWYgYGNvb3JkYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gMmBcbiAqXG4gKiAgICAgSWYgYGNvbG9yYCBpcyBpbiB0aGUgbmFtZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gNGBcbiAqXG4gKiAgICAgb3RoZXJ3aXNlIGFzc3VtZXMgYG51bUNvbXBvbmVudHMgPSAzYFxuICpcbiAqIE9iamVjdHMgd2l0aCB2YXJpb3VzIGZpZWxkcy4gU2VlIHtAbGluayBtb2R1bGU6dHdnbC5GdWxsQXJyYXlTcGVjfS5cbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sIH0sXG4gKiAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCBkYXRhOiBbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0sICAgICAgICAgICAgICAgICB9LFxuICogICAgICAgbm9ybWFsOiAgIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLCAgICAgfSxcbiAqICAgICAgIGluZGljZXM6ICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAxLCAyLCAxLCAyLCAzXSwgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkFycmF5U3BlYz59IEFycmF5c1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2YgYXR0cmlidXRlIGRhdGEgYW5kIFdlYkdMQnVmZmVycyBmcm9tIHNldCBvZiBhcnJheXNcbiAqXG4gKiBHaXZlblxuICpcbiAqICAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogeyBudW1Db21wb25lbnRzOiAzLCBkYXRhOiBbMCwgMCwgMCwgMTAsIDAsIDAsIDAsIDEwLCAwLCAxMCwgMTAsIDBdLCB9LFxuICogICAgICAgIHRleGNvb3JkOiB7IG51bUNvbXBvbmVudHM6IDIsIGRhdGE6IFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSwgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgbm9ybWFsOiAgIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLCAgICAgfSxcbiAqICAgICAgICBjb2xvcjogICAgeyBudW1Db21wb25lbnRzOiA0LCBkYXRhOiBbMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDAsIDAsIDI1NSwgMCwgMCwgMjU1LCAyNTVdLCB0eXBlOiBVaW50OEFycmF5LCB9LFxuICogICAgICAgIGluZGljZXM6ICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAxLCAyLCAxLCAyLCAzXSwgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgIH07XG4gKlxuICogcmV0dXJucyBzb21ldGhpbmcgbGlrZVxuICpcbiAqICAgICAgdmFyIGF0dHJpYnMgPSB7XG4gKiAgICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgdHlwZTogZ2wuRkxPQVQsICAgICAgICAgbm9ybWFsaXplOiBmYWxzZSwgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgfSxcbiAqICAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCB0eXBlOiBnbC5GTE9BVCwgICAgICAgICBub3JtYWxpemU6IGZhbHNlLCBidWZmZXI6IFdlYkdMQnVmZmVyLCB9LFxuICogICAgICAgIG5vcm1hbDogICB7IG51bUNvbXBvbmVudHM6IDMsIHR5cGU6IGdsLkZMT0FULCAgICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsIGJ1ZmZlcjogV2ViR0xCdWZmZXIsIH0sXG4gKiAgICAgICAgY29sb3I6ICAgIHsgbnVtQ29tcG9uZW50czogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplOiB0cnVlLCAgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgfSxcbiAqICAgICAgfTtcbiAqXG4gKiBub3RlczpcbiAqXG4gKiAqICAgQXJyYXlzIGNhbiB0YWtlIHZhcmlvdXMgZm9ybXNcbiAqXG4gKiAgICAgQmFyZSBKYXZhU2NyaXB0IEFycmF5c1xuICpcbiAqICAgICAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICAgICAgcG9zaXRpb246IFstMSwgMSwgMF0sXG4gKiAgICAgICAgICAgIG5vcm1hbDogWzAsIDEsIDBdLFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqICAgICBCYXJlIFR5cGVkQXJyYXlzXG4gKlxuICogICAgICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShbLTEsIDEsIDBdKSxcbiAqICAgICAgICAgICAgY29sb3I6IG5ldyBVaW50OEFycmF5KFsyNTUsIDEyOCwgNjQsIDI1NV0pLFxuICogICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqICogICBXaWxsIGd1ZXNzIGF0IGBudW1Db21wb25lbnRzYCBpZiBub3Qgc3BlY2lmaWVkIGJhc2VkIG9uIG5hbWUuXG4gKlxuICogICAgIElmIGBjb29yZGAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDJgXG4gKlxuICogICAgIElmIGBjb2xvcmAgaXMgaW4gdGhlIG5hbWUgYXNzdW1lcyBgbnVtQ29tcG9uZW50cyA9IDRgXG4gKlxuICogICAgIG90aGVyd2lzZSBhc3N1bWVzIGBudW1Db21wb25lbnRzID0gM2BcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIHdlYmdsIHJlbmRlcmluZyBjb250ZXh0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5BcnJheXN9IGFycmF5cyBUaGUgYXJyYXlzXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFtzcmNCdWZmZXJJbmZvXSBhIEJ1ZmZlckluZm8gdG8gY29weSBmcm9tXG4gKiAgIFRoaXMgbGV0cyB5b3Ugc2hhcmUgYnVmZmVycy4gQW55IGFycmF5cyB5b3Ugc3VwcGx5IHdpbGwgb3ZlcnJpZGVcbiAqICAgdGhlIGJ1ZmZlcnMgZnJvbSBzcmNCdWZmZXJJbmZvLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSB0aGUgYXR0cmlic1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2F0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXR0cmlic0Zyb21BcnJheXMoZ2wsIGFycmF5cykge1xuICBjb25zdCBhdHRyaWJzID0ge307XG4gIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbihhcnJheU5hbWUpIHtcbiAgICBpZiAoIWlzSW5kaWNlcyhhcnJheU5hbWUpKSB7XG4gICAgICBjb25zdCBhcnJheSA9IGFycmF5c1thcnJheU5hbWVdO1xuICAgICAgY29uc3QgYXR0cmliTmFtZSA9IGFycmF5LmF0dHJpYiB8fCBhcnJheS5uYW1lIHx8IGFycmF5LmF0dHJpYk5hbWUgfHwgKGRlZmF1bHRzLmF0dHJpYlByZWZpeCArIGFycmF5TmFtZSk7XG4gICAgICBpZiAoYXJyYXkudmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5LnZhbHVlKSAmJiAhaXNBcnJheUJ1ZmZlcihhcnJheS52YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5LnZhbHVlIGlzIG5vdCBhcnJheSBvciB0eXBlZGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlic1thdHRyaWJOYW1lXSA9IHtcbiAgICAgICAgICB2YWx1ZTogYXJyYXkudmFsdWUsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgbGV0IG5vcm1hbGl6YXRpb247XG4gICAgICAgIGxldCBudW1Db21wb25lbnRzO1xuICAgICAgICBpZiAoYXJyYXkuYnVmZmVyICYmIGFycmF5LmJ1ZmZlciBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVyID0gYXJyYXkuYnVmZmVyO1xuICAgICAgICAgIG51bUNvbXBvbmVudHMgPSBhcnJheS5udW1Db21wb25lbnRzIHx8IGFycmF5LnNpemU7XG4gICAgICAgICAgdHlwZSA9IGFycmF5LnR5cGU7XG4gICAgICAgICAgbm9ybWFsaXphdGlvbiA9IGFycmF5Lm5vcm1hbGl6ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyYXkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGFycmF5LmRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjb25zdCBudW1WYWx1ZXMgPSBhcnJheS5kYXRhIHx8IGFycmF5O1xuICAgICAgICAgIGNvbnN0IGFycmF5VHlwZSA9IGFycmF5LnR5cGUgfHwgRmxvYXQzMkFycmF5O1xuICAgICAgICAgIGNvbnN0IG51bUJ5dGVzID0gbnVtVmFsdWVzICogYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICAgIHR5cGUgPSBnZXRHTFR5cGVGb3JUeXBlZEFycmF5VHlwZShhcnJheVR5cGUpO1xuICAgICAgICAgIG5vcm1hbGl6YXRpb24gPSBhcnJheS5ub3JtYWxpemUgIT09IHVuZGVmaW5lZCA/IGFycmF5Lm5vcm1hbGl6ZSA6IGdldE5vcm1hbGl6YXRpb25Gb3JUeXBlZEFycmF5VHlwZShhcnJheVR5cGUpO1xuICAgICAgICAgIG51bUNvbXBvbmVudHMgPSBhcnJheS5udW1Db21wb25lbnRzIHx8IGFycmF5LnNpemUgfHwgZ3Vlc3NOdW1Db21wb25lbnRzRnJvbU5hbWUoYXJyYXlOYW1lLCBudW1WYWx1ZXMpO1xuICAgICAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoQVJSQVlfQlVGRkVSLCBudW1CeXRlcywgYXJyYXkuZHJhd1R5cGUgfHwgU1RBVElDX0RSQVcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXkgPSBtYWtlVHlwZWRBcnJheShhcnJheSwgYXJyYXlOYW1lKTtcbiAgICAgICAgICBidWZmZXIgPSBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgdHlwZWRBcnJheSwgdW5kZWZpbmVkLCBhcnJheS5kcmF3VHlwZSk7XG4gICAgICAgICAgdHlwZSA9IGdldEdMVHlwZUZvclR5cGVkQXJyYXkodHlwZWRBcnJheSk7XG4gICAgICAgICAgbm9ybWFsaXphdGlvbiA9IGFycmF5Lm5vcm1hbGl6ZSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubm9ybWFsaXplIDogZ2V0Tm9ybWFsaXphdGlvbkZvclR5cGVkQXJyYXkodHlwZWRBcnJheSk7XG4gICAgICAgICAgbnVtQ29tcG9uZW50cyA9IGdldE51bUNvbXBvbmVudHMoYXJyYXksIGFycmF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlic1thdHRyaWJOYW1lXSA9IHtcbiAgICAgICAgICBidWZmZXI6ICAgICAgICBidWZmZXIsXG4gICAgICAgICAgbnVtQ29tcG9uZW50czogbnVtQ29tcG9uZW50cyxcbiAgICAgICAgICB0eXBlOiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG5vcm1hbGl6ZTogICAgIG5vcm1hbGl6YXRpb24sXG4gICAgICAgICAgc3RyaWRlOiAgICAgICAgYXJyYXkuc3RyaWRlIHx8IDAsXG4gICAgICAgICAgb2Zmc2V0OiAgICAgICAgYXJyYXkub2Zmc2V0IHx8IDAsXG4gICAgICAgICAgZGl2aXNvcjogICAgICAgYXJyYXkuZGl2aXNvciA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYXJyYXkuZGl2aXNvcixcbiAgICAgICAgICBkcmF3VHlwZTogICAgICBhcnJheS5kcmF3VHlwZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIHJldHVybiBhdHRyaWJzO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGNvbnRlbnRzIG9mIGEgYnVmZmVyIGF0dGFjaGVkIHRvIGFuIGF0dHJpYkluZm9cbiAqXG4gKiBUaGlzIGlzIGhlbHBlciBmdW5jdGlvbiB0byBkeW5hbWljYWxseSB1cGRhdGUgYSBidWZmZXIuXG4gKlxuICogTGV0J3Mgc2F5IHlvdSBtYWtlIGEgYnVmZmVySW5mb1xuICpcbiAqICAgICB2YXIgYXJyYXlzID0ge1xuICogICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0pLFxuICogICAgICAgIHRleGNvb3JkOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSksXG4gKiAgICAgICAgbm9ybWFsOiAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdKSxcbiAqICAgICAgICBpbmRpY2VzOiAgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAxLCAyLCAzXSksXG4gKiAgICAgfTtcbiAqICAgICB2YXIgYnVmZmVySW5mbyA9IHR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gKlxuICogIEFuZCB5b3Ugd2FudCB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIHBvc2l0aW9ucy4gWW91IGNvdWxkIGRvIHRoaXNcbiAqXG4gKiAgICAgLy8gYXNzdW1pbmcgYXJyYXlzLnBvc2l0aW9uIGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZCB3aXRoIG5ldyBkYXRhLlxuICogICAgIHR3Z2wuc2V0QXR0cmliSW5mb0J1ZmZlckZyb21BcnJheShnbCwgYnVmZmVySW5mby5hdHRyaWJzLnBvc2l0aW9uLCBhcnJheXMucG9zaXRpb24pO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICogQHBhcmFtIHtBdHRyaWJJbmZvfSBhdHRyaWJJbmZvIFRoZSBhdHRyaWJJbmZvIHdobydzIGJ1ZmZlciBjb250ZW50cyB0byBzZXQuIE5PVEU6IElmIHlvdSBoYXZlIGFuIGF0dHJpYnV0ZSBwcmVmaXhcbiAqICAgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB3aWxsIGluY2x1ZGUgdGhlIHByZWZpeC5cbiAqIEBwYXJhbSB7QXJyYXlTcGVjfSBhcnJheSBOb3RlOiBpdCBpcyBhcmd1YWJseSBpbmVmZmljaWVudCB0byBwYXNzIGluIGFueXRoaW5nIGJ1dCBhIHR5cGVkIGFycmF5IGJlY2F1c2UgYW55dGhpbmdcbiAqICAgIGVsc2Ugd2lsbCBoYXZlIHRvIGJlIGNvbnZlcnRlZCB0byBhIHR5cGVkIGFycmF5IGJlZm9yZSBpdCBjYW4gYmUgdXNlZCBieSBXZWJHTC4gRHVyaW5nIGluaXQgdGltZSB0aGF0XG4gKiAgICBpbmVmZmljaWVuY3kgaXMgdXN1YWxseSBub3QgaW1wb3J0YW50IGJ1dCBpZiB5b3UncmUgdXBkYXRpbmcgZGF0YSBkeW5hbWljYWxseSBiZXN0IHRvIGJlIGVmZmljaWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBhbiBvcHRpb25hbCBvZmZzZXQgaW50byB0aGUgYnVmZmVyLiBUaGlzIGlzIG9ubHkgYW4gb2Zmc2V0IGludG8gdGhlIFdlYkdMIGJ1ZmZlclxuICogICAgbm90IHRoZSBhcnJheS4gVG8gcGFzcyBpbiBhbiBvZmZzZXQgaW50byB0aGUgYXJyYXkgaXRzZWxmIHVzZSBhIHR5cGVkIGFycmF5IGFuZCBjcmVhdGUgYW4gYEFycmF5QnVmZmVyVmlld2BcbiAqICAgIGZvciB0aGUgcG9ydGlvbiBvZiB0aGUgYXJyYXkgeW91IHdhbnQgdG8gdXNlLlxuICpcbiAqICAgICAgICB2YXIgc29tZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxMDAwKTsgLy8gYW4gYXJyYXkgd2l0aCAxMDAwIGZsb2F0c1xuICogICAgICAgIHZhciBzb21lU3ViQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHNvbWVBcnJheS5idWZmZXIsIG9mZnNldEluQnl0ZXMsIHNpemVJblVuaXRzKTsgLy8gYSB2aWV3IGludG8gc29tZUFycmF5XG4gKlxuICogICAgTm93IHlvdSBjYW4gcGFzcyBgc29tZVN1YkFycmF5YCBpbnRvIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXlgXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJJbmZvQnVmZmVyRnJvbUFycmF5KGdsLCBhdHRyaWJJbmZvLCBhcnJheSwgb2Zmc2V0KSB7XG4gIGFycmF5ID0gbWFrZVR5cGVkQXJyYXkoYXJyYXkpO1xuICBpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiwgYXR0cmliSW5mby5idWZmZXIpO1xuICAgIGdsLmJ1ZmZlclN1YkRhdGEoQVJSQVlfQlVGRkVSLCBvZmZzZXQsIGFycmF5KTtcbiAgfSBlbHNlIHtcbiAgICBzZXRCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgQVJSQVlfQlVGRkVSLCBhdHRyaWJJbmZvLmJ1ZmZlciwgYXJyYXksIGF0dHJpYkluZm8uZHJhd1R5cGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJ5dGVzUGVyVmFsdWVGb3JHTFR5cGUoZ2wsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IEJZVEUkMSkgICAgICAgICAgIHJldHVybiAxOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZSA9PT0gVU5TSUdORURfQllURSQxKSAgcmV0dXJuIDE7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlID09PSBTSE9SVCQxKSAgICAgICAgICByZXR1cm4gMjsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGUgPT09IFVOU0lHTkVEX1NIT1JUJDEpIHJldHVybiAyOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBpZiAodHlwZSA9PT0gSU5UJDEpICAgICAgICAgICAgcmV0dXJuIDQ7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGlmICh0eXBlID09PSBVTlNJR05FRF9JTlQkMSkgICByZXR1cm4gNDsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGUgPT09IEZMT0FUJDEpICAgICAgICAgIHJldHVybiA0OyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICByZXR1cm4gMDtcbn1cblxuLy8gVHJpZXMgdG8gZ2V0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZnJvbSBhIHNldCBvZiBhcnJheXMuXG5jb25zdCBwb3NpdGlvbktleXMgPSBbJ3Bvc2l0aW9uJywgJ3Bvc2l0aW9ucycsICdhX3Bvc2l0aW9uJ107XG5mdW5jdGlvbiBnZXROdW1FbGVtZW50c0Zyb21Ob25JbmRleGVkQXJyYXlzKGFycmF5cykge1xuICBsZXQga2V5O1xuICBsZXQgaWk7XG4gIGZvciAoaWkgPSAwOyBpaSA8IHBvc2l0aW9uS2V5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBrZXkgPSBwb3NpdGlvbktleXNbaWldO1xuICAgIGlmIChrZXkgaW4gYXJyYXlzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGlpID09PSBwb3NpdGlvbktleXMubGVuZ3RoKSB7XG4gICAga2V5ID0gT2JqZWN0LmtleXMoYXJyYXlzKVswXTtcbiAgfVxuICBjb25zdCBhcnJheSA9IGFycmF5c1trZXldO1xuICBjb25zdCBsZW5ndGggPSBnZXRBcnJheShhcnJheSkubGVuZ3RoO1xuICBjb25zdCBudW1Db21wb25lbnRzID0gZ2V0TnVtQ29tcG9uZW50cyhhcnJheSwga2V5KTtcbiAgY29uc3QgbnVtRWxlbWVudHMgPSBsZW5ndGggLyBudW1Db21wb25lbnRzO1xuICBpZiAobGVuZ3RoICUgbnVtQ29tcG9uZW50cyA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG51bUNvbXBvbmVudHMgJHtudW1Db21wb25lbnRzfSBub3QgY29ycmVjdCBmb3IgbGVuZ3RoICR7bGVuZ3RofWApO1xuICB9XG4gIHJldHVybiBudW1FbGVtZW50cztcbn1cblxuZnVuY3Rpb24gZ2V0TnVtRWxlbWVudHNGcm9tQXR0cmlidXRlcyhnbCwgYXR0cmlicykge1xuICBsZXQga2V5O1xuICBsZXQgaWk7XG4gIGZvciAoaWkgPSAwOyBpaSA8IHBvc2l0aW9uS2V5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBrZXkgPSBwb3NpdGlvbktleXNbaWldO1xuICAgIGlmIChrZXkgaW4gYXR0cmlicykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGtleSA9IGRlZmF1bHRzLmF0dHJpYlByZWZpeCArIGtleTtcbiAgICBpZiAoa2V5IGluIGF0dHJpYnMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaWkgPT09IHBvc2l0aW9uS2V5cy5sZW5ndGgpIHtcbiAgICBrZXkgPSBPYmplY3Qua2V5cyhhdHRyaWJzKVswXTtcbiAgfVxuICBjb25zdCBhdHRyaWIgPSBhdHRyaWJzW2tleV07XG4gIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBhdHRyaWIuYnVmZmVyKTtcbiAgY29uc3QgbnVtQnl0ZXMgPSBnbC5nZXRCdWZmZXJQYXJhbWV0ZXIoQVJSQVlfQlVGRkVSLCBCVUZGRVJfU0laRSk7XG4gIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSLCBudWxsKTtcblxuICBjb25zdCBieXRlc1BlclZhbHVlID0gZ2V0Qnl0ZXNQZXJWYWx1ZUZvckdMVHlwZShnbCwgYXR0cmliLnR5cGUpO1xuICBjb25zdCB0b3RhbEVsZW1lbnRzID0gbnVtQnl0ZXMgLyBieXRlc1BlclZhbHVlO1xuICBjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmliLm51bUNvbXBvbmVudHMgfHwgYXR0cmliLnNpemU7XG4gIC8vIFRPRE86IGNoZWNrIHN0cmlkZVxuICBjb25zdCBudW1FbGVtZW50cyA9IHRvdGFsRWxlbWVudHMgLyBudW1Db21wb25lbnRzO1xuICBpZiAobnVtRWxlbWVudHMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBudW1Db21wb25lbnRzICR7bnVtQ29tcG9uZW50c30gbm90IGNvcnJlY3QgZm9yIGxlbmd0aCAke2xlbmd0aH1gKTtcbiAgfVxuICByZXR1cm4gbnVtRWxlbWVudHM7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQnVmZmVySW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG51bUVsZW1lbnRzIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcGFzcyB0byBgZ2wuZHJhd0FycmF5c2Agb3IgYGdsLmRyYXdFbGVtZW50c2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2VsZW1lbnRUeXBlXSBUaGUgdHlwZSBvZiBpbmRpY2VzIGBVTlNJR05FRF9CWVRFYCwgYFVOU0lHTkVEX1NIT1JUYCBldGMuLlxuICogQHByb3BlcnR5IHtXZWJHTEJ1ZmZlcn0gW2luZGljZXNdIFRoZSBpbmRpY2VzIGBFTEVNRU5UX0FSUkFZX0JVRkZFUmAgaWYgYW55IGluZGljZXMgZXhpc3QuXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPn0gW2F0dHJpYnNdIFRoZSBhdHRyaWJzIGFwcHJvcHJpYXRlIHRvIGNhbGwgYHNldEF0dHJpYnV0ZXNgXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBCdWZmZXJJbmZvIGZyb20gYW4gb2JqZWN0IG9mIGFycmF5cy5cbiAqXG4gKiBUaGlzIGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rIG1vZHVsZTp0d2dsLnNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzfSBhbmQgdG9cbiAqIHtAbGluayBtb2R1bGU6dHdnbDpkcmF3QnVmZmVySW5mb30uXG4gKlxuICogR2l2ZW4gYW4gb2JqZWN0IGxpa2VcbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sIH0sXG4gKiAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCBkYXRhOiBbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0sICAgICAgICAgICAgICAgICB9LFxuICogICAgICAgbm9ybWFsOiAgIHsgbnVtQ29tcG9uZW50czogMywgZGF0YTogWzAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDFdLCAgICAgfSxcbiAqICAgICAgIGluZGljZXM6ICB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAxLCAyLCAxLCAyLCAzXSwgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiAgQ3JlYXRlcyBhbiBCdWZmZXJJbmZvIGxpa2UgdGhpc1xuICpcbiAqICAgICBidWZmZXJJbmZvID0ge1xuICogICAgICAgbnVtRWxlbWVudHM6IDQsICAgICAgICAvLyBvciB3aGF0ZXZlciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzXG4gKiAgICAgICBpbmRpY2VzOiBXZWJHTEJ1ZmZlciwgIC8vIHRoaXMgcHJvcGVydHkgd2lsbCBub3QgZXhpc3QgaWYgdGhlcmUgYXJlIG5vIGluZGljZXNcbiAqICAgICAgIGF0dHJpYnM6IHtcbiAqICAgICAgICAgcG9zaXRpb246IHsgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgbnVtQ29tcG9uZW50czogMywgfSxcbiAqICAgICAgICAgbm9ybWFsOiAgIHsgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgbnVtQ29tcG9uZW50czogMywgfSxcbiAqICAgICAgICAgdGV4Y29vcmQ6IHsgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgbnVtQ29tcG9uZW50czogMiwgfSxcbiAqICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiAgVGhlIHByb3BlcnRpZXMgb2YgYXJyYXlzIGNhbiBiZSBKYXZhU2NyaXB0IGFycmF5cyBpbiB3aGljaCBjYXNlIHRoZSBudW1iZXIgb2YgY29tcG9uZW50c1xuICogIHdpbGwgYmUgZ3Vlc3NlZC5cbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbjogWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSxcbiAqICAgICAgICB0ZXhjb29yZDogWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdLFxuICogICAgICAgIG5vcm1hbDogICBbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0sXG4gKiAgICAgICAgaW5kaWNlczogIFswLCAxLCAyLCAxLCAyLCAzXSxcbiAqICAgICB9O1xuICpcbiAqICBUaGV5IGNhbiBhbHNvIGJlIFR5cGVkQXJyYXlzXG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgcG9zaXRpb246IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEwLCAwLCAwLCAwLCAxMCwgMCwgMTAsIDEwLCAwXSksXG4gKiAgICAgICAgdGV4Y29vcmQ6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdKSxcbiAqICAgICAgICBub3JtYWw6ICAgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0pLFxuICogICAgICAgIGluZGljZXM6ICBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDEsIDIsIDNdKSxcbiAqICAgICB9O1xuICpcbiAqICBPciBBdWdtZW50ZWRUeXBlZEFycmF5c1xuICpcbiAqICAgICB2YXIgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCA0KTtcbiAqICAgICB2YXIgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCA0KTtcbiAqICAgICB2YXIgbm9ybWFscyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCA0KTtcbiAqICAgICB2YXIgaW5kaWNlcyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCAyLCBVaW50MTZBcnJheSk7XG4gKlxuICogICAgIHBvc2l0aW9ucy5wdXNoKFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0pO1xuICogICAgIHRleGNvb3Jkcy5wdXNoKFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSk7XG4gKiAgICAgbm9ybWFscy5wdXNoKFswLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxXSk7XG4gKiAgICAgaW5kaWNlcy5wdXNoKFswLCAxLCAyLCAxLCAyLCAzXSk7XG4gKlxuICogICAgIHZhciBhcnJheXMgPSB7XG4gKiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAqICAgICAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICogICAgICAgIG5vcm1hbDogICBub3JtYWxzLFxuICogICAgICAgIGluZGljZXM6ICBpbmRpY2VzLFxuICogICAgIH07XG4gKlxuICogRm9yIHRoZSBsYXN0IGV4YW1wbGUgaXQgaXMgZXF1aXZhbGVudCB0b1xuICpcbiAqICAgICB2YXIgYnVmZmVySW5mbyA9IHtcbiAqICAgICAgIGF0dHJpYnM6IHtcbiAqICAgICAgICAgcG9zaXRpb246IHsgbnVtQ29tcG9uZW50czogMywgYnVmZmVyOiBnbC5jcmVhdGVCdWZmZXIoKSwgfSxcbiAqICAgICAgICAgdGV4Y29vcmQ6IHsgbnVtQ29tcG9uZW50czogMiwgYnVmZmVyOiBnbC5jcmVhdGVCdWZmZXIoKSwgfSxcbiAqICAgICAgICAgbm9ybWFsOiB7IG51bUNvbXBvbmVudHM6IDMsIGJ1ZmZlcjogZ2wuY3JlYXRlQnVmZmVyKCksIH0sXG4gKiAgICAgICB9LFxuICogICAgICAgaW5kaWNlczogZ2wuY3JlYXRlQnVmZmVyKCksXG4gKiAgICAgICBudW1FbGVtZW50czogNixcbiAqICAgICB9O1xuICpcbiAqICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVySW5mby5hdHRyaWJzLnBvc2l0aW9uLmJ1ZmZlcik7XG4gKiAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFycmF5cy5wb3NpdGlvbiwgZ2wuU1RBVElDX0RSQVcpO1xuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJJbmZvLmF0dHJpYnMudGV4Y29vcmQuYnVmZmVyKTtcbiAqICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXlzLnRleGNvb3JkLCBnbC5TVEFUSUNfRFJBVyk7XG4gKiAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckluZm8uYXR0cmlicy5ub3JtYWwuYnVmZmVyKTtcbiAqICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXlzLm5vcm1hbCwgZ2wuU1RBVElDX0RSQVcpO1xuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlckluZm8uaW5kaWNlcyk7XG4gKiAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYXJyYXlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzfSBhcnJheXMgWW91ciBkYXRhXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFtzcmNCdWZmZXJJbmZvXSBBbiBleGlzdGluZ1xuICogICAgICAgIGJ1ZmZlciBpbmZvIHRvIHN0YXJ0IGZyb20uIFdlYkdMQnVmZmVycyBldGMgc3BlY2lmaWVkXG4gKiAgICAgICAgaW4gdGhlIHNyY0J1ZmZlckluZm8gd2lsbCBiZSB1c2VkIGluIGEgbmV3IEJ1ZmZlckluZm9cbiAqICAgICAgICB3aXRoIGFueSBhcnJheXMgc3BlY2lmaWVkIG92ZXJyaWRpbmcgdGhlIG9uZXMgaW5cbiAqICAgICAgICBzcmNCdWZmZXJJbmZvLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gQSBCdWZmZXJJbmZvXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYXJyYXlzLCBzcmNCdWZmZXJJbmZvKSB7XG4gIGNvbnN0IG5ld0F0dHJpYnMgPSBjcmVhdGVBdHRyaWJzRnJvbUFycmF5cyhnbCwgYXJyYXlzKTtcbiAgY29uc3QgYnVmZmVySW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHNyY0J1ZmZlckluZm8gPyBzcmNCdWZmZXJJbmZvIDoge30pO1xuICBidWZmZXJJbmZvLmF0dHJpYnMgPSBPYmplY3QuYXNzaWduKHt9LCBzcmNCdWZmZXJJbmZvID8gc3JjQnVmZmVySW5mby5hdHRyaWJzIDoge30sIG5ld0F0dHJpYnMpO1xuICBjb25zdCBpbmRpY2VzID0gYXJyYXlzLmluZGljZXM7XG4gIGlmIChpbmRpY2VzKSB7XG4gICAgY29uc3QgbmV3SW5kaWNlcyA9IG1ha2VUeXBlZEFycmF5KGluZGljZXMsIFwiaW5kaWNlc1wiKTtcbiAgICBidWZmZXJJbmZvLmluZGljZXMgPSBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgbmV3SW5kaWNlcywgRUxFTUVOVF9BUlJBWV9CVUZGRVIpO1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBuZXdJbmRpY2VzLmxlbmd0aDtcbiAgICBidWZmZXJJbmZvLmVsZW1lbnRUeXBlID0gZ2V0R0xUeXBlRm9yVHlwZWRBcnJheShuZXdJbmRpY2VzKTtcbiAgfSBlbHNlIGlmICghYnVmZmVySW5mby5udW1FbGVtZW50cykge1xuICAgIGJ1ZmZlckluZm8ubnVtRWxlbWVudHMgPSBnZXROdW1FbGVtZW50c0Zyb21BdHRyaWJ1dGVzKGdsLCBidWZmZXJJbmZvLmF0dHJpYnMpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlckluZm87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJ1ZmZlciBmcm9tIGFuIGFycmF5LCB0eXBlZCBhcnJheSwgb3IgYXJyYXkgc3BlY1xuICpcbiAqIEdpdmVuIHNvbWV0aGluZyBsaWtlIHRoaXNcbiAqXG4gKiAgICAgWzEsIDIsIDNdLFxuICpcbiAqIG9yXG4gKlxuICogICAgIG5ldyBVaW50MTZBcnJheShbMSwyLDNdKTtcbiAqXG4gKiBvclxuICpcbiAqICAgICB7XG4gKiAgICAgICAgZGF0YTogWzEsIDIsIDNdLFxuICogICAgICAgIHR5cGU6IFVpbnQ4QXJyYXksXG4gKiAgICAgfVxuICpcbiAqIHJldHVybnMgYSBXZWJHTEJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlTcGVjfSBhcnJheSBhbiBhcnJheSwgdHlwZWQgYXJyYXksIG9yIGFycmF5IHNwZWMuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJyYXlOYW1lIG5hbWUgb2YgYXJyYXkuIFVzZWQgdG8gZ3Vlc3MgdGhlIHR5cGUgaWYgdHlwZSBjYW4gbm90IGJlIGRlcml2ZWQgb3RoZXJ3aXNlLlxuICogQHJldHVybiB7V2ViR0xCdWZmZXJ9IGEgV2ViR0xCdWZmZXIgY29udGFpbmluZyB0aGUgZGF0YSBpbiBhcnJheS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9hdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckZyb21BcnJheShnbCwgYXJyYXksIGFycmF5TmFtZSkge1xuICBjb25zdCB0eXBlID0gYXJyYXlOYW1lID09PSBcImluZGljZXNcIiA/IEVMRU1FTlRfQVJSQVlfQlVGRkVSIDogQVJSQVlfQlVGRkVSO1xuICBjb25zdCB0eXBlZEFycmF5ID0gbWFrZVR5cGVkQXJyYXkoYXJyYXksIGFycmF5TmFtZSk7XG4gIHJldHVybiBjcmVhdGVCdWZmZXJGcm9tVHlwZWRBcnJheShnbCwgdHlwZWRBcnJheSwgdHlwZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBidWZmZXJzIGZyb20gYXJyYXlzIG9yIHR5cGVkIGFycmF5c1xuICpcbiAqIEdpdmVuIHNvbWV0aGluZyBsaWtlIHRoaXNcbiAqXG4gKiAgICAgdmFyIGFycmF5cyA9IHtcbiAqICAgICAgICBwb3NpdGlvbnM6IFsxLCAyLCAzXSxcbiAqICAgICAgICBub3JtYWxzOiBbMCwgMCwgMV0sXG4gKiAgICAgfVxuICpcbiAqIHJldHVybnMgc29tZXRoaW5nIGxpa2VcbiAqXG4gKiAgICAgYnVmZmVycyA9IHtcbiAqICAgICAgIHBvc2l0aW9uczogV2ViR0xCdWZmZXIsXG4gKiAgICAgICBub3JtYWxzOiBXZWJHTEJ1ZmZlcixcbiAqICAgICB9XG4gKlxuICogSWYgdGhlIGJ1ZmZlciBpcyBuYW1lZCAnaW5kaWNlcycgaXQgd2lsbCBiZSBtYWRlIGFuIEVMRU1FTlRfQVJSQVlfQlVGRkVSLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzfSBhcnJheXNcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBvbmUgV2ViR0xCdWZmZXIgcGVyIGFycmF5XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJzRnJvbUFycmF5cyhnbCwgYXJyYXlzKSB7XG4gIGNvbnN0IGJ1ZmZlcnMgPSB7IH07XG4gIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBidWZmZXJzW2tleV0gPSBjcmVhdGVCdWZmZXJGcm9tQXJyYXkoZ2wsIGFycmF5c1trZXldLCBrZXkpO1xuICB9KTtcblxuICAvLyBVZ2ghXG4gIGlmIChhcnJheXMuaW5kaWNlcykge1xuICAgIGJ1ZmZlcnMubnVtRWxlbWVudHMgPSBhcnJheXMuaW5kaWNlcy5sZW5ndGg7XG4gICAgYnVmZmVycy5lbGVtZW50VHlwZSA9IGdldEdMVHlwZUZvclR5cGVkQXJyYXkobWFrZVR5cGVkQXJyYXkoYXJyYXlzLmluZGljZXMpKTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXJzLm51bUVsZW1lbnRzID0gZ2V0TnVtRWxlbWVudHNGcm9tTm9uSW5kZXhlZEFycmF5cyhhcnJheXMpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59XG5cbnZhciBhdHRyaWJ1dGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNyZWF0ZUF0dHJpYnNGcm9tQXJyYXlzOiBjcmVhdGVBdHRyaWJzRnJvbUFycmF5cyxcbiAgY3JlYXRlQnVmZmVyc0Zyb21BcnJheXM6IGNyZWF0ZUJ1ZmZlcnNGcm9tQXJyYXlzLFxuICBjcmVhdGVCdWZmZXJGcm9tQXJyYXk6IGNyZWF0ZUJ1ZmZlckZyb21BcnJheSxcbiAgY3JlYXRlQnVmZmVyRnJvbVR5cGVkQXJyYXk6IGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5LFxuICBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5czogY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMsXG4gIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXk6IHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXksXG4gIHNldEF0dHJpYnV0ZVByZWZpeDogc2V0QXR0cmlidXRlUHJlZml4LFxuICBzZXRBdHRyaWJ1dGVEZWZhdWx0c186IHNldERlZmF1bHRzLFxuICBnZXROdW1Db21wb25lbnRzXzogZ2V0TnVtQ29tcG9uZW50cyxcbiAgZ2V0QXJyYXlfOiBnZXRBcnJheVxufSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuY29uc3QgZ2V0QXJyYXkkMSA9IGdldEFycmF5OyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuY29uc3QgZ2V0TnVtQ29tcG9uZW50cyQxID0gZ2V0TnVtQ29tcG9uZW50czsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAdHlwZWRlZiB7KEludDhBcnJheXxVaW50OEFycmF5fEludDE2QXJyYXl8VWludDE2QXJyYXl8SW50MzJBcnJheXxVaW50MzJBcnJheXxGbG9hdDMyQXJyYXkpfSBUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBBZGQgYHB1c2hgIHRvIGEgdHlwZWQgYXJyYXkuIEl0IGp1c3Qga2VlcHMgYSAnY3Vyc29yJ1xuICogYW5kIGFsbG93cyB1c2UgdG8gYHB1c2hgIHZhbHVlcyBpbnRvIHRoZSBhcnJheSBzbyB3ZVxuICogZG9uJ3QgaGF2ZSB0byBtYW51YWxseSBjb21wdXRlIG9mZnNldHNcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdHlwZWRBcnJheSBUeXBlZEFycmF5IHRvIGF1Z21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1Db21wb25lbnRzIG51bWJlciBvZiBjb21wb25lbnRzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXVnbWVudFR5cGVkQXJyYXkodHlwZWRBcnJheSwgbnVtQ29tcG9uZW50cykge1xuICBsZXQgY3Vyc29yID0gMDtcbiAgdHlwZWRBcnJheS5wdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraWkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXJndW1lbnRzW2lpXTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5IHx8IGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGpqID0gMDsgamogPCB2YWx1ZS5sZW5ndGg7ICsramopIHtcbiAgICAgICAgICB0eXBlZEFycmF5W2N1cnNvcisrXSA9IHZhbHVlW2pqXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZWRBcnJheVtjdXJzb3IrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHR5cGVkQXJyYXkucmVzZXQgPSBmdW5jdGlvbihvcHRfaW5kZXgpIHtcbiAgICBjdXJzb3IgPSBvcHRfaW5kZXggfHwgMDtcbiAgfTtcbiAgdHlwZWRBcnJheS5udW1Db21wb25lbnRzID0gbnVtQ29tcG9uZW50cztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGVkQXJyYXksICdudW1FbGVtZW50cycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC8gdGhpcy5udW1Db21wb25lbnRzIHwgMDtcbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIHR5cGVkQXJyYXk7XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIHR5cGVkIGFycmF5IHdpdGggYSBgcHVzaGAgZnVuY3Rpb24gYXR0YWNoZWRcbiAqIHNvIHRoYXQgeW91IGNhbiBlYXNpbHkgKnB1c2gqIHZhbHVlcy5cbiAqXG4gKiBgcHVzaGAgY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzLiBJZiBhbiBhcmd1bWVudCBpcyBhbiBhcnJheSBlYWNoIGVsZW1lbnRcbiAqIG9mIHRoZSBhcnJheSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0eXBlZCBhcnJheS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcnJheSA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgMik7ICAvLyBjcmVhdGVzIGEgRmxvYXQzMkFycmF5IHdpdGggNiB2YWx1ZXNcbiAqICAgICBhcnJheS5wdXNoKDEsIDIsIDMpO1xuICogICAgIGFycmF5LnB1c2goWzQsIDUsIDZdKTtcbiAqICAgICAvLyBhcnJheSBub3cgY29udGFpbnMgWzEsIDIsIDMsIDQsIDUsIDZdXG4gKlxuICogQWxzbyBoYXMgYG51bUNvbXBvbmVudHNgIGFuZCBgbnVtRWxlbWVudHNgIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bUNvbXBvbmVudHMgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1FbGVtZW50cyBudW1iZXIgb2YgZWxlbWVudHMuIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBhcnJheSB3aWxsIGJlIGBudW1Db21wb25lbnRzICogbnVtRWxlbWVudHNgLlxuICogQHBhcmFtIHtjb25zdHJ1Y3Rvcn0gb3B0X3R5cGUgQSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuIERlZmF1bHQgPSBgRmxvYXQzMkFycmF5YC5cbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyVmlld30gQSB0eXBlZCBhcnJheS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkobnVtQ29tcG9uZW50cywgbnVtRWxlbWVudHMsIG9wdF90eXBlKSB7XG4gIGNvbnN0IFR5cGUgPSBvcHRfdHlwZSB8fCBGbG9hdDMyQXJyYXk7XG4gIHJldHVybiBhdWdtZW50VHlwZWRBcnJheShuZXcgVHlwZShudW1Db21wb25lbnRzICogbnVtRWxlbWVudHMpLCBudW1Db21wb25lbnRzKTtcbn1cblxuZnVuY3Rpb24gYWxsQnV0SW5kaWNlcyhuYW1lKSB7XG4gIHJldHVybiBuYW1lICE9PSBcImluZGljZXNcIjtcbn1cblxuLyoqXG4gKiBHaXZlbiBpbmRleGVkIHZlcnRpY2VzIGNyZWF0ZXMgYSBuZXcgc2V0IG9mIHZlcnRpY2VzIHVuLWluZGV4ZWQgYnkgZXhwYW5kaW5nIHRoZSBpbmRleGVkIHZlcnRpY2VzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IHZlcnRpY2VzIFRoZSBpbmRleGVkIHZlcnRpY2VzIHRvIGRlaW5kZXhcbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGRlaW5kZXhlZCB2ZXJ0aWNlc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuZnVuY3Rpb24gZGVpbmRleFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIGNvbnN0IGluZGljZXMgPSB2ZXJ0aWNlcy5pbmRpY2VzO1xuICBjb25zdCBuZXdWZXJ0aWNlcyA9IHt9O1xuICBjb25zdCBudW1FbGVtZW50cyA9IGluZGljZXMubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGV4cGFuZFRvVW5pbmRleGVkKGNoYW5uZWwpIHtcbiAgICBjb25zdCBzcmNCdWZmZXIgPSB2ZXJ0aWNlc1tjaGFubmVsXTtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gc3JjQnVmZmVyLm51bUNvbXBvbmVudHM7XG4gICAgY29uc3QgZHN0QnVmZmVyID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheShudW1Db21wb25lbnRzLCBudW1FbGVtZW50cywgc3JjQnVmZmVyLmNvbnN0cnVjdG9yKTtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbnVtRWxlbWVudHM7ICsraWkpIHtcbiAgICAgIGNvbnN0IG5keCA9IGluZGljZXNbaWldO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbmR4ICogbnVtQ29tcG9uZW50cztcbiAgICAgIGZvciAobGV0IGpqID0gMDsgamogPCBudW1Db21wb25lbnRzOyArK2pqKSB7XG4gICAgICAgIGRzdEJ1ZmZlci5wdXNoKHNyY0J1ZmZlcltvZmZzZXQgKyBqal0pO1xuICAgICAgfVxuICAgIH1cbiAgICBuZXdWZXJ0aWNlc1tjaGFubmVsXSA9IGRzdEJ1ZmZlcjtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHZlcnRpY2VzKS5maWx0ZXIoYWxsQnV0SW5kaWNlcykuZm9yRWFjaChleHBhbmRUb1VuaW5kZXhlZCk7XG5cbiAgcmV0dXJuIG5ld1ZlcnRpY2VzO1xufVxuXG4vKipcbiAqIGZsYXR0ZW5zIHRoZSBub3JtYWxzIG9mIGRlaW5kZXhlZCB2ZXJ0aWNlcyBpbiBwbGFjZS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSB2ZXJ0aWNlcyBUaGUgZGVpbmRleGVkIHZlcnRpY2VzIHdobydzIG5vcm1hbHMgdG8gZmxhdHRlblxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgZmxhdHRlbmVkIHZlcnRpY2VzIChzYW1lIGFzIHdhcyBwYXNzZWQgaW4pXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBmbGF0dGVuTm9ybWFscyh2ZXJ0aWNlcykge1xuICBpZiAodmVydGljZXMuaW5kaWNlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuIG5vdCBmbGF0dGVuIG5vcm1hbHMgb2YgaW5kZXhlZCB2ZXJ0aWNlcy4gZGVpbmRleCB0aGVtIGZpcnN0Jyk7XG4gIH1cblxuICBjb25zdCBub3JtYWxzID0gdmVydGljZXMubm9ybWFsO1xuICBjb25zdCBudW1Ob3JtYWxzID0gbm9ybWFscy5sZW5ndGg7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBudW1Ob3JtYWxzOyBpaSArPSA5KSB7XG4gICAgLy8gcHVsbCBvdXQgdGhlIDMgbm9ybWFscyBmb3IgdGhpcyB0cmlhbmdsZVxuICAgIGNvbnN0IG5heCA9IG5vcm1hbHNbaWkgKyAwXTtcbiAgICBjb25zdCBuYXkgPSBub3JtYWxzW2lpICsgMV07XG4gICAgY29uc3QgbmF6ID0gbm9ybWFsc1tpaSArIDJdO1xuXG4gICAgY29uc3QgbmJ4ID0gbm9ybWFsc1tpaSArIDNdO1xuICAgIGNvbnN0IG5ieSA9IG5vcm1hbHNbaWkgKyA0XTtcbiAgICBjb25zdCBuYnogPSBub3JtYWxzW2lpICsgNV07XG5cbiAgICBjb25zdCBuY3ggPSBub3JtYWxzW2lpICsgNl07XG4gICAgY29uc3QgbmN5ID0gbm9ybWFsc1tpaSArIDddO1xuICAgIGNvbnN0IG5jeiA9IG5vcm1hbHNbaWkgKyA4XTtcblxuICAgIC8vIGFkZCB0aGVtXG4gICAgbGV0IG54ID0gbmF4ICsgbmJ4ICsgbmN4O1xuICAgIGxldCBueSA9IG5heSArIG5ieSArIG5jeTtcbiAgICBsZXQgbnogPSBuYXogKyBuYnogKyBuY3o7XG5cbiAgICAvLyBub3JtYWxpemUgdGhlbVxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChueCAqIG54ICsgbnkgKiBueSArIG56ICogbnopO1xuXG4gICAgbnggLz0gbGVuZ3RoO1xuICAgIG55IC89IGxlbmd0aDtcbiAgICBueiAvPSBsZW5ndGg7XG5cbiAgICAvLyBjb3B5IHRoZW0gYmFjayBpblxuICAgIG5vcm1hbHNbaWkgKyAwXSA9IG54O1xuICAgIG5vcm1hbHNbaWkgKyAxXSA9IG55O1xuICAgIG5vcm1hbHNbaWkgKyAyXSA9IG56O1xuXG4gICAgbm9ybWFsc1tpaSArIDNdID0gbng7XG4gICAgbm9ybWFsc1tpaSArIDRdID0gbnk7XG4gICAgbm9ybWFsc1tpaSArIDVdID0gbno7XG5cbiAgICBub3JtYWxzW2lpICsgNl0gPSBueDtcbiAgICBub3JtYWxzW2lpICsgN10gPSBueTtcbiAgICBub3JtYWxzW2lpICsgOF0gPSBuejtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn1cblxuZnVuY3Rpb24gYXBwbHlGdW5jVG9WM0FycmF5KGFycmF5LCBtYXRyaXgsIGZuKSB7XG4gIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgY29uc3QgdG1wID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGxlbjsgaWkgKz0gMykge1xuICAgIGZuKG1hdHJpeCwgW2FycmF5W2lpXSwgYXJyYXlbaWkgKyAxXSwgYXJyYXlbaWkgKyAyXV0sIHRtcCk7XG4gICAgYXJyYXlbaWkgICAgXSA9IHRtcFswXTtcbiAgICBhcnJheVtpaSArIDFdID0gdG1wWzFdO1xuICAgIGFycmF5W2lpICsgMl0gPSB0bXBbMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9ybWFsJDEobWksIHYsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwgY3JlYXRlKCk7XG4gIGNvbnN0IHYwID0gdlswXTtcbiAgY29uc3QgdjEgPSB2WzFdO1xuICBjb25zdCB2MiA9IHZbMl07XG5cbiAgZHN0WzBdID0gdjAgKiBtaVswICogNCArIDBdICsgdjEgKiBtaVswICogNCArIDFdICsgdjIgKiBtaVswICogNCArIDJdO1xuICBkc3RbMV0gPSB2MCAqIG1pWzEgKiA0ICsgMF0gKyB2MSAqIG1pWzEgKiA0ICsgMV0gKyB2MiAqIG1pWzEgKiA0ICsgMl07XG4gIGRzdFsyXSA9IHYwICogbWlbMiAqIDQgKyAwXSArIHYxICogbWlbMiAqIDQgKyAxXSArIHYyICogbWlbMiAqIDQgKyAyXTtcblxuICByZXR1cm4gZHN0O1xufVxuXG4vKipcbiAqIFJlb3JpZW50cyBkaXJlY3Rpb25zIGJ5IHRoZSBnaXZlbiBtYXRyaXguLlxuICogQHBhcmFtIHsobnVtYmVyW118VHlwZWRBcnJheSl9IGFycmF5IFRoZSBhcnJheS4gQXNzdW1lcyB2YWx1ZSBmbG9hdHMgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG1hdHJpeCBBIG1hdHJpeCB0byBtdWx0aXBseSBieS5cbiAqIEByZXR1cm4geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gdGhlIHNhbWUgYXJyYXkgdGhhdCB3YXMgcGFzc2VkIGluXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiByZW9yaWVudERpcmVjdGlvbnMoYXJyYXksIG1hdHJpeCkge1xuICBhcHBseUZ1bmNUb1YzQXJyYXkoYXJyYXksIG1hdHJpeCwgdHJhbnNmb3JtRGlyZWN0aW9uKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFJlb3JpZW50cyBub3JtYWxzIGJ5IHRoZSBpbnZlcnNlLXRyYW5zcG9zZSBvZiB0aGUgZ2l2ZW5cbiAqIG1hdHJpeC4uXG4gKiBAcGFyYW0geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gYXJyYXkgVGhlIGFycmF5LiBBc3N1bWVzIHZhbHVlIGZsb2F0cyBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gbWF0cml4IEEgbWF0cml4IHRvIG11bHRpcGx5IGJ5LlxuICogQHJldHVybiB7KG51bWJlcltdfFR5cGVkQXJyYXkpfSB0aGUgc2FtZSBhcnJheSB0aGF0IHdhcyBwYXNzZWQgaW5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIHJlb3JpZW50Tm9ybWFscyhhcnJheSwgbWF0cml4KSB7XG4gIGFwcGx5RnVuY1RvVjNBcnJheShhcnJheSwgaW52ZXJzZShtYXRyaXgpLCB0cmFuc2Zvcm1Ob3JtYWwkMSk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBSZW9yaWVudHMgcG9zaXRpb25zIGJ5IHRoZSBnaXZlbiBtYXRyaXguIEluIG90aGVyIHdvcmRzLCBpdFxuICogbXVsdGlwbGllcyBlYWNoIHZlcnRleCBieSB0aGUgZ2l2ZW4gbWF0cml4LlxuICogQHBhcmFtIHsobnVtYmVyW118VHlwZWRBcnJheSl9IGFycmF5IFRoZSBhcnJheS4gQXNzdW1lcyB2YWx1ZSBmbG9hdHMgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsL200Lk1hdDR9IG1hdHJpeCBBIG1hdHJpeCB0byBtdWx0aXBseSBieS5cbiAqIEByZXR1cm4geyhudW1iZXJbXXxUeXBlZEFycmF5KX0gdGhlIHNhbWUgYXJyYXkgdGhhdCB3YXMgcGFzc2VkIGluXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiByZW9yaWVudFBvc2l0aW9ucyhhcnJheSwgbWF0cml4KSB7XG4gIGFwcGx5RnVuY1RvVjNBcnJheShhcnJheSwgbWF0cml4LCB0cmFuc2Zvcm1Qb2ludCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7KG51bWJlcltdfFR5cGVkQXJyYXkpfSBOYXRpdmVBcnJheU9yVHlwZWRBcnJheVxuICovXG5cbi8qKlxuICogUmVvcmllbnRzIGFycmF5cyBieSB0aGUgZ2l2ZW4gbWF0cml4LiBBc3N1bWVzIGFycmF5cyBoYXZlXG4gKiBuYW1lcyB0aGF0IGNvbnRhaW5zICdwb3MnIGNvdWxkIGJlIHJlb3JpZW50ZWQgYXMgcG9zaXRpb25zLFxuICogJ2Jpbm9ybScgb3IgJ3RhbicgYXMgZGlyZWN0aW9ucywgYW5kICdub3JtJyBhcyBub3JtYWxzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIE5hdGl2ZUFycmF5T3JUeXBlZEFycmF5Pn0gYXJyYXlzIFRoZSB2ZXJ0aWNlcyB0byByZW9yaWVudFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBtYXRyaXggbWF0cml4IHRvIHJlb3JpZW50IGJ5LlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIE5hdGl2ZUFycmF5T3JUeXBlZEFycmF5Pn0gc2FtZSBhcnJheXMgdGhhdCB3ZXJlIHBhc3NlZCBpbi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIHJlb3JpZW50VmVydGljZXMoYXJyYXlzLCBtYXRyaXgpIHtcbiAgT2JqZWN0LmtleXMoYXJyYXlzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBjb25zdCBhcnJheSA9IGFycmF5c1tuYW1lXTtcbiAgICBpZiAobmFtZS5pbmRleE9mKFwicG9zXCIpID49IDApIHtcbiAgICAgIHJlb3JpZW50UG9zaXRpb25zKGFycmF5LCBtYXRyaXgpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5pbmRleE9mKFwidGFuXCIpID49IDAgfHwgbmFtZS5pbmRleE9mKFwiYmlub3JtXCIpID49IDApIHtcbiAgICAgIHJlb3JpZW50RGlyZWN0aW9ucyhhcnJheSwgbWF0cml4KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcIm5vcm1cIikgPj0gMCkge1xuICAgICAgcmVvcmllbnROb3JtYWxzKGFycmF5LCBtYXRyaXgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhcnJheXM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBYWSBxdWFkIEJ1ZmZlckluZm9cbiAqXG4gKiBUaGUgZGVmYXVsdCB3aXRoIG5vIHBhcmFtZXRlcnMgd2lsbCByZXR1cm4gYSAyeDIgcXVhZCB3aXRoIHZhbHVlcyBmcm9tIC0xIHRvICsxLlxuICogSWYgeW91IHdhbnQgYSB1bml0IHF1YWQgd2l0aCB0aGF0IGdvZXMgZnJvbSAwIHRvIDEgeW91J2QgY2FsbCBpdCB3aXRoXG4gKlxuICogICAgIHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVYWVF1YWRCdWZmZXJJbmZvKGdsLCAxLCAwLjUsIDAuNSk7XG4gKlxuICogSWYgeW91IHdhbnQgYSB1bml0IHF1YWQgY2VudGVyZWQgYWJvdmUgMCwwIHlvdSdkIGNhbGwgaXQgd2l0aFxuICpcbiAqICAgICB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlWFlRdWFkQnVmZmVySW5mbyhnbCwgMSwgMCwgMC41KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZV0gdGhlIHNpemUgYWNyb3NzIHRoZSBxdWFkLiBEZWZhdWx0cyB0byAyIHdoaWNoIG1lYW5zIHZlcnRpY2VzIHdpbGwgZ28gZnJvbSAtMSB0byArMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4T2Zmc2V0XSB0aGUgYW1vdW50IHRvIG9mZnNldCB0aGUgcXVhZCBpbiBYXG4gKiBAcGFyYW0ge251bWJlcn0gW3lPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFlcbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IHRoZSBjcmVhdGVkIFhZIFF1YWQgQnVmZmVySW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVYWVF1YWRCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIFhZIHF1YWQgQnVmZmVyc1xuICpcbiAqIFRoZSBkZWZhdWx0IHdpdGggbm8gcGFyYW1ldGVycyB3aWxsIHJldHVybiBhIDJ4MiBxdWFkIHdpdGggdmFsdWVzIGZyb20gLTEgdG8gKzEuXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCB3aXRoIHRoYXQgZ29lcyBmcm9tIDAgdG8gMSB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8oZ2wsIDEsIDAuNSwgMC41KTtcbiAqXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCBjZW50ZXJlZCBhYm92ZSAwLDAgeW91J2QgY2FsbCBpdCB3aXRoXG4gKlxuICogICAgIHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVYWVF1YWRCdWZmZXJJbmZvKGdsLCAxLCAwLCAwLjUpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplXSB0aGUgc2l6ZSBhY3Jvc3MgdGhlIHF1YWQuIERlZmF1bHRzIHRvIDIgd2hpY2ggbWVhbnMgdmVydGljZXMgd2lsbCBnbyBmcm9tIC0xIHRvICsxXG4gKiBAcGFyYW0ge251bWJlcn0gW3hPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeU9mZnNldF0gdGhlIGFtb3VudCB0byBvZmZzZXQgdGhlIHF1YWQgaW4gWVxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gdGhlIGNyZWF0ZWQgWFkgUXVhZCBidWZmZXJzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVhZUXVhZEJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgWFkgcXVhZCB2ZXJ0aWNlc1xuICpcbiAqIFRoZSBkZWZhdWx0IHdpdGggbm8gcGFyYW1ldGVycyB3aWxsIHJldHVybiBhIDJ4MiBxdWFkIHdpdGggdmFsdWVzIGZyb20gLTEgdG8gKzEuXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCB3aXRoIHRoYXQgZ29lcyBmcm9tIDAgdG8gMSB5b3UnZCBjYWxsIGl0IHdpdGhcbiAqXG4gKiAgICAgdHdnbC5wcmltaXRpdmVzLmNyZWF0ZVhZUXVhZFZlcnRpY2VzKDEsIDAuNSwgMC41KTtcbiAqXG4gKiBJZiB5b3Ugd2FudCBhIHVuaXQgcXVhZCBjZW50ZXJlZCBhYm92ZSAwLDAgeW91J2QgY2FsbCBpdCB3aXRoXG4gKlxuICogICAgIHR3Z2wucHJpbWl0aXZlcy5jcmVhdGVYWVF1YWRWZXJ0aWNlcygxLCAwLCAwLjUpO1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZV0gdGhlIHNpemUgYWNyb3NzIHRoZSBxdWFkLiBEZWZhdWx0cyB0byAyIHdoaWNoIG1lYW5zIHZlcnRpY2VzIHdpbGwgZ28gZnJvbSAtMSB0byArMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4T2Zmc2V0XSB0aGUgYW1vdW50IHRvIG9mZnNldCB0aGUgcXVhZCBpbiBYXG4gKiBAcGFyYW0ge251bWJlcn0gW3lPZmZzZXRdIHRoZSBhbW91bnQgdG8gb2Zmc2V0IHRoZSBxdWFkIGluIFlcbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gdGhlIGNyZWF0ZWQgWFkgUXVhZCB2ZXJ0aWNlc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlWFlRdWFkVmVydGljZXMoc2l6ZSwgeE9mZnNldCwgeU9mZnNldCkge1xuICBzaXplID0gc2l6ZSB8fCAyO1xuICB4T2Zmc2V0ID0geE9mZnNldCB8fCAwO1xuICB5T2Zmc2V0ID0geU9mZnNldCB8fCAwO1xuICBzaXplICo9IDAuNTtcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgbnVtQ29tcG9uZW50czogMixcbiAgICAgIGRhdGE6IFtcbiAgICAgICAgeE9mZnNldCArIC0xICogc2l6ZSwgeU9mZnNldCArIC0xICogc2l6ZSxcbiAgICAgICAgeE9mZnNldCArICAxICogc2l6ZSwgeU9mZnNldCArIC0xICogc2l6ZSxcbiAgICAgICAgeE9mZnNldCArIC0xICogc2l6ZSwgeU9mZnNldCArICAxICogc2l6ZSxcbiAgICAgICAgeE9mZnNldCArICAxICogc2l6ZSwgeU9mZnNldCArICAxICogc2l6ZSxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBub3JtYWw6IFtcbiAgICAgIDAsIDAsIDEsXG4gICAgICAwLCAwLCAxLFxuICAgICAgMCwgMCwgMSxcbiAgICAgIDAsIDAsIDEsXG4gICAgXSxcbiAgICB0ZXhjb29yZDogW1xuICAgICAgMCwgMCxcbiAgICAgIDEsIDAsXG4gICAgICAwLCAxLFxuICAgICAgMSwgMSxcbiAgICBdLFxuICAgIGluZGljZXM6IFsgMCwgMSwgMiwgMiwgMSwgMyBdLFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgWFogcGxhbmUgQnVmZmVySW5mby5cbiAqXG4gKiBUaGUgY3JlYXRlZCBwbGFuZSBoYXMgcG9zaXRpb24sIG5vcm1hbCwgYW5kIHRleGNvb3JkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIFdpZHRoIG9mIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGhdIERlcHRoIG9mIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3ViZGl2aXNpb25zV2lkdGhdIE51bWJlciBvZiBzdGVwcyBhY3Jvc3MgdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHtudW1iZXJ9IFtzdWJkaXZpc2lvbnNEZXB0aF0gTnVtYmVyIG9mIHN0ZXBzIGRvd24gdGhlIHBsYW5lLiBEZWZhdWx0ID0gMVxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9tNC5NYXQ0fSBbbWF0cml4XSBBIG1hdHJpeCBieSB3aGljaCB0byBtdWx0aXBseSBhbGwgdGhlIHZlcnRpY2VzLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgcGxhbmUgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlUGxhbmVCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIFhaIHBsYW5lIGJ1ZmZlcnMuXG4gKlxuICogVGhlIGNyZWF0ZWQgcGxhbmUgaGFzIHBvc2l0aW9uLCBub3JtYWwsIGFuZCB0ZXhjb29yZCBkYXRhXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSBXaWR0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoXSBEZXB0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc1dpZHRoXSBOdW1iZXIgb2Ygc3RlcHMgYWNyb3NzIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3ViZGl2aXNpb25zRGVwdGhdIE51bWJlciBvZiBzdGVwcyBkb3duIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW21hdHJpeF0gQSBtYXRyaXggYnkgd2hpY2ggdG8gbXVsdGlwbHkgYWxsIHRoZSB2ZXJ0aWNlcy5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIHBsYW5lIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVBsYW5lQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBYWiBwbGFuZSB2ZXJ0aWNlcy5cbiAqXG4gKiBUaGUgY3JlYXRlZCBwbGFuZSBoYXMgcG9zaXRpb24sIG5vcm1hbCwgYW5kIHRleGNvb3JkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSBXaWR0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoXSBEZXB0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHQgPSAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3N1YmRpdmlzaW9uc1dpZHRoXSBOdW1iZXIgb2Ygc3RlcHMgYWNyb3NzIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3ViZGl2aXNpb25zRGVwdGhdIE51bWJlciBvZiBzdGVwcyBkb3duIHRoZSBwbGFuZS4gRGVmYXVsdCA9IDFcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wvbTQuTWF0NH0gW21hdHJpeF0gQSBtYXRyaXggYnkgd2hpY2ggdG8gbXVsdGlwbHkgYWxsIHRoZSB2ZXJ0aWNlcy5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgcGxhbmUgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVQbGFuZVZlcnRpY2VzKFxuICAgIHdpZHRoLFxuICAgIGRlcHRoLFxuICAgIHN1YmRpdmlzaW9uc1dpZHRoLFxuICAgIHN1YmRpdmlzaW9uc0RlcHRoLFxuICAgIG1hdHJpeCkge1xuICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gIGRlcHRoID0gZGVwdGggfHwgMTtcbiAgc3ViZGl2aXNpb25zV2lkdGggPSBzdWJkaXZpc2lvbnNXaWR0aCB8fCAxO1xuICBzdWJkaXZpc2lvbnNEZXB0aCA9IHN1YmRpdmlzaW9uc0RlcHRoIHx8IDE7XG4gIG1hdHJpeCA9IG1hdHJpeCB8fCBpZGVudGl0eSgpO1xuXG4gIGNvbnN0IG51bVZlcnRpY2VzID0gKHN1YmRpdmlzaW9uc1dpZHRoICsgMSkgKiAoc3ViZGl2aXNpb25zRGVwdGggKyAxKTtcbiAgY29uc3QgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IG5vcm1hbHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgY29uc3QgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG5cbiAgZm9yIChsZXQgeiA9IDA7IHogPD0gc3ViZGl2aXNpb25zRGVwdGg7IHorKykge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDw9IHN1YmRpdmlzaW9uc1dpZHRoOyB4KyspIHtcbiAgICAgIGNvbnN0IHUgPSB4IC8gc3ViZGl2aXNpb25zV2lkdGg7XG4gICAgICBjb25zdCB2ID0geiAvIHN1YmRpdmlzaW9uc0RlcHRoO1xuICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgICAgd2lkdGggKiB1IC0gd2lkdGggKiAwLjUsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBkZXB0aCAqIHYgLSBkZXB0aCAqIDAuNSk7XG4gICAgICBub3JtYWxzLnB1c2goMCwgMSwgMCk7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1LCB2KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBudW1WZXJ0c0Fjcm9zcyA9IHN1YmRpdmlzaW9uc1dpZHRoICsgMTtcbiAgY29uc3QgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoXG4gICAgICAzLCBzdWJkaXZpc2lvbnNXaWR0aCAqIHN1YmRpdmlzaW9uc0RlcHRoICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGZvciAobGV0IHogPSAwOyB6IDwgc3ViZGl2aXNpb25zRGVwdGg7IHorKykgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgc3ViZGl2aXNpb25zV2lkdGg7IHgrKykgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gTWFrZSB0cmlhbmdsZSAxIG9mIHF1YWQuXG4gICAgICBpbmRpY2VzLnB1c2goXG4gICAgICAgICAgKHogKyAwKSAqIG51bVZlcnRzQWNyb3NzICsgeCxcbiAgICAgICAgICAoeiArIDEpICogbnVtVmVydHNBY3Jvc3MgKyB4LFxuICAgICAgICAgICh6ICsgMCkgKiBudW1WZXJ0c0Fjcm9zcyArIHggKyAxKTtcblxuICAgICAgLy8gTWFrZSB0cmlhbmdsZSAyIG9mIHF1YWQuXG4gICAgICBpbmRpY2VzLnB1c2goXG4gICAgICAgICAgKHogKyAxKSAqIG51bVZlcnRzQWNyb3NzICsgeCxcbiAgICAgICAgICAoeiArIDEpICogbnVtVmVydHNBY3Jvc3MgKyB4ICsgMSxcbiAgICAgICAgICAoeiArIDApICogbnVtVmVydHNBY3Jvc3MgKyB4ICsgMSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXJyYXlzID0gcmVvcmllbnRWZXJ0aWNlcyh7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6IG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICB9LCBtYXRyaXgpO1xuICByZXR1cm4gYXJyYXlzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgc3BoZXJlIEJ1ZmZlckluZm8uXG4gKlxuICogVGhlIGNyZWF0ZWQgc3BoZXJlIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNBeGlzIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNIZWlnaHQgbnVtYmVyIG9mIHZlcnRpY2FsbHkgb24gdGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0IHRoZVxuICogICAgIHRvcCBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X2VuZExhdGl0dWRlSW5SYWRpYW5zXSBXaGVyZSB0byBlbmQgdGhlXG4gKiAgICAgYm90dG9tIG9mIHRoZSBzcGhlcmUuIERlZmF1bHQgPSBNYXRoLlBJLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfc3RhcnRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIHN0YXJ0XG4gKiAgICAgd3JhcHBpbmcgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMb25naXR1ZGVJblJhZGlhbnNdIHdoZXJlIHRvIGVuZFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAyICogTWF0aC5QSS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIHNwaGVyZSBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVTcGhlcmVCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHNwaGVyZSBidWZmZXJzLlxuICpcbiAqIFRoZSBjcmVhdGVkIHNwaGVyZSBoYXMgcG9zaXRpb24sIG5vcm1hbCwgYW5kIHRleGNvb3JkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zQXhpcyBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zSGVpZ2h0IG51bWJlciBvZiB2ZXJ0aWNhbGx5IG9uIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBzdGFydCB0aGVcbiAqICAgICB0b3Agb2YgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMYXRpdHVkZUluUmFkaWFuc10gV2hlcmUgdG8gZW5kIHRoZVxuICogICAgIGJvdHRvbSBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gTWF0aC5QSS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBzdGFydFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfZW5kTG9uZ2l0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBlbmRcbiAqICAgICB3cmFwcGluZyB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMiAqIE1hdGguUEkuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBzcGhlcmUgYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlU3BoZXJlQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBzcGhlcmUgdmVydGljZXMuXG4gKlxuICogVGhlIGNyZWF0ZWQgc3BoZXJlIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgdGV4Y29vcmQgZGF0YVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zQXhpcyBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zSGVpZ2h0IG51bWJlciBvZiB2ZXJ0aWNhbGx5IG9uIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zdGFydExhdGl0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBzdGFydCB0aGVcbiAqICAgICB0b3Agb2YgdGhlIHNwaGVyZS4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9lbmRMYXRpdHVkZUluUmFkaWFuc10gV2hlcmUgdG8gZW5kIHRoZVxuICogICAgIGJvdHRvbSBvZiB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gTWF0aC5QSS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBzdGFydFxuICogICAgIHdyYXBwaW5nIHRoZSBzcGhlcmUuIERlZmF1bHQgPSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfZW5kTG9uZ2l0dWRlSW5SYWRpYW5zXSB3aGVyZSB0byBlbmRcbiAqICAgICB3cmFwcGluZyB0aGUgc3BoZXJlLiBEZWZhdWx0ID0gMiAqIE1hdGguUEkuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHNwaGVyZSB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNwaGVyZVZlcnRpY2VzKFxuICAgIHJhZGl1cyxcbiAgICBzdWJkaXZpc2lvbnNBeGlzLFxuICAgIHN1YmRpdmlzaW9uc0hlaWdodCxcbiAgICBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucyxcbiAgICBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMsXG4gICAgb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zLFxuICAgIG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMpIHtcbiAgaWYgKHN1YmRpdmlzaW9uc0F4aXMgPD0gMCB8fCBzdWJkaXZpc2lvbnNIZWlnaHQgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3ViZGl2aXNpb25BeGlzIGFuZCBzdWJkaXZpc2lvbkhlaWdodCBtdXN0IGJlID4gMCcpO1xuICB9XG5cbiAgb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnMgPSBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucyB8fCAwO1xuICBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgPSBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgfHwgTWF0aC5QSTtcbiAgb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zID0gb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zIHx8IDA7XG4gIG9wdF9lbmRMb25naXR1ZGVJblJhZGlhbnMgPSBvcHRfZW5kTG9uZ2l0dWRlSW5SYWRpYW5zIHx8IChNYXRoLlBJICogMik7XG5cbiAgY29uc3QgbGF0UmFuZ2UgPSBvcHRfZW5kTGF0aXR1ZGVJblJhZGlhbnMgLSBvcHRfc3RhcnRMYXRpdHVkZUluUmFkaWFucztcbiAgY29uc3QgbG9uZ1JhbmdlID0gb3B0X2VuZExvbmdpdHVkZUluUmFkaWFucyAtIG9wdF9zdGFydExvbmdpdHVkZUluUmFkaWFucztcblxuICAvLyBXZSBhcmUgZ29pbmcgdG8gZ2VuZXJhdGUgb3VyIHNwaGVyZSBieSBpdGVyYXRpbmcgdGhyb3VnaCBpdHNcbiAgLy8gc3BoZXJpY2FsIGNvb3JkaW5hdGVzIGFuZCBnZW5lcmF0aW5nIDIgdHJpYW5nbGVzIGZvciBlYWNoIHF1YWQgb24gYVxuICAvLyByaW5nIG9mIHRoZSBzcGhlcmUuXG4gIGNvbnN0IG51bVZlcnRpY2VzID0gKHN1YmRpdmlzaW9uc0F4aXMgKyAxKSAqIChzdWJkaXZpc2lvbnNIZWlnaHQgKyAxKTtcbiAgY29uc3QgcG9zaXRpb25zID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IG5vcm1hbHMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCB0ZXhjb29yZHMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDIsIG51bVZlcnRpY2VzKTtcblxuICAvLyBHZW5lcmF0ZSB0aGUgaW5kaXZpZHVhbCB2ZXJ0aWNlcyBpbiBvdXIgdmVydGV4IGJ1ZmZlci5cbiAgZm9yIChsZXQgeSA9IDA7IHkgPD0gc3ViZGl2aXNpb25zSGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSBzdWJkaXZpc2lvbnNBeGlzOyB4KyspIHtcbiAgICAgIC8vIEdlbmVyYXRlIGEgdmVydGV4IGJhc2VkIG9uIGl0cyBzcGhlcmljYWwgY29vcmRpbmF0ZXNcbiAgICAgIGNvbnN0IHUgPSB4IC8gc3ViZGl2aXNpb25zQXhpcztcbiAgICAgIGNvbnN0IHYgPSB5IC8gc3ViZGl2aXNpb25zSGVpZ2h0O1xuICAgICAgY29uc3QgdGhldGEgPSBsb25nUmFuZ2UgKiB1ICsgb3B0X3N0YXJ0TG9uZ2l0dWRlSW5SYWRpYW5zO1xuICAgICAgY29uc3QgcGhpID0gbGF0UmFuZ2UgKiB2ICsgb3B0X3N0YXJ0TGF0aXR1ZGVJblJhZGlhbnM7XG4gICAgICBjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgIGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgY29uc3Qgc2luUGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICAgIGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgICBjb25zdCB1eCA9IGNvc1RoZXRhICogc2luUGhpO1xuICAgICAgY29uc3QgdXkgPSBjb3NQaGk7XG4gICAgICBjb25zdCB1eiA9IHNpblRoZXRhICogc2luUGhpO1xuICAgICAgcG9zaXRpb25zLnB1c2gocmFkaXVzICogdXgsIHJhZGl1cyAqIHV5LCByYWRpdXMgKiB1eik7XG4gICAgICBub3JtYWxzLnB1c2godXgsIHV5LCB1eik7XG4gICAgICB0ZXhjb29yZHMucHVzaCgxIC0gdSwgdik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbnVtVmVydHNBcm91bmQgPSBzdWJkaXZpc2lvbnNBeGlzICsgMTtcbiAgY29uc3QgaW5kaWNlcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgc3ViZGl2aXNpb25zQXhpcyAqIHN1YmRpdmlzaW9uc0hlaWdodCAqIDIsIFVpbnQxNkFycmF5KTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBzdWJkaXZpc2lvbnNBeGlzOyB4KyspIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHN1YmRpdmlzaW9uc0hlaWdodDsgeSsrKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBNYWtlIHRyaWFuZ2xlIDEgb2YgcXVhZC5cbiAgICAgIGluZGljZXMucHVzaChcbiAgICAgICAgICAoeSArIDApICogbnVtVmVydHNBcm91bmQgKyB4LFxuICAgICAgICAgICh5ICsgMCkgKiBudW1WZXJ0c0Fyb3VuZCArIHggKyAxLFxuICAgICAgICAgICh5ICsgMSkgKiBudW1WZXJ0c0Fyb3VuZCArIHgpO1xuXG4gICAgICAvLyBNYWtlIHRyaWFuZ2xlIDIgb2YgcXVhZC5cbiAgICAgIGluZGljZXMucHVzaChcbiAgICAgICAgICAoeSArIDEpICogbnVtVmVydHNBcm91bmQgKyB4LFxuICAgICAgICAgICh5ICsgMCkgKiBudW1WZXJ0c0Fyb3VuZCArIHggKyAxLFxuICAgICAgICAgICh5ICsgMSkgKiBudW1WZXJ0c0Fyb3VuZCArIHggKyAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiBub3JtYWxzLFxuICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gICAgaW5kaWNlczogaW5kaWNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBBcnJheSBvZiB0aGUgaW5kaWNlcyBvZiBjb3JuZXJzIG9mIGVhY2ggZmFjZSBvZiBhIGN1YmUuXG4gKiBAdHlwZSB7QXJyYXkuPG51bWJlcltdPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IENVQkVfRkFDRV9JTkRJQ0VTID0gW1xuICBbMywgNywgNSwgMV0sICAvLyByaWdodFxuICBbNiwgMiwgMCwgNF0sICAvLyBsZWZ0XG4gIFs2LCA3LCAzLCAyXSwgIC8vID8/XG4gIFswLCAxLCA1LCA0XSwgIC8vID8/XG4gIFs3LCA2LCA0LCA1XSwgIC8vIGZyb250XG4gIFsyLCAzLCAxLCAwXSwgIC8vIGJhY2tcbl07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEJ1ZmZlckluZm8gZm9yIGEgY3ViZS5cbiAqXG4gKiBUaGUgY3ViZSBpcyBjcmVhdGVkIGFyb3VuZCB0aGUgb3JpZ2luLiAoLXNpemUgLyAyLCBzaXplIC8gMikuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHdpZHRoLCBoZWlnaHQgYW5kIGRlcHRoIG9mIHRoZSBjdWJlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3ViZUJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGJ1ZmZlcnMgYW5kIGluZGljZXMgZm9yIGEgY3ViZS5cbiAqXG4gKiBUaGUgY3ViZSBpcyBjcmVhdGVkIGFyb3VuZCB0aGUgb3JpZ2luLiAoLXNpemUgLyAyLCBzaXplIC8gMikuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIHdpZHRoLCBoZWlnaHQgYW5kIGRlcHRoIG9mIHRoZSBjdWJlLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFdlYkdMQnVmZmVyPn0gVGhlIGNyZWF0ZWQgYnVmZmVycy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3ViZUJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIHZlcnRpY2VzIGFuZCBpbmRpY2VzIGZvciBhIGN1YmUuXG4gKlxuICogVGhlIGN1YmUgaXMgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gKC1zaXplIC8gMiwgc2l6ZSAvIDIpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZV0gd2lkdGgsIGhlaWdodCBhbmQgZGVwdGggb2YgdGhlIGN1YmUuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3ViZVZlcnRpY2VzKHNpemUpIHtcbiAgc2l6ZSA9IHNpemUgfHwgMTtcbiAgY29uc3QgayA9IHNpemUgLyAyO1xuXG4gIGNvbnN0IGNvcm5lclZlcnRpY2VzID0gW1xuICAgIFstaywgLWssIC1rXSxcbiAgICBbK2ssIC1rLCAta10sXG4gICAgWy1rLCAraywgLWtdLFxuICAgIFsraywgK2ssIC1rXSxcbiAgICBbLWssIC1rLCAra10sXG4gICAgWytrLCAtaywgK2tdLFxuICAgIFstaywgK2ssICtrXSxcbiAgICBbK2ssICtrLCAra10sXG4gIF07XG5cbiAgY29uc3QgZmFjZU5vcm1hbHMgPSBbXG4gICAgWysxLCArMCwgKzBdLFxuICAgIFstMSwgKzAsICswXSxcbiAgICBbKzAsICsxLCArMF0sXG4gICAgWyswLCAtMSwgKzBdLFxuICAgIFsrMCwgKzAsICsxXSxcbiAgICBbKzAsICswLCAtMV0sXG4gIF07XG5cbiAgY29uc3QgdXZDb29yZHMgPSBbXG4gICAgWzEsIDBdLFxuICAgIFswLCAwXSxcbiAgICBbMCwgMV0sXG4gICAgWzEsIDFdLFxuICBdO1xuXG4gIGNvbnN0IG51bVZlcnRpY2VzID0gNiAqIDQ7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCBub3JtYWxzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgY29uc3QgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyICwgbnVtVmVydGljZXMpO1xuICBjb25zdCBpbmRpY2VzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIDYgKiAyLCBVaW50MTZBcnJheSk7XG5cbiAgZm9yIChsZXQgZiA9IDA7IGYgPCA2OyArK2YpIHtcbiAgICBjb25zdCBmYWNlSW5kaWNlcyA9IENVQkVfRkFDRV9JTkRJQ0VTW2ZdO1xuICAgIGZvciAobGV0IHYgPSAwOyB2IDwgNDsgKyt2KSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGNvcm5lclZlcnRpY2VzW2ZhY2VJbmRpY2VzW3ZdXTtcbiAgICAgIGNvbnN0IG5vcm1hbCA9IGZhY2VOb3JtYWxzW2ZdO1xuICAgICAgY29uc3QgdXYgPSB1dkNvb3Jkc1t2XTtcblxuICAgICAgLy8gRWFjaCBmYWNlIG5lZWRzIGFsbCBmb3VyIHZlcnRpY2VzIGJlY2F1c2UgdGhlIG5vcm1hbHMgYW5kIHRleHR1cmVcbiAgICAgIC8vIGNvb3JkaW5hdGVzIGFyZSBub3QgYWxsIHRoZSBzYW1lLlxuICAgICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICAgICAgbm9ybWFscy5wdXNoKG5vcm1hbCk7XG4gICAgICB0ZXhjb29yZHMucHVzaCh1dik7XG5cbiAgICB9XG4gICAgLy8gVHdvIHRyaWFuZ2xlcyBtYWtlIGEgc3F1YXJlIGZhY2UuXG4gICAgY29uc3Qgb2Zmc2V0ID0gNCAqIGY7XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCArIDAsIG9mZnNldCArIDEsIG9mZnNldCArIDIpO1xuICAgIGluZGljZXMucHVzaChvZmZzZXQgKyAwLCBvZmZzZXQgKyAyLCBvZmZzZXQgKyAzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6IG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBCdWZmZXJJbmZvIGZvciBhIHRydW5jYXRlZCBjb25lLCB3aGljaCBpcyBsaWtlIGEgY3lsaW5kZXJcbiAqIGV4Y2VwdCB0aGF0IGl0IGhhcyBkaWZmZXJlbnQgdG9wIGFuZCBib3R0b20gcmFkaWkuIEEgdHJ1bmNhdGVkIGNvbmVcbiAqIGNhbiBhbHNvIGJlIHVzZWQgdG8gY3JlYXRlIGN5bGluZGVycyBhbmQgcmVndWxhciBjb25lcy4gVGhlXG4gKiB0cnVuY2F0ZWQgY29uZSB3aWxsIGJlIGNyZWF0ZWQgY2VudGVyZWQgYWJvdXQgdGhlIG9yaWdpbiwgd2l0aCB0aGVcbiAqIHkgYXhpcyBhcyBpdHMgdmVydGljYWwgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21SYWRpdXMgQm90dG9tIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BSYWRpdXMgVG9wIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgZG93biB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF90b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF9ib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIGNvbmUgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYnVmZmVycyBmb3IgYSB0cnVuY2F0ZWQgY29uZSwgd2hpY2ggaXMgbGlrZSBhIGN5bGluZGVyXG4gKiBleGNlcHQgdGhhdCBpdCBoYXMgZGlmZmVyZW50IHRvcCBhbmQgYm90dG9tIHJhZGlpLiBBIHRydW5jYXRlZCBjb25lXG4gKiBjYW4gYWxzbyBiZSB1c2VkIHRvIGNyZWF0ZSBjeWxpbmRlcnMgYW5kIHJlZ3VsYXIgY29uZXMuIFRoZVxuICogdHJ1bmNhdGVkIGNvbmUgd2lsbCBiZSBjcmVhdGVkIGNlbnRlcmVkIGFib3V0IHRoZSBvcmlnaW4sIHdpdGggdGhlXG4gKiB5IGF4aXMgYXMgaXRzIHZlcnRpY2FsIGF4aXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tUmFkaXVzIEJvdHRvbSByYWRpdXMgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wUmFkaXVzIFRvcCByYWRpdXMgb2YgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZVxuICogICAgIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRfdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRfYm90dG9tQ2FwXSBDcmVhdGUgYm90dG9tIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBjb25lIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHZlcnRpY2VzIGZvciBhIHRydW5jYXRlZCBjb25lLCB3aGljaCBpcyBsaWtlIGEgY3lsaW5kZXJcbiAqIGV4Y2VwdCB0aGF0IGl0IGhhcyBkaWZmZXJlbnQgdG9wIGFuZCBib3R0b20gcmFkaWkuIEEgdHJ1bmNhdGVkIGNvbmVcbiAqIGNhbiBhbHNvIGJlIHVzZWQgdG8gY3JlYXRlIGN5bGluZGVycyBhbmQgcmVndWxhciBjb25lcy4gVGhlXG4gKiB0cnVuY2F0ZWQgY29uZSB3aWxsIGJlIGNyZWF0ZWQgY2VudGVyZWQgYWJvdXQgdGhlIG9yaWdpbiwgd2l0aCB0aGVcbiAqIHkgYXhpcyBhcyBpdHMgdmVydGljYWwgYXhpcy4gLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21SYWRpdXMgQm90dG9tIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BSYWRpdXMgVG9wIHJhZGl1cyBvZiB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRydW5jYXRlZCBjb25lLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlXG4gKiAgICAgdHJ1bmNhdGVkIGNvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgZG93biB0aGVcbiAqICAgICB0cnVuY2F0ZWQgY29uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF90b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdF9ib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgY29uZSB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyhcbiAgICBib3R0b21SYWRpdXMsXG4gICAgdG9wUmFkaXVzLFxuICAgIGhlaWdodCxcbiAgICByYWRpYWxTdWJkaXZpc2lvbnMsXG4gICAgdmVydGljYWxTdWJkaXZpc2lvbnMsXG4gICAgb3B0X3RvcENhcCxcbiAgICBvcHRfYm90dG9tQ2FwKSB7XG4gIGlmIChyYWRpYWxTdWJkaXZpc2lvbnMgPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpYWxTdWJkaXZpc2lvbnMgbXVzdCBiZSAzIG9yIGdyZWF0ZXInKTtcbiAgfVxuXG4gIGlmICh2ZXJ0aWNhbFN1YmRpdmlzaW9ucyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRpY2FsU3ViZGl2aXNpb25zIG11c3QgYmUgMSBvciBncmVhdGVyJyk7XG4gIH1cblxuICBjb25zdCB0b3BDYXAgPSAob3B0X3RvcENhcCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRfdG9wQ2FwO1xuICBjb25zdCBib3R0b21DYXAgPSAob3B0X2JvdHRvbUNhcCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRfYm90dG9tQ2FwO1xuXG4gIGNvbnN0IGV4dHJhID0gKHRvcENhcCA/IDIgOiAwKSArIChib3R0b21DYXAgPyAyIDogMCk7XG5cbiAgY29uc3QgbnVtVmVydGljZXMgPSAocmFkaWFsU3ViZGl2aXNpb25zICsgMSkgKiAodmVydGljYWxTdWJkaXZpc2lvbnMgKyAxICsgZXh0cmEpO1xuICBjb25zdCBwb3NpdGlvbnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgY29uc3Qgbm9ybWFscyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IHRleGNvb3JkcyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgbnVtVmVydGljZXMpO1xuICBjb25zdCBpbmRpY2VzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIHJhZGlhbFN1YmRpdmlzaW9ucyAqICh2ZXJ0aWNhbFN1YmRpdmlzaW9ucyArIGV4dHJhIC8gMikgKiAyLCBVaW50MTZBcnJheSk7XG5cbiAgY29uc3QgdmVydHNBcm91bmRFZGdlID0gcmFkaWFsU3ViZGl2aXNpb25zICsgMTtcblxuICAvLyBUaGUgc2xhbnQgb2YgdGhlIGNvbmUgaXMgY29uc3RhbnQgYWNyb3NzIGl0cyBzdXJmYWNlXG4gIGNvbnN0IHNsYW50ID0gTWF0aC5hdGFuMihib3R0b21SYWRpdXMgLSB0b3BSYWRpdXMsIGhlaWdodCk7XG4gIGNvbnN0IGNvc1NsYW50ID0gTWF0aC5jb3Moc2xhbnQpO1xuICBjb25zdCBzaW5TbGFudCA9IE1hdGguc2luKHNsYW50KTtcblxuICBjb25zdCBzdGFydCA9IHRvcENhcCA/IC0yIDogMDtcbiAgY29uc3QgZW5kID0gdmVydGljYWxTdWJkaXZpc2lvbnMgKyAoYm90dG9tQ2FwID8gMiA6IDApO1xuXG4gIGZvciAobGV0IHl5ID0gc3RhcnQ7IHl5IDw9IGVuZDsgKyt5eSkge1xuICAgIGxldCB2ID0geXkgLyB2ZXJ0aWNhbFN1YmRpdmlzaW9ucztcbiAgICBsZXQgeSA9IGhlaWdodCAqIHY7XG4gICAgbGV0IHJpbmdSYWRpdXM7XG4gICAgaWYgKHl5IDwgMCkge1xuICAgICAgeSA9IDA7XG4gICAgICB2ID0gMTtcbiAgICAgIHJpbmdSYWRpdXMgPSBib3R0b21SYWRpdXM7XG4gICAgfSBlbHNlIGlmICh5eSA+IHZlcnRpY2FsU3ViZGl2aXNpb25zKSB7XG4gICAgICB5ID0gaGVpZ2h0O1xuICAgICAgdiA9IDE7XG4gICAgICByaW5nUmFkaXVzID0gdG9wUmFkaXVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByaW5nUmFkaXVzID0gYm90dG9tUmFkaXVzICtcbiAgICAgICAgKHRvcFJhZGl1cyAtIGJvdHRvbVJhZGl1cykgKiAoeXkgLyB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyk7XG4gICAgfVxuICAgIGlmICh5eSA9PT0gLTIgfHwgeXkgPT09IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgMikge1xuICAgICAgcmluZ1JhZGl1cyA9IDA7XG4gICAgICB2ID0gMDtcbiAgICB9XG4gICAgeSAtPSBoZWlnaHQgLyAyO1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCB2ZXJ0c0Fyb3VuZEVkZ2U7ICsraWkpIHtcbiAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGlpICogTWF0aC5QSSAqIDIgLyByYWRpYWxTdWJkaXZpc2lvbnMpO1xuICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoaWkgKiBNYXRoLlBJICogMiAvIHJhZGlhbFN1YmRpdmlzaW9ucyk7XG4gICAgICBwb3NpdGlvbnMucHVzaChzaW4gKiByaW5nUmFkaXVzLCB5LCBjb3MgKiByaW5nUmFkaXVzKTtcbiAgICAgIGlmICh5eSA8IDApIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKDAsIC0xLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoeXkgPiB2ZXJ0aWNhbFN1YmRpdmlzaW9ucykge1xuICAgICAgICBub3JtYWxzLnB1c2goMCwgMSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHJpbmdSYWRpdXMgPT09IDAuMCkge1xuICAgICAgICBub3JtYWxzLnB1c2goMCwgMCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxzLnB1c2goc2luICogY29zU2xhbnQsIHNpblNsYW50LCBjb3MgKiBjb3NTbGFudCk7XG4gICAgICB9XG4gICAgICB0ZXhjb29yZHMucHVzaCgoaWkgLyByYWRpYWxTdWJkaXZpc2lvbnMpLCAxIC0gdik7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgeXkgPSAwOyB5eSA8IHZlcnRpY2FsU3ViZGl2aXNpb25zICsgZXh0cmE7ICsreXkpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoeXkgPT09IDEgJiYgdG9wQ2FwIHx8IHl5ID09PSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyArIGV4dHJhIC0gMiAmJiBib3R0b21DYXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcmFkaWFsU3ViZGl2aXNpb25zOyArK2lpKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpbmRpY2VzLnB1c2godmVydHNBcm91bmRFZGdlICogKHl5ICsgMCkgKyAwICsgaWksXG4gICAgICAgICAgICAgICAgICAgdmVydHNBcm91bmRFZGdlICogKHl5ICsgMCkgKyAxICsgaWksXG4gICAgICAgICAgICAgICAgICAgdmVydHNBcm91bmRFZGdlICogKHl5ICsgMSkgKyAxICsgaWkpO1xuICAgICAgaW5kaWNlcy5wdXNoKHZlcnRzQXJvdW5kRWRnZSAqICh5eSArIDApICsgMCArIGlpLFxuICAgICAgICAgICAgICAgICAgIHZlcnRzQXJvdW5kRWRnZSAqICh5eSArIDEpICsgMSArIGlpLFxuICAgICAgICAgICAgICAgICAgIHZlcnRzQXJvdW5kRWRnZSAqICh5eSArIDEpICsgMCArIGlpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiBub3JtYWxzLFxuICAgIHRleGNvb3JkOiB0ZXhjb29yZHMsXG4gICAgaW5kaWNlczogaW5kaWNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHBhbmRzIFJMRSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcltdfSBybGVEYXRhIGRhdGEgaW4gZm9ybWF0IG9mIHJ1bi1sZW5ndGgsIHgsIHksIHosIHJ1bi1sZW5ndGgsIHgsIHksIHpcbiAqIEBwYXJhbSB7bnVtYmVyW119IFtwYWRkaW5nXSB2YWx1ZSB0byBhZGQgZWFjaCBlbnRyeSB3aXRoLlxuICogQHJldHVybiB7bnVtYmVyW119IHRoZSBleHBhbmRlZCBybGVEYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHBhbmRSTEVEYXRhKHJsZURhdGEsIHBhZGRpbmcpIHtcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgW107XG4gIGNvbnN0IGRhdGEgPSBbXTtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHJsZURhdGEubGVuZ3RoOyBpaSArPSA0KSB7XG4gICAgY29uc3QgcnVuTGVuZ3RoID0gcmxlRGF0YVtpaV07XG4gICAgY29uc3QgZWxlbWVudCA9IHJsZURhdGEuc2xpY2UoaWkgKyAxLCBpaSArIDQpO1xuICAgIGVsZW1lbnQucHVzaC5hcHBseShlbGVtZW50LCBwYWRkaW5nKTtcbiAgICBmb3IgKGxldCBqaiA9IDA7IGpqIDwgcnVuTGVuZ3RoOyArK2pqKSB7XG4gICAgICBkYXRhLnB1c2guYXBwbHkoZGF0YSwgZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIEJ1ZmZlckluZm8uXG4gKiBBbiAnRicgaXMgdXNlZnVsIGJlY2F1c2UgeW91IGNhbiBlYXNpbHkgdGVsbCB3aGljaCB3YXkgaXQgaXMgb3JpZW50ZWQuXG4gKiBUaGUgY3JlYXRlZCAnRicgaGFzIHBvc2l0aW9uLCBub3JtYWwsIHRleGNvb3JkLCBhbmQgY29sb3IgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZTNERkJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIGJ1ZmZlcnMuXG4gKiBBbiAnRicgaXMgdXNlZnVsIGJlY2F1c2UgeW91IGNhbiBlYXNpbHkgdGVsbCB3aGljaCB3YXkgaXQgaXMgb3JpZW50ZWQuXG4gKiBUaGUgY3JlYXRlZCAnRicgaGFzIHBvc2l0aW9uLCBub3JtYWwsIHRleGNvb3JkLCBhbmQgY29sb3IgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZTNERkJ1ZmZlcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgM0QgJ0YnIHZlcnRpY2VzLlxuICogQW4gJ0YnIGlzIHVzZWZ1bCBiZWNhdXNlIHlvdSBjYW4gZWFzaWx5IHRlbGwgd2hpY2ggd2F5IGl0IGlzIG9yaWVudGVkLlxuICogVGhlIGNyZWF0ZWQgJ0YnIGhhcyBwb3NpdGlvbiwgbm9ybWFsLCB0ZXhjb29yZCwgYW5kIGNvbG9yIGFycmF5cy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlM0RGVmVydGljZXMoKSB7XG5cbiAgY29uc3QgcG9zaXRpb25zID0gW1xuICAgIC8vIGxlZnQgY29sdW1uIGZyb250XG4gICAgMCwgICAwLCAgMCxcbiAgICAwLCAxNTAsICAwLFxuICAgIDMwLCAgIDAsICAwLFxuICAgIDAsIDE1MCwgIDAsXG4gICAgMzAsIDE1MCwgIDAsXG4gICAgMzAsICAgMCwgIDAsXG5cbiAgICAvLyB0b3AgcnVuZyBmcm9udFxuICAgIDMwLCAgIDAsICAwLFxuICAgIDMwLCAgMzAsICAwLFxuICAgIDEwMCwgICAwLCAgMCxcbiAgICAzMCwgIDMwLCAgMCxcbiAgICAxMDAsICAzMCwgIDAsXG4gICAgMTAwLCAgIDAsICAwLFxuXG4gICAgLy8gbWlkZGxlIHJ1bmcgZnJvbnRcbiAgICAzMCwgIDYwLCAgMCxcbiAgICAzMCwgIDkwLCAgMCxcbiAgICA2NywgIDYwLCAgMCxcbiAgICAzMCwgIDkwLCAgMCxcbiAgICA2NywgIDkwLCAgMCxcbiAgICA2NywgIDYwLCAgMCxcblxuICAgIC8vIGxlZnQgY29sdW1uIGJhY2tcbiAgICAgIDAsICAgMCwgIDMwLFxuICAgICAzMCwgICAwLCAgMzAsXG4gICAgICAwLCAxNTAsICAzMCxcbiAgICAgIDAsIDE1MCwgIDMwLFxuICAgICAzMCwgICAwLCAgMzAsXG4gICAgIDMwLCAxNTAsICAzMCxcblxuICAgIC8vIHRvcCBydW5nIGJhY2tcbiAgICAgMzAsICAgMCwgIDMwLFxuICAgIDEwMCwgICAwLCAgMzAsXG4gICAgIDMwLCAgMzAsICAzMCxcbiAgICAgMzAsICAzMCwgIDMwLFxuICAgIDEwMCwgICAwLCAgMzAsXG4gICAgMTAwLCAgMzAsICAzMCxcblxuICAgIC8vIG1pZGRsZSBydW5nIGJhY2tcbiAgICAgMzAsICA2MCwgIDMwLFxuICAgICA2NywgIDYwLCAgMzAsXG4gICAgIDMwLCAgOTAsICAzMCxcbiAgICAgMzAsICA5MCwgIDMwLFxuICAgICA2NywgIDYwLCAgMzAsXG4gICAgIDY3LCAgOTAsICAzMCxcblxuICAgIC8vIHRvcFxuICAgICAgMCwgICAwLCAgIDAsXG4gICAgMTAwLCAgIDAsICAgMCxcbiAgICAxMDAsICAgMCwgIDMwLFxuICAgICAgMCwgICAwLCAgIDAsXG4gICAgMTAwLCAgIDAsICAzMCxcbiAgICAgIDAsICAgMCwgIDMwLFxuXG4gICAgLy8gdG9wIHJ1bmcgZnJvbnRcbiAgICAxMDAsICAgMCwgICAwLFxuICAgIDEwMCwgIDMwLCAgIDAsXG4gICAgMTAwLCAgMzAsICAzMCxcbiAgICAxMDAsICAgMCwgICAwLFxuICAgIDEwMCwgIDMwLCAgMzAsXG4gICAgMTAwLCAgIDAsICAzMCxcblxuICAgIC8vIHVuZGVyIHRvcCBydW5nXG4gICAgMzAsICAgMzAsICAgMCxcbiAgICAzMCwgICAzMCwgIDMwLFxuICAgIDEwMCwgIDMwLCAgMzAsXG4gICAgMzAsICAgMzAsICAgMCxcbiAgICAxMDAsICAzMCwgIDMwLFxuICAgIDEwMCwgIDMwLCAgIDAsXG5cbiAgICAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgICAzMCwgICAzMCwgICAwLFxuICAgIDMwLCAgIDYwLCAgMzAsXG4gICAgMzAsICAgMzAsICAzMCxcbiAgICAzMCwgICAzMCwgICAwLFxuICAgIDMwLCAgIDYwLCAgIDAsXG4gICAgMzAsICAgNjAsICAzMCxcblxuICAgIC8vIHRvcCBvZiBtaWRkbGUgcnVuZ1xuICAgIDMwLCAgIDYwLCAgIDAsXG4gICAgNjcsICAgNjAsICAzMCxcbiAgICAzMCwgICA2MCwgIDMwLFxuICAgIDMwLCAgIDYwLCAgIDAsXG4gICAgNjcsICAgNjAsICAgMCxcbiAgICA2NywgICA2MCwgIDMwLFxuXG4gICAgLy8gZnJvbnQgb2YgbWlkZGxlIHJ1bmdcbiAgICA2NywgICA2MCwgICAwLFxuICAgIDY3LCAgIDkwLCAgMzAsXG4gICAgNjcsICAgNjAsICAzMCxcbiAgICA2NywgICA2MCwgICAwLFxuICAgIDY3LCAgIDkwLCAgIDAsXG4gICAgNjcsICAgOTAsICAzMCxcblxuICAgIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgICAzMCwgICA5MCwgICAwLFxuICAgIDMwLCAgIDkwLCAgMzAsXG4gICAgNjcsICAgOTAsICAzMCxcbiAgICAzMCwgICA5MCwgICAwLFxuICAgIDY3LCAgIDkwLCAgMzAsXG4gICAgNjcsICAgOTAsICAgMCxcblxuICAgIC8vIGZyb250IG9mIGJvdHRvbVxuICAgIDMwLCAgIDkwLCAgIDAsXG4gICAgMzAsICAxNTAsICAzMCxcbiAgICAzMCwgICA5MCwgIDMwLFxuICAgIDMwLCAgIDkwLCAgIDAsXG4gICAgMzAsICAxNTAsICAgMCxcbiAgICAzMCwgIDE1MCwgIDMwLFxuXG4gICAgLy8gYm90dG9tXG4gICAgMCwgICAxNTAsICAgMCxcbiAgICAwLCAgIDE1MCwgIDMwLFxuICAgIDMwLCAgMTUwLCAgMzAsXG4gICAgMCwgICAxNTAsICAgMCxcbiAgICAzMCwgIDE1MCwgIDMwLFxuICAgIDMwLCAgMTUwLCAgIDAsXG5cbiAgICAvLyBsZWZ0IHNpZGVcbiAgICAwLCAgIDAsICAgMCxcbiAgICAwLCAgIDAsICAzMCxcbiAgICAwLCAxNTAsICAzMCxcbiAgICAwLCAgIDAsICAgMCxcbiAgICAwLCAxNTAsICAzMCxcbiAgICAwLCAxNTAsICAgMCxcbiAgXTtcblxuICBjb25zdCB0ZXhjb29yZHMgPSBbXG4gICAgLy8gbGVmdCBjb2x1bW4gZnJvbnRcbiAgICAwLjIyLCAwLjE5LFxuICAgIDAuMjIsIDAuNzksXG4gICAgMC4zNCwgMC4xOSxcbiAgICAwLjIyLCAwLjc5LFxuICAgIDAuMzQsIDAuNzksXG4gICAgMC4zNCwgMC4xOSxcblxuICAgIC8vIHRvcCBydW5nIGZyb250XG4gICAgMC4zNCwgMC4xOSxcbiAgICAwLjM0LCAwLjMxLFxuICAgIDAuNjIsIDAuMTksXG4gICAgMC4zNCwgMC4zMSxcbiAgICAwLjYyLCAwLjMxLFxuICAgIDAuNjIsIDAuMTksXG5cbiAgICAvLyBtaWRkbGUgcnVuZyBmcm9udFxuICAgIDAuMzQsIDAuNDMsXG4gICAgMC4zNCwgMC41NSxcbiAgICAwLjQ5LCAwLjQzLFxuICAgIDAuMzQsIDAuNTUsXG4gICAgMC40OSwgMC41NSxcbiAgICAwLjQ5LCAwLjQzLFxuXG4gICAgLy8gbGVmdCBjb2x1bW4gYmFja1xuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAwLCAxLFxuICAgIDAsIDEsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuXG4gICAgLy8gdG9wIHJ1bmcgYmFja1xuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAwLCAxLFxuICAgIDAsIDEsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuXG4gICAgLy8gbWlkZGxlIHJ1bmcgYmFja1xuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAwLCAxLFxuICAgIDAsIDEsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuXG4gICAgLy8gdG9wXG4gICAgMCwgMCxcbiAgICAxLCAwLFxuICAgIDEsIDEsXG4gICAgMCwgMCxcbiAgICAxLCAxLFxuICAgIDAsIDEsXG5cbiAgICAvLyB0b3AgcnVuZyBmcm9udFxuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuICAgIDAsIDAsXG4gICAgMSwgMSxcbiAgICAwLCAxLFxuXG4gICAgLy8gdW5kZXIgdG9wIHJ1bmdcbiAgICAwLCAwLFxuICAgIDAsIDEsXG4gICAgMSwgMSxcbiAgICAwLCAwLFxuICAgIDEsIDEsXG4gICAgMSwgMCxcblxuICAgIC8vIGJldHdlZW4gdG9wIHJ1bmcgYW5kIG1pZGRsZVxuICAgIDAsIDAsXG4gICAgMSwgMSxcbiAgICAwLCAxLFxuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuXG4gICAgLy8gdG9wIG9mIG1pZGRsZSBydW5nXG4gICAgMCwgMCxcbiAgICAxLCAxLFxuICAgIDAsIDEsXG4gICAgMCwgMCxcbiAgICAxLCAwLFxuICAgIDEsIDEsXG5cbiAgICAvLyBmcm9udCBvZiBtaWRkbGUgcnVuZ1xuICAgIDAsIDAsXG4gICAgMSwgMSxcbiAgICAwLCAxLFxuICAgIDAsIDAsXG4gICAgMSwgMCxcbiAgICAxLCAxLFxuXG4gICAgLy8gYm90dG9tIG9mIG1pZGRsZSBydW5nLlxuICAgIDAsIDAsXG4gICAgMCwgMSxcbiAgICAxLCAxLFxuICAgIDAsIDAsXG4gICAgMSwgMSxcbiAgICAxLCAwLFxuXG4gICAgLy8gZnJvbnQgb2YgYm90dG9tXG4gICAgMCwgMCxcbiAgICAxLCAxLFxuICAgIDAsIDEsXG4gICAgMCwgMCxcbiAgICAxLCAwLFxuICAgIDEsIDEsXG5cbiAgICAvLyBib3R0b21cbiAgICAwLCAwLFxuICAgIDAsIDEsXG4gICAgMSwgMSxcbiAgICAwLCAwLFxuICAgIDEsIDEsXG4gICAgMSwgMCxcblxuICAgIC8vIGxlZnQgc2lkZVxuICAgIDAsIDAsXG4gICAgMCwgMSxcbiAgICAxLCAxLFxuICAgIDAsIDAsXG4gICAgMSwgMSxcbiAgICAxLCAwLFxuICBdO1xuXG4gIGNvbnN0IG5vcm1hbHMgPSBleHBhbmRSTEVEYXRhKFtcbiAgICAvLyBsZWZ0IGNvbHVtbiBmcm9udFxuICAgIC8vIHRvcCBydW5nIGZyb250XG4gICAgLy8gbWlkZGxlIHJ1bmcgZnJvbnRcbiAgICAxOCwgMCwgMCwgMSxcblxuICAgIC8vIGxlZnQgY29sdW1uIGJhY2tcbiAgICAvLyB0b3AgcnVuZyBiYWNrXG4gICAgLy8gbWlkZGxlIHJ1bmcgYmFja1xuICAgIDE4LCAwLCAwLCAtMSxcblxuICAgIC8vIHRvcFxuICAgIDYsIDAsIDEsIDAsXG5cbiAgICAvLyB0b3AgcnVuZyBmcm9udFxuICAgIDYsIDEsIDAsIDAsXG5cbiAgICAvLyB1bmRlciB0b3AgcnVuZ1xuICAgIDYsIDAsIC0xLCAwLFxuXG4gICAgLy8gYmV0d2VlbiB0b3AgcnVuZyBhbmQgbWlkZGxlXG4gICAgNiwgMSwgMCwgMCxcblxuICAgIC8vIHRvcCBvZiBtaWRkbGUgcnVuZ1xuICAgIDYsIDAsIDEsIDAsXG5cbiAgICAvLyBmcm9udCBvZiBtaWRkbGUgcnVuZ1xuICAgIDYsIDEsIDAsIDAsXG5cbiAgICAvLyBib3R0b20gb2YgbWlkZGxlIHJ1bmcuXG4gICAgNiwgMCwgLTEsIDAsXG5cbiAgICAvLyBmcm9udCBvZiBib3R0b21cbiAgICA2LCAxLCAwLCAwLFxuXG4gICAgLy8gYm90dG9tXG4gICAgNiwgMCwgLTEsIDAsXG5cbiAgICAvLyBsZWZ0IHNpZGVcbiAgICA2LCAtMSwgMCwgMCxcbiAgXSk7XG5cbiAgY29uc3QgY29sb3JzID0gZXhwYW5kUkxFRGF0YShbXG4gICAgICAgIC8vIGxlZnQgY29sdW1uIGZyb250XG4gICAgICAgIC8vIHRvcCBydW5nIGZyb250XG4gICAgICAgIC8vIG1pZGRsZSBydW5nIGZyb250XG4gICAgICAxOCwgMjAwLCAgNzAsIDEyMCxcblxuICAgICAgICAvLyBsZWZ0IGNvbHVtbiBiYWNrXG4gICAgICAgIC8vIHRvcCBydW5nIGJhY2tcbiAgICAgICAgLy8gbWlkZGxlIHJ1bmcgYmFja1xuICAgICAgMTgsIDgwLCA3MCwgMjAwLFxuXG4gICAgICAgIC8vIHRvcFxuICAgICAgNiwgNzAsIDIwMCwgMjEwLFxuXG4gICAgICAgIC8vIHRvcCBydW5nIGZyb250XG4gICAgICA2LCAyMDAsIDIwMCwgNzAsXG5cbiAgICAgICAgLy8gdW5kZXIgdG9wIHJ1bmdcbiAgICAgIDYsIDIxMCwgMTAwLCA3MCxcblxuICAgICAgICAvLyBiZXR3ZWVuIHRvcCBydW5nIGFuZCBtaWRkbGVcbiAgICAgIDYsIDIxMCwgMTYwLCA3MCxcblxuICAgICAgICAvLyB0b3Agb2YgbWlkZGxlIHJ1bmdcbiAgICAgIDYsIDcwLCAxODAsIDIxMCxcblxuICAgICAgICAvLyBmcm9udCBvZiBtaWRkbGUgcnVuZ1xuICAgICAgNiwgMTAwLCA3MCwgMjEwLFxuXG4gICAgICAgIC8vIGJvdHRvbSBvZiBtaWRkbGUgcnVuZy5cbiAgICAgIDYsIDc2LCAyMTAsIDEwMCxcblxuICAgICAgICAvLyBmcm9udCBvZiBib3R0b21cbiAgICAgIDYsIDE0MCwgMjEwLCA4MCxcblxuICAgICAgICAvLyBib3R0b21cbiAgICAgIDYsIDkwLCAxMzAsIDExMCxcblxuICAgICAgICAvLyBsZWZ0IHNpZGVcbiAgICAgIDYsIDE2MCwgMTYwLCAyMjAsXG4gIF0sIFsyNTVdKTtcblxuICBjb25zdCBudW1WZXJ0cyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXG4gIGNvbnN0IGFycmF5cyA9IHtcbiAgICBwb3NpdGlvbjogY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0cyksXG4gICAgdGV4Y29vcmQ6IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMiwgIG51bVZlcnRzKSxcbiAgICBub3JtYWw6IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydHMpLFxuICAgIGNvbG9yOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDQsIG51bVZlcnRzLCBVaW50OEFycmF5KSxcbiAgICBpbmRpY2VzOiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRzIC8gMywgVWludDE2QXJyYXkpLFxuICB9O1xuXG4gIGFycmF5cy5wb3NpdGlvbi5wdXNoKHBvc2l0aW9ucyk7XG4gIGFycmF5cy50ZXhjb29yZC5wdXNoKHRleGNvb3Jkcyk7XG4gIGFycmF5cy5ub3JtYWwucHVzaChub3JtYWxzKTtcbiAgYXJyYXlzLmNvbG9yLnB1c2goY29sb3JzKTtcblxuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbnVtVmVydHM7ICsraWkpIHtcbiAgICBhcnJheXMuaW5kaWNlcy5wdXNoKGlpKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheXM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzY2VudCBCdWZmZXJJbmZvLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsUmFkaXVzIFRoZSB2ZXJ0aWNhbCByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG91dGVyUmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGlubmVyUmFkaXVzIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRoaWNrbmVzcyBUaGUgdGhpY2tuZXNzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdWJkaXZpc2lvbnNEb3duIG51bWJlciBvZiBzdGVwcyBhcm91bmQgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydE9mZnNldF0gV2hlcmUgdG8gc3RhcnQgYXJjLiBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZE9mZnNldF0gV2hlcmUgdG8gZW5kIGFyZy4gRGVmYXVsdCAxLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlQ3Jlc2VudEJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgY3Jlc2NlbnQgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFJhZGl1cyBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbm5lclJhZGl1cyBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgVGhlIHRoaWNrbmVzcyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zRG93biBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRPZmZzZXRdIFdoZXJlIHRvIHN0YXJ0IGFyYy4gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRPZmZzZXRdIFdoZXJlIHRvIGVuZCBhcmcuIERlZmF1bHQgMS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUNyZXNlbnRCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGNyZXNjZW50IHZlcnRpY2VzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFJhZGl1cyBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbm5lclJhZGl1cyBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgVGhlIHRoaWNrbmVzcyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zRG93biBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRPZmZzZXRdIFdoZXJlIHRvIHN0YXJ0IGFyYy4gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRPZmZzZXRdIFdoZXJlIHRvIGVuZCBhcmcuIERlZmF1bHQgMS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUNyZXNlbnRCdWZmZXJzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGNyZXNjZW50IEJ1ZmZlckluZm8uXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBUaGUgY3JlYXRlZCBCdWZmZXJJbmZvLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVDcmVzY2VudEJ1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgY3Jlc2NlbnQgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFJhZGl1cyBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbm5lclJhZGl1cyBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgVGhlIHRoaWNrbmVzcyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25zRG93biBudW1iZXIgb2Ygc3RlcHMgYXJvdW5kIHRoZSBjcmVzY2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRPZmZzZXRdIFdoZXJlIHRvIHN0YXJ0IGFyYy4gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRPZmZzZXRdIFdoZXJlIHRvIGVuZCBhcmcuIERlZmF1bHQgMS5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUNyZXNjZW50QnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBjcmVzY2VudCB2ZXJ0aWNlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmVydGljYWxSYWRpdXMgVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0ZXJSYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5uZXJSYWRpdXMgVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIFRoZSB0aGlja25lc3Mgb2YgdGhlIGNyZXNjZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN1YmRpdmlzaW9uc0Rvd24gbnVtYmVyIG9mIHN0ZXBzIGFyb3VuZCB0aGUgY3Jlc2NlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0T2Zmc2V0XSBXaGVyZSB0byBzdGFydCBhcmMuIERlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kT2Zmc2V0XSBXaGVyZSB0byBlbmQgYXJnLiBEZWZhdWx0IDEuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgVHlwZWRBcnJheT59IFRoZSBjcmVhdGVkIHZlcnRpY2VzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuIGZ1bmN0aW9uIGNyZWF0ZUNyZXNjZW50VmVydGljZXMoXG4gICAgdmVydGljYWxSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXMsXG4gICAgaW5uZXJSYWRpdXMsXG4gICAgdGhpY2tuZXNzLFxuICAgIHN1YmRpdmlzaW9uc0Rvd24sXG4gICAgc3RhcnRPZmZzZXQsXG4gICAgZW5kT2Zmc2V0KSB7XG4gIGlmIChzdWJkaXZpc2lvbnNEb3duIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YmRpdmlzaW9uRG93biBtdXN0IGJlID4gMCcpO1xuICB9XG5cbiAgc3RhcnRPZmZzZXQgPSBzdGFydE9mZnNldCB8fCAwO1xuICBlbmRPZmZzZXQgICA9IGVuZE9mZnNldCB8fCAxO1xuXG4gIGNvbnN0IHN1YmRpdmlzaW9uc1RoaWNrID0gMjtcblxuICBjb25zdCBvZmZzZXRSYW5nZSA9IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xuICBjb25zdCBudW1WZXJ0aWNlcyA9IChzdWJkaXZpc2lvbnNEb3duICsgMSkgKiAyICogKDIgKyBzdWJkaXZpc2lvbnNUaGljayk7XG4gIGNvbnN0IHBvc2l0aW9ucyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IG5vcm1hbHMgICAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IHRleGNvb3JkcyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG5cbiAgZnVuY3Rpb24gbGVycChhLCBiLCBzKSB7XG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFyYyhhcmNSYWRpdXMsIHgsIG5vcm1hbE11bHQsIG5vcm1hbEFkZCwgdU11bHQsIHVBZGQpIHtcbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8PSBzdWJkaXZpc2lvbnNEb3duOyB6KyspIHtcbiAgICAgIGNvbnN0IHVCYWNrID0geCAvIChzdWJkaXZpc2lvbnNUaGljayAtIDEpO1xuICAgICAgY29uc3QgdiA9IHogLyBzdWJkaXZpc2lvbnNEb3duO1xuICAgICAgY29uc3QgeEJhY2sgPSAodUJhY2sgLSAwLjUpICogMjtcbiAgICAgIGNvbnN0IGFuZ2xlID0gKHN0YXJ0T2Zmc2V0ICsgKHYgKiBvZmZzZXRSYW5nZSkpICogTWF0aC5QSTtcbiAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgY29uc3QgcmFkaXVzID0gbGVycCh2ZXJ0aWNhbFJhZGl1cywgYXJjUmFkaXVzLCBzKTtcbiAgICAgIGNvbnN0IHB4ID0geEJhY2sgKiB0aGlja25lc3M7XG4gICAgICBjb25zdCBweSA9IGMgKiB2ZXJ0aWNhbFJhZGl1cztcbiAgICAgIGNvbnN0IHB6ID0gcyAqIHJhZGl1cztcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHB4LCBweSwgcHopO1xuICAgICAgY29uc3QgbiA9IGFkZChtdWx0aXBseShbMCwgcywgY10sIG5vcm1hbE11bHQpLCBub3JtYWxBZGQpO1xuICAgICAgbm9ybWFscy5wdXNoKG4pO1xuICAgICAgdGV4Y29vcmRzLnB1c2godUJhY2sgKiB1TXVsdCArIHVBZGQsIHYpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHRoZSBpbmRpdmlkdWFsIHZlcnRpY2VzIGluIG91ciB2ZXJ0ZXggYnVmZmVyLlxuICBmb3IgKGxldCB4ID0gMDsgeCA8IHN1YmRpdmlzaW9uc1RoaWNrOyB4KyspIHtcbiAgICBjb25zdCB1QmFjayA9ICh4IC8gKHN1YmRpdmlzaW9uc1RoaWNrIC0gMSkgLSAwLjUpICogMjtcbiAgICBjcmVhdGVBcmMob3V0ZXJSYWRpdXMsIHgsIFsxLCAxLCAxXSwgWzAsICAgICAwLCAwXSwgMSwgMCk7XG4gICAgY3JlYXRlQXJjKG91dGVyUmFkaXVzLCB4LCBbMCwgMCwgMF0sIFt1QmFjaywgMCwgMF0sIDAsIDApO1xuICAgIGNyZWF0ZUFyYyhpbm5lclJhZGl1cywgeCwgWzEsIDEsIDFdLCBbMCwgICAgIDAsIDBdLCAxLCAwKTtcbiAgICBjcmVhdGVBcmMoaW5uZXJSYWRpdXMsIHgsIFswLCAwLCAwXSwgW3VCYWNrLCAwLCAwXSwgMCwgMSk7XG4gIH1cblxuICAvLyBEbyBvdXRlciBzdXJmYWNlLlxuICBjb25zdCBpbmRpY2VzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCAoc3ViZGl2aXNpb25zRG93biAqIDIpICogKDIgKyBzdWJkaXZpc2lvbnNUaGljayksIFVpbnQxNkFycmF5KTtcblxuICBmdW5jdGlvbiBjcmVhdGVTdXJmYWNlKGxlZnRBcmNPZmZzZXQsIHJpZ2h0QXJjT2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBzdWJkaXZpc2lvbnNEb3duOyArK3opIHtcbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMSBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKFxuICAgICAgICAgIGxlZnRBcmNPZmZzZXQgKyB6ICsgMCxcbiAgICAgICAgICBsZWZ0QXJjT2Zmc2V0ICsgeiArIDEsXG4gICAgICAgICAgcmlnaHRBcmNPZmZzZXQgKyB6ICsgMCk7XG5cbiAgICAgIC8vIE1ha2UgdHJpYW5nbGUgMiBvZiBxdWFkLlxuICAgICAgaW5kaWNlcy5wdXNoKFxuICAgICAgICAgIGxlZnRBcmNPZmZzZXQgKyB6ICsgMSxcbiAgICAgICAgICByaWdodEFyY09mZnNldCArIHogKyAxLFxuICAgICAgICAgIHJpZ2h0QXJjT2Zmc2V0ICsgeiArIDApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG51bVZlcnRpY2VzRG93biA9IHN1YmRpdmlzaW9uc0Rvd24gKyAxO1xuICAvLyBmcm9udFxuICBjcmVhdGVTdXJmYWNlKG51bVZlcnRpY2VzRG93biAqIDAsIG51bVZlcnRpY2VzRG93biAqIDQpO1xuICAvLyByaWdodFxuICBjcmVhdGVTdXJmYWNlKG51bVZlcnRpY2VzRG93biAqIDUsIG51bVZlcnRpY2VzRG93biAqIDcpO1xuICAvLyBiYWNrXG4gIGNyZWF0ZVN1cmZhY2UobnVtVmVydGljZXNEb3duICogNiwgbnVtVmVydGljZXNEb3duICogMik7XG4gIC8vIGxlZnRcbiAgY3JlYXRlU3VyZmFjZShudW1WZXJ0aWNlc0Rvd24gKiAzLCBudW1WZXJ0aWNlc0Rvd24gKiAxKTtcblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbnMsXG4gICAgbm9ybWFsOiAgIG5vcm1hbHMsXG4gICAgdGV4Y29vcmQ6IHRleGNvb3JkcyxcbiAgICBpbmRpY2VzOiAgaW5kaWNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGN5bGluZGVyIEJ1ZmZlckluZm8uIFRoZSBjeWxpbmRlciB3aWxsIGJlIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW5cbiAqIGFsb25nIHRoZSB5LWF4aXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdG9wQ2FwXSBDcmVhdGUgdG9wIGNhcC4gRGVmYXVsdCA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFRoZSBjcmVhdGVkIEJ1ZmZlckluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyQnVmZmVySW5mb1xuICovXG5cbiAvKipcbiAgKiBDcmVhdGVzIGN5bGluZGVyIGJ1ZmZlcnMuIFRoZSBjeWxpbmRlciB3aWxsIGJlIGNyZWF0ZWQgYXJvdW5kIHRoZSBvcmlnaW5cbiAgKiBhbG9uZyB0aGUgeS1heGlzLlxuICAqXG4gICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY3lsaW5kZXIuXG4gICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgY3lsaW5kZXIuXG4gICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGN5bGluZGVyLlxuICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0aWNhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBkb3duIHRoZSBjeWxpbmRlci5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0b3BDYXBdIENyZWF0ZSB0b3AgY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib3R0b21DYXBdIENyZWF0ZSBib3R0b20gY2FwLiBEZWZhdWx0ID0gdHJ1ZS5cbiAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gICogQGZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyQnVmZmVyc1xuICAqL1xuXG4gLyoqXG4gICogQ3JlYXRlcyBjeWxpbmRlciB2ZXJ0aWNlcy4gVGhlIGN5bGluZGVyIHdpbGwgYmUgY3JlYXRlZCBhcm91bmQgdGhlIG9yaWdpblxuICAqIGFsb25nIHRoZSB5LWF4aXMuXG4gICpcbiAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjeWxpbmRlci5cbiAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBjeWxpbmRlci5cbiAgKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgY3lsaW5kZXIuXG4gICogQHBhcmFtIHtudW1iZXJ9IHZlcnRpY2FsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGRvd24gdGhlIGN5bGluZGVyLlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RvcENhcF0gQ3JlYXRlIHRvcCBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JvdHRvbUNhcF0gQ3JlYXRlIGJvdHRvbSBjYXAuIERlZmF1bHQgPSB0cnVlLlxuICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAgKi9cbmZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyVmVydGljZXMoXG4gICAgcmFkaXVzLFxuICAgIGhlaWdodCxcbiAgICByYWRpYWxTdWJkaXZpc2lvbnMsXG4gICAgdmVydGljYWxTdWJkaXZpc2lvbnMsXG4gICAgdG9wQ2FwLFxuICAgIGJvdHRvbUNhcCkge1xuICByZXR1cm4gY3JlYXRlVHJ1bmNhdGVkQ29uZVZlcnRpY2VzKFxuICAgICAgcmFkaXVzLFxuICAgICAgcmFkaXVzLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcmFkaWFsU3ViZGl2aXNpb25zLFxuICAgICAgdmVydGljYWxTdWJkaXZpc2lvbnMsXG4gICAgICB0b3BDYXAsXG4gICAgICBib3R0b21DYXApO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgQnVmZmVySW5mbyBmb3IgYSB0b3J1c1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyByYWRpdXMgb2YgY2VudGVyIG9mIHRvcnVzIGNpcmNsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGlja25lc3MgcmFkaXVzIG9mIHRvcnVzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFsU3ViZGl2aXNpb25zIFRoZSBudW1iZXIgb2Ygc3ViZGl2aXNpb25zIGFyb3VuZCB0aGUgdG9ydXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYm9keVN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIGJvZHkgdG9ydXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFydEFuZ2xlXSBzdGFydCBhbmdsZSBpbiByYWRpYW5zLiBEZWZhdWx0ID0gMC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZEFuZ2xlXSBlbmQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IE1hdGguUEkgKiAyLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlVG9ydXNCdWZmZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGJ1ZmZlcnMgZm9yIGEgdG9ydXNcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBXZWJHTEJ1ZmZlcj59IFRoZSBjcmVhdGVkIGJ1ZmZlcnMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICogQGZ1bmN0aW9uIGNyZWF0ZVRvcnVzQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyB2ZXJ0aWNlcyBmb3IgYSB0b3J1c1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIGNlbnRlciBvZiB0b3J1cyBjaXJjbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGhpY2tuZXNzIHJhZGl1cyBvZiB0b3J1cyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbFN1YmRpdmlzaW9ucyBUaGUgbnVtYmVyIG9mIHN1YmRpdmlzaW9ucyBhcm91bmQgdGhlIHRvcnVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvZHlTdWJkaXZpc2lvbnMgVGhlIG51bWJlciBvZiBzdWJkaXZpc2lvbnMgYXJvdW5kIHRoZSBib2R5IHRvcnVzLlxuICogQHBhcmFtIHtib29sZWFufSBbc3RhcnRBbmdsZV0gc3RhcnQgYW5nbGUgaW4gcmFkaWFucy4gRGVmYXVsdCA9IDAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRBbmdsZV0gZW5kIGFuZ2xlIGluIHJhZGlhbnMuIERlZmF1bHQgPSBNYXRoLlBJICogMi5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBUeXBlZEFycmF5Pn0gVGhlIGNyZWF0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUb3J1c1ZlcnRpY2VzKFxuICAgIHJhZGl1cyxcbiAgICB0aGlja25lc3MsXG4gICAgcmFkaWFsU3ViZGl2aXNpb25zLFxuICAgIGJvZHlTdWJkaXZpc2lvbnMsXG4gICAgc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSkge1xuICBpZiAocmFkaWFsU3ViZGl2aXNpb25zIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmFkaWFsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBpZiAoYm9keVN1YmRpdmlzaW9ucyA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnRpY2FsU3ViZGl2aXNpb25zIG11c3QgYmUgMyBvciBncmVhdGVyJyk7XG4gIH1cblxuICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSB8fCAwO1xuICBlbmRBbmdsZSA9IGVuZEFuZ2xlIHx8IE1hdGguUEkgKiAyO1xuICBjb25zdCByYW5nZSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcblxuICBjb25zdCByYWRpYWxQYXJ0cyA9IHJhZGlhbFN1YmRpdmlzaW9ucyArIDE7XG4gIGNvbnN0IGJvZHlQYXJ0cyAgID0gYm9keVN1YmRpdmlzaW9ucyArIDE7XG4gIGNvbnN0IG51bVZlcnRpY2VzID0gcmFkaWFsUGFydHMgKiBib2R5UGFydHM7XG4gIGNvbnN0IHBvc2l0aW9ucyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IG5vcm1hbHMgICAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IHRleGNvb3JkcyAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IGluZGljZXMgICAgID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgzLCAocmFkaWFsU3ViZGl2aXNpb25zKSAqIChib2R5U3ViZGl2aXNpb25zKSAqIDIsIFVpbnQxNkFycmF5KTtcblxuICBmb3IgKGxldCBzbGljZSA9IDA7IHNsaWNlIDwgYm9keVBhcnRzOyArK3NsaWNlKSB7XG4gICAgY29uc3QgdiA9IHNsaWNlIC8gYm9keVN1YmRpdmlzaW9ucztcbiAgICBjb25zdCBzbGljZUFuZ2xlID0gdiAqIE1hdGguUEkgKiAyO1xuICAgIGNvbnN0IHNsaWNlU2luID0gTWF0aC5zaW4oc2xpY2VBbmdsZSk7XG4gICAgY29uc3QgcmluZ1JhZGl1cyA9IHJhZGl1cyArIHNsaWNlU2luICogdGhpY2tuZXNzO1xuICAgIGNvbnN0IG55ID0gTWF0aC5jb3Moc2xpY2VBbmdsZSk7XG4gICAgY29uc3QgeSA9IG55ICogdGhpY2tuZXNzO1xuICAgIGZvciAobGV0IHJpbmcgPSAwOyByaW5nIDwgcmFkaWFsUGFydHM7ICsrcmluZykge1xuICAgICAgY29uc3QgdSA9IHJpbmcgLyByYWRpYWxTdWJkaXZpc2lvbnM7XG4gICAgICBjb25zdCByaW5nQW5nbGUgPSBzdGFydEFuZ2xlICsgdSAqIHJhbmdlO1xuICAgICAgY29uc3QgeFNpbiA9IE1hdGguc2luKHJpbmdBbmdsZSk7XG4gICAgICBjb25zdCB6Q29zID0gTWF0aC5jb3MocmluZ0FuZ2xlKTtcbiAgICAgIGNvbnN0IHggPSB4U2luICogcmluZ1JhZGl1cztcbiAgICAgIGNvbnN0IHogPSB6Q29zICogcmluZ1JhZGl1cztcbiAgICAgIGNvbnN0IG54ID0geFNpbiAqIHNsaWNlU2luO1xuICAgICAgY29uc3QgbnogPSB6Q29zICogc2xpY2VTaW47XG4gICAgICBwb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgIG5vcm1hbHMucHVzaChueCwgbnksIG56KTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKHUsIDEgLSB2KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBzbGljZSA9IDA7IHNsaWNlIDwgYm9keVN1YmRpdmlzaW9uczsgKytzbGljZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZvciAobGV0IHJpbmcgPSAwOyByaW5nIDwgcmFkaWFsU3ViZGl2aXNpb25zOyArK3JpbmcpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGNvbnN0IG5leHRSaW5nSW5kZXggID0gMSArIHJpbmc7XG4gICAgICBjb25zdCBuZXh0U2xpY2VJbmRleCA9IDEgKyBzbGljZTtcbiAgICAgIGluZGljZXMucHVzaChyYWRpYWxQYXJ0cyAqIHNsaWNlICAgICAgICAgICsgcmluZyxcbiAgICAgICAgICAgICAgICAgICByYWRpYWxQYXJ0cyAqIG5leHRTbGljZUluZGV4ICsgcmluZyxcbiAgICAgICAgICAgICAgICAgICByYWRpYWxQYXJ0cyAqIHNsaWNlICAgICAgICAgICsgbmV4dFJpbmdJbmRleCk7XG4gICAgICBpbmRpY2VzLnB1c2gocmFkaWFsUGFydHMgKiBuZXh0U2xpY2VJbmRleCArIHJpbmcsXG4gICAgICAgICAgICAgICAgICAgcmFkaWFsUGFydHMgKiBuZXh0U2xpY2VJbmRleCArIG5leHRSaW5nSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgcmFkaWFsUGFydHMgKiBzbGljZSAgICAgICAgICArIG5leHRSaW5nSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9ucyxcbiAgICBub3JtYWw6ICAgbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6ICBpbmRpY2VzLFxuICB9O1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGRpc2MgQnVmZmVySW5mby4gVGhlIGRpc2Mgd2lsbCBiZSBpbiB0aGUgeHogcGxhbmUsIGNlbnRlcmVkIGF0XG4gKiB0aGUgb3JpZ2luLiBXaGVuIGNyZWF0aW5nLCBhdCBsZWFzdCAzIGRpdmlzaW9ucywgb3IgcGllXG4gKiBwaWVjZXMsIG5lZWQgdG8gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgdGhlIHRyaWFuZ2xlcyBtYWtpbmdcbiAqIHVwIHRoZSBkaXNjIHdpbGwgYmUgZGVnZW5lcmF0ZS4gWW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlXG4gKiBudW1iZXIgb2YgcmFkaWFsIHBpZWNlcyBgc3RhY2tzYC4gQSB2YWx1ZSBvZiAxIGZvclxuICogc3RhY2tzIHdpbGwgZ2l2ZSB5b3UgYSBzaW1wbGUgZGlzYyBvZiBwaWUgcGllY2VzLiAgSWYgeW91XG4gKiB3YW50IHRvIGNyZWF0ZSBhbiBhbm51bHVzIHlvdSBjYW4gc2V0IGBpbm5lclJhZGl1c2AgdG8gYVxuICogdmFsdWUgPiAwLiBGaW5hbGx5LCBgc3RhY2tQb3dlcmAgYWxsb3dzIHlvdSB0byBoYXZlIHRoZSB3aWR0aHNcbiAqIGluY3JlYXNlIG9yIGRlY3JlYXNlIGFzIHlvdSBtb3ZlIGF3YXkgZnJvbSB0aGUgY2VudGVyLiBUaGlzXG4gKiBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIGRpc2MgYXMgYSBncm91bmQgcGxhbmVcbiAqIHdpdGggYSBmaXhlZCBjYW1lcmEgc3VjaCB0aGF0IHlvdSBkb24ndCBuZWVkIHRoZSByZXNvbHV0aW9uXG4gKiBvZiBzbWFsbCB0cmlhbmdsZXMgbmVhciB0aGUgcGVyaW1ldGVyLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuICogb2YgMiB3aWxsIHByb2R1Y2Ugc3RhY2tzIHdob3NlIG91dHNpZGUgcmFkaXVzIGluY3JlYXNlcyB3aXRoXG4gKiB0aGUgc3F1YXJlIG9mIHRoZSBzdGFjayBpbmRleC4gQSB2YWx1ZSBvZiAxIHdpbGwgZ2l2ZSB1bmlmb3JtXG4gKiBzdGFja3MuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgZ3JvdW5kIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyBOdW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoZSBncm91bmQgcGxhbmUgKGF0IGxlYXN0IDMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja3NdIE51bWJlciBvZiByYWRpYWwgZGl2aXNpb25zIChkZWZhdWx0PTEpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja1Bvd2VyXSBQb3dlciB0byByYWlzZSBzdGFjayBzaXplIHRvIGZvciBkZWNyZWFzaW5nIHdpZHRoLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gVGhlIGNyZWF0ZWQgQnVmZmVySW5mby5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKiBAZnVuY3Rpb24gY3JlYXRlRGlzY0J1ZmZlckluZm9cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgZGlzYyBidWZmZXJzLiBUaGUgZGlzYyB3aWxsIGJlIGluIHRoZSB4eiBwbGFuZSwgY2VudGVyZWQgYXRcbiAqIHRoZSBvcmlnaW4uIFdoZW4gY3JlYXRpbmcsIGF0IGxlYXN0IDMgZGl2aXNpb25zLCBvciBwaWVcbiAqIHBpZWNlcywgbmVlZCB0byBiZSBzcGVjaWZpZWQsIG90aGVyd2lzZSB0aGUgdHJpYW5nbGVzIG1ha2luZ1xuICogdXAgdGhlIGRpc2Mgd2lsbCBiZSBkZWdlbmVyYXRlLiBZb3UgY2FuIGFsc28gc3BlY2lmeSB0aGVcbiAqIG51bWJlciBvZiByYWRpYWwgcGllY2VzIGBzdGFja3NgLiBBIHZhbHVlIG9mIDEgZm9yXG4gKiBzdGFja3Mgd2lsbCBnaXZlIHlvdSBhIHNpbXBsZSBkaXNjIG9mIHBpZSBwaWVjZXMuICBJZiB5b3VcbiAqIHdhbnQgdG8gY3JlYXRlIGFuIGFubnVsdXMgeW91IGNhbiBzZXQgYGlubmVyUmFkaXVzYCB0byBhXG4gKiB2YWx1ZSA+IDAuIEZpbmFsbHksIGBzdGFja1Bvd2VyYCBhbGxvd3MgeW91IHRvIGhhdmUgdGhlIHdpZHRoc1xuICogaW5jcmVhc2Ugb3IgZGVjcmVhc2UgYXMgeW91IG1vdmUgYXdheSBmcm9tIHRoZSBjZW50ZXIuIFRoaXNcbiAqIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiB1c2luZyB0aGUgZGlzYyBhcyBhIGdyb3VuZCBwbGFuZVxuICogd2l0aCBhIGZpeGVkIGNhbWVyYSBzdWNoIHRoYXQgeW91IGRvbid0IG5lZWQgdGhlIHJlc29sdXRpb25cbiAqIG9mIHNtYWxsIHRyaWFuZ2xlcyBuZWFyIHRoZSBwZXJpbWV0ZXIuIEZvciBleGFtcGxlLCBhIHZhbHVlXG4gKiBvZiAyIHdpbGwgcHJvZHVjZSBzdGFja3Mgd2hvc2Ugb3V0c2lkZSByYWRpdXMgaW5jcmVhc2VzIHdpdGhcbiAqIHRoZSBzcXVhcmUgb2YgdGhlIHN0YWNrIGluZGV4LiBBIHZhbHVlIG9mIDEgd2lsbCBnaXZlIHVuaWZvcm1cbiAqIHN0YWNrcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSBncm91bmQgcGxhbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gZGl2aXNpb25zIE51bWJlciBvZiB0cmlhbmdsZXMgaW4gdGhlIGdyb3VuZCBwbGFuZSAoYXQgbGVhc3QgMykuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YWNrc10gTnVtYmVyIG9mIHJhZGlhbCBkaXZpc2lvbnMgKGRlZmF1bHQ9MSkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2lubmVyUmFkaXVzXSBEZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YWNrUG93ZXJdIFBvd2VyIHRvIHJhaXNlIHN0YWNrIHNpemUgdG8gZm9yIGRlY3JlYXNpbmcgd2lkdGguXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgV2ViR0xCdWZmZXI+fSBUaGUgY3JlYXRlZCBidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqIEBmdW5jdGlvbiBjcmVhdGVEaXNjQnVmZmVyc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBkaXNjIHZlcnRpY2VzLiBUaGUgZGlzYyB3aWxsIGJlIGluIHRoZSB4eiBwbGFuZSwgY2VudGVyZWQgYXRcbiAqIHRoZSBvcmlnaW4uIFdoZW4gY3JlYXRpbmcsIGF0IGxlYXN0IDMgZGl2aXNpb25zLCBvciBwaWVcbiAqIHBpZWNlcywgbmVlZCB0byBiZSBzcGVjaWZpZWQsIG90aGVyd2lzZSB0aGUgdHJpYW5nbGVzIG1ha2luZ1xuICogdXAgdGhlIGRpc2Mgd2lsbCBiZSBkZWdlbmVyYXRlLiBZb3UgY2FuIGFsc28gc3BlY2lmeSB0aGVcbiAqIG51bWJlciBvZiByYWRpYWwgcGllY2VzIGBzdGFja3NgLiBBIHZhbHVlIG9mIDEgZm9yXG4gKiBzdGFja3Mgd2lsbCBnaXZlIHlvdSBhIHNpbXBsZSBkaXNjIG9mIHBpZSBwaWVjZXMuICBJZiB5b3VcbiAqIHdhbnQgdG8gY3JlYXRlIGFuIGFubnVsdXMgeW91IGNhbiBzZXQgYGlubmVyUmFkaXVzYCB0byBhXG4gKiB2YWx1ZSA+IDAuIEZpbmFsbHksIGBzdGFja1Bvd2VyYCBhbGxvd3MgeW91IHRvIGhhdmUgdGhlIHdpZHRoc1xuICogaW5jcmVhc2Ugb3IgZGVjcmVhc2UgYXMgeW91IG1vdmUgYXdheSBmcm9tIHRoZSBjZW50ZXIuIFRoaXNcbiAqIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiB1c2luZyB0aGUgZGlzYyBhcyBhIGdyb3VuZCBwbGFuZVxuICogd2l0aCBhIGZpeGVkIGNhbWVyYSBzdWNoIHRoYXQgeW91IGRvbid0IG5lZWQgdGhlIHJlc29sdXRpb25cbiAqIG9mIHNtYWxsIHRyaWFuZ2xlcyBuZWFyIHRoZSBwZXJpbWV0ZXIuIEZvciBleGFtcGxlLCBhIHZhbHVlXG4gKiBvZiAyIHdpbGwgcHJvZHVjZSBzdGFja3Mgd2hvc2Ugb3V0c2lkZSByYWRpdXMgaW5jcmVhc2VzIHdpdGhcbiAqIHRoZSBzcXVhcmUgb2YgdGhlIHN0YWNrIGluZGV4LiBBIHZhbHVlIG9mIDEgd2lsbCBnaXZlIHVuaWZvcm1cbiAqIHN0YWNrcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgZ3JvdW5kIHBsYW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzaW9ucyBOdW1iZXIgb2YgdHJpYW5nbGVzIGluIHRoZSBncm91bmQgcGxhbmUgKGF0IGxlYXN0IDMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja3NdIE51bWJlciBvZiByYWRpYWwgZGl2aXNpb25zIChkZWZhdWx0PTEpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gRGVmYXVsdCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFja1Bvd2VyXSBQb3dlciB0byByYWlzZSBzdGFjayBzaXplIHRvIGZvciBkZWNyZWFzaW5nIHdpZHRoLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIFR5cGVkQXJyYXk+fSBUaGUgY3JlYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2NWZXJ0aWNlcyhcbiAgICByYWRpdXMsXG4gICAgZGl2aXNpb25zLFxuICAgIHN0YWNrcyxcbiAgICBpbm5lclJhZGl1cyxcbiAgICBzdGFja1Bvd2VyKSB7XG4gIGlmIChkaXZpc2lvbnMgPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaXZpc2lvbnMgbXVzdCBiZSBhdCBsZWFzdCAzJyk7XG4gIH1cblxuICBzdGFja3MgPSBzdGFja3MgPyBzdGFja3MgOiAxO1xuICBzdGFja1Bvd2VyID0gc3RhY2tQb3dlciA/IHN0YWNrUG93ZXIgOiAxO1xuICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzID8gaW5uZXJSYWRpdXMgOiAwO1xuXG4gIC8vIE5vdGU6IFdlIGRvbid0IHNoYXJlIHRoZSBjZW50ZXIgdmVydGV4IGJlY2F1c2UgdGhhdCB3b3VsZFxuICAvLyBtZXNzIHVwIHRleHR1cmUgY29vcmRpbmF0ZXMuXG4gIGNvbnN0IG51bVZlcnRpY2VzID0gKGRpdmlzaW9ucyArIDEpICogKHN0YWNrcyArIDEpO1xuXG4gIGNvbnN0IHBvc2l0aW9ucyA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgbnVtVmVydGljZXMpO1xuICBjb25zdCBub3JtYWxzICAgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDMsIG51bVZlcnRpY2VzKTtcbiAgY29uc3QgdGV4Y29vcmRzID0gY3JlYXRlQXVnbWVudGVkVHlwZWRBcnJheSgyLCBudW1WZXJ0aWNlcyk7XG4gIGNvbnN0IGluZGljZXMgICA9IGNyZWF0ZUF1Z21lbnRlZFR5cGVkQXJyYXkoMywgc3RhY2tzICogZGl2aXNpb25zICogMiwgVWludDE2QXJyYXkpO1xuXG4gIGxldCBmaXJzdEluZGV4ID0gMDtcbiAgY29uc3QgcmFkaXVzU3BhbiA9IHJhZGl1cyAtIGlubmVyUmFkaXVzO1xuICBjb25zdCBwb2ludHNQZXJTdGFjayA9IGRpdmlzaW9ucyArIDE7XG5cbiAgLy8gQnVpbGQgdGhlIGRpc2sgb25lIHN0YWNrIGF0IGEgdGltZS5cbiAgZm9yIChsZXQgc3RhY2sgPSAwOyBzdGFjayA8PSBzdGFja3M7ICsrc3RhY2spIHtcbiAgICBjb25zdCBzdGFja1JhZGl1cyA9IGlubmVyUmFkaXVzICsgcmFkaXVzU3BhbiAqIE1hdGgucG93KHN0YWNrIC8gc3RhY2tzLCBzdGFja1Bvd2VyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgKytpKSB7XG4gICAgICBjb25zdCB0aGV0YSA9IDIuMCAqIE1hdGguUEkgKiBpIC8gZGl2aXNpb25zO1xuICAgICAgY29uc3QgeCA9IHN0YWNrUmFkaXVzICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgY29uc3QgeiA9IHN0YWNrUmFkaXVzICogTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICBwb3NpdGlvbnMucHVzaCh4LCAwLCB6KTtcbiAgICAgIG5vcm1hbHMucHVzaCgwLCAxLCAwKTtcbiAgICAgIHRleGNvb3Jkcy5wdXNoKDEgLSAoaSAvIGRpdmlzaW9ucyksIHN0YWNrIC8gc3RhY2tzKTtcbiAgICAgIGlmIChzdGFjayA+IDAgJiYgaSAhPT0gZGl2aXNpb25zKSB7XG4gICAgICAgIC8vIGEsIGIsIGMgYW5kIGQgYXJlIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlcyBvZiBhIHF1YWQuICB1bmxlc3NcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgc3RhY2sgaXMgdGhlIG9uZSBjbG9zZXN0IHRvIHRoZSBjZW50ZXIsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgLy8gdGhlIHZlcnRpY2VzIGEgYW5kIGIgY29ubmVjdCB0byB0aGUgY2VudGVyIHZlcnRleC5cbiAgICAgICAgY29uc3QgYSA9IGZpcnN0SW5kZXggKyAoaSArIDEpO1xuICAgICAgICBjb25zdCBiID0gZmlyc3RJbmRleCArIGk7XG4gICAgICAgIGNvbnN0IGMgPSBmaXJzdEluZGV4ICsgaSAtIHBvaW50c1BlclN0YWNrO1xuICAgICAgICBjb25zdCBkID0gZmlyc3RJbmRleCArIChpICsgMSkgLSBwb2ludHNQZXJTdGFjaztcblxuICAgICAgICAvLyBNYWtlIGEgcXVhZCBvZiB0aGUgdmVydGljZXMgYSwgYiwgYywgZC5cbiAgICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGMpO1xuICAgICAgICBpbmRpY2VzLnB1c2goYSwgYywgZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RJbmRleCArPSBkaXZpc2lvbnMgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25zLFxuICAgIG5vcm1hbDogbm9ybWFscyxcbiAgICB0ZXhjb29yZDogdGV4Y29vcmRzLFxuICAgIGluZGljZXM6IGluZGljZXMsXG4gIH07XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgcmFuZ2UgLSAxIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZVxuICogQHJldHVybiB7bnVtYmVyfSByYW5kb20gdmFsdWUgYmV0d2VlbiAwIGFuZCByYW5nZSAtIDEgaW5jbHVzaXZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmFuZEludChyYW5nZSkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHJhbmdlIHwgMDtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHN1cHBseSByYW5kb20gY29sb3JzXG4gKiBAY2FsbGJhY2sgUmFuZG9tQ29sb3JGdW5jXG4gKiBAcGFyYW0ge251bWJlcn0gbmR4IGluZGV4IG9mIHRyaWFuZ2xlL3F1YWQgaWYgdW5pbmRleGVkIG9yIGluZGV4IG9mIHZlcnRleCBpZiBpbmRleGVkXG4gKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAwID0gcmVkLCAxID0gZ3JlZW4sIDIgPSBibHVlLCAzID0gYWxwaGFcbiAqIEByZXR1cm4ge251bWJlcn0gYSBudW1iZXIgZnJvbSAwIHRvIDI1NVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ByaW1pdGl2ZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJhbmRvbVZlcnRpY2VzT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt2ZXJ0c1BlckNvbG9yXSBEZWZhdWx0cyB0byAzIGZvciBub24taW5kZXhlZCB2ZXJ0aWNlc1xuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC9wcmltaXRpdmVzLlJhbmRvbUNvbG9yRnVuY30gW3JhbmRdIEEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgcmFuZG9tIG51bWJlcnNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGF1Z21lbnRlZFR5cGVkQXJyYXkgb2YgcmFuZG9tIHZlcnRleCBjb2xvcnMuXG4gKiBJZiB0aGUgdmVydGljZXMgYXJlIGluZGV4ZWQgKGhhdmUgYW4gaW5kaWNlcyBhcnJheSkgdGhlbiB3aWxsXG4gKiBqdXN0IG1ha2UgcmFuZG9tIGNvbG9ycy4gT3RoZXJ3aXNlIGFzc3VtZXMgdGhleSBhcmUgdHJpYW5nbGVzXG4gKiBhbmQgbWFrZXMgb25lIHJhbmRvbSBjb2xvciBmb3IgZXZlcnkgMyB2ZXJ0aWNlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEF1Z21lbnRlZFR5cGVkQXJyYXk+fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBhcyByZXR1cm5lZCBmcm9tIG9uZSBvZiB0aGUgY3JlYXRlWFhYVmVydGljZXMgZnVuY3Rpb25zLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC9wcmltaXRpdmVzLlJhbmRvbVZlcnRpY2VzT3B0aW9uc30gW29wdGlvbnNdIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgQXVnbWVudGVkVHlwZWRBcnJheT59IHNhbWUgdmVydGljZXMgYXMgcGFzc2VkIGluIHdpdGggYGNvbG9yYCBhZGRlZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIG1ha2VSYW5kb21WZXJ0ZXhDb2xvcnModmVydGljZXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG51bUVsZW1lbnRzID0gdmVydGljZXMucG9zaXRpb24ubnVtRWxlbWVudHM7XG4gIGNvbnN0IHZDb2xvcnMgPSBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5KDQsIG51bUVsZW1lbnRzLCBVaW50OEFycmF5KTtcbiAgY29uc3QgcmFuZCA9IG9wdGlvbnMucmFuZCB8fCBmdW5jdGlvbihuZHgsIGNoYW5uZWwpIHtcbiAgICByZXR1cm4gY2hhbm5lbCA8IDMgPyByYW5kSW50KDI1NikgOiAyNTU7XG4gIH07XG4gIHZlcnRpY2VzLmNvbG9yID0gdkNvbG9ycztcbiAgaWYgKHZlcnRpY2VzLmluZGljZXMpIHtcbiAgICAvLyBqdXN0IG1ha2UgcmFuZG9tIGNvbG9ycyBpZiBpbmRleFxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBudW1FbGVtZW50czsgKytpaSkge1xuICAgICAgdkNvbG9ycy5wdXNoKHJhbmQoaWksIDApLCByYW5kKGlpLCAxKSwgcmFuZChpaSwgMiksIHJhbmQoaWksIDMpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFrZSByYW5kb20gY29sb3JzIHBlciB0cmlhbmdsZVxuICAgIGNvbnN0IG51bVZlcnRzUGVyQ29sb3IgPSBvcHRpb25zLnZlcnRzUGVyQ29sb3IgfHwgMztcbiAgICBjb25zdCBudW1TZXRzID0gbnVtRWxlbWVudHMgLyBudW1WZXJ0c1BlckNvbG9yO1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBudW1TZXRzOyArK2lpKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBjb25zdCBjb2xvciA9IFtyYW5kKGlpLCAwKSwgcmFuZChpaSwgMSksIHJhbmQoaWksIDIpLCByYW5kKGlpLCAzKV07XG4gICAgICBmb3IgKGxldCBqaiA9IDA7IGpqIDwgbnVtVmVydHNQZXJDb2xvcjsgKytqaikge1xuICAgICAgICB2Q29sb3JzLnB1c2goY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmVydGljZXM7XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVycyBmb3IgdGhlbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRnVuYyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24oZ2wpIHtcbiAgICBjb25zdCBhcnJheXMgPSBmbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyc0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gIH07XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZm4gdG8gY3JlYXRlIHZlcnRpY2VzIGFuZCB0aGVuXG4gKiBjcmVhdGVzIGEgYnVmZmVySW5mbyBvYmplY3QgZm9yIHRoZW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbihnbCkge1xuICAgIGNvbnN0IGFycmF5cyA9IGZuLmFwcGx5KG51bGwsICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMoZ2wsIGFycmF5cyk7XG4gIH07XG59XG5cbmNvbnN0IGFycmF5U3BlY1Byb3BlcnR5TmFtZXMgPSBbXG4gIFwibnVtQ29tcG9uZW50c1wiLFxuICBcInNpemVcIixcbiAgXCJ0eXBlXCIsXG4gIFwibm9ybWFsaXplXCIsXG4gIFwic3RyaWRlXCIsXG4gIFwib2Zmc2V0XCIsXG4gIFwiYXR0cmliXCIsXG4gIFwibmFtZVwiLFxuICBcImF0dHJpYk5hbWVcIixcbl07XG5cbi8qKlxuICogQ29weSBlbGVtZW50cyBmcm9tIG9uZSBhcnJheSB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBzcmMgc291cmNlIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRzdCBkZXN0IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gZHN0TmR4IGluZGV4IGluIGRlc3QgdG8gY29weSBzcmNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBvZmZzZXQgdG8gYWRkIHRvIGNvcGllZCB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvcHlFbGVtZW50cyhzcmMsIGRzdCwgZHN0TmR4LCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGxlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBsZW5ndGg7ICsraWkpIHtcbiAgICBkc3RbZHN0TmR4ICsgaWldID0gc3JjW2lpXSArIG9mZnNldDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIHNhbWUgdGltZVxuICpcbiAqIEBwYXJhbSB7KG51bWJlcltdfEFycmF5QnVmZmVyVmlld3xtb2R1bGU6dHdnbC5GdWxsQXJyYXlTcGVjKX0gc3JjQXJyYXkgYXJyYXkgd2hvJ3MgdHlwZSB0byBjb3B5XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHNpemUgb2YgbmV3IGFycmF5XG4gKiBAcmV0dXJuIHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3fG1vZHVsZTp0d2dsLkZ1bGxBcnJheVNwZWMpfSBhcnJheSB3aXRoIHNhbWUgdHlwZSBhcyBzcmNBcnJheVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlNhbWVUeXBlKHNyY0FycmF5LCBsZW5ndGgpIHtcbiAgY29uc3QgYXJyYXlTcmMgPSBnZXRBcnJheSQxKHNyY0FycmF5KTtcbiAgY29uc3QgbmV3QXJyYXkgPSBuZXcgYXJyYXlTcmMuY29uc3RydWN0b3IobGVuZ3RoKTtcbiAgbGV0IG5ld0FycmF5U3BlYyA9IG5ld0FycmF5O1xuICAvLyBJZiBpdCBhcHBlYXJzIHRvIGhhdmUgYmVlbiBhdWdtZW50ZWQgbWFrZSBuZXcgb25lIGF1Z21lbnRlZFxuICBpZiAoYXJyYXlTcmMubnVtQ29tcG9uZW50cyAmJiBhcnJheVNyYy5udW1FbGVtZW50cykge1xuICAgIGF1Z21lbnRUeXBlZEFycmF5KG5ld0FycmF5LCBhcnJheVNyYy5udW1Db21wb25lbnRzKTtcbiAgfVxuICAvLyBJZiBpdCB3YXMgYSBmdWxsIHNwZWMgbWFrZSBuZXcgb25lIGEgZnVsbCBzcGVjXG4gIGlmIChzcmNBcnJheS5kYXRhKSB7XG4gICAgbmV3QXJyYXlTcGVjID0ge1xuICAgICAgZGF0YTogbmV3QXJyYXksXG4gICAgfTtcbiAgICBjb3B5TmFtZWRQcm9wZXJ0aWVzKGFycmF5U3BlY1Byb3BlcnR5TmFtZXMsIHNyY0FycmF5LCBuZXdBcnJheVNwZWMpO1xuICB9XG4gIHJldHVybiBuZXdBcnJheVNwZWM7XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHNldHMgb2YgdmVydGljZXNcbiAqXG4gKiBBc3N1bWVzIHRoZSB2ZXJ0aWNlcyBtYXRjaCBpbiBjb21wb3NpdGlvbi4gRm9yIGV4YW1wbGVcbiAqIGlmIG9uZSBzZXQgb2YgdmVydGljZXMgaGFzIHBvc2l0aW9ucywgbm9ybWFscywgYW5kIGluZGljZXNcbiAqIGFsbCBzZXRzIG9mIHZlcnRpY2VzIG11c3QgaGF2ZSBwb3NpdGlvbnMsIG5vcm1hbHMsIGFuZCBpbmRpY2VzXG4gKiBhbmQgb2YgdGhlIHNhbWUgdHlwZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgY29uc3QgY3ViZVZlcnRpY2VzID0gdHdnbC5wcmltaXRpdmVzLmNyZWF0ZUN1YmVWZXJ0aWNlcygyKTtcbiAqICAgICAgY29uc3Qgc3BoZXJlVmVydGljZXMgPSB0d2dsLnByaW1pdGl2ZXMuY3JlYXRlU3BoZXJlVmVydGljZXMoMSwgMTAsIDEwKTtcbiAqICAgICAgLy8gbW92ZSB0aGUgc3BoZXJlIDIgdW5pdHMgdXBcbiAqICAgICAgdHdnbC5wcmltaXRpdmVzLnJlb3JpZW50VmVydGljZXMoXG4gKiAgICAgICAgICBzcGhlcmVWZXJ0aWNlcywgdHdnbC5tNC50cmFuc2xhdGlvbihbMCwgMiwgMF0pKTtcbiAqICAgICAgLy8gbWVyZ2UgdGhlIHNwaGVyZSB3aXRoIHRoZSBjdWJlXG4gKiAgICAgIGNvbnN0IGN1YmVTcGhlcmVWZXJ0aWNlcyA9IHR3Z2wucHJpbWl0aXZlcy5jb25jYXRWZXJ0aWNlcyhcbiAqICAgICAgICAgIFtjdWJlVmVydGljZXMsIHNwaGVyZVZlcnRpY2VzXSk7XG4gKiAgICAgIC8vIHR1cm4gdGhlbSBpbnRvIFdlYkdMIGJ1ZmZlcnMgYW5kIGF0dHJpYiBkYXRhXG4gKiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzKGdsLCBjdWJlU3BoZXJlVmVydGljZXMpO1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzW119IGFycmF5cyBBcnJheSBvZiBhcnJheXMgb2YgdmVydGljZXNcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkFycmF5c30gVGhlIGNvbmNhdGVuYXRlZCB2ZXJ0aWNlcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcmltaXRpdmVzXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdFZlcnRpY2VzKGFycmF5T2ZBcnJheXMpIHtcbiAgY29uc3QgbmFtZXMgPSB7fTtcbiAgbGV0IGJhc2VOYW1lO1xuICAvLyBnZXQgbmFtZXMgb2YgYWxsIGFycmF5cy5cbiAgLy8gYW5kIG51bUVsZW1lbnRzIGZvciBlYWNoIHNldCBvZiB2ZXJ0aWNlc1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsraWkpIHtcbiAgICBjb25zdCBhcnJheXMgPSBhcnJheU9mQXJyYXlzW2lpXTtcbiAgICBPYmplY3Qua2V5cyhhcnJheXMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKCFuYW1lc1tuYW1lXSkge1xuICAgICAgICBuYW1lc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFiYXNlTmFtZSAmJiBuYW1lICE9PSAnaW5kaWNlcycpIHtcbiAgICAgICAgYmFzZU5hbWUgPSBuYW1lO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJyYXlJbmZvID0gYXJyYXlzW25hbWVdO1xuICAgICAgY29uc3QgbnVtQ29tcG9uZW50cyA9IGdldE51bUNvbXBvbmVudHMkMShhcnJheUluZm8sIG5hbWUpO1xuICAgICAgY29uc3QgYXJyYXkgPSBnZXRBcnJheSQxKGFycmF5SW5mbyk7XG4gICAgICBjb25zdCBudW1FbGVtZW50cyA9IGFycmF5Lmxlbmd0aCAvIG51bUNvbXBvbmVudHM7XG4gICAgICBuYW1lc1tuYW1lXS5wdXNoKG51bUVsZW1lbnRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIG9mIGNvbWJpbmVkIGFycmF5XG4gIC8vIGFuZCByZXR1cm4gb25lIGZvciByZWZlcmVuY2VcbiAgZnVuY3Rpb24gZ2V0TGVuZ3RoT2ZDb21iaW5lZEFycmF5cyhuYW1lKSB7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IGFycmF5U3BlYztcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYXJyYXlPZkFycmF5cy5sZW5ndGg7ICsraWkpIHtcbiAgICAgIGNvbnN0IGFycmF5cyA9IGFycmF5T2ZBcnJheXNbaWldO1xuICAgICAgY29uc3QgYXJyYXlJbmZvID0gYXJyYXlzW25hbWVdO1xuICAgICAgY29uc3QgYXJyYXkgPSBnZXRBcnJheSQxKGFycmF5SW5mbyk7XG4gICAgICBsZW5ndGggKz0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFhcnJheVNwZWMgfHwgYXJyYXlJbmZvLmRhdGEpIHtcbiAgICAgICAgYXJyYXlTcGVjID0gYXJyYXlJbmZvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICBzcGVjOiBhcnJheVNwZWMsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlBcnJheXNUb05ld0FycmF5KG5hbWUsIGJhc2UsIG5ld0FycmF5KSB7XG4gICAgbGV0IGJhc2VJbmRleCA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGFycmF5T2ZBcnJheXMubGVuZ3RoOyArK2lpKSB7XG4gICAgICBjb25zdCBhcnJheXMgPSBhcnJheU9mQXJyYXlzW2lpXTtcbiAgICAgIGNvbnN0IGFycmF5SW5mbyA9IGFycmF5c1tuYW1lXTtcbiAgICAgIGNvbnN0IGFycmF5ID0gZ2V0QXJyYXkkMShhcnJheUluZm8pO1xuICAgICAgaWYgKG5hbWUgPT09ICdpbmRpY2VzJykge1xuICAgICAgICBjb3B5RWxlbWVudHMoYXJyYXksIG5ld0FycmF5LCBvZmZzZXQsIGJhc2VJbmRleCk7XG4gICAgICAgIGJhc2VJbmRleCArPSBiYXNlW2lpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlFbGVtZW50cyhhcnJheSwgbmV3QXJyYXksIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJhc2UgPSBuYW1lc1tiYXNlTmFtZV07XG5cbiAgY29uc3QgbmV3QXJyYXlzID0ge307XG4gIE9iamVjdC5rZXlzKG5hbWVzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBjb25zdCBpbmZvID0gZ2V0TGVuZ3RoT2ZDb21iaW5lZEFycmF5cyhuYW1lKTtcbiAgICBjb25zdCBuZXdBcnJheVNwZWMgPSBjcmVhdGVBcnJheU9mU2FtZVR5cGUoaW5mby5zcGVjLCBpbmZvLmxlbmd0aCk7XG4gICAgY29weUFycmF5c1RvTmV3QXJyYXkobmFtZSwgYmFzZSwgZ2V0QXJyYXkkMShuZXdBcnJheVNwZWMpKTtcbiAgICBuZXdBcnJheXNbbmFtZV0gPSBuZXdBcnJheVNwZWM7XG4gIH0pO1xuICByZXR1cm4gbmV3QXJyYXlzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkdXBsaWNhdGUgc2V0IG9mIHZlcnRpY2VzXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhbGxpbmcgcmVvcmllbnRWZXJ0aWNlcyB3aGVuIHlvdVxuICogYWxzbyB3YW50IHRvIGtlZXAgdGhlIG9yaWdpbmFsIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXJyYXlzfSBhcnJheXMgb2YgdmVydGljZXNcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkFycmF5c30gVGhlIGR1cGxpY2F0ZWQgdmVydGljZXMuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJpbWl0aXZlc1xuICovXG5mdW5jdGlvbiBkdXBsaWNhdGVWZXJ0aWNlcyhhcnJheXMpIHtcbiAgY29uc3QgbmV3QXJyYXlzID0ge307XG4gIE9iamVjdC5rZXlzKGFycmF5cykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgY29uc3QgYXJyYXlTcGVjID0gYXJyYXlzW25hbWVdO1xuICAgIGNvbnN0IHNyY0FycmF5ID0gZ2V0QXJyYXkkMShhcnJheVNwZWMpO1xuICAgIGNvbnN0IG5ld0FycmF5U3BlYyA9IGNyZWF0ZUFycmF5T2ZTYW1lVHlwZShhcnJheVNwZWMsIHNyY0FycmF5Lmxlbmd0aCk7XG4gICAgY29weUVsZW1lbnRzKHNyY0FycmF5LCBnZXRBcnJheSQxKG5ld0FycmF5U3BlYyksIDApO1xuICAgIG5ld0FycmF5c1tuYW1lXSA9IG5ld0FycmF5U3BlYztcbiAgfSk7XG4gIHJldHVybiBuZXdBcnJheXM7XG59XG5cbmNvbnN0IGNyZWF0ZTNERkJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGUzREZWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGUzREZCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGUzREZWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVDdWJlQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZUN1YmVWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVDdWJlQnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlQ3ViZVZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVBsYW5lQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVBsYW5lVmVydGljZXMpO1xuY29uc3QgY3JlYXRlUGxhbmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVQbGFuZVZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVNwaGVyZUJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVTcGhlcmVWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVTcGhlcmVCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVTcGhlcmVWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZVRydW5jYXRlZENvbmVWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlVHJ1bmNhdGVkQ29uZVZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVYWVF1YWRWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVYWVF1YWRCdWZmZXJzID0gY3JlYXRlQnVmZmVyRnVuYyhjcmVhdGVYWVF1YWRWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVDcmVzY2VudEJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVDcmVzY2VudFZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZUNyZXNjZW50QnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlQ3Jlc2NlbnRWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVDeWxpbmRlckJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVDeWxpbmRlclZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZUN5bGluZGVyQnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVUb3J1c0J1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnVuYyhjcmVhdGVUb3J1c1ZlcnRpY2VzKTtcbmNvbnN0IGNyZWF0ZVRvcnVzQnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlVG9ydXNWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVEaXNjQnVmZmVySW5mbyA9IGNyZWF0ZUJ1ZmZlckluZm9GdW5jKGNyZWF0ZURpc2NWZXJ0aWNlcyk7XG5jb25zdCBjcmVhdGVEaXNjQnVmZmVycyA9IGNyZWF0ZUJ1ZmZlckZ1bmMoY3JlYXRlRGlzY1ZlcnRpY2VzKTtcblxuLy8gdGhlc2Ugd2VyZSBtaXMtc3BlbGxlZCB1bnRpbCA0LjEyXG5jb25zdCBjcmVhdGVDcmVzZW50QnVmZmVySW5mbyA9IGNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbztcbmNvbnN0IGNyZWF0ZUNyZXNlbnRCdWZmZXJzID0gY3JlYXRlQ3Jlc2NlbnRCdWZmZXJzO1xuY29uc3QgY3JlYXRlQ3Jlc2VudFZlcnRpY2VzID0gY3JlYXRlQ3Jlc2NlbnRWZXJ0aWNlcztcblxudmFyIHByaW1pdGl2ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY3JlYXRlM0RGQnVmZmVySW5mbzogY3JlYXRlM0RGQnVmZmVySW5mbyxcbiAgY3JlYXRlM0RGQnVmZmVyczogY3JlYXRlM0RGQnVmZmVycyxcbiAgY3JlYXRlM0RGVmVydGljZXM6IGNyZWF0ZTNERlZlcnRpY2VzLFxuICBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5OiBjcmVhdGVBdWdtZW50ZWRUeXBlZEFycmF5LFxuICBjcmVhdGVDdWJlQnVmZmVySW5mbzogY3JlYXRlQ3ViZUJ1ZmZlckluZm8sXG4gIGNyZWF0ZUN1YmVCdWZmZXJzOiBjcmVhdGVDdWJlQnVmZmVycyxcbiAgY3JlYXRlQ3ViZVZlcnRpY2VzOiBjcmVhdGVDdWJlVmVydGljZXMsXG4gIGNyZWF0ZVBsYW5lQnVmZmVySW5mbzogY3JlYXRlUGxhbmVCdWZmZXJJbmZvLFxuICBjcmVhdGVQbGFuZUJ1ZmZlcnM6IGNyZWF0ZVBsYW5lQnVmZmVycyxcbiAgY3JlYXRlUGxhbmVWZXJ0aWNlczogY3JlYXRlUGxhbmVWZXJ0aWNlcyxcbiAgY3JlYXRlU3BoZXJlQnVmZmVySW5mbzogY3JlYXRlU3BoZXJlQnVmZmVySW5mbyxcbiAgY3JlYXRlU3BoZXJlQnVmZmVyczogY3JlYXRlU3BoZXJlQnVmZmVycyxcbiAgY3JlYXRlU3BoZXJlVmVydGljZXM6IGNyZWF0ZVNwaGVyZVZlcnRpY2VzLFxuICBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVySW5mbzogY3JlYXRlVHJ1bmNhdGVkQ29uZUJ1ZmZlckluZm8sXG4gIGNyZWF0ZVRydW5jYXRlZENvbmVCdWZmZXJzOiBjcmVhdGVUcnVuY2F0ZWRDb25lQnVmZmVycyxcbiAgY3JlYXRlVHJ1bmNhdGVkQ29uZVZlcnRpY2VzOiBjcmVhdGVUcnVuY2F0ZWRDb25lVmVydGljZXMsXG4gIGNyZWF0ZVhZUXVhZEJ1ZmZlckluZm86IGNyZWF0ZVhZUXVhZEJ1ZmZlckluZm8sXG4gIGNyZWF0ZVhZUXVhZEJ1ZmZlcnM6IGNyZWF0ZVhZUXVhZEJ1ZmZlcnMsXG4gIGNyZWF0ZVhZUXVhZFZlcnRpY2VzOiBjcmVhdGVYWVF1YWRWZXJ0aWNlcyxcbiAgY3JlYXRlQ3Jlc2VudEJ1ZmZlckluZm86IGNyZWF0ZUNyZXNlbnRCdWZmZXJJbmZvLFxuICBjcmVhdGVDcmVzZW50QnVmZmVyczogY3JlYXRlQ3Jlc2VudEJ1ZmZlcnMsXG4gIGNyZWF0ZUNyZXNlbnRWZXJ0aWNlczogY3JlYXRlQ3Jlc2VudFZlcnRpY2VzLFxuICBjcmVhdGVDcmVzY2VudEJ1ZmZlckluZm86IGNyZWF0ZUNyZXNjZW50QnVmZmVySW5mbyxcbiAgY3JlYXRlQ3Jlc2NlbnRCdWZmZXJzOiBjcmVhdGVDcmVzY2VudEJ1ZmZlcnMsXG4gIGNyZWF0ZUNyZXNjZW50VmVydGljZXM6IGNyZWF0ZUNyZXNjZW50VmVydGljZXMsXG4gIGNyZWF0ZUN5bGluZGVyQnVmZmVySW5mbzogY3JlYXRlQ3lsaW5kZXJCdWZmZXJJbmZvLFxuICBjcmVhdGVDeWxpbmRlckJ1ZmZlcnM6IGNyZWF0ZUN5bGluZGVyQnVmZmVycyxcbiAgY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlczogY3JlYXRlQ3lsaW5kZXJWZXJ0aWNlcyxcbiAgY3JlYXRlVG9ydXNCdWZmZXJJbmZvOiBjcmVhdGVUb3J1c0J1ZmZlckluZm8sXG4gIGNyZWF0ZVRvcnVzQnVmZmVyczogY3JlYXRlVG9ydXNCdWZmZXJzLFxuICBjcmVhdGVUb3J1c1ZlcnRpY2VzOiBjcmVhdGVUb3J1c1ZlcnRpY2VzLFxuICBjcmVhdGVEaXNjQnVmZmVySW5mbzogY3JlYXRlRGlzY0J1ZmZlckluZm8sXG4gIGNyZWF0ZURpc2NCdWZmZXJzOiBjcmVhdGVEaXNjQnVmZmVycyxcbiAgY3JlYXRlRGlzY1ZlcnRpY2VzOiBjcmVhdGVEaXNjVmVydGljZXMsXG4gIGRlaW5kZXhWZXJ0aWNlczogZGVpbmRleFZlcnRpY2VzLFxuICBmbGF0dGVuTm9ybWFsczogZmxhdHRlbk5vcm1hbHMsXG4gIG1ha2VSYW5kb21WZXJ0ZXhDb2xvcnM6IG1ha2VSYW5kb21WZXJ0ZXhDb2xvcnMsXG4gIHJlb3JpZW50RGlyZWN0aW9uczogcmVvcmllbnREaXJlY3Rpb25zLFxuICByZW9yaWVudE5vcm1hbHM6IHJlb3JpZW50Tm9ybWFscyxcbiAgcmVvcmllbnRQb3NpdGlvbnM6IHJlb3JpZW50UG9zaXRpb25zLFxuICByZW9yaWVudFZlcnRpY2VzOiByZW9yaWVudFZlcnRpY2VzLFxuICBjb25jYXRWZXJ0aWNlczogY29uY2F0VmVydGljZXMsXG4gIGR1cGxpY2F0ZVZlcnRpY2VzOiBkdXBsaWNhdGVWZXJ0aWNlc1xufSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBnbCB2ZXJzaW9uIGFzIGEgbnVtYmVyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge251bWJlcn0gdmVyc2lvbiBvZiBnbFxuICogQHByaXZhdGVcbiAqL1xuLy9mdW5jdGlvbiBnZXRWZXJzaW9uQXNOdW1iZXIoZ2wpIHtcbi8vICByZXR1cm4gcGFyc2VGbG9hdChnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuc3Vic3RyKDYpKTtcbi8vfVxuXG4vKipcbiAqIENoZWNrIGlmIGNvbnRleHQgaXMgV2ViR0wgMi4wXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgaXQncyBXZWJHTCAyLjBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5mdW5jdGlvbiBpc1dlYkdMMihnbCkge1xuICAvLyBUaGlzIGlzIHRoZSBjb3JyZWN0IGNoZWNrIGJ1dCBpdCdzIHNsb3dcbiAgLy8gIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVSU0lPTikuaW5kZXhPZihcIldlYkdMIDIuMFwiKSA9PT0gMDtcbiAgLy8gVGhpcyBtaWdodCBhbHNvIGJlIHRoZSBjb3JyZWN0IGNoZWNrIGJ1dCBJJ20gYXNzdW1pbmcgaXQncyBzbG93LWlzaFxuICAvLyByZXR1cm4gZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICByZXR1cm4gISFnbC50ZXhTdG9yYWdlMkQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgY29udGV4dCBpcyBXZWJHTCAxLjBcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHJldHVybiB7Ym9vbH0gdHJ1ZSBpZiBpdCdzIFdlYkdMIDEuMFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIGlzV2ViR0wxKGdsKSB7XG4gIC8vIFRoaXMgaXMgdGhlIGNvcnJlY3QgY2hlY2sgYnV0IGl0J3Mgc2xvd1xuICAvLyBjb25zdCB2ZXJzaW9uID0gZ2V0VmVyc2lvbkFzTnVtYmVyKGdsKTtcbiAgLy8gcmV0dXJuIHZlcnNpb24gPD0gMS4wICYmIHZlcnNpb24gPiAwLjA7ICAvLyBiZWNhdXNlIGFzIG9mIDIwMTYvNSBFZGdlIHJldHVybnMgMC45NlxuICAvLyBUaGlzIG1pZ2h0IGFsc28gYmUgdGhlIGNvcnJlY3QgY2hlY2sgYnV0IEknbSBhc3N1bWluZyBpdCdzIHNsb3ctaXNoXG4gIC8vIHJldHVybiBnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgcmV0dXJuICFnbC50ZXhTdG9yYWdlMkQ7XG59XG5cbi8qKlxuICogR2V0cyBhIHN0cmluZyBmb3IgV2ViR0wgZW51bVxuICpcbiAqIE5vdGU6IFNldmVyYWwgZW51bXMgYXJlIHRoZSBzYW1lLiBXaXRob3V0IG1vcmVcbiAqIGNvbnRleHQgKHdoaWNoIGZ1bmN0aW9uKSBpdCdzIGltcG9zc2libGUgdG8gYWx3YXlzXG4gKiBnaXZlIHRoZSBjb3JyZWN0IGVudW0uIEFzIGl0IGlzLCBmb3IgbWF0Y2hpbmcgdmFsdWVzXG4gKiBpdCBnaXZlcyBhbGwgZW51bXMuIENoZWNraW5nIHRoZSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiB0aGF0IG1lYW5zXG4gKlxuICogICAgICAwICAgICA9IFpFUk8gfCBQT0lOVCB8IE5PTkUgfCBOT19FUlJPUlxuICogICAgICAxICAgICA9IE9ORSB8IExJTkVTIHwgU1lOQ19GTFVTSF9DT01NQU5EU19CSVRcbiAqICAgICAgMzI3NzcgPSBCTEVORF9FUVVBVElPTl9SR0IgfCBCTEVORF9FUVVBVElPTl9SR0JcbiAqICAgICAgMzY2NjIgPSBDT1BZX1JFQURfQlVGRkVSIHwgQ09QWV9SRUFEX0JVRkZFUl9CSU5ESU5HXG4gKiAgICAgIDM2NjYzID0gQ09QWV9XUklURV9CVUZGRVIgfCBDT1BZX1dSSVRFX0JVRkZFUl9CSU5ESU5HXG4gKiAgICAgIDM2MDA2ID0gRlJBTUVCVUZGRVJfQklORElORyB8IERSQVdfRlJBTUVCVUZGRVJfQklORElOR1xuICpcbiAqIEl0J3MgYWxzbyBub3QgdXNlZnVsIGZvciBiaXRzIHJlYWxseSB1bmxlc3MgeW91IHBhc3MgaW4gaW5kaXZpZHVhbCBiaXRzLlxuICogSW4gb3RoZXIgd29yZHNcbiAqXG4gKiAgICAgY29uc3QgYml0cyA9IGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUO1xuICogICAgIHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZ2wsIGJpdHMpOyAgLy8gbm90IGdvaW5nIHRvIHdvcmtcbiAqXG4gKiBOb3RlIHRoYXQgc29tZSBlbnVtcyBvbmx5IGV4aXN0IG9uIGV4dGVuc2lvbnMuIElmIHlvdVxuICogd2FudCB0aGVtIHRvIHNob3cgdXAgeW91IG5lZWQgdG8gcGFzcyB0aGUgZXh0ZW5zaW9uIGF0IGxlYXN0XG4gKiBvbmNlLiBGb3IgZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XG4gKiAgICAgaWYgKGV4dCkge1xuICogICAgICAgIHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZXh0LCAwKTsgIC8vIGp1c3QgcHJpbWUgdGhlIGZ1bmN0aW9uXG4gKlxuICogICAgICAgIC4ubGF0ZXIuLlxuICpcbiAqICAgICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IGV4dC5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICogICAgICAgIGNvbnNvbGUubG9nKHR3Z2wuZ2xFbnVtVG9TdHJpbmcoZ2wsIGludGVybmFsRm9ybWF0KSk7XG4gKlxuICogTm90aWNlIEkgZGlkbid0IGhhdmUgdG8gcGFzcyB0aGUgZXh0ZW5zaW9uIHRoZSBzZWNvbmQgdGltZS4gVGhpcyBtZWFuc1xuICogeW91IGNhbiBoYXZlIHBsYWNlIHRoYXQgZ2VuZXJpY2FsbHkgZ2V0cyBhbiBlbnVtIGZvciB0ZXh0dXJlIGZvcm1hdHMgZm9yIGV4YW1wbGUuXG4gKiBhbmQgYXMgbG9uZyBhcyB5b3UgcHJpbWVkIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBleHRlbnNpb25zXG4gKlxuICogSWYgeW91J3JlIHVzaW5nIGB0d2dsLmFkZEV4dGVuc2lvbnNUb0NvbnRleHRgIHRvIGVuYWJsZSB5b3VyIGV4dGVuc2lvbnNcbiAqIHRoZW4gdHdnbCB3aWxsIGF1dG9tYXRpY2FsbHkgZ2V0IHRoZSBleHRlbnNpb24ncyBlbnVtcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgb3IgYW55IGV4dGVuc2lvbiBvYmplY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIGVudW0geW91IHdhbnQgdG8gbG9vayB1cC5cbiAqIEByZXR1cm4ge3N0cmluZ30gZW51bSBzdHJpbmcgb3IgaGV4IHZhbHVlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqIEBmdW5jdGlvbiBnbEVudW1Ub1N0cmluZ1xuICovXG5jb25zdCBnbEVudW1Ub1N0cmluZyA9IChmdW5jdGlvbigpIHtcbiAgY29uc3QgaGF2ZUVudW1zRm9yVHlwZSA9IHt9O1xuICBjb25zdCBlbnVtcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGFkZEVudW1zKGdsKSB7XG4gICAgY29uc3QgdHlwZSA9IGdsLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKCFoYXZlRW51bXNGb3JUeXBlW3R5cGVdKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBnbCkge1xuICAgICAgICBpZiAodHlwZW9mIGdsW2tleV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBlbnVtc1tnbFtrZXldXTtcbiAgICAgICAgICBlbnVtc1tnbFtrZXldXSA9IGV4aXN0aW5nID8gYCR7ZXhpc3Rpbmd9IHwgJHtrZXl9YCA6IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGF2ZUVudW1zRm9yVHlwZVt0eXBlXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGdsRW51bVRvU3RyaW5nKGdsLCB2YWx1ZSkge1xuICAgIGFkZEVudW1zKGdsKTtcbiAgICByZXR1cm4gZW51bXNbdmFsdWVdIHx8ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gYDB4JHt2YWx1ZS50b1N0cmluZygxNil9YCA6IHZhbHVlKTtcbiAgfTtcbn0oKSk7XG5cbnZhciB1dGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnbEVudW1Ub1N0cmluZzogZ2xFbnVtVG9TdHJpbmcsXG4gIGlzV2ViR0wxOiBpc1dlYkdMMSxcbiAgaXNXZWJHTDI6IGlzV2ViR0wyXG59KTtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuY29uc3QgZGVmYXVsdHMkMSA9IHtcbiAgdGV4dHVyZUNvbG9yOiBuZXcgVWludDhBcnJheShbMTI4LCAxOTIsIDI1NSwgMjU1XSksXG4gIHRleHR1cmVPcHRpb25zOiB7fSxcbiAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcbn07XG5jb25zdCBpc0FycmF5QnVmZmVyJDEgPSBpc0FycmF5QnVmZmVyO1xuXG4vLyBTaG91bGQgd2UgbWFrZSB0aGlzIG9uIGRlbWFuZD9cbmNvbnN0IGdldFNoYXJlZDJEQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgc19jdHg7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRTaGFyZWQyRENvbnRleHQoKSB7XG4gICAgc19jdHggPSBzX2N0eCB8fFxuICAgICAgICAoKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudClcbiAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgICAgICAgOiBudWxsKTtcbiAgICByZXR1cm4gc19jdHg7XG4gIH07XG59KCk7XG5cbi8vIE5PVEU6IENocm9tZSBzdXBwb3J0cyAyRCBjYW52YXMgaW4gYSBXb3JrZXIgKGJlaGluZCBmbGFnIGFzIG9mIHY2NCBidXRcbi8vICAgICAgIG5vdCBvbmx5IGRvZXMgRmlyZWZveCBOT1Qgc3VwcG9ydCBpdCBidXQgRmlyZWZveCBmcmVlemVzIGltbWVkaWF0ZWx5XG4vLyAgICAgICBpZiB5b3UgdHJ5IHRvIGNyZWF0ZSBvbmUgaW5zdGVhZCBvZiBqdXN0IHJldHVybmluZyBudWxsIGFuZCBjb250aW51aW5nLlxuLy8gIDogKGdsb2JhbC5PZmZzY3JlZW5DYW52YXMgJiYgKG5ldyBnbG9iYWwuT2Zmc2NyZWVuQ2FudmFzKDEsIDEpKS5nZXRDb250ZXh0KFwiMmRcIikpOyAgLy8gT2Zmc2NyZWVuQ2FudmFzIG1heSBub3Qgc3VwcG9ydCAyZFxuXG4vLyBOT1RFOiBXZSBjYW4gbWF5YmUgcmVtb3ZlIHNvbWUgb2YgdGhlIG5lZWQgZm9yIHRoZSAyZCBjYW52YXMuIEluIFdlYkdMMlxuLy8gd2UgY2FuIHVzZSB0aGUgdmFyaW91cyB1bnBhY2sgc2V0dGluZ3MuIE90aGVyd2lzZSB3ZSBjb3VsZCB0cnkgdXNpbmdcbi8vIHRoZSBhYmlsaXR5IG9mIGFuIEltYWdlQml0bWFwIHRvIGJlIGN1dC4gVW5mb3J0dW5hdGVseSBjdXR0aW5nIGFuIEltYWdlQml0bWFwXG4vLyBpcyBhc3luYyBhbmQgdGhlIGN1cnJlbnQgVFdHTCBjb2RlIGV4cGVjdHMgYSBub24tQXN5bmMgcmVzdWx0IHRob3VnaCB0aGF0XG4vLyBtaWdodCBub3QgYmUgYSBwcm9ibGVtLiBJbWFnZUJpdG1hcCB0aG91Z2ggaXMgbm90IGF2YWlsYWJsZSBpbiBFZGdlIG9yIFNhZmFyaVxuLy8gYXMgb2YgMjAxOC0wMS0wMlxuXG4vKiBQaXhlbEZvcm1hdCAqL1xuY29uc3QgQUxQSEEgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxOTA2O1xuY29uc3QgUkdCICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxOTA3O1xuY29uc3QgUkdCQSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxOTA4O1xuY29uc3QgTFVNSU5BTkNFICAgICAgICAgICAgICAgICAgICAgID0gMHgxOTA5O1xuY29uc3QgTFVNSU5BTkNFX0FMUEhBICAgICAgICAgICAgICAgID0gMHgxOTBBO1xuY29uc3QgREVQVEhfQ09NUE9ORU5UICAgICAgICAgICAgICAgID0gMHgxOTAyO1xuY29uc3QgREVQVEhfU1RFTkNJTCAgICAgICAgICAgICAgICAgID0gMHg4NEY5O1xuXG4vKiBUZXh0dXJlV3JhcE1vZGUgKi9cbi8vIGNvbnN0IFJFUEVBVCAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MjkwMTtcbi8vIGNvbnN0IE1JUlJPUkVEX1JFUEVBVCAgICAgICAgICAgICAgICA9IDB4ODM3MDtcbmNvbnN0IENMQU1QX1RPX0VER0UgICAgICAgICAgICAgICAgICA9IDB4ODEyZjtcblxuLyogVGV4dHVyZU1hZ0ZpbHRlciAqL1xuY29uc3QgTkVBUkVTVCAgICAgICAgICAgICAgICAgICAgICAgID0gMHgyNjAwO1xuY29uc3QgTElORUFSICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgyNjAxO1xuXG4vKiBUZXh0dXJlTWluRmlsdGVyICovXG4vLyBjb25zdCBORUFSRVNUX01JUE1BUF9ORUFSRVNUICAgICAgICAgPSAweDI3MDA7XG4vLyBjb25zdCBMSU5FQVJfTUlQTUFQX05FQVJFU1QgICAgICAgICAgPSAweDI3MDE7XG4vLyBjb25zdCBORUFSRVNUX01JUE1BUF9MSU5FQVIgICAgICAgICAgPSAweDI3MDI7XG4vLyBjb25zdCBMSU5FQVJfTUlQTUFQX0xJTkVBUiAgICAgICAgICAgPSAweDI3MDM7XG5cbi8qIFRleHR1cmUgVGFyZ2V0ICovXG5jb25zdCBURVhUVVJFXzJEICAgICAgICAgICAgICAgICAgICAgPSAweDBkZTE7XG5jb25zdCBURVhUVVJFX0NVQkVfTUFQICAgICAgICAgICAgICAgPSAweDg1MTM7XG5jb25zdCBURVhUVVJFXzNEICAgICAgICAgICAgICAgICAgICAgPSAweDgwNmY7XG5jb25zdCBURVhUVVJFXzJEX0FSUkFZICAgICAgICAgICAgICAgPSAweDhjMWE7XG5cbi8qIEN1YmVtYXAgVGFyZ2V0cyAqL1xuY29uc3QgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICAgID0gMHg4NTE1O1xuY29uc3QgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YICAgID0gMHg4NTE2O1xuY29uc3QgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZICAgID0gMHg4NTE3O1xuY29uc3QgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZICAgID0gMHg4NTE4O1xuY29uc3QgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aICAgID0gMHg4NTE5O1xuY29uc3QgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aICAgID0gMHg4NTFhO1xuXG4vKiBUZXh0dXJlIFBhcmFtZXRlcnMgKi9cbmNvbnN0IFRFWFRVUkVfTUlOX0ZJTFRFUiAgICAgICAgICAgICA9IDB4MjgwMTtcbmNvbnN0IFRFWFRVUkVfTUFHX0ZJTFRFUiAgICAgICAgICAgICA9IDB4MjgwMDtcbmNvbnN0IFRFWFRVUkVfV1JBUF9TICAgICAgICAgICAgICAgICA9IDB4MjgwMjtcbmNvbnN0IFRFWFRVUkVfV1JBUF9UICAgICAgICAgICAgICAgICA9IDB4MjgwMztcbmNvbnN0IFRFWFRVUkVfV1JBUF9SICAgICAgICAgICAgICAgICA9IDB4ODA3MjtcbmNvbnN0IFRFWFRVUkVfTUlOX0xPRCAgICAgICAgICAgICAgICA9IDB4ODEzYTtcbmNvbnN0IFRFWFRVUkVfTUFYX0xPRCAgICAgICAgICAgICAgICA9IDB4ODEzYjtcbmNvbnN0IFRFWFRVUkVfQkFTRV9MRVZFTCAgICAgICAgICAgICA9IDB4ODEzYztcbmNvbnN0IFRFWFRVUkVfTUFYX0xFVkVMICAgICAgICAgICAgICA9IDB4ODEzZDtcblxuXG4vKiBQaXhlbCBzdG9yZSAqL1xuY29uc3QgVU5QQUNLX0FMSUdOTUVOVCAgICAgICAgICAgICAgICAgICA9IDB4MGNmNTtcbmNvbnN0IFVOUEFDS19ST1dfTEVOR1RIICAgICAgICAgICAgICAgICAgPSAweDBjZjI7XG5jb25zdCBVTlBBQ0tfSU1BR0VfSEVJR0hUICAgICAgICAgICAgICAgID0gMHg4MDZlO1xuY29uc3QgVU5QQUNLX1NLSVBfUElYRUxTICAgICAgICAgICAgICAgICA9IDB4MGNmNDtcbmNvbnN0IFVOUEFDS19TS0lQX1JPV1MgICAgICAgICAgICAgICAgICAgPSAweDBjZjM7XG5jb25zdCBVTlBBQ0tfU0tJUF9JTUFHRVMgICAgICAgICAgICAgICAgID0gMHg4MDZkO1xuY29uc3QgVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCA9IDB4OTI0MztcbmNvbnN0IFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCAgICAgPSAweDkyNDE7XG5jb25zdCBVTlBBQ0tfRkxJUF9ZX1dFQkdMICAgICAgICAgICAgICAgID0gMHg5MjQwO1xuXG5jb25zdCBSOCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjI5O1xuY29uc3QgUjhfU05PUk0gICAgICAgICAgICAgICAgICAgICA9IDB4OEY5NDtcbmNvbnN0IFIxNkYgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMkQ7XG5jb25zdCBSMzJGICAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjJFO1xuY29uc3QgUjhVSSAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzMjtcbmNvbnN0IFI4SSAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMzE7XG5jb25zdCBSRzE2VUkgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjNBO1xuY29uc3QgUkcxNkkgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzOTtcbmNvbnN0IFJHMzJVSSAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyM0M7XG5jb25zdCBSRzMySSAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjNCO1xuY29uc3QgUkc4ICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIyQjtcbmNvbnN0IFJHOF9TTk9STSAgICAgICAgICAgICAgICAgICAgPSAweDhGOTU7XG5jb25zdCBSRzE2RiAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjJGO1xuY29uc3QgUkczMkYgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzMDtcbmNvbnN0IFJHOFVJICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMzg7XG5jb25zdCBSRzhJICAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjM3O1xuY29uc3QgUjE2VUkgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzNDtcbmNvbnN0IFIxNkkgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMzM7XG5jb25zdCBSMzJVSSAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4MjM2O1xuY29uc3QgUjMySSAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODIzNTtcbmNvbnN0IFJHQjggICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgwNTE7XG5jb25zdCBTUkdCOCAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4QzQxO1xuY29uc3QgUkdCNTY1ICAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ2MjtcbmNvbnN0IFJHQjhfU05PUk0gICAgICAgICAgICAgICAgICAgPSAweDhGOTY7XG5jb25zdCBSMTFGX0cxMUZfQjEwRiAgICAgICAgICAgICAgID0gMHg4QzNBO1xuY29uc3QgUkdCOV9FNSAgICAgICAgICAgICAgICAgICAgICA9IDB4OEMzRDtcbmNvbnN0IFJHQjE2RiAgICAgICAgICAgICAgICAgICAgICAgPSAweDg4MUI7XG5jb25zdCBSR0IzMkYgICAgICAgICAgICAgICAgICAgICAgID0gMHg4ODE1O1xuY29uc3QgUkdCOFVJICAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ3RDtcbmNvbnN0IFJHQjhJICAgICAgICAgICAgICAgICAgICAgICAgPSAweDhEOEY7XG5jb25zdCBSR0IxNlVJICAgICAgICAgICAgICAgICAgICAgID0gMHg4RDc3O1xuY29uc3QgUkdCMTZJICAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ4OTtcbmNvbnN0IFJHQjMyVUkgICAgICAgICAgICAgICAgICAgICAgPSAweDhENzE7XG5jb25zdCBSR0IzMkkgICAgICAgICAgICAgICAgICAgICAgID0gMHg4RDgzO1xuY29uc3QgUkdCQTggICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODA1ODtcbmNvbnN0IFNSR0I4X0FMUEhBOCAgICAgICAgICAgICAgICAgPSAweDhDNDM7XG5jb25zdCBSR0JBOF9TTk9STSAgICAgICAgICAgICAgICAgID0gMHg4Rjk3O1xuY29uc3QgUkdCNV9BMSAgICAgICAgICAgICAgICAgICAgICA9IDB4ODA1NztcbmNvbnN0IFJHQkE0ICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgwNTY7XG5jb25zdCBSR0IxMF9BMiAgICAgICAgICAgICAgICAgICAgID0gMHg4MDU5O1xuY29uc3QgUkdCQTE2RiAgICAgICAgICAgICAgICAgICAgICA9IDB4ODgxQTtcbmNvbnN0IFJHQkEzMkYgICAgICAgICAgICAgICAgICAgICAgPSAweDg4MTQ7XG5jb25zdCBSR0JBOFVJICAgICAgICAgICAgICAgICAgICAgID0gMHg4RDdDO1xuY29uc3QgUkdCQThJICAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ4RTtcbmNvbnN0IFJHQjEwX0EyVUkgICAgICAgICAgICAgICAgICAgPSAweDkwNkY7XG5jb25zdCBSR0JBMTZVSSAgICAgICAgICAgICAgICAgICAgID0gMHg4RDc2O1xuY29uc3QgUkdCQTE2SSAgICAgICAgICAgICAgICAgICAgICA9IDB4OEQ4ODtcbmNvbnN0IFJHQkEzMkkgICAgICAgICAgICAgICAgICAgICAgPSAweDhEODI7XG5jb25zdCBSR0JBMzJVSSAgICAgICAgICAgICAgICAgICAgID0gMHg4RDcwO1xuXG5jb25zdCBERVBUSF9DT01QT05FTlQxNiAgICAgICAgICAgID0gMHg4MUE1O1xuY29uc3QgREVQVEhfQ09NUE9ORU5UMjQgICAgICAgICAgICA9IDB4ODFBNjtcbmNvbnN0IERFUFRIX0NPTVBPTkVOVDMyRiAgICAgICAgICAgPSAweDhDQUM7XG5jb25zdCBERVBUSDMyRl9TVEVOQ0lMOCAgICAgICAgICAgID0gMHg4Q0FEO1xuY29uc3QgREVQVEgyNF9TVEVOQ0lMOCAgICAgICAgICAgICA9IDB4ODhGMDtcblxuLyogRGF0YVR5cGUgKi9cbmNvbnN0IEJZVEUkMiAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMDtcbmNvbnN0IFVOU0lHTkVEX0JZVEUkMiAgICAgICAgICAgICAgICA9IDB4MTQwMTtcbmNvbnN0IFNIT1JUJDIgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMjtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUJDIgICAgICAgICAgICAgICA9IDB4MTQwMztcbmNvbnN0IElOVCQyICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNDtcbmNvbnN0IFVOU0lHTkVEX0lOVCQyICAgICAgICAgICAgICAgICA9IDB4MTQwNTtcbmNvbnN0IEZMT0FUJDIgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNjtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUXzRfNF80XzQkMSAgICAgICA9IDB4ODAzMztcbmNvbnN0IFVOU0lHTkVEX1NIT1JUXzVfNV81XzEkMSAgICAgICA9IDB4ODAzNDtcbmNvbnN0IFVOU0lHTkVEX1NIT1JUXzVfNl81JDEgICAgICAgICA9IDB4ODM2MztcbmNvbnN0IEhBTEZfRkxPQVQkMSAgICAgICAgICAgICAgICAgICA9IDB4MTQwQjtcbmNvbnN0IEhBTEZfRkxPQVRfT0VTICAgICAgICAgICAgICAgPSAweDhENjE7ICAvLyBUaGFua3MgS2hyb25vcyBmb3IgbWFraW5nIHRoaXMgZGlmZmVyZW50ID46KFxuY29uc3QgVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWJDEgID0gMHg4MzY4O1xuY29uc3QgVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFViQxID0gMHg4QzNCO1xuY29uc3QgVU5TSUdORURfSU5UXzVfOV85XzlfUkVWJDEgICAgID0gMHg4QzNFO1xuY29uc3QgRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWJDEgPSAweDhEQUQ7XG5jb25zdCBVTlNJR05FRF9JTlRfMjRfOCQxICAgICAgICAgICAgPSAweDg0RkE7XG5cbmNvbnN0IFJHICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgyMjc7XG5jb25zdCBSR19JTlRFR0VSICAgICAgICAgICAgICAgICAgID0gMHg4MjI4O1xuY29uc3QgUkVEICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTkwMztcbmNvbnN0IFJFRF9JTlRFR0VSICAgICAgICAgICAgICAgICAgPSAweDhEOTQ7XG5jb25zdCBSR0JfSU5URUdFUiAgICAgICAgICAgICAgICAgID0gMHg4RDk4O1xuY29uc3QgUkdCQV9JTlRFR0VSICAgICAgICAgICAgICAgICA9IDB4OEQ5OTtcblxuY29uc3QgZm9ybWF0SW5mbyA9IHt9O1xue1xuICAvLyBOT1RFOiB0aGlzIGlzIG5hbWVkIGBudW1Db2xvckNvbXBvbmVudHNgIHZzIGBudW1Db21wb25lbnRzYCBzbyB3ZSBjYW4gbGV0IFVnbGlmeSBtYW5nbGVcbiAgLy8gdGhlIG5hbWUuXG4gIGNvbnN0IGYgPSBmb3JtYXRJbmZvO1xuICBmW0FMUEhBXSAgICAgICAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogMSwgfTtcbiAgZltMVU1JTkFOQ0VdICAgICAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDEsIH07XG4gIGZbTFVNSU5BTkNFX0FMUEhBXSA9IHsgbnVtQ29sb3JDb21wb25lbnRzOiAyLCB9O1xuICBmW1JHQl0gICAgICAgICAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogMywgfTtcbiAgZltSR0JBXSAgICAgICAgICAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDQsIH07XG4gIGZbUkVEXSAgICAgICAgICAgICA9IHsgbnVtQ29sb3JDb21wb25lbnRzOiAxLCB9O1xuICBmW1JFRF9JTlRFR0VSXSAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogMSwgfTtcbiAgZltSR10gICAgICAgICAgICAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDIsIH07XG4gIGZbUkdfSU5URUdFUl0gICAgICA9IHsgbnVtQ29sb3JDb21wb25lbnRzOiAyLCB9O1xuICBmW1JHQl0gICAgICAgICAgICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogMywgfTtcbiAgZltSR0JfSU5URUdFUl0gICAgID0geyBudW1Db2xvckNvbXBvbmVudHM6IDMsIH07XG4gIGZbUkdCQV0gICAgICAgICAgICA9IHsgbnVtQ29sb3JDb21wb25lbnRzOiA0LCB9O1xuICBmW1JHQkFfSU5URUdFUl0gICAgPSB7IG51bUNvbG9yQ29tcG9uZW50czogNCwgfTtcbiAgZltERVBUSF9DT01QT05FTlRdID0geyBudW1Db2xvckNvbXBvbmVudHM6IDEsIH07XG4gIGZbREVQVEhfU1RFTkNJTF0gICA9IHsgbnVtQ29sb3JDb21wb25lbnRzOiAyLCB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHR1cmVGb3JtYXREZXRhaWxzXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGV4dHVyZUZvcm1hdCBmb3JtYXQgdG8gcGFzcyB0ZXhJbWFnZTJEIGFuZCBzaW1pbGFyIGZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29sb3JSZW5kZXJhYmxlIHRydWUgaWYgeW91IGNhbiByZW5kZXIgdG8gdGhpcyBmb3JtYXQgb2YgdGV4dHVyZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdGV4dHVyZUZpbHRlcmFibGUgdHJ1ZSBpZiB5b3UgY2FuIGZpbHRlciB0aGUgdGV4dHVyZSwgZmFsc2UgaWYgeW91IGNhbiBvbnkgdXNlIGBORUFSRVNUYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IHR5cGUgQXJyYXkgb2YgcG9zc2libGUgdHlwZXMgeW91IGNhbiBwYXNzIHRvIHRleEltYWdlMkQgYW5kIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxudW1iZXIsbnVtYmVyPn0gYnl0ZXNQZXJFbGVtZW50TWFwIEEgbWFwIG9mIHR5cGVzIHRvIGJ5dGVzIHBlciBlbGVtZW50XG4gKiBAcHJpdmF0ZVxuICovXG5cbmxldCBzX3RleHR1cmVJbnRlcm5hbEZvcm1hdEluZm87XG5mdW5jdGlvbiBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvKGludGVybmFsRm9ybWF0KSB7XG4gIGlmICghc190ZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvKSB7XG4gICAgLy8gTk9URTogdGhlc2UgcHJvcGVydGllcyBuZWVkIHVuaXF1ZSBuYW1lcyBzbyB3ZSBjYW4gbGV0IFVnbGlmeSBtYW5nbGUgdGhlIG5hbWUuXG4gICAgY29uc3QgdCA9IHt9O1xuICAgIC8vIHVuc2l6ZWQgZm9ybWF0c1xuICAgIHRbQUxQSEFdICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogQUxQSEEsICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzEsIDIsIDIsIDRdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMiwgSEFMRl9GTE9BVCQxLCBIQUxGX0ZMT0FUX09FUywgRkxPQVQkMl0sIH07XG4gICAgdFtMVU1JTkFOQ0VdICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBMVU1JTkFOQ0UsICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMSwgMiwgMiwgNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQyLCBIQUxGX0ZMT0FUJDEsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVCQyXSwgfTtcbiAgICB0W0xVTUlOQU5DRV9BTFBIQV0gICAgPSB7IHRleHR1cmVGb3JtYXQ6IExVTUlOQU5DRV9BTFBIQSwgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFsyLCA0LCA0LCA4XSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFJDIsIEhBTEZfRkxPQVQkMSwgSEFMRl9GTE9BVF9PRVMsIEZMT0FUJDJdLCB9O1xuICAgIHRbUkdCXSAgICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCLCAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzMsIDYsIDYsIDEyLCAyXSwgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMiwgSEFMRl9GTE9BVCQxLCBIQUxGX0ZMT0FUX09FUywgRkxPQVQkMiwgVU5TSUdORURfU0hPUlRfNV82XzUkMV0sIH07XG4gICAgdFtSR0JBXSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgOCwgOCwgMTYsIDIsIDJdLCB0eXBlOiBbVU5TSUdORURfQllURSQyLCBIQUxGX0ZMT0FUJDEsIEhBTEZfRkxPQVRfT0VTLCBGTE9BVCQyLCBVTlNJR05FRF9TSE9SVF80XzRfNF80JDEsIFVOU0lHTkVEX1NIT1JUXzVfNV81XzEkMV0sIH07XG4gICAgdFtERVBUSF9DT01QT05FTlRdICAgID0geyB0ZXh0dXJlRm9ybWF0OiBERVBUSF9DT01QT05FTlQsIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMiwgNF0sICAgICAgICAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UJDIsIFVOU0lHTkVEX1NIT1JUJDJdLCB9O1xuXG4gICAgLy8gc2l6ZWQgZm9ybWF0c1xuICAgIHRbUjhdICAgICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkVELCAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzFdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMl0sIH07XG4gICAgdFtSOF9TTk9STV0gICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRUQsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMV0sICAgICAgICB0eXBlOiBbQllURSQyXSwgfTtcbiAgICB0W1IxNkZdICAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJFRCwgICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFs0LCAyXSwgICAgIHR5cGU6IFtGTE9BVCQyLCBIQUxGX0ZMT0FUJDFdLCB9O1xuICAgIHRbUjMyRl0gICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkVELCAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzRdLCAgICAgICAgdHlwZTogW0ZMT0FUJDJdLCB9O1xuICAgIHRbUjhVSV0gICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkVEX0lOVEVHRVIsICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzFdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMl0sIH07XG4gICAgdFtSOEldICAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUiwgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMV0sICAgICAgICB0eXBlOiBbQllURSQyXSwgfTtcbiAgICB0W1IxNlVJXSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsyXSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVCQyXSwgfTtcbiAgICB0W1IxNkldICAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsyXSwgICAgICAgIHR5cGU6IFtTSE9SVCQyXSwgfTtcbiAgICB0W1IzMlVJXSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJFRF9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlQkMl0sIH07XG4gICAgdFtSMzJJXSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRURfSU5URUdFUiwgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbSU5UJDJdLCB9O1xuICAgIHRbUkc4XSAgICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkcsICAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzJdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMl0sIH07XG4gICAgdFtSRzhfU05PUk1dICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSRywgICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMl0sICAgICAgICB0eXBlOiBbQllURSQyXSwgfTtcbiAgICB0W1JHMTZGXSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHLCAgICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFs4LCA0XSwgICAgIHR5cGU6IFtGTE9BVCQyLCBIQUxGX0ZMT0FUJDFdLCB9O1xuICAgIHRbUkczMkZdICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkcsICAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzhdLCAgICAgICAgdHlwZTogW0ZMT0FUJDJdLCB9O1xuICAgIHRbUkc4VUldICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdfSU5URUdFUiwgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzJdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMl0sIH07XG4gICAgdFtSRzhJXSAgICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR19JTlRFR0VSLCAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMl0sICAgICAgICB0eXBlOiBbQllURSQyXSwgfTtcbiAgICB0W1JHMTZVSV0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVCQyXSwgfTtcbiAgICB0W1JHMTZJXSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtTSE9SVCQyXSwgfTtcbiAgICB0W1JHMzJVSV0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHX0lOVEVHRVIsICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs4XSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlQkMl0sIH07XG4gICAgdFtSRzMySV0gICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR19JTlRFR0VSLCAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbOF0sICAgICAgICB0eXBlOiBbSU5UJDJdLCB9O1xuICAgIHRbUkdCOF0gICAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCLCAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzNdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0JZVEUkMl0sIH07XG4gICAgdFtTUkdCOF0gICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbM10sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQyXSwgfTtcbiAgICB0W1JHQjU2NV0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQiwgICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFszLCAyXSwgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFJDIsIFVOU0lHTkVEX1NIT1JUXzVfNl81JDFdLCB9O1xuICAgIHRbUkdCOF9TTk9STV0gICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCLCAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzNdLCAgICAgICAgdHlwZTogW0JZVEUkMl0sIH07XG4gICAgdFtSMTFGX0cxMUZfQjEwRl0gICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbMTIsIDYsIDRdLCB0eXBlOiBbRkxPQVQkMiwgSEFMRl9GTE9BVCQxLCBVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWJDFdLCB9O1xuICAgIHRbUkdCOV9FNV0gICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCLCAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzEyLCA2LCA0XSwgdHlwZTogW0ZMT0FUJDIsIEhBTEZfRkxPQVQkMSwgVU5TSUdORURfSU5UXzVfOV85XzlfUkVWJDFdLCB9O1xuICAgIHRbUkdCMTZGXSAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCLCAgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzEyLCA2XSwgICAgdHlwZTogW0ZMT0FUJDIsIEhBTEZfRkxPQVQkMV0sIH07XG4gICAgdFtSR0IzMkZdICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0IsICAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMTJdLCAgICAgICB0eXBlOiBbRkxPQVQkMl0sIH07XG4gICAgdFtSR0I4VUldICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JfSU5URUdFUiwgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbM10sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQyXSwgfTtcbiAgICB0W1JHQjhJXSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFszXSwgICAgICAgIHR5cGU6IFtCWVRFJDJdLCB9O1xuICAgIHRbUkdCMTZVSV0gICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzZdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX1NIT1JUJDJdLCB9O1xuICAgIHRbUkdCMTZJXSAgICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzZdLCAgICAgICAgdHlwZTogW1NIT1JUJDJdLCB9O1xuICAgIHRbUkdCMzJVSV0gICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCX0lOVEVHRVIsICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzEyXSwgICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVCQyXSwgfTtcbiAgICB0W1JHQjMySV0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQl9JTlRFR0VSLCAgICAgY29sb3JSZW5kZXJhYmxlOiBmYWxzZSwgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsxMl0sICAgICAgIHR5cGU6IFtJTlQkMl0sIH07XG4gICAgdFtSR0JBOF0gICAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQyXSwgfTtcbiAgICB0W1NSR0I4X0FMUEhBOF0gICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkEsICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFJDJdLCB9O1xuICAgIHRbUkdCQThfU05PUk1dICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQSwgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzRdLCAgICAgICAgdHlwZTogW0JZVEUkMl0sIH07XG4gICAgdFtSR0I1X0ExXSAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbNCwgMiwgNF0sICB0eXBlOiBbVU5TSUdORURfQllURSQyLCBVTlNJR05FRF9TSE9SVF81XzVfNV8xJDEsIFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViQxXSwgfTtcbiAgICB0W1JHQkE0XSAgICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkEsICAgICAgICAgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IHRydWUsICBieXRlc1BlckVsZW1lbnQ6IFs0LCAyXSwgICAgIHR5cGU6IFtVTlNJR05FRF9CWVRFJDIsIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQkMV0sIH07XG4gICAgdFtSR0IxMF9BMl0gICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiB0cnVlLCAgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWJDFdLCB9O1xuICAgIHRbUkdCQTE2Rl0gICAgICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQSwgICAgICAgICAgICBjb2xvclJlbmRlcmFibGU6IGZhbHNlLCB0ZXh0dXJlRmlsdGVyYWJsZTogdHJ1ZSwgIGJ5dGVzUGVyRWxlbWVudDogWzE2LCA4XSwgICAgdHlwZTogW0ZMT0FUJDIsIEhBTEZfRkxPQVQkMV0sIH07XG4gICAgdFtSR0JBMzJGXSAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBLCAgICAgICAgICAgIGNvbG9yUmVuZGVyYWJsZTogZmFsc2UsIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMTZdLCAgICAgICB0eXBlOiBbRkxPQVQkMl0sIH07XG4gICAgdFtSR0JBOFVJXSAgICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbNF0sICAgICAgICB0eXBlOiBbVU5TSUdORURfQllURSQyXSwgfTtcbiAgICB0W1JHQkE4SV0gICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUiwgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtCWVRFJDJdLCB9O1xuICAgIHRbUkdCMTBfQTJVSV0gICAgICAgICA9IHsgdGV4dHVyZUZvcm1hdDogUkdCQV9JTlRFR0VSLCAgICBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzRdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViQxXSwgfTtcbiAgICB0W1JHQkExNlVJXSAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUiwgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs4XSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9TSE9SVCQyXSwgfTtcbiAgICB0W1JHQkExNkldICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUiwgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs4XSwgICAgICAgIHR5cGU6IFtTSE9SVCQyXSwgfTtcbiAgICB0W1JHQkEzMkldICAgICAgICAgICAgPSB7IHRleHR1cmVGb3JtYXQ6IFJHQkFfSU5URUdFUiwgICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFsxNl0sICAgICAgIHR5cGU6IFtJTlQkMl0sIH07XG4gICAgdFtSR0JBMzJVSV0gICAgICAgICAgID0geyB0ZXh0dXJlRm9ybWF0OiBSR0JBX0lOVEVHRVIsICAgIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMTZdLCAgICAgICB0eXBlOiBbVU5TSUdORURfSU5UJDJdLCB9O1xuICAgIC8vIFNpemVkIEludGVybmFsXG4gICAgdFtERVBUSF9DT01QT05FTlQxNl0gID0geyB0ZXh0dXJlRm9ybWF0OiBERVBUSF9DT01QT05FTlQsIGNvbG9yUmVuZGVyYWJsZTogdHJ1ZSwgIHRleHR1cmVGaWx0ZXJhYmxlOiBmYWxzZSwgYnl0ZXNQZXJFbGVtZW50OiBbMiwgNF0sICAgICB0eXBlOiBbVU5TSUdORURfU0hPUlQkMiwgVU5TSUdORURfSU5UJDJdLCB9O1xuICAgIHRbREVQVEhfQ09NUE9ORU5UMjRdICA9IHsgdGV4dHVyZUZvcm1hdDogREVQVEhfQ09NUE9ORU5ULCBjb2xvclJlbmRlcmFibGU6IHRydWUsICB0ZXh0dXJlRmlsdGVyYWJsZTogZmFsc2UsIGJ5dGVzUGVyRWxlbWVudDogWzRdLCAgICAgICAgdHlwZTogW1VOU0lHTkVEX0lOVCQyXSwgfTtcbiAgICB0W0RFUFRIX0NPTVBPTkVOVDMyRl0gPSB7IHRleHR1cmVGb3JtYXQ6IERFUFRIX0NPTVBPTkVOVCwgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtGTE9BVCQyXSwgfTtcbiAgICB0W0RFUFRIMjRfU1RFTkNJTDhdICAgPSB7IHRleHR1cmVGb3JtYXQ6IERFUFRIX1NURU5DSUwsICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtVTlNJR05FRF9JTlRfMjRfOCQxXSwgfTtcbiAgICB0W0RFUFRIMzJGX1NURU5DSUw4XSAgPSB7IHRleHR1cmVGb3JtYXQ6IERFUFRIX1NURU5DSUwsICAgY29sb3JSZW5kZXJhYmxlOiB0cnVlLCAgdGV4dHVyZUZpbHRlcmFibGU6IGZhbHNlLCBieXRlc1BlckVsZW1lbnQ6IFs0XSwgICAgICAgIHR5cGU6IFtGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVYkMV0sIH07XG5cbiAgICBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGludGVybmFsRm9ybWF0KSB7XG4gICAgICBjb25zdCBpbmZvID0gdFtpbnRlcm5hbEZvcm1hdF07XG4gICAgICBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcCA9IHt9O1xuICAgICAgaW5mby5ieXRlc1BlckVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbihieXRlc1BlckVsZW1lbnQsIG5keCkge1xuICAgICAgICBjb25zdCB0eXBlID0gaW5mby50eXBlW25keF07XG4gICAgICAgIGluZm8uYnl0ZXNQZXJFbGVtZW50TWFwW3R5cGVdID0gYnl0ZXNQZXJFbGVtZW50O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc190ZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvID0gdDtcbiAgfVxuICByZXR1cm4gc190ZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvW2ludGVybmFsRm9ybWF0XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgcGVyIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gaW50ZXJuYWxGb3JtYXQgLyB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJuYWxGb3JtYXQgVGhlIGludGVybmFsRm9ybWF0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSB0eXBlIHBhcmFtZXRlciBmb3IgdGV4SW1hZ2UyRCBldGMuLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHBlciBlbGVtZW50IGZvciB0aGUgZ2l2ZW4gaW50ZXJuYWxGb3JtYXQsIHR5cGUgY29tYm9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBnZXRCeXRlc1BlckVsZW1lbnRGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCwgdHlwZSkge1xuICBjb25zdCBpbmZvID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyhpbnRlcm5hbEZvcm1hdCk7XG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuICBjb25zdCBieXRlc1BlckVsZW1lbnQgPSBpbmZvLmJ5dGVzUGVyRWxlbWVudE1hcFt0eXBlXTtcbiAgaWYgKGJ5dGVzUGVyRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgXCJ1bmtub3duIGludGVybmFsIGZvcm1hdFwiO1xuICB9XG4gIHJldHVybiBieXRlc1BlckVsZW1lbnQ7XG59XG5cbi8qKlxuICogSW5mbyByZWxhdGVkIHRvIGEgc3BlY2lmaWMgdGV4dHVyZSBpbnRlcm5hbEZvcm1hdCBhcyByZXR1cm5lZFxuICogZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wvdGV4dHVyZXMuZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0fS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0dXJlRm9ybWF0SW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZvcm1hdCBGb3JtYXQgdG8gcGFzcyB0byB0ZXhJbWFnZTJEIGFuZCByZWxhdGVkIGZ1bmN0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGUgVHlwZSB0byBwYXNzIHRvIHRleEltYWdlMkQgYW5kIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIGZvcm1hdCBhbmQgdHlwZSBmb3IgYSBnaXZlbiBpbnRlcm5hbEZvcm1hdFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcm5hbEZvcm1hdCBUaGUgaW50ZXJuYWwgZm9ybWF0XG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC90ZXh0dXJlcy5UZXh0dXJlRm9ybWF0SW5mb30gdGhlIGNvcnJlc3BvbmRpbmcgZm9ybWF0IGFuZCB0eXBlLFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCkge1xuICBjb25zdCBpbmZvID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0SW5mbyhpbnRlcm5hbEZvcm1hdCk7XG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBpbnRlcm5hbCBmb3JtYXRcIjtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogaW5mby50ZXh0dXJlRm9ybWF0LFxuICAgIHR5cGU6IGluZm8udHlwZVswXSxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgcG93ZXIgb2YgMlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIG51bWJlciB0byBjaGVjay5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB2YWx1ZSBpcyBwb3dlciBvZiAyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1Bvd2VyT2YyKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDA7XG59XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIG9yIG5vdCB3ZSBjYW4gZ2VuZXJhdGUgbWlwcyBmb3IgdGhlIGdpdmVuXG4gKiBpbnRlcm5hbCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcm5hbEZvcm1hdCBUaGUgaW50ZXJuYWxGb3JtYXQgcGFyYW1ldGVyIGZyb20gdGV4SW1hZ2UyRCBldGMuLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSBjYW4gZ2VuZXJhdGUgbWlwc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIGNhbkdlbmVyYXRlTWlwbWFwKGdsLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCkge1xuICBpZiAoIWlzV2ViR0wyKGdsKSkge1xuICAgIHJldHVybiBpc1Bvd2VyT2YyKHdpZHRoKSAmJiBpc1Bvd2VyT2YyKGhlaWdodCk7XG4gIH1cbiAgY29uc3QgaW5mbyA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdEluZm8oaW50ZXJuYWxGb3JtYXQpO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aHJvdyBcInVua25vd24gaW50ZXJuYWwgZm9ybWF0XCI7XG4gIH1cbiAgcmV0dXJuIGluZm8uY29sb3JSZW5kZXJhYmxlICYmIGluZm8udGV4dHVyZUZpbHRlcmFibGU7XG59XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIG9yIG5vdCB3ZSBjYW4gZ2VuZXJhdGUgbWlwcyBmb3IgdGhlIGdpdmVuIGZvcm1hdFxuICogQHBhcmFtIHtudW1iZXJ9IGludGVybmFsRm9ybWF0IFRoZSBpbnRlcm5hbEZvcm1hdCBwYXJhbWV0ZXIgZnJvbSB0ZXhJbWFnZTJEIGV0Yy4uXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHdlIGNhbiBnZW5lcmF0ZSBtaXBzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuZnVuY3Rpb24gY2FuRmlsdGVyKGludGVybmFsRm9ybWF0KSB7XG4gIGNvbnN0IGluZm8gPSBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXRJbmZvKGludGVybmFsRm9ybWF0KTtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhyb3cgXCJ1bmtub3duIGludGVybmFsIGZvcm1hdFwiO1xuICB9XG4gIHJldHVybiBpbmZvLnRleHR1cmVGaWx0ZXJhYmxlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciBhIGdpdmVuIGltYWdlIGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3JtYXQgdGhlIGZvcm1hdC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIGZvciB0aGUgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIGdldE51bUNvbXBvbmVudHNGb3JGb3JtYXQoZm9ybWF0KSB7XG4gIGNvbnN0IGluZm8gPSBmb3JtYXRJbmZvW2Zvcm1hdF07XG4gIGlmICghaW5mbykge1xuICAgIHRocm93IFwidW5rbm93biBmb3JtYXQ6IFwiICsgZm9ybWF0O1xuICB9XG4gIHJldHVybiBpbmZvLm51bUNvbG9yQ29tcG9uZW50cztcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0ZXh0dXJlIHR5cGUgZm9yIGEgZ2l2ZW4gYXJyYXkgdHlwZS5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBnbCB0ZXh0dXJlIHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFRleHR1cmVUeXBlRm9yQXJyYXlUeXBlKGdsLCBzcmMsIGRlZmF1bHRUeXBlKSB7XG4gIGlmIChpc0FycmF5QnVmZmVyJDEoc3JjKSkge1xuICAgIHJldHVybiBnZXRHTFR5cGVGb3JUeXBlZEFycmF5KHNyYyk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRUeXBlIHx8IFVOU0lHTkVEX0JZVEUkMjtcbn1cblxuZnVuY3Rpb24gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG51bUVsZW1lbnRzKSB7XG4gIGlmIChudW1FbGVtZW50cyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBcImNhbid0IGd1ZXNzIGRpbWVuc2lvbnNcIjtcbiAgfVxuICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICBjb25zdCBzaXplID0gTWF0aC5zcXJ0KG51bUVsZW1lbnRzIC8gKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCA/IDYgOiAxKSk7XG4gICAgaWYgKHNpemUgJSAxID09PSAwKSB7XG4gICAgICB3aWR0aCA9IHNpemU7XG4gICAgICBoZWlnaHQgPSBzaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IG51bUVsZW1lbnRzO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWhlaWdodCkge1xuICAgIGhlaWdodCA9IG51bUVsZW1lbnRzIC8gd2lkdGg7XG4gICAgaWYgKGhlaWdodCAlIDEpIHtcbiAgICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgZGltZW5zaW9uc1wiO1xuICAgIH1cbiAgfSBlbHNlIGlmICghd2lkdGgpIHtcbiAgICB3aWR0aCA9IG51bUVsZW1lbnRzIC8gaGVpZ2h0O1xuICAgIGlmICh3aWR0aCAlIDEpIHtcbiAgICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgZGltZW5zaW9uc1wiO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IHRleHR1cmUgY29sb3IuXG4gKlxuICogVGhlIGRlZmF1bHQgdGV4dHVyZSBjb2xvciBpcyB1c2VkIHdoZW4gbG9hZGluZyB0ZXh0dXJlcyBmcm9tXG4gKiB1cmxzLiBCZWNhdXNlIHRoZSBVUkwgd2lsbCBiZSBsb2FkZWQgYXN5bmMgd2UnZCBsaWtlIHRvIGJlXG4gKiBhYmxlIHRvIHVzZSB0aGUgdGV4dHVyZSBpbW1lZGlhdGVseS4gQnkgcHV0dGluZyBhIDF4MSBwaXhlbFxuICogY29sb3IgaW4gdGhlIHRleHR1cmUgd2UgY2FuIHN0YXJ0IHVzaW5nIHRoZSB0ZXh0dXJlIGJlZm9yZVxuICogdGhlIFVSTCBoYXMgbG9hZGVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yIEFycmF5IG9mIDQgdmFsdWVzIGluIHRoZSByYW5nZSAwIHRvIDFcbiAqIEBkZXByZWNhdGVkIHNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0RGVmYXVsdHN9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdFRleHR1cmVDb2xvcihjb2xvcikge1xuICBkZWZhdWx0cyQxLnRleHR1cmVDb2xvciA9IG5ldyBVaW50OEFycmF5KFtjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1LCBjb2xvclszXSAqIDI1NV0pO1xufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0cyQxKG5ld0RlZmF1bHRzKSB7XG4gIGNvcHlFeGlzdGluZ1Byb3BlcnRpZXMobmV3RGVmYXVsdHMsIGRlZmF1bHRzJDEpO1xuICBpZiAobmV3RGVmYXVsdHMudGV4dHVyZUNvbG9yKSB7XG4gICAgc2V0RGVmYXVsdFRleHR1cmVDb2xvcihuZXdEZWZhdWx0cy50ZXh0dXJlQ29sb3IpO1xuICB9XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgc291cmNlIGZvciBhIHRleHR1cmUuXG4gKiBAY2FsbGJhY2sgVGV4dHVyZUZ1bmNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyB0aGUgdGV4dHVyZSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIGFueSBvZiB0aGUgdGhpbmdzIGRvY3VtZW50ZWQgZm9yIGBzcmNgIGZvciB7QGxpbmsgbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBUZXh0dXJlIG9wdGlvbnMgcGFzc2VkIHRvIG1vc3QgdGV4dHVyZSBmdW5jdGlvbnMuIEVhY2ggZnVuY3Rpb24gd2lsbCB1c2Ugd2hhdGV2ZXIgb3B0aW9uc1xuICogYXJlIGFwcHJvcHJpYXRlIGZvciBpdHMgbmVlZHMuIFRoaXMgbGV0cyB5b3UgcGFzcyB0aGUgc2FtZSBvcHRpb25zIHRvIGFsbCBmdW5jdGlvbnMuXG4gKlxuICogTm90ZTogQSBgVGV4SW1hZ2VTb3VyY2VgIGlzIGRlZmluZWQgaW4gdGhlIFdlYkdMIHNwZWMgYXMgYSBgSFRNTEltYWdlRWxlbWVudGAsIGBIVE1MVmlkZW9FbGVtZW50YCxcbiAqIGBIVE1MQ2FudmFzRWxlbWVudGAsIGBJbWFnZUJpdG1hcGAsIG9yIGBJbWFnZURhdGFgLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHR1cmVPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldF0gdGhlIHR5cGUgb2YgdGV4dHVyZSBgZ2wuVEVYVFVSRV8yRGAgb3IgYGdsLlRFWFRVUkVfQ1VCRV9NQVBgLiBEZWZhdWx0cyB0byBgZ2wuVEVYVFVSRV8yRGAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xldmVsXSB0aGUgbWlwIGxldmVsIHRvIGFmZmVjdC4gRGVmYXVsdHMgdG8gMC4gTm90ZSwgaWYgc2V0IGF1dG8gd2lsbCBiZSBjb25zaWRlcmVkIGZhbHNlIHVubGVzcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gdGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiBPbmx5IHVzZWQgaWYgc3JjIGlzIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5IG9yIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gdGhlIGhlaWdodCBvZiBhIHRleHR1cmUuIE9ubHkgdXNlZCBpZiBzcmMgaXMgYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXkgb3IgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVwdGhdIHRoZSBkZXB0aCBvZiBhIHRleHR1cmUuIE9ubHkgdXNlZCBpZiBzcmMgaXMgYW4gYXJyYXkgb3IgdHlwZSBhcnJheSBvciBudWxsIGFuZCB0YXJnZXQgaXMgYFRFWFRVUkVfM0RgIC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluXSB0aGUgbWluIGZpbHRlciBzZXR0aW5nIChlZy4gYGdsLkxJTkVBUmApLiBEZWZhdWx0cyB0byBgZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSYFxuICogICAgIG9yIGlmIHRleHR1cmUgaXMgbm90IGEgcG93ZXIgb2YgMiBvbiBib3RoIGRpbWVuc2lvbnMgdGhlbiBkZWZhdWx0cyB0byBgZ2wuTElORUFSYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWFnXSB0aGUgbWFnIGZpbHRlciBzZXR0aW5nIChlZy4gYGdsLkxJTkVBUmApLiBEZWZhdWx0cyB0byBgZ2wuTElORUFSYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5NYWddIGJvdGggdGhlIG1pbiBhbmQgbWFnIGZpbHRlciBzZXR0aW5ncy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW50ZXJuYWxGb3JtYXRdIGludGVybmFsIGZvcm1hdCBmb3IgdGV4dHVyZS4gRGVmYXVsdHMgdG8gYGdsLlJHQkFgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Zvcm1hdF0gZm9ybWF0IGZvciB0ZXh0dXJlLiBEZWZhdWx0cyB0byBgZ2wuUkdCQWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIHR5cGUgZm9yIHRleHR1cmUuIERlZmF1bHRzIHRvIGBnbC5VTlNJR05FRF9CWVRFYCB1bmxlc3MgYHNyY2AgaXMgQXJyYXlCdWZmZXJWaWV3LiBJZiBgc3JjYFxuICogICAgIGlzIEFycmF5QnVmZmVyVmlldyBkZWZhdWx0cyB0byB0eXBlIHRoYXQgbWF0Y2hlcyBBcnJheUJ1ZmZlclZpZXcgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd3JhcF0gVGV4dHVyZSB3cmFwcGluZyBmb3IgYm90aCBTIGFuZCBUIChhbmQgUiBpZiBURVhUVVJFXzNEIG9yIFdlYkdMU2FtcGxlcikuIERlZmF1bHRzIHRvIGBnbC5SRVBFQVRgIGZvciAyRCB1bmxlc3Mgc3JjIGlzIFdlYkdMMSBhbmQgc3JjIG5vdCBucG90IGFuZCBgZ2wuQ0xBTVBfVE9fRURHRWAgZm9yIGN1YmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd3JhcFNdIFRleHR1cmUgd3JhcHBpbmcgZm9yIFMuIERlZmF1bHRzIHRvIGBnbC5SRVBFQVRgIGFuZCBgZ2wuQ0xBTVBfVE9fRURHRWAgZm9yIGN1YmUuIElmIHNldCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHdyYXBgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3cmFwVF0gVGV4dHVyZSB3cmFwcGluZyBmb3IgVC4gRGVmYXVsdHMgdG8gYGdsLlJFUEVBVGAgYW5kIGBnbC5DTEFNUF9UT19FREdFYCBmb3IgY3ViZS4gSWYgc2V0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgd3JhcGAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyYXBSXSBUZXh0dXJlIHdyYXBwaW5nIGZvciBSLiBEZWZhdWx0cyB0byBgZ2wuUkVQRUFUYCBhbmQgYGdsLkNMQU1QX1RPX0VER0VgIGZvciBjdWJlLiBJZiBzZXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGB3cmFwYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluTG9kXSBURVhUVVJFX01JTl9MT0Qgc2V0dGluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhMb2RdIFRFWFRVUkVfTUFYX0xPRCBzZXR0aW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2Jhc2VMZXZlbF0gVEVYVFVSRV9CQVNFX0xFVkVMIHNldHRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4TGV2ZWxdIFRFWFRVUkVfTUFYX0xFVkVMIHNldHRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdW5wYWNrQWxpZ25tZW50XSBUaGUgYGdsLlVOUEFDS19BTElHTk1FTlRgIHVzZWQgd2hlbiB1cGxvYWRpbmcgYW4gYXJyYXkuIERlZmF1bHRzIHRvIDEuXG4gKiBAcHJvcGVydHkge251bWJlcltdfEFycmF5QnVmZmVyVmlld30gW2NvbG9yXSBDb2xvciB0byBpbml0aWFsaXplIHRoaXMgdGV4dHVyZSB3aXRoIGlmIGxvYWRpbmcgYW4gaW1hZ2UgYXN5bmNocm9ub3VzbHkuXG4gKiAgICAgVGhlIGRlZmF1bHQgdXNlIGEgYmx1ZSAxeDEgcGl4ZWwgdGV4dHVyZS4gWW91IGNhbiBzZXQgYW5vdGhlciBkZWZhdWx0IGJ5IGNhbGxpbmcgYHR3Z2wuc2V0RGVmYXVsdHNgXG4gKiAgICAgb3IgeW91IGNhbiBzZXQgYW4gaW5kaXZpZHVhbCB0ZXh0dXJlJ3MgaW5pdGlhbCBjb2xvciBieSBzZXR0aW5nIHRoaXMgcHJvcGVydHkuIEV4YW1wbGU6IGBbMSwgLjUsIC41LCAxXWAgPSBwaW5rXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ByZW11bHRpcGx5QWxwaGFdIFdoZXRoZXIgb3Igbm90IHRvIHByZW11bHRpcGx5IGFscGhhLiBEZWZhdWx0cyB0byB3aGF0ZXZlciB0aGUgY3VycmVudCBzZXR0aW5nIGlzLlxuICogICAgIFRoaXMgbGV0cyB5b3Ugc2V0IGl0IG9uY2UgYmVmb3JlIGNhbGxpbmcgYHR3Z2wuY3JlYXRlVGV4dHVyZWAgb3IgYHR3Z2wuY3JlYXRlVGV4dHVyZXNgIGFuZCBvbmx5IG92ZXJyaWRlXG4gKiAgICAgdGhlIGN1cnJlbnQgc2V0dGluZyBmb3Igc3BlY2lmaWMgdGV4dHVyZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZsaXBZXSBXaGV0aGVyIG9yIG5vdCB0byBmbGlwIHRoZSB0ZXh0dXJlIHZlcnRpY2FsbHkgb24gdXBsb2FkLiBEZWZhdWx0cyB0byB3aGF0ZXZlciB0aGUgY3VycmVudCBzZXR0aW5nIGlzLlxuICogICAgIFRoaXMgbGV0cyB5b3Ugc2V0IGl0IG9uY2UgYmVmb3JlIGNhbGxpbmcgYHR3Z2wuY3JlYXRlVGV4dHVyZWAgb3IgYHR3Z2wuY3JlYXRlVGV4dHVyZXNgIGFuZCBvbmx5IG92ZXJyaWRlXG4gKiAgICAgdGhlIGN1cnJlbnQgc2V0dGluZyBmb3Igc3BlY2lmaWMgdGV4dHVyZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvbG9yc3BhY2VDb252ZXJzaW9uXSBXaGV0aGVyIG9yIG5vdCB0byBsZXQgdGhlIGJyb3dzZXIgZG8gY29sb3JzcGFjZSBjb252ZXJzaW9uIG9mIHRoZSB0ZXh0dXJlIG9uIHVwbG9hZC4gRGVmYXVsdHMgdG8gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgc2V0dGluZyBpcy5cbiAqICAgICBUaGlzIGxldHMgeW91IHNldCBpdCBvbmNlIGJlZm9yZSBjYWxsaW5nIGB0d2dsLmNyZWF0ZVRleHR1cmVgIG9yIGB0d2dsLmNyZWF0ZVRleHR1cmVzYCBhbmQgb25seSBvdmVycmlkZVxuICogICAgIHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIHNwZWNpZmljIHRleHR1cmVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b10gSWYgYHVuZGVmaW5lZGAgb3IgYHRydWVgLCBpbiBXZWJHTDEsIHRleHR1cmUgZmlsdGVyaW5nIGlzIHNldCBhdXRvbWF0aWNhbGx5IGZvciBub24tcG93ZXIgb2YgMiBpbWFnZXMgYW5kXG4gKiAgICBtaXBzIGFyZSBnZW5lcmF0ZWQgZm9yIHBvd2VyIG9mIDIgaW1hZ2VzLiBJbiBXZWJHTDIgbWlwcyBhcmUgZ2VuZXJhdGVkIGlmIHRoZXkgY2FuIGJlLiBOb3RlOiBpZiBgbGV2ZWxgIGlzIHNldCBhYm92ZVxuICogICAgdGhlbiB0aGVuIGBhdXRvYCBpcyBhc3N1bWVkIHRvIGJlIGBmYWxzZWAgdW5sZXNzIGV4cGxpY2l0eSBzZXQgdG8gYHRydWVgLlxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gW2N1YmVGYWNlT3JkZXJdIFRoZSBvcmRlciB0aGF0IGN1YmUgZmFjZXMgYXJlIHB1bGxlZCBvdXQgb2YgYW4gaW1nIG9yIHNldCBvZiBpbWFnZXMuIFRoZSBkZWZhdWx0IGlzXG4gKlxuICogICAgIFtnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCxcbiAqICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZLFxuICogICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksXG4gKiAgICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWixcbiAqICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aXVxuICpcbiAqIEBwcm9wZXJ0eSB7KG51bWJlcltdfEFycmF5QnVmZmVyVmlld3xUZXhJbWFnZVNvdXJjZXxUZXhJbWFnZVNvdXJjZVtdfHN0cmluZ3xzdHJpbmdbXXxtb2R1bGU6dHdnbC5UZXh0dXJlRnVuYyl9IFtzcmNdIHNvdXJjZSBmb3IgdGV4dHVyZVxuICpcbiAqICAgIElmIGBzdHJpbmdgIHRoZW4gaXQncyBhc3N1bWVkIHRvIGJlIGEgVVJMIHRvIGFuIGltYWdlLiBUaGUgaW1hZ2Ugd2lsbCBiZSBkb3dubG9hZGVkIGFzeW5jLiBBIHVzYWJsZVxuICogICAgMXgxIHBpeGVsIHRleHR1cmUgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseS4gVGhlIHRleHR1cmUgd2lsbCBiZSB1cGRhdGVkIG9uY2UgdGhlIGltYWdlIGhhcyBkb3dubG9hZGVkLlxuICogICAgSWYgYHRhcmdldGAgaXMgYGdsLlRFWFRVUkVfQ1VCRV9NQVBgIHdpbGwgYXR0ZW1wdCB0byBkaXZpZGUgaW1hZ2UgaW50byA2IHNxdWFyZSBwaWVjZXMuIDF4NiwgNngxLCAzeDIsIDJ4My5cbiAqICAgIFRoZSBwaWVjZXMgd2lsbCBiZSB1cGxvYWRlZCBpbiBgY3ViZUZhY2VPcmRlcmBcbiAqXG4gKiAgICBJZiBgc3RyaW5nW11gIG9yIGBUZXhJbWFnZVNvdXJjZVtdYCBhbmQgdGFyZ2V0IGlzIGBnbC5URVhUVVJFX0NVQkVfTUFQYCB0aGVuIGl0IG11c3QgaGF2ZSA2IGVudHJpZXMsIG9uZSBmb3IgZWFjaCBmYWNlIG9mIGEgY3ViZSBtYXAuXG4gKlxuICogICAgSWYgYHN0cmluZ1tdYCBvciBgVGV4SW1hZ2VTb3VyY2VbXWAgYW5kIHRhcmdldCBpcyBgZ2wuVEVYVFVSRV8yRF9BUlJBWWAgdGhlbiBlYWNoIGVudHJ5IGlzIGEgc2xpY2Ugb2YgdGhlIGEgMmQgYXJyYXkgdGV4dHVyZVxuICogICAgYW5kIHdpbGwgYmUgc2NhbGVkIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodCBPUiB0byB0aGUgc2l6ZSBvZiB0aGUgZmlyc3QgaW1hZ2UgdGhhdCBsb2Fkcy5cbiAqXG4gKiAgICBJZiBgVGV4SW1hZ2VTb3VyY2VgIHRoZW4gaXQgd2lsIGJlIHVzZWQgaW1tZWRpYXRlbHkgdG8gY3JlYXRlIHRoZSBjb250ZW50cyBvZiB0aGUgdGV4dHVyZS4gRXhhbXBsZXMgYEhUTUxJbWFnZUVsZW1lbnRgLFxuICogICAgYEhUTUxDYW52YXNFbGVtZW50YCwgYEhUTUxWaWRlb0VsZW1lbnRgLlxuICpcbiAqICAgIElmIGBudW1iZXJbXWAgb3IgYEFycmF5QnVmZmVyVmlld2AgaXQncyBhc3N1bWVkIHRvIGJlIGRhdGEgZm9yIGEgdGV4dHVyZS4gSWYgYHdpZHRoYCBvciBgaGVpZ2h0YCBpc1xuICogICAgbm90IHNwZWNpZmllZCBpdCBpcyBndWVzc2VkIGFzIGZvbGxvd3MuIEZpcnN0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgY29tcHV0ZWQgYnkgYHNyYy5sZW5ndGggLyBudW1Db21wb25lbnRzYFxuICogICAgd2hlcmUgYG51bUNvbXBvbmVudHNgIGlzIGRlcml2ZWQgZnJvbSBgZm9ybWF0YC4gSWYgYHRhcmdldGAgaXMgYGdsLlRFWFRVUkVfQ1VCRV9NQVBgIHRoZW4gYG51bUVsZW1lbnRzYCBpcyBkaXZpZGVkXG4gKiAgICBieSA2LiBUaGVuXG4gKlxuICogICAgKiAgIElmIG5laXRoZXIgYHdpZHRoYCBub3IgYGhlaWdodGAgYXJlIHNwZWNpZmllZCBhbmQgYHNxcnQobnVtRWxlbWVudHMpYCBpcyBhbiBpbnRlZ2VyIHRoZW4gd2lkdGggYW5kIGhlaWdodFxuICogICAgICAgIGFyZSBzZXQgdG8gYHNxcnQobnVtRWxlbWVudHMpYC4gT3RoZXJ3aXNlIGB3aWR0aCA9IG51bUVsZW1lbnRzYCBhbmQgYGhlaWdodCA9IDFgLlxuICpcbiAqICAgICogICBJZiBvbmx5IG9uZSBvZiBgd2lkdGhgIG9yIGBoZWlnaHRgIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBvdGhlciBlcXVhbHMgYG51bUVsZW1lbnRzIC8gc3BlY2lmaWVkRGltZW5zaW9uYC5cbiAqXG4gKiBJZiBgbnVtYmVyW11gIHdpbGwgYmUgY29udmVydGVkIHRvIGB0eXBlYC5cbiAqXG4gKiBJZiBgc3JjYCBpcyBhIGZ1bmN0aW9uIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YCBhbmQgdGhlc2Ugb3B0aW9ucy5cbiAqIFdoYXRldmVyIGl0IHJldHVybnMgaXMgc3ViamVjdCB0byB0aGVzZSBydWxlcy4gU28gaXQgY2FuIHJldHVybiBhIHN0cmluZyB1cmwsIGFuIGBIVE1MRWxlbWVudGBcbiAqIGFuIGFycmF5IGV0Yy4uLlxuICpcbiAqIElmIGBzcmNgIGlzIHVuZGVmaW5lZCB0aGVuIGFuIGVtcHR5IHRleHR1cmUgd2lsbCBiZSBjcmVhdGVkIG9mIHNpemUgYHdpZHRoYCBieSBgaGVpZ2h0YC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Nyb3NzT3JpZ2luXSBXaGF0IHRvIHNldCB0aGUgY3Jvc3NPcmlnaW4gcHJvcGVydHkgb2YgaW1hZ2VzIHdoZW4gdGhleSBhcmUgZG93bmxvYWRlZC5cbiAqICAgIGRlZmF1bHQ6IHVuZGVmaW5lZC4gQWxzbyBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldERlZmF1bHRzfS5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIFNldHMgYW55IHBhY2tpbmcgc3RhdGUgdGhhdCB3aWxsIGJlIHNldCBiYXNlZCBvbiB0aGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY29sb3JzcGFjZUNvbnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIG9wdGlvbnMuY29sb3JzcGFjZUNvbnZlcnNpb24pO1xuICB9XG4gIGlmIChvcHRpb25zLnByZW11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhKTtcbiAgfVxuICBpZiAob3B0aW9ucy5mbGlwWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0ZMSVBfWV9XRUJHTCwgb3B0aW9ucy5mbGlwWSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgc2tpcCBzdGF0ZSB0byBkZWZhdWx0c1xuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFNraXBTdGF0ZVRvRGVmYXVsdChnbCkge1xuICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfQUxJR05NRU5ULCA0KTtcbiAgaWYgKGlzV2ViR0wyKGdsKSkge1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19ST1dfTEVOR1RILCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfSU1BR0VfSEVJR0hULCAwKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfU0tJUF9QSVhFTFMsIDApO1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19TS0lQX1JPV1MsIDApO1xuICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19TS0lQX0lNQUdFUywgMCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBwYXJhbWV0ZXJzIG9mIGEgdGV4dHVyZSBvciBzYW1wbGVyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ8V2ViR0xTYW1wbGVyfSB0YXJnZXQgdGV4dHVyZSB0YXJnZXQgb3Igc2FtcGxlclxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBwYXJhbWV0ZXJpRm4gdGV4UGFyYW1ldGVyaSBvciBzYW1wbGVyUGFyYW1ldGVyaSBmblxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0VGV4dHVyZVNhbXBsZXJQYXJhbWV0ZXJzKGdsLCB0YXJnZXQsIHBhcmFtZXRlcmlGbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5taW5NYWcpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01JTl9GSUxURVIsIG9wdGlvbnMubWluTWFnKTtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01BR19GSUxURVIsIG9wdGlvbnMubWluTWFnKTtcbiAgfVxuICBpZiAob3B0aW9ucy5taW4pIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01JTl9GSUxURVIsIG9wdGlvbnMubWluKTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYWcpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01BR19GSUxURVIsIG9wdGlvbnMubWFnKTtcbiAgfVxuICBpZiAob3B0aW9ucy53cmFwKSB7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMud3JhcCk7XG4gICAgcGFyYW1ldGVyaUZuLmNhbGwoZ2wsIHRhcmdldCwgVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMud3JhcCk7XG4gICAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCB8fCBpc1NhbXBsZXIoZ2wsIHRhcmdldCkpIHtcbiAgICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9SLCBvcHRpb25zLndyYXApO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy53cmFwUikge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9SLCBvcHRpb25zLndyYXBSKTtcbiAgfVxuICBpZiAob3B0aW9ucy53cmFwUykge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9TLCBvcHRpb25zLndyYXBTKTtcbiAgfVxuICBpZiAob3B0aW9ucy53cmFwVCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfV1JBUF9ULCBvcHRpb25zLndyYXBUKTtcbiAgfVxuICBpZiAob3B0aW9ucy5taW5Mb2QpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01JTl9MT0QsIG9wdGlvbnMubWluTG9kKTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXhMb2QpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX01BWF9MT0QsIG9wdGlvbnMubWF4TG9kKTtcbiAgfVxuICBpZiAob3B0aW9ucy5iYXNlTGV2ZWwpIHtcbiAgICBwYXJhbWV0ZXJpRm4uY2FsbChnbCwgdGFyZ2V0LCBURVhUVVJFX0JBU0VfTEVWRUwsIG9wdGlvbnMuYmFzZUxldmVsKTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXhMZXZlbCkge1xuICAgIHBhcmFtZXRlcmlGbi5jYWxsKGdsLCB0YXJnZXQsIFRFWFRVUkVfTUFYX0xFVkVMLCBvcHRpb25zLm1heExldmVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHRleHR1cmUgcGFyYW1ldGVycyBvZiBhIHRleHR1cmUuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogICBUaGlzIGlzIG9mdGVuIHRoZSBzYW1lIG9wdGlvbnMgeW91IHBhc3NlZCBpbiB3aGVuIHlvdSBjcmVhdGVkIHRoZSB0ZXh0dXJlLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKGdsLCB0ZXgsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICBzZXRUZXh0dXJlU2FtcGxlclBhcmFtZXRlcnMoZ2wsIHRhcmdldCwgZ2wudGV4UGFyYW1ldGVyaSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc2FtcGxlciBwYXJhbWV0ZXJzIG9mIGEgc2FtcGxlci5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMU2FtcGxlcn0gc2FtcGxlciB0aGUgV2ViR0xTYW1wbGVyIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIHNldFNhbXBsZXJQYXJhbWV0ZXJzKGdsLCBzYW1wbGVyLCBvcHRpb25zKSB7XG4gIHNldFRleHR1cmVTYW1wbGVyUGFyYW1ldGVycyhnbCwgc2FtcGxlciwgZ2wuc2FtcGxlclBhcmFtZXRlcmksIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc2FtcGxlciBvYmplY3QgYW5kIHNldHMgcGFyYW1ldGVycy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgY29uc3Qgc2FtcGxlciA9IHR3Z2wuY3JlYXRlU2FtcGxlcihnbCwge1xuICogICAgICAgIG1pbk1hZzogZ2wuTkVBUkVTVCwgICAgICAgICAvLyBzZXRzIGJvdGggVEVYVFVSRV9NSU5fRklMVEVSIGFuZCBURVhUVVJFX01BR19GSUxURVJcbiAqICAgICAgICB3cmFwOiBnbC5DTEFNUF9UT19ORUFSRVNULCAgLy8gc2V0cyBib3RoIFRFWFRVUkVfV1JBUF9TIGFuZCBURVhUVVJFX1dSQVBfVCBhbmQgVEVYVFVSRV9XUkFQX1JcbiAqICAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnM+fSBvcHRpb25zIEEgb2JqZWN0IG9mIFRleHR1cmVPcHRpb25zIG9uZSBwZXIgc2FtcGxlci5cbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLFdlYkdMU2FtcGxlcj59IHRoZSBjcmVhdGVkIHNhbXBsZXJzIGJ5IG5hbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNhbXBsZXIoZ2wsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2FtcGxlciA9IGdsLmNyZWF0ZVNhbXBsZXIoKTtcbiAgc2V0U2FtcGxlclBhcmFtZXRlcnMoZ2wsIHNhbXBsZXIsIG9wdGlvbnMpO1xuICByZXR1cm4gc2FtcGxlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbXVsdGlwbGUgc2FtcGxlciBvYmplY3RzIGFuZCBzZXRzIHBhcmFtZXRlcnMgb24gZWFjaC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgY29uc3Qgc2FtcGxlcnMgPSB0d2dsLmNyZWF0ZVNhbXBsZXJzKGdsLCB7XG4gKiAgICAgICAgbmVhcmVzdDoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5ORUFSRVNULFxuICogICAgICAgIH0sXG4gKiAgICAgICAgbmVhcmVzdENsYW1wUzoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5ORUFSRVNULFxuICogICAgICAgICAgd3JhcFM6IGdsLkNMQU1QX1RPX05FQVJFU1QsXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBsaW5lYXI6IHtcbiAqICAgICAgICAgIG1pbk1hZzogZ2wuTElORUFSLFxuICogICAgICAgIH0sXG4gKiAgICAgICAgbmVhcmVzdENsYW1wOiB7XG4gKiAgICAgICAgICBtaW5NYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgICB3cmFwOiBnbC5DTEFNUF9UT19FREdFLFxuICogICAgICAgIH0sXG4gKiAgICAgICAgbGluZWFyQ2xhbXA6IHtcbiAqICAgICAgICAgIG1pbk1hZzogZ2wuTElORUFSLFxuICogICAgICAgICAgd3JhcDogZ2wuQ0xBTVBfVE9fRURHRSxcbiAqICAgICAgICB9LFxuICogICAgICAgIGxpbmVhckNsYW1wVDoge1xuICogICAgICAgICAgbWluTWFnOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgICB3cmFwVDogZ2wuQ0xBTVBfVE9fRURHRSxcbiAqICAgICAgICB9LFxuICogICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQgb24gdGhlIHNhbXBsZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNhbXBsZXJzKGdsLCBzYW1wbGVyT3B0aW9ucykge1xuICBjb25zdCBzYW1wbGVycyA9IHt9O1xuICBPYmplY3Qua2V5cyhzYW1wbGVyT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgc2FtcGxlcnNbbmFtZV0gPSBjcmVhdGVTYW1wbGVyKGdsLCBzYW1wbGVyT3B0aW9uc1tuYW1lXSk7XG4gIH0pO1xuICByZXR1cm4gc2FtcGxlcnM7XG59XG5cbi8qKlxuICogTWFrZXMgYSAxeDEgcGl4ZWxcbiAqIElmIG5vIGNvbG9yIGlzIHBhc3NlZCBpbiB1c2VzIHRoZSBkZWZhdWx0IGNvbG9yIHdoaWNoIGNhbiBiZSBzZXQgYnkgY2FsbGluZyBgc2V0RGVmYXVsdFRleHR1cmVDb2xvcmAuXG4gKiBAcGFyYW0geyhudW1iZXJbXXxBcnJheUJ1ZmZlclZpZXcpfSBbY29sb3JdIFRoZSBjb2xvciB1c2luZyAwLTEgdmFsdWVzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSBVbml0OEFycmF5IHdpdGggY29sb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlMVBpeGVsKGNvbG9yKSB7XG4gIGNvbG9yID0gY29sb3IgfHwgZGVmYXVsdHMkMS50ZXh0dXJlQ29sb3I7XG4gIGlmIChpc0FycmF5QnVmZmVyJDEoY29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShbY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSwgY29sb3JbM10gKiAyNTVdKTtcbn1cblxuLyoqXG4gKiBTZXRzIGZpbHRlcmluZyBvciBnZW5lcmF0ZXMgbWlwcyBmb3IgdGV4dHVyZSBiYXNlZCBvbiB3aWR0aCBvciBoZWlnaHRcbiAqIElmIHdpZHRoIG9yIGhlaWdodCBpcyBub3QgcGFzc2VkIGluIHVzZXMgYG9wdGlvbnMud2lkdGhgIGFuZC8vb3IgYG9wdGlvbnMuaGVpZ2h0YFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIHdpZHRoIG9mIHRleHR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSBoZWlnaHQgb2YgdGV4dHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlcm5hbEZvcm1hdF0gVGhlIGludGVybmFsRm9ybWF0IHBhcmFtZXRlciBmcm9tIHRleEltYWdlMkQgZXRjLi5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxLnRleHR1cmVPcHRpb25zO1xuICBpbnRlcm5hbEZvcm1hdCA9IGludGVybmFsRm9ybWF0IHx8IFJHQkE7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQ7XG4gIHdpZHRoID0gd2lkdGggfHwgb3B0aW9ucy53aWR0aDtcbiAgaGVpZ2h0ID0gaGVpZ2h0IHx8IG9wdGlvbnMuaGVpZ2h0O1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIGlmIChjYW5HZW5lcmF0ZU1pcG1hcChnbCwgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQpKSB7XG4gICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmaWx0ZXJpbmcgPSBjYW5GaWx0ZXIoaW50ZXJuYWxGb3JtYXQpID8gTElORUFSIDogTkVBUkVTVDtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJpbmcpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX01BR19GSUxURVIsIGZpbHRlcmluZyk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIFRFWFRVUkVfV1JBUF9TLCBDTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgVEVYVFVSRV9XUkFQX1QsIENMQU1QX1RPX0VER0UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9tYXRpY2FsbHlTZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmF1dG8gPT09IHRydWUgfHwgKG9wdGlvbnMuYXV0byA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMubGV2ZWwgPT09IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogR2V0cyBhbiBhcnJheSBvZiBjdWJlbWFwIGZhY2UgZW51bXNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gY3ViZW1hcCBmYWNlIGVudW1zXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRDdWJlRmFjZU9yZGVyKGdsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICByZXR1cm4gb3B0aW9ucy5jdWJlRmFjZU9yZGVyIHx8IFtcbiAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCxcbiAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCxcbiAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSxcbiAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSxcbiAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWixcbiAgICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWixcbiAgICBdO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZhY2VJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gZmFjZSBnbCBlbnVtIGZvciB0ZXhJbWFnZTJEXG4gKiBAcHJvcGVydHkge251bWJlcn0gbmR4IGZhY2UgaW5kZXggKDAgLSA1KSBpbnRvIHNvdXJjZSBkYXRhXG4gKiBAaWdub3JlXG4gKi9cblxuLyoqXG4gKiBHZXRzIGFuIGFycmF5IG9mIEZhY2VJbmZvc1xuICogVGhlcmUncyBhIGJ1ZyBpbiBzb21lIE5WaWRpYSBkcml2ZXJzIHRoYXQgd2lsbCBjcmFzaCB0aGUgZHJpdmVyIGlmXG4gKiBgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YYCBpcyBub3QgdXBsb2FkZWQgZmlyc3QuIFNvLCB3ZSB0YWtlXG4gKiB0aGUgdXNlcidzIGRlc2lyZWQgb3JkZXIgZnJvbSBoaXMgZmFjZXMgdG8gV2ViR0wgYW5kIG1ha2Ugc3VyZSB3ZVxuICogZG8gdGhlIGZhY2VzIGluIFdlYkdMIG9yZGVyXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEByZXR1cm4ge0ZhY2VJbmZvW119IGN1YmVtYXAgZmFjZSBpbmZvcy4gQXJndWFibHkgdGhlIGBmYWNlYCBwcm9wZXJ0eSBvZiBlYWNoIGVsZW1lbnQgaXMgcmVkdW5kYW50IGJ1dFxuICogICAgaXQncyBuZWVkZWQgaW50ZXJuYWxseSB0byBzb3J0IHRoZSBhcnJheSBvZiBgbmR4YCBwcm9wZXJ0aWVzIGJ5IGBmYWNlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEN1YmVGYWNlc1dpdGhOZHgoZ2wsIG9wdGlvbnMpIHtcbiAgY29uc3QgZmFjZXMgPSBnZXRDdWJlRmFjZU9yZGVyKGdsLCBvcHRpb25zKTtcbiAgLy8gd29yayBhcm91bmQgYnVnIGluIE5WaWRpYSBkcml2ZXJzLiBXZSBoYXZlIHRvIHVwbG9hZCB0aGUgZmlyc3QgZmFjZSBmaXJzdCBlbHNlIHRoZSBkcml2ZXIgY3Jhc2hlcyA6KFxuICBjb25zdCBmYWNlc1dpdGhOZHggPSBmYWNlcy5tYXAoZnVuY3Rpb24oZmFjZSwgbmR4KSB7XG4gICAgcmV0dXJuIHsgZmFjZTogZmFjZSwgbmR4OiBuZHggfTtcbiAgfSk7XG4gIGZhY2VzV2l0aE5keC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mYWNlIC0gYi5mYWNlO1xuICB9KTtcbiAgcmV0dXJuIGZhY2VzV2l0aE5keDtcbn1cblxuLyoqXG4gKiBTZXQgYSB0ZXh0dXJlIGZyb20gdGhlIGNvbnRlbnRzIG9mIGFuIGVsZW1lbnQuIFdpbGwgYWxzbyBzZXRcbiAqIHRleHR1cmUgZmlsdGVyaW5nIG9yIGdlbmVyYXRlIG1pcHMgYmFzZWQgb24gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVsZW1lbnRcbiAqIHVubGVzcyBgb3B0aW9ucy5hdXRvID09PSBmYWxzZWAuIElmIGB0YXJnZXQgPT09IGdsLlRFWFRVUkVfQ1VCRV9NQVBgIHdpbGxcbiAqIGF0dGVtcHQgdG8gc2xpY2UgaW1hZ2UgaW50byAxeDYsIDJ4MywgM3gyLCBvciA2eDEgaW1hZ2VzLCBvbmUgZm9yIGVhY2ggZmFjZS5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGEgY2FudmFzLCBpbWcsIG9yIHZpZGVvIGVsZW1lbnQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICogQGtpbmQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc2V0VGV4dHVyZUZyb21FbGVtZW50KGdsLCB0ZXgsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMkMS50ZXh0dXJlT3B0aW9ucztcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcbiAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IDA7XG4gIGxldCB3aWR0aCA9IGVsZW1lbnQud2lkdGg7XG4gIGxldCBoZWlnaHQgPSBlbGVtZW50LmhlaWdodDtcbiAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IFJHQkE7XG4gIGNvbnN0IGZvcm1hdFR5cGUgPSBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXQpO1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBmb3JtYXRUeXBlLmZvcm1hdDtcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIHNldFBhY2tTdGF0ZShnbCwgb3B0aW9ucyk7XG4gIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcbiAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIC8vIGd1ZXNzIHRoZSBwYXJ0c1xuICAgIGNvbnN0IGltZ1dpZHRoICA9IGVsZW1lbnQud2lkdGg7XG4gICAgY29uc3QgaW1nSGVpZ2h0ID0gZWxlbWVudC5oZWlnaHQ7XG4gICAgbGV0IHNpemU7XG4gICAgbGV0IHNsaWNlcztcbiAgICBpZiAoaW1nV2lkdGggLyA2ID09PSBpbWdIZWlnaHQpIHtcbiAgICAgIC8vIEl0J3MgNngxXG4gICAgICBzaXplID0gaW1nSGVpZ2h0O1xuICAgICAgc2xpY2VzID0gWzAsIDAsIDEsIDAsIDIsIDAsIDMsIDAsIDQsIDAsIDUsIDBdO1xuICAgIH0gZWxzZSBpZiAoaW1nSGVpZ2h0IC8gNiA9PT0gaW1nV2lkdGgpIHtcbiAgICAgIC8vIEl0J3MgMXg2XG4gICAgICBzaXplID0gaW1nV2lkdGg7XG4gICAgICBzbGljZXMgPSBbMCwgMCwgMCwgMSwgMCwgMiwgMCwgMywgMCwgNCwgMCwgNV07XG4gICAgfSBlbHNlIGlmIChpbWdXaWR0aCAvIDMgPT09IGltZ0hlaWdodCAvIDIpIHtcbiAgICAgIC8vIEl0J3MgM3gyXG4gICAgICBzaXplID0gaW1nV2lkdGggLyAzO1xuICAgICAgc2xpY2VzID0gWzAsIDAsIDEsIDAsIDIsIDAsIDAsIDEsIDEsIDEsIDIsIDFdO1xuICAgIH0gZWxzZSBpZiAoaW1nV2lkdGggLyAyID09PSBpbWdIZWlnaHQgLyAzKSB7XG4gICAgICAvLyBJdCdzIDJ4M1xuICAgICAgc2l6ZSA9IGltZ1dpZHRoIC8gMjtcbiAgICAgIHNsaWNlcyA9IFswLCAwLCAxLCAwLCAwLCAxLCAxLCAxLCAwLCAyLCAxLCAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJjYW4ndCBmaWd1cmUgb3V0IGN1YmUgbWFwIGZyb20gZWxlbWVudDogXCIgKyAoZWxlbWVudC5zcmMgPyBlbGVtZW50LnNyYyA6IGVsZW1lbnQubm9kZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSBnZXRTaGFyZWQyRENvbnRleHQoKTtcbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguY2FudmFzLndpZHRoID0gc2l6ZTtcbiAgICAgIGN0eC5jYW52YXMuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgIHdpZHRoID0gc2l6ZTtcbiAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgICBnZXRDdWJlRmFjZXNXaXRoTmR4KGdsLCBvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAwXSAqIHNpemU7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSBzbGljZXNbZi5uZHggKiAyICsgMV0gKiBzaXplO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGVsZW1lbnQsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIHNpemUsIDAsIDAsIHNpemUsIHNpemUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGN0eC5jYW52YXMpO1xuICAgICAgfSk7XG4gICAgICAvLyBGcmVlIHVwIHRoZSBjYW52YXMgbWVtb3J5XG4gICAgICBjdHguY2FudmFzLndpZHRoID0gMTtcbiAgICAgIGN0eC5jYW52YXMuaGVpZ2h0ID0gMTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE5PVEU6IEl0IHNlZW1zIGxpa2Ugd2Ugc2hvdWxkIHByZWZlciBJbWFnZUJpdG1hcCBiZWNhdXNlIHVubGlrZSBjYW52YXMgaXQnc1xuICAgICAgLy8gbm90ZSBsb3NzeT8gKGFscGhhIGlzIG5vdCBwcmVtdWx0aXBsaWVkPyBhbHRob3VnaCBJJ20gbm90IHN1cmUgd2hhdFxuICAgICAgd2lkdGggPSBzaXplO1xuICAgICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICAgIGdldEN1YmVGYWNlc1dpdGhOZHgoZ2wsIG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gc2xpY2VzW2YubmR4ICogMiArIDBdICogc2l6ZTtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IHNsaWNlc1tmLm5keCAqIDIgKyAxXSAqIHNpemU7XG4gICAgICAgIC8vIFdlIGNhbid0IGVhc2lseSB1c2UgYSBkZWZhdWx0IHRleHR1cmUgY29sb3IgaGVyZSBhcyBpdCB3b3VsZCBoYXZlIHRvIG1hdGNoXG4gICAgICAgIC8vIHRoZSB0eXBlIGFjcm9zcyBhbGwgZmFjZXMgd2hlcmUgYXMgd2l0aCBhIDJEIG9uZSB0aGVyZSdzIG9ubHkgb25lIGZhY2VcbiAgICAgICAgLy8gc28gd2UncmUgcmVwbGFjaW5nIGV2ZXJ5dGhpbmcgYWxsIGF0IG9uY2UuIEl0IGFsc28gaGFzIHRvIGJlIHRoZSBjb3JyZWN0IHNpemUuXG4gICAgICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kIHdlIG5lZWQgYWxsIGZhY2VzIHRvIGJlIHRoZSBzYW1lIHNpemUgc28gYXMgb25lIGZhY2UgbG9hZHNcbiAgICAgICAgLy8gdGhlIHJlc3QgbWF0Y2ggZWxzZSB0aGUgdGV4dHVyZSB3aWxsIGJlIHVuLXJlbmRlcmFibGUuXG4gICAgICAgIGdsLnRleEltYWdlMkQoZi5mYWNlLCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHNpemUsIHNpemUsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gICAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGVsZW1lbnQsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIHNpemUsIHtcbiAgICAgICAgICBwcmVtdWx0aXBseUFscGhhOiAnbm9uZScsXG4gICAgICAgICAgY29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJyxcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKGYuZmFjZSwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGltYWdlQml0bWFwKTtcbiAgICAgICAgICBpZiAoc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBpbnRlcm5hbEZvcm1hdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YXJnZXQgPT09IFRFWFRVUkVfM0QgfHwgdGFyZ2V0ID09PSBURVhUVVJFXzJEX0FSUkFZKSB7XG4gICAgY29uc3Qgc21hbGxlc3QgPSBNYXRoLm1pbihlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCk7XG4gICAgY29uc3QgbGFyZ2VzdCA9IE1hdGgubWF4KGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0KTtcbiAgICBjb25zdCBkZXB0aCA9IGxhcmdlc3QgLyBzbWFsbGVzdDtcbiAgICBpZiAoZGVwdGggJSAxICE9PSAwKSB7XG4gICAgICB0aHJvdyBcImNhbiBub3QgY29tcHV0ZSAzRCBkaW1lbnNpb25zIG9mIGVsZW1lbnRcIjtcbiAgICB9XG4gICAgY29uc3QgeE11bHQgPSBlbGVtZW50LndpZHRoICA9PT0gbGFyZ2VzdCA/IDEgOiAwO1xuICAgIGNvbnN0IHlNdWx0ID0gZWxlbWVudC5oZWlnaHQgPT09IGxhcmdlc3QgPyAxIDogMDtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfQUxJR05NRU5ULCAxKTtcbiAgICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfUk9XX0xFTkdUSCwgZWxlbWVudC53aWR0aCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX0lNQUdFX0hFSUdIVCwgMCk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1NLSVBfSU1BR0VTLCAwKTtcbiAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBzbWFsbGVzdCwgc21hbGxlc3QsIHNtYWxsZXN0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgY29uc3Qgc3JjWCA9IGQgKiBzbWFsbGVzdCAqIHhNdWx0O1xuICAgICAgY29uc3Qgc3JjWSA9IGQgKiBzbWFsbGVzdCAqIHlNdWx0O1xuICAgICAgZ2wucGl4ZWxTdG9yZWkoVU5QQUNLX1NLSVBfUElYRUxTLCBzcmNYKTtcbiAgICAgIGdsLnBpeGVsU3RvcmVpKFVOUEFDS19TS0lQX1JPV1MsIHNyY1kpO1xuICAgICAgZ2wudGV4U3ViSW1hZ2UzRCh0YXJnZXQsIGxldmVsLCAwLCAwLCBkLCBzbWFsbGVzdCwgc21hbGxlc3QsIDEsIGZvcm1hdCwgdHlwZSwgZWxlbWVudCk7XG4gICAgfVxuICAgIHNldFNraXBTdGF0ZVRvRGVmYXVsdChnbCk7XG4gIH0gZWxzZSB7XG4gICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBlbGVtZW50KTtcbiAgfVxuICBpZiAoc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpKSB7XG4gICAgc2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUoZ2wsIHRleCwgb3B0aW9ucywgd2lkdGgsIGhlaWdodCwgaW50ZXJuYWxGb3JtYXQpO1xuICB9XG4gIHNldFRleHR1cmVQYXJhbWV0ZXJzKGdsLCB0ZXgsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1cmwncyBvcmlnaW4gaXMgdGhlIHNhbWUgc28gdGhhdCB3ZSBjYW4gc2V0IHRoZSBgY3Jvc3NPcmlnaW5gXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIHVybCB0byBpbWFnZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHdpbmRvdydzIG9yaWdpbiBpcyB0aGUgc2FtZSBhcyBpbWFnZSdzIHVybFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXJsSXNTYW1lT3JpZ2luKHVybCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGZvciBJRSByZWFsbHlcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gYS5ob3N0bmFtZSA9PT0gbG9jYXRpb24uaG9zdG5hbWUgJiZcbiAgICAgICAgICAgYS5wb3J0ICAgICA9PT0gbG9jYXRpb24ucG9ydCAmJlxuICAgICAgICAgICBhLnByb3RvY29sID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsb2NhbE9yaWdpbiA9IChuZXcgVVJMKGxvY2F0aW9uLmhyZWYpKS5vcmlnaW47XG4gICAgY29uc3QgdXJsT3JpZ2luID0gKG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKSkub3JpZ2luO1xuICAgIHJldHVybiB1cmxPcmlnaW4gPT09IGxvY2FsT3JpZ2luO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFRvQW5vbnltb3VzSWZVbmRlZmluZWRBbmRVUkxJc05vdFNhbWVPcmlnaW4odXJsLCBjcm9zc09yaWdpbikge1xuICByZXR1cm4gY3Jvc3NPcmlnaW4gPT09IHVuZGVmaW5lZCAmJiAhdXJsSXNTYW1lT3JpZ2luKHVybClcbiAgICAgPyAnYW5vbnltb3VzJ1xuICAgICA6IGNyb3NzT3JpZ2luO1xufVxuXG4vKipcbiAqIExvYWRzIGFuIGltYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIHVybCB0byBpbWFnZVxuICogQHBhcmFtIHtzdHJpbmd9IGNyb3NzT3JpZ2luXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGVyciwgaW1nKX0gW2NhbGxiYWNrXSBhIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgYW4gZXJyb3IgYW5kIHRoZSBpbWFnZS4gVGhlIGVycm9yIHdpbGwgYmUgbm9uLW51bGxcbiAqICAgICBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IHRoZSBpbWFnZSBiZWluZyBsb2FkZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkSW1hZ2UodXJsLCBjcm9zc09yaWdpbiwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICBsZXQgaW1nO1xuICBjcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBjcm9zc09yaWdpbiA6IGRlZmF1bHRzJDEuY3Jvc3NPcmlnaW47XG4gIGNyb3NzT3JpZ2luID0gc2V0VG9Bbm9ueW1vdXNJZlVuZGVmaW5lZEFuZFVSTElzTm90U2FtZU9yaWdpbih1cmwsIGNyb3NzT3JpZ2luKTtcbiAgaWYgKHR5cGVvZiBJbWFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAoY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgfVxuXG4gICAgY29uc3QgY2xlYXJFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gY2xlYXJFdmVudEhhbmRsZXJzKCkge1xuICAgICAgaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpbWcgPSBudWxsO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcigpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiY291bGRuJ3QgbG9hZCBpbWFnZTogXCIgKyB1cmw7XG4gICAgICBlcnJvcihtc2cpO1xuICAgICAgY2FsbGJhY2sobXNnLCBpbWcpO1xuICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTG9hZCA9IGZ1bmN0aW9uIG9uTG9hZCgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGltZyk7XG4gICAgICBjbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICB9O1xuXG4gICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIGltZy5zcmMgPSB1cmw7XG4gICAgcmV0dXJuIGltZztcbiAgfSBlbHNlIGlmICh0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IGVycjtcbiAgICBsZXQgYm07XG4gICAgY29uc3QgY2IgPSBmdW5jdGlvbiBjYigpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgYm0pO1xuICAgIH07XG5cbiAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgICBvcHRpb25zLm1vZGUgPSAnY29ycyc7IC8vIFRPRE86IG5vdCBzdXJlIGhvdyB0byB0cmFuc2xhdGUgaW1hZ2UuY3Jvc3NPcmlnaW5cbiAgICB9XG4gICAgZmV0Y2godXJsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKGJsb2IpIHtcbiAgICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCB7XG4gICAgICAgIHByZW11bHRpcGx5QWxwaGE6ICdub25lJyxcbiAgICAgICAgY29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJyxcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oYml0bWFwKSB7XG4gICAgICAvLyBub3Qgc3VyZSBpZiB0aGlzIHdvcmtzLiBXZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBjYXRjaCB0aGUgdXNlcidzIGVycm9yLiBTbywgY2FsbFxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGluIGEgdGltZW91dCBzbyB3ZSdyZVxuICAgICAgLy8gbm90IGluIHRoaXMgc2NvcGUgaW5zaWRlIHRoZSBwcm9taXNlLlxuICAgICAgYm0gPSBiaXRtYXA7XG4gICAgICBzZXRUaW1lb3V0KGNiKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgICAgc2V0VGltZW91dChjYik7XG4gICAgfSk7XG4gICAgaW1nID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW1nO1xufVxuXG4vKipcbiAqIGNoZWNrIGlmIG9iamVjdCBpcyBhIFRleEltYWdlU291cmNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgYSBUZXhJbWFnZVNvdXJjZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNUZXhJbWFnZVNvdXJjZShvYmopIHtcbiAgcmV0dXJuICh0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB8fFxuICAgICAgICAgKHR5cGVvZiBJbWFnZURhdGEgIT09ICd1bmRlZmluZWQnICAmJiBvYmogaW5zdGFuY2VvZiBJbWFnZURhdGEpIHx8XG4gICAgICAgICAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpO1xufVxuXG4vKipcbiAqIGlmIG9iaiBpcyBhbiBUZXhJbWFnZVNvdXJjZSB0aGVuIGp1c3RcbiAqIHVzZXMgaXQgb3RoZXJ3aXNlIGlmIG9iaiBpcyBhIHN0cmluZ1xuICogdGhlbiBsb2FkIGl0IGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFRleEltYWdlU291cmNlfSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjcm9zc09yaWdpblxuICogQHBhcmFtIHtmdW5jdGlvbihlcnIsIGltZyl9IFtjYWxsYmFja10gYSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIGFuIGVycm9yIGFuZCB0aGUgaW1hZ2UuIFRoZSBlcnJvciB3aWxsIGJlIG5vbi1udWxsXG4gKiAgICAgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkQW5kVXNlSW1hZ2Uob2JqLCBjcm9zc09yaWdpbiwgY2FsbGJhY2spIHtcbiAgaWYgKGlzVGV4SW1hZ2VTb3VyY2Uob2JqKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBvYmopO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4gbG9hZEltYWdlKG9iaiwgY3Jvc3NPcmlnaW4sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBTZXRzIGEgdGV4dHVyZSB0byBhIDF4MSBwaXhlbCBjb2xvci4gSWYgYG9wdGlvbnMuY29sb3IgPT09IGZhbHNlYCBpcyBub3RoaW5nIGhhcHBlbnMuIElmIGl0J3Mgbm90IHNldFxuICogdGhlIGRlZmF1bHQgdGV4dHVyZSBjb2xvciBpcyB1c2VkIHdoaWNoIGNhbiBiZSBzZXQgYnkgY2FsbGluZyBgc2V0RGVmYXVsdFRleHR1cmVDb2xvcmAuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gW29wdGlvbnNdIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiAgIFRoaXMgaXMgb2Z0ZW4gdGhlIHNhbWUgb3B0aW9ucyB5b3UgcGFzc2VkIGluIHdoZW4geW91IGNyZWF0ZWQgdGhlIHRleHR1cmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuZnVuY3Rpb24gc2V0VGV4dHVyZVRvMVBpeGVsQ29sb3IoZ2wsIHRleCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxLnRleHR1cmVPcHRpb25zO1xuICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIGlmIChvcHRpb25zLmNvbG9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBBc3N1bWUgaXQncyBhIFVSTFxuICAvLyBQdXQgMXgxIHBpeGVscyBpbiB0ZXh0dXJlLiBUaGF0IG1ha2VzIGl0IHJlbmRlcmFibGUgaW1tZWRpYXRlbHkgcmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcuXG4gIGNvbnN0IGNvbG9yID0gbWFrZTFQaXhlbChvcHRpb25zLmNvbG9yKTtcbiAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCA2OyArK2lpKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGlpLCAwLCBSR0JBLCAxLCAxLCAwLCBSR0JBLCBVTlNJR05FRF9CWVRFJDIsIGNvbG9yKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCAwLCBSR0JBLCAxLCAxLCAxLCAwLCBSR0JBLCBVTlNJR05FRF9CWVRFJDIsIGNvbG9yKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgMCwgUkdCQSwgMSwgMSwgMCwgUkdCQSwgVU5TSUdORURfQllURSQyLCBjb2xvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgc3JjIGltYWdlKHMpIHVzZWQgdG8gY3JlYXRlIGEgdGV4dHVyZS5cbiAqXG4gKiBXaGVuIHlvdSBjYWxsIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVUZXh0dXJlfSBvciB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVGV4dHVyZXN9XG4gKiB5b3UgY2FuIHBhc3MgaW4gdXJscyBmb3IgaW1hZ2VzIHRvIGxvYWQgaW50byB0aGUgdGV4dHVyZXMuIElmIGl0J3MgYSBzaW5nbGUgdXJsXG4gKiB0aGVuIHRoaXMgd2lsbCBiZSBhIHNpbmdsZSBIVE1MSW1hZ2VFbGVtZW50LiBJZiBpdCdzIGFuIGFycmF5IG9mIHVybHMgdXNlZCBmb3IgYSBjdWJlbWFwXG4gKiB0aGlzIHdpbGwgYmUgYSBjb3JyZXNwb25kaW5nIGFycmF5IG9mIGltYWdlcyBmb3IgdGhlIGN1YmVtYXAuXG4gKlxuICogQHR5cGVkZWYge0hUTUxJbWFnZUVsZW1lbnR8SFRNTEltYWdlRWxlbWVudFtdfSBUZXh0dXJlU3JjXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYW4gaW1hZ2UgZmluaXNoZWQgZG93bmxvYWRpbmcgYW5kIGJlZW4gdXBsb2FkZWQgaW50byBhIHRleHR1cmVcbiAqIEBjYWxsYmFjayBUZXh0dXJlUmVhZHlDYWxsYmFja1xuICogQHBhcmFtIHsqfSBlcnIgSWYgdHJ1dGh5IHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXh0dXJlIHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlU3JjfSBzb3VyY2UgaW1hZ2UocykgdXNlZCB0byBhcyB0aGUgc3JjIGZvciB0aGUgdGV4dHVyZVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIGZvciB3aGVuIGFsbCBpbWFnZXMgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZyBhbmQgYmVlbiB1cGxvYWRlZCBpbnRvIHRoZWlyIHJlc3BlY3RpdmUgdGV4dHVyZXNcbiAqIEBjYWxsYmFjayBUZXh0dXJlc1JlYWR5Q2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gZXJyIElmIHRydXRoeSB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBXZWJHTFRleHR1cmU+fSB0ZXh0dXJlcyB0aGUgY3JlYXRlZCB0ZXh0dXJlcyBieSBuYW1lLiBTYW1lIGFzIHJldHVybmVkIGJ5IHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVUZXh0dXJlc30uXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBtb2R1bGU6dHdnbC5UZXh0dXJlU3JjPn0gc291cmNlcyB0aGUgaW1hZ2UocykgdXNlZCBmb3IgdGhlIHRleHR1cmUgYnkgbmFtZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQSBjYWxsYmFjayBmb3Igd2hlbiBhbiBpbWFnZSBmaW5pc2hlZCBkb3dubG9hZGluZyBhbmQgYmVlbiB1cGxvYWRlZCBpbnRvIGEgdGV4dHVyZVxuICogQGNhbGxiYWNrIEN1YmVtYXBSZWFkeUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGVyciBJZiB0cnV0aHkgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudFtdfSBpbWdzIHRoZSBpbWFnZXMgZm9yIGVhY2ggZmFjZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQSBjYWxsYmFjayBmb3Igd2hlbiBhbiBpbWFnZSBmaW5pc2hlZCBkb3dubG9hZGluZyBhbmQgYmVlbiB1cGxvYWRlZCBpbnRvIGEgdGV4dHVyZVxuICogQGNhbGxiYWNrIFRocmVlRFJlYWR5Q2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gZXJyIElmIHRydXRoeSB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50W119IGltZ3MgdGhlIGltYWdlcyBmb3IgZWFjaCBzbGljZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogTG9hZHMgYSB0ZXh0dXJlIGZyb20gYW4gaW1hZ2UgZnJvbSBhIFVybCBhcyBzcGVjaWZpZWQgaW4gYG9wdGlvbnMuc3JjYFxuICogSWYgYG9wdGlvbnMuY29sb3IgIT09IGZhbHNlYCB3aWxsIHNldCB0aGUgdGV4dHVyZSB0byBhIDF4MSBwaXhlbCBjb2xvciBzbyB0aGF0IHRoZSB0ZXh0dXJlIGlzXG4gKiBpbW1lZGlhdGVseSB1c2VhYmxlLiBJdCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGltYWdlIG9uY2UgdGhlIGltYWdlIGhhcyBmaW5pc2hlZFxuICogZG93bmxvYWRpbmcuIEZpbHRlcmluZyBvcHRpb25zIHdpbGwgYmUgc2V0IGFzIGFwcHJvcHJpYXRlIGZvciBpbWFnZSB1bmxlc3MgYG9wdGlvbnMuYXV0byA9PT0gZmFsc2VgLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IFtvcHRpb25zXSBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlUmVhZHlDYWxsYmFja30gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBpbWFnZSBoYXMgZmluaXNoZWQgbG9hZGluZy4gZXJyIHdpbGxcbiAqICAgIGJlIG5vbiBudWxsIGlmIHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IHRoZSBpbWFnZSBiZWluZyBkb3dubG9hZGVkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIGxvYWRUZXh0dXJlRnJvbVVybChnbCwgdGV4LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDEudGV4dHVyZU9wdGlvbnM7XG4gIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpO1xuICAvLyBCZWNhdXNlIGl0J3MgYXN5bmMgd2UgbmVlZCB0byBjb3B5IHRoZSBvcHRpb25zLlxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIGNvbnN0IGltZyA9IGxvYWRBbmRVc2VJbWFnZShvcHRpb25zLnNyYywgb3B0aW9ucy5jcm9zc09yaWdpbiwgZnVuY3Rpb24oZXJyLCBpbWcpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIHRleCwgaW1nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGV4dHVyZUZyb21FbGVtZW50KGdsLCB0ZXgsIGltZywgb3B0aW9ucyk7XG4gICAgICBjYWxsYmFjayhudWxsLCB0ZXgsIGltZyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGltZztcbn1cblxuLyoqXG4gKiBMb2FkcyBhIGN1YmVtYXAgZnJvbSA2IHVybHMgb3IgVGV4SW1hZ2VTb3VyY2VzIGFzIHNwZWNpZmllZCBpbiBgb3B0aW9ucy5zcmNgLiBXaWxsIHNldCB0aGUgY3ViZW1hcCB0byBhIDF4MSBwaXhlbCBjb2xvclxuICogc28gdGhhdCBpdCBpcyB1c2FibGUgaW1tZWRpYXRlbHkgdW5sZXNzIGBvcHRpb24uY29sb3IgPT09IGZhbHNlYC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4IHRoZSBXZWJHTFRleHR1cmUgdG8gc2V0IHBhcmFtZXRlcnMgZm9yXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkN1YmVtYXBSZWFkeUNhbGxiYWNrfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYWxsIHRoZSBpbWFnZXMgaGF2ZSBmaW5pc2hlZCBsb2FkaW5nLiBlcnIgd2lsbFxuICogICAgYmUgbm9uIG51bGwgaWYgdGhlcmUgd2FzIGFuIGVycm9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIGxvYWRDdWJlbWFwRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICBjb25zdCB1cmxzID0gb3B0aW9ucy5zcmM7XG4gIGlmICh1cmxzLmxlbmd0aCAhPT0gNikge1xuICAgIHRocm93IFwidGhlcmUgbXVzdCBiZSA2IHVybHMgZm9yIGEgY3ViZW1hcFwiO1xuICB9XG4gIGNvbnN0IGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQgfHwgUkdCQTtcbiAgY29uc3QgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICBjb25zdCB0eXBlID0gb3B0aW9ucy50eXBlIHx8IFVOU0lHTkVEX0JZVEUkMjtcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcbiAgaWYgKHRhcmdldCAhPT0gVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIHRocm93IFwidGFyZ2V0IG11c3QgYmUgVEVYVFVSRV9DVUJFX01BUFwiO1xuICB9XG4gIHNldFRleHR1cmVUbzFQaXhlbENvbG9yKGdsLCB0ZXgsIG9wdGlvbnMpO1xuICAvLyBCZWNhdXNlIGl0J3MgYXN5bmMgd2UgbmVlZCB0byBjb3B5IHRoZSBvcHRpb25zLlxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIGxldCBudW1Ub0xvYWQgPSA2O1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgZmFjZXMgPSBnZXRDdWJlRmFjZU9yZGVyKGdsLCBvcHRpb25zKTtcbiAgbGV0IGltZ3M7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgZnVuY3Rpb24gdXBsb2FkSW1nKGZhY2VUYXJnZXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyLCBpbWcpIHtcbiAgICAgIC0tbnVtVG9Mb2FkO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGltZy53aWR0aCAhPT0gaW1nLmhlaWdodCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKFwiY3ViZW1hcCBmYWNlIGltZyBpcyBub3QgYSBzcXVhcmU6IFwiICsgaW1nLnNyYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0UGFja1N0YXRlKGdsLCBvcHRpb25zKTtcbiAgICAgICAgICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG5cbiAgICAgICAgICAvLyBTbyBhc3N1bWluZyB0aGlzIGlzIHRoZSBmaXJzdCBpbWFnZSB3ZSBub3cgaGF2ZSBvbmUgZmFjZSB0aGF0J3MgaW1nIHNpemVkXG4gICAgICAgICAgLy8gYW5kIDUgZmFjZXMgdGhhdCBhcmUgMXgxIHBpeGVsIHNvIHNpemUgdGhlIG90aGVyIGZhY2VzXG4gICAgICAgICAgaWYgKG51bVRvTG9hZCA9PT0gNSkge1xuICAgICAgICAgICAgLy8gdXNlIHRoZSBkZWZhdWx0IG9yZGVyXG4gICAgICAgICAgICBnZXRDdWJlRmFjZU9yZGVyKCkuZm9yRWFjaChmdW5jdGlvbihvdGhlclRhcmdldCkge1xuICAgICAgICAgICAgICAvLyBTaG91bGQgd2UgcmUtdXNlIHRoZSBzYW1lIGZhY2Ugb3IgYSBjb2xvcj9cbiAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChvdGhlclRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIGltZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChmYWNlVGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgaW1nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQXV0b21hdGljYWxseVNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtVG9Mb2FkID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiB1bmRlZmluZWQsIHRleCwgaW1ncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGltZ3MgPSB1cmxzLm1hcChmdW5jdGlvbih1cmwsIG5keCkge1xuICAgIHJldHVybiBsb2FkQW5kVXNlSW1hZ2UodXJsLCBvcHRpb25zLmNyb3NzT3JpZ2luLCB1cGxvYWRJbWcoZmFjZXNbbmR4XSkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhIDJkIGFycmF5IG9yIDNkIHRleHR1cmUgZnJvbSB1cmxzIE9SIFRleEltYWdlU291cmNlcyBhcyBzcGVjaWZpZWQgaW4gYG9wdGlvbnMuc3JjYC5cbiAqIFdpbGwgc2V0IHRoZSB0ZXh0dXJlIHRvIGEgMXgxIHBpeGVsIGNvbG9yXG4gKiBzbyB0aGF0IGl0IGlzIHVzYWJsZSBpbW1lZGlhdGVseSB1bmxlc3MgYG9wdGlvbi5jb2xvciA9PT0gZmFsc2VgLlxuICpcbiAqIElmIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGlzIG5vdCBzcGVjaWZpZWQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGZpcnN0XG4gKiBpbWFnZSBsb2FkZWQgd2lsbCBiZSB1c2VkLiBOb3RlIHRoYXQgc2luY2UgaW1hZ2VzIGFyZSBsb2FkZWQgYXN5bmNcbiAqIHdoaWNoIGltYWdlIGRvd25sb2FkcyBmaXJzdCBpcyB1bmtub3duLlxuICpcbiAqIElmIGFuIGltYWdlIGlzIG5vdCB0aGUgc2FtZSBzaXplIGFzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGl0IHdpbGwgYmUgc2NhbGVkXG4gKiB0byB0aGF0IHdpZHRoIGFuZCBoZWlnaHQuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIFdlYkdMVGV4dHVyZSB0byBzZXQgcGFyYW1ldGVycyBmb3JcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnN9IG9wdGlvbnMgQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGhyZWVEUmVhZHlDYWxsYmFja30gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGFsbCB0aGUgaW1hZ2VzIGhhdmUgZmluaXNoZWQgbG9hZGluZy4gZXJyIHdpbGxcbiAqICAgIGJlIG5vbiBudWxsIGlmIHRoZXJlIHdhcyBhbiBlcnJvci5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBsb2FkU2xpY2VzRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICBjb25zdCB1cmxzID0gb3B0aW9ucy5zcmM7XG4gIGNvbnN0IGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICBjb25zdCBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgVU5TSUdORURfQllURSQyO1xuICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEX0FSUkFZO1xuICBpZiAodGFyZ2V0ICE9PSBURVhUVVJFXzNEICYmIHRhcmdldCAhPT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIHRocm93IFwidGFyZ2V0IG11c3QgYmUgVEVYVFVSRV8zRCBvciBURVhUVVJFXzJEX0FSUkFZXCI7XG4gIH1cbiAgc2V0VGV4dHVyZVRvMVBpeGVsQ29sb3IoZ2wsIHRleCwgb3B0aW9ucyk7XG4gIC8vIEJlY2F1c2UgaXQncyBhc3luYyB3ZSBuZWVkIHRvIGNvcHkgdGhlIG9wdGlvbnMuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgbGV0IG51bVRvTG9hZCA9IHVybHMubGVuZ3RoO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgbGV0IGltZ3M7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGNvbnN0IGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICBsZXQgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICBsZXQgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIGNvbnN0IGRlcHRoID0gdXJscy5sZW5ndGg7XG4gIGxldCBmaXJzdEltYWdlID0gdHJ1ZTtcblxuICBmdW5jdGlvbiB1cGxvYWRJbWcoc2xpY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyLCBpbWcpIHtcbiAgICAgIC0tbnVtVG9Mb2FkO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UGFja1N0YXRlKGdsLCBvcHRpb25zKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuXG4gICAgICAgIGlmIChmaXJzdEltYWdlKSB7XG4gICAgICAgICAgZmlyc3RJbWFnZSA9IGZhbHNlO1xuICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy53aWR0aCB8fCBpbWcud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgaW1nLmhlaWdodDtcbiAgICAgICAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcblxuICAgICAgICAgIC8vIHB1dCBpdCBpbiBldmVyeSBzbGljZSBvdGhlcndpc2Ugc29tZSBzbGljZXMgd2lsbCBiZSAwLDAsMCwwXG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBkZXB0aDsgKytzKSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIDAsIDAsIHMsIHdpZHRoLCBoZWlnaHQsIDEsIGZvcm1hdCwgdHlwZSwgaW1nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHNyYyA9IGltZztcbiAgICAgICAgICBsZXQgY3R4O1xuICAgICAgICAgIGlmIChpbWcud2lkdGggIT09IHdpZHRoIHx8IGltZy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgLy8gU2l6ZSB0aGUgaW1hZ2UgdG8gZml4XG4gICAgICAgICAgICBjdHggPSBnZXRTaGFyZWQyRENvbnRleHQoKTtcbiAgICAgICAgICAgIHNyYyA9IGN0eC5jYW52YXM7XG4gICAgICAgICAgICBjdHguY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjdHguY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnbC50ZXhTdWJJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIDAsIDAsIHNsaWNlLCB3aWR0aCwgaGVpZ2h0LCAxLCBmb3JtYXQsIHR5cGUsIHNyYyk7XG5cbiAgICAgICAgICAvLyBmcmVlIHRoZSBjYW52YXMgbWVtb3J5XG4gICAgICAgICAgaWYgKGN0eCAmJiBzcmMgPT09IGN0eC5jYW52YXMpIHtcbiAgICAgICAgICAgIGN0eC5jYW52YXMud2lkdGggPSAwO1xuICAgICAgICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRBdXRvbWF0aWNhbGx5U2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemUob3B0aW9ucykpIHtcbiAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1Ub0xvYWQgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHVuZGVmaW5lZCwgdGV4LCBpbWdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW1ncyA9IHVybHMubWFwKGZ1bmN0aW9uKHVybCwgbmR4KSB7XG4gICAgcmV0dXJuIGxvYWRBbmRVc2VJbWFnZSh1cmwsIG9wdGlvbnMuY3Jvc3NPcmlnaW4sIHVwbG9hZEltZyhuZHgpKTtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0cyBhIHRleHR1cmUgZnJvbSBhbiBhcnJheSBvciB0eXBlZCBhcnJheS4gSWYgdGhlIHdpZHRoIG9yIGhlaWdodCBpcyBub3QgcHJvdmlkZWQgd2lsbCBhdHRlbXB0IHRvXG4gKiBndWVzcyB0aGUgc2l6ZS4gU2VlIHtAbGluayBtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHsobnVtYmVyW118QXJyYXlCdWZmZXJWaWV3KX0gc3JjIEFuIGFycmF5IG9yIHR5cGVkIGFycnkgd2l0aCB0ZXh0dXJlIGRhdGEuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqICAgVGhpcyBpcyBvZnRlbiB0aGUgc2FtZSBvcHRpb25zIHlvdSBwYXNzZWQgaW4gd2hlbiB5b3UgY3JlYXRlZCB0aGUgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBzZXRUZXh0dXJlRnJvbUFycmF5KGdsLCB0ZXgsIHNyYywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxLnRleHR1cmVPcHRpb25zO1xuICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIGxldCB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gIGxldCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgbGV0IGRlcHRoID0gb3B0aW9ucy5kZXB0aDtcbiAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IDA7XG4gIGNvbnN0IGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICBjb25zdCBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZ2V0VGV4dHVyZVR5cGVGb3JBcnJheVR5cGUoZ2wsIHNyYywgZm9ybWF0VHlwZS50eXBlKTtcbiAgaWYgKCFpc0FycmF5QnVmZmVyJDEoc3JjKSkge1xuICAgIGNvbnN0IFR5cGUgPSBnZXRUeXBlZEFycmF5VHlwZUZvckdMVHlwZSh0eXBlKTtcbiAgICBzcmMgPSBuZXcgVHlwZShzcmMpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgc3JjID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlcik7XG4gIH1cblxuICBjb25zdCBieXRlc1BlckVsZW1lbnQgPSBnZXRCeXRlc1BlckVsZW1lbnRGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCwgdHlwZSk7XG4gIGNvbnN0IG51bUVsZW1lbnRzID0gc3JjLmJ5dGVMZW5ndGggLyBieXRlc1BlckVsZW1lbnQ7ICAvLyBUT0RPOiBjaGVjayBVTlBBQ0tfQUxJR05NRU5UP1xuICBpZiAobnVtRWxlbWVudHMgJSAxKSB7XG4gICAgdGhyb3cgXCJsZW5ndGggd3Jvbmcgc2l6ZSBmb3IgZm9ybWF0OiBcIiArIGdsRW51bVRvU3RyaW5nKGdsLCBmb3JtYXQpO1xuICB9XG4gIGxldCBkaW1lbnNpb25zO1xuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGlmICghd2lkdGggJiYgIWhlaWdodCAmJiAhZGVwdGgpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBNYXRoLmNicnQobnVtRWxlbWVudHMpO1xuICAgICAgaWYgKHNpemUgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IFwiY2FuJ3QgZ3Vlc3MgY3ViZSBzaXplIG9mIGFycmF5IG9mIG51bUVsZW1lbnRzOiBcIiArIG51bUVsZW1lbnRzO1xuICAgICAgfVxuICAgICAgd2lkdGggPSBzaXplO1xuICAgICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICAgIGRlcHRoID0gc2l6ZTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoICYmICghaGVpZ2h0IHx8ICFkZXB0aCkpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSBndWVzc0RpbWVuc2lvbnMoZ2wsIHRhcmdldCwgaGVpZ2h0LCBkZXB0aCwgbnVtRWxlbWVudHMgLyB3aWR0aCk7XG4gICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgZGVwdGggPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGhlaWdodCAmJiAoIXdpZHRoIHx8ICFkZXB0aCkpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSBndWVzc0RpbWVuc2lvbnMoZ2wsIHRhcmdldCwgd2lkdGgsIGRlcHRoLCBudW1FbGVtZW50cyAvIGhlaWdodCk7XG4gICAgICB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICBkZXB0aCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaW1lbnNpb25zID0gZ3Vlc3NEaW1lbnNpb25zKGdsLCB0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG51bUVsZW1lbnRzIC8gZGVwdGgpO1xuICAgICAgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpbWVuc2lvbnMgPSBndWVzc0RpbWVuc2lvbnMoZ2wsIHRhcmdldCwgd2lkdGgsIGhlaWdodCwgbnVtRWxlbWVudHMpO1xuICAgIHdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgfVxuICBzZXRTa2lwU3RhdGVUb0RlZmF1bHQoZ2wpO1xuICBnbC5waXhlbFN0b3JlaShVTlBBQ0tfQUxJR05NRU5ULCBvcHRpb25zLnVucGFja0FsaWdubWVudCB8fCAxKTtcbiAgc2V0UGFja1N0YXRlKGdsLCBvcHRpb25zKTtcbiAgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV9DVUJFX01BUCkge1xuICAgIGNvbnN0IGVsZW1lbnRzUGVyRWxlbWVudCA9IGJ5dGVzUGVyRWxlbWVudCAvIHNyYy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBjb25zdCBmYWNlU2l6ZSA9IG51bUVsZW1lbnRzIC8gNiAqIGVsZW1lbnRzUGVyRWxlbWVudDtcblxuICAgIGdldEN1YmVGYWNlc1dpdGhOZHgoZ2wsIG9wdGlvbnMpLmZvckVhY2goZiA9PiB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBmYWNlU2l6ZSAqIGYubmR4O1xuICAgICAgY29uc3QgZGF0YSA9IHNyYy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGZhY2VTaXplKTtcbiAgICAgIGdsLnRleEltYWdlMkQoZi5mYWNlLCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIHNyYyk7XG4gIH0gZWxzZSB7XG4gICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBzcmMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGRlcHRoOiBkZXB0aCxcbiAgICB0eXBlOiB0eXBlLFxuICB9O1xufVxuXG4vKipcbiAqIFNldHMgYSB0ZXh0dXJlIHdpdGggbm8gY29udGVudHMgb2YgYSBjZXJ0YWluIHNpemUuIEluIG90aGVyIHdvcmRzIGNhbGxzIGBnbC50ZXhJbWFnZTJEYCB3aXRoIGBudWxsYC5cbiAqIFlvdSBtdXN0IHNldCBgb3B0aW9ucy53aWR0aGAgYW5kIGBvcHRpb25zLmhlaWdodGAuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IHRleCB0aGUgV2ViR0xUZXh0dXJlIHRvIHNldCBwYXJhbWV0ZXJzIGZvclxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gb3B0aW9ucyBBIFRleHR1cmVPcHRpb25zIG9iamVjdCB3aXRoIHdoYXRldmVyIHBhcmFtZXRlcnMgeW91IHdhbnQgc2V0LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIHNldEVtcHR5VGV4dHVyZShnbCwgdGV4LCBvcHRpb25zKSB7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQ7XG4gIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4KTtcbiAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IDA7XG4gIGNvbnN0IGludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCBvcHRpb25zLmZvcm1hdCB8fCBSR0JBO1xuICBjb25zdCBmb3JtYXRUeXBlID0gZ2V0Rm9ybWF0QW5kVHlwZUZvckludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0KTtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0VHlwZS5mb3JtYXQ7XG4gIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZm9ybWF0VHlwZS50eXBlO1xuICBzZXRQYWNrU3RhdGUoZ2wsIG9wdGlvbnMpO1xuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IDY7ICsraWkpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaWksIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gVEVYVFVSRV8zRCB8fCB0YXJnZXQgPT09IFRFWFRVUkVfMkRfQVJSQVkpIHtcbiAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgb3B0aW9ucy5kZXB0aCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBvcHRpb25zIHBhc3NlZCBpbi5cbiAqXG4gKiBOb3RlOiBtYXkgcmVzZXQgVU5QQUNLX0FMSUdOTUVOVCwgVU5QQUNLX1JPV19MRU5HVEgsIFVOUEFDS19JTUFHRV9IRUlHSFQsIFVOUEFDS19TS0lQX0lNQUdFU1xuICogVU5QQUNLX1NLSVBfUElYRUxTLCBhbmQgVU5QQUNLX1NLSVBfUk9XU1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBbb3B0aW9uc10gQSBUZXh0dXJlT3B0aW9ucyBvYmplY3Qgd2l0aCB3aGF0ZXZlciBwYXJhbWV0ZXJzIHlvdSB3YW50IHNldC5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZVJlYWR5Q2FsbGJhY2t9IFtjYWxsYmFja10gQSBjYWxsYmFjayBjYWxsZWQgd2hlbiBhbiBpbWFnZSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCB1cGxvYWRlZCB0byB0aGUgdGV4dHVyZS5cbiAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX0gdGhlIGNyZWF0ZWQgdGV4dHVyZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC90ZXh0dXJlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDEudGV4dHVyZU9wdGlvbnM7XG4gIGNvbnN0IHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgVEVYVFVSRV8yRDtcbiAgbGV0IHdpZHRoICA9IG9wdGlvbnMud2lkdGggIHx8IDE7XG4gIGxldCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCAxO1xuICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgUkdCQTtcbiAgZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXgpO1xuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgLy8gdGhpcyBzaG91bGQgaGF2ZSBiZWVuIHRoZSBkZWZhdWx0IGZvciBjdWJlbWFwcyA6KFxuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBURVhUVVJFX1dSQVBfUywgQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIFRFWFRVUkVfV1JBUF9ULCBDTEFNUF9UT19FREdFKTtcbiAgfVxuICBsZXQgc3JjID0gb3B0aW9ucy5zcmM7XG4gIGlmIChzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzcmMgPSBzcmMoZ2wsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChzcmMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBsb2FkVGV4dHVyZUZyb21VcmwoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlciQxKHNyYykgfHxcbiAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHNyYykgJiYgKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc3JjWzBdID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHNyY1swXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheUJ1ZmZlciQxKHNyY1swXSkpXG4gICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICkge1xuICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHNldFRleHR1cmVGcm9tQXJyYXkoZ2wsIHRleCwgc3JjLCBvcHRpb25zKTtcbiAgICAgIHdpZHRoICA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSAmJiAodHlwZW9mIChzcmNbMF0pID09PSAnc3RyaW5nJyB8fCBpc1RleEltYWdlU291cmNlKHNyY1swXSkpKSB7XG4gICAgICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgICAgIGxvYWRDdWJlbWFwRnJvbVVybHMoZ2wsIHRleCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZFNsaWNlc0Zyb21VcmxzKGdsLCB0ZXgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBpZiAoaXNUZXhJbWFnZVNvdXJjZShzcmMpKVxuICAgICAgc2V0VGV4dHVyZUZyb21FbGVtZW50KGdsLCB0ZXgsIHNyYywgb3B0aW9ucyk7XG4gICAgICB3aWR0aCAgPSBzcmMud2lkdGg7XG4gICAgICBoZWlnaHQgPSBzcmMuaGVpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRFbXB0eVRleHR1cmUoZ2wsIHRleCwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKHNob3VsZEF1dG9tYXRpY2FsbHlTZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZShvcHRpb25zKSkge1xuICAgIHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplKGdsLCB0ZXgsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIGludGVybmFsRm9ybWF0KTtcbiAgfVxuICBzZXRUZXh0dXJlUGFyYW1ldGVycyhnbCwgdGV4LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRleDtcbn1cblxuLyoqXG4gKiBSZXNpemVzIGEgdGV4dHVyZSBiYXNlZCBvbiB0aGUgb3B0aW9ucyBwYXNzZWQgaW4uXG4gKlxuICogTm90ZTogVGhpcyBpcyBub3QgYSBnZW5lcmljIHJlc2l6ZSBhbnl0aGluZyBmdW5jdGlvbi5cbiAqIEl0J3MgbW9zdGx5IHVzZWQgYnkge0BsaW5rIG1vZHVsZTp0d2dsLnJlc2l6ZUZyYW1lYnVmZmVySW5mb31cbiAqIEl0IHdpbGwgdXNlIGBvcHRpb25zLnNyY2AgaWYgaXQgZXhpc3RzIHRvIHRyeSB0byBkZXRlcm1pbmUgYSBgdHlwZWBcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBgZ2wuVU5TSUdORURfQllURWAuIE5vIGRhdGEgaXMgcHJvdmlkZWRcbiAqIGZvciB0aGUgdGV4dHVyZS4gVGV4dHVyZSBwYXJhbWV0ZXJzIHdpbGwgYmUgc2V0IGFjY29yZGluZ2x5XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSB0ZXggdGhlIHRleHR1cmUgdG8gcmVzaXplXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfSBvcHRpb25zIEEgVGV4dHVyZU9wdGlvbnMgb2JqZWN0IHdpdGggd2hhdGV2ZXIgcGFyYW1ldGVycyB5b3Ugd2FudCBzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSB0aGUgbmV3IHdpZHRoLiBJZiBub3QgcGFzc2VkIGluIHdpbGwgdXNlIGBvcHRpb25zLndpZHRoYFxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBuZXcgaGVpZ2h0LiBJZiBub3QgcGFzc2VkIGluIHdpbGwgdXNlIGBvcHRpb25zLmhlaWdodGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGhdIHRoZSBuZXcgZGVwdGguIElmIG5vdCBwYXNzZWQgaW4gd2lsbCB1c2UgYG9wdGlvbnMuZGVwdGhgXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdGV4dHVyZXNcbiAqL1xuZnVuY3Rpb24gcmVzaXplVGV4dHVyZShnbCwgdGV4LCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCkge1xuICB3aWR0aCA9IHdpZHRoIHx8IG9wdGlvbnMud2lkdGg7XG4gIGhlaWdodCA9IGhlaWdodCB8fCBvcHRpb25zLmhlaWdodDtcbiAgZGVwdGggPSBkZXB0aCB8fCBvcHRpb25zLmRlcHRoO1xuICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldCB8fCBURVhUVVJFXzJEO1xuICBnbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gIGNvbnN0IGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQgfHwgUkdCQTtcbiAgY29uc3QgZm9ybWF0VHlwZSA9IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdChpbnRlcm5hbEZvcm1hdCk7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdFR5cGUuZm9ybWF0O1xuICBsZXQgdHlwZTtcbiAgY29uc3Qgc3JjID0gb3B0aW9ucy5zcmM7XG4gIGlmICghc3JjKSB7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBmb3JtYXRUeXBlLnR5cGU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlciQxKHNyYykgfHwgKEFycmF5LmlzQXJyYXkoc3JjKSAmJiB0eXBlb2YgKHNyY1swXSkgPT09ICdudW1iZXInKSkge1xuICAgIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZ2V0VGV4dHVyZVR5cGVGb3JBcnJheVR5cGUoZ2wsIHNyYywgZm9ybWF0VHlwZS50eXBlKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlIHx8IGZvcm1hdFR5cGUudHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0ID09PSBURVhUVVJFX0NVQkVfTUFQKSB7XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IDY7ICsraWkpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaWksIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBURVhUVVJFXzNEIHx8IHRhcmdldCA9PT0gVEVYVFVSRV8yRF9BUlJBWSkge1xuICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHNyYyBpcyBhbiBhc3luYyByZXF1ZXN0LlxuICogaWYgc3JjIGlzIGEgc3RyaW5nIHdlJ3JlIGdvaW5nIHRvIGRvd25sb2FkIGFuIGltYWdlXG4gKiBpZiBzcmMgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyB3ZSdyZSBnb2luZyB0byBkb3dubG9hZCBjdWJlbWFwIGltYWdlc1xuICogQHBhcmFtIHsqfSBzcmMgVGhlIHNyYyBmcm9tIGEgVGV4dHVyZU9wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sfSB0cnVlIGlmIHNyYyBpcyBhc3luYy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQXN5bmNTcmMoc3JjKSB7XG4gIHJldHVybiB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgKEFycmF5LmlzQXJyYXkoc3JjKSAmJiB0eXBlb2Ygc3JjWzBdID09PSAnc3RyaW5nJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJ1bmNoIG9mIHRleHR1cmVzIGJhc2VkIG9uIHRoZSBwYXNzZWQgaW4gb3B0aW9ucy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB0ZXh0dXJlcyA9IHR3Z2wuY3JlYXRlVGV4dHVyZXMoZ2wsIHtcbiAqICAgICAgIC8vIGEgcG93ZXIgb2YgMiBpbWFnZVxuICogICAgICAgaGZ0SWNvbjogeyBzcmM6IFwiaW1hZ2VzL2hmdC1pY29uLTE2LnBuZ1wiLCBtYWc6IGdsLk5FQVJFU1QgfSxcbiAqICAgICAgIC8vIGEgbm9uLXBvd2VyIG9mIDIgaW1hZ2VcbiAqICAgICAgIGNsb3ZlcjogeyBzcmM6IFwiaW1hZ2VzL2Nsb3Zlci5qcGdcIiB9LFxuICogICAgICAgLy8gRnJvbSBhIGNhbnZhc1xuICogICAgICAgZnJvbUNhbnZhczogeyBzcmM6IGN0eC5jYW52YXMgfSxcbiAqICAgICAgIC8vIEEgY3ViZW1hcCBmcm9tIDYgaW1hZ2VzXG4gKiAgICAgICB5b2tvaGFtYToge1xuICogICAgICAgICB0YXJnZXQ6IGdsLlRFWFRVUkVfQ1VCRV9NQVAsXG4gKiAgICAgICAgIHNyYzogW1xuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zeC5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVneC5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zeS5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVneS5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvcG9zei5qcGcnLFxuICogICAgICAgICAgICdpbWFnZXMveW9rb2hhbWEvbmVnei5qcGcnLFxuICogICAgICAgICBdLFxuICogICAgICAgfSxcbiAqICAgICAgIC8vIEEgY3ViZW1hcCBmcm9tIDEgaW1hZ2UgKGNhbiBiZSAxeDYsIDJ4MywgM3gyLCA2eDEpXG4gKiAgICAgICBnb2xkZW5nYXRlOiB7XG4gKiAgICAgICAgIHRhcmdldDogZ2wuVEVYVFVSRV9DVUJFX01BUCxcbiAqICAgICAgICAgc3JjOiAnaW1hZ2VzL2dvbGRlbmdhdGUuanBnJyxcbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBBIDJ4MiBwaXhlbCB0ZXh0dXJlIGZyb20gYSBKYXZhU2NyaXB0IGFycmF5XG4gKiAgICAgICBjaGVja2VyOiB7XG4gKiAgICAgICAgIG1hZzogZ2wuTkVBUkVTVCxcbiAqICAgICAgICAgbWluOiBnbC5MSU5FQVIsXG4gKiAgICAgICAgIHNyYzogW1xuICogICAgICAgICAgIDI1NSwyNTUsMjU1LDI1NSxcbiAqICAgICAgICAgICAxOTIsMTkyLDE5MiwyNTUsXG4gKiAgICAgICAgICAgMTkyLDE5MiwxOTIsMjU1LFxuICogICAgICAgICAgIDI1NSwyNTUsMjU1LDI1NSxcbiAqICAgICAgICAgXSxcbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBhIDF4MiBwaXhlbCB0ZXh0dXJlIGZyb20gYSB0eXBlZCBhcnJheS5cbiAqICAgICAgIHN0cmlwZToge1xuICogICAgICAgICBtYWc6IGdsLk5FQVJFU1QsXG4gKiAgICAgICAgIG1pbjogZ2wuTElORUFSLFxuICogICAgICAgICBmb3JtYXQ6IGdsLkxVTUlOQU5DRSxcbiAqICAgICAgICAgc3JjOiBuZXcgVWludDhBcnJheShbXG4gKiAgICAgICAgICAgMjU1LFxuICogICAgICAgICAgIDEyOCxcbiAqICAgICAgICAgICAyNTUsXG4gKiAgICAgICAgICAgMTI4LFxuICogICAgICAgICAgIDI1NSxcbiAqICAgICAgICAgICAxMjgsXG4gKiAgICAgICAgICAgMjU1LFxuICogICAgICAgICAgIDEyOCxcbiAqICAgICAgICAgXSksXG4gKiAgICAgICAgIHdpZHRoOiAxLFxuICogICAgICAgfSxcbiAqICAgICB9KTtcbiAqXG4gKiBOb3dcbiAqXG4gKiAqICAgYHRleHR1cmVzLmhmdEljb25gIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKiAqICAgYHRleHR1cmVzLmNsb3ZlcmAgd2lsbCBiZSBhIDJkIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuZnJvbUNhbnZhc2Agd2lsbCBiZSBhIDJkIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMueW9ob2hhbWFgIHdpbGwgYmUgYSBjdWJlbWFwIHRleHR1cmVcbiAqICogICBgdGV4dHVyZXMuZ29sZGVuZ2F0ZWAgd2lsbCBiZSBhIGN1YmVtYXAgdGV4dHVyZVxuICogKiAgIGB0ZXh0dXJlcy5jaGVja2VyYCB3aWxsIGJlIGEgMmQgdGV4dHVyZVxuICogKiAgIGB0ZXh0dXJlcy5zdHJpcGVgIHdpbGwgYmUgYSAyZCB0ZXh0dXJlXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnM+fSBvcHRpb25zIEEgb2JqZWN0IG9mIFRleHR1cmVPcHRpb25zIG9uZSBwZXIgdGV4dHVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVGV4dHVyZXNSZWFkeUNhbGxiYWNrfSBbY2FsbGJhY2tdIEEgY2FsbGJhY2sgY2FsbGVkIHdoZW4gYWxsIHRleHR1cmVzIGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsV2ViR0xUZXh0dXJlPn0gdGhlIGNyZWF0ZWQgdGV4dHVyZXMgYnkgbmFtZVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3RleHR1cmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVzKGdsLCB0ZXh0dXJlT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICBsZXQgbnVtRG93bmxvYWRpbmcgPSAwO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgdGV4dHVyZXMgPSB7fTtcbiAgY29uc3QgaW1hZ2VzID0ge307XG5cbiAgZnVuY3Rpb24gY2FsbENhbGxiYWNrSWZSZWFkeSgpIHtcbiAgICBpZiAobnVtRG93bmxvYWRpbmcgPT09IDApIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiB1bmRlZmluZWQsIHRleHR1cmVzLCBpbWFnZXMpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXModGV4dHVyZU9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0ZXh0dXJlT3B0aW9uc1tuYW1lXTtcbiAgICBsZXQgb25Mb2FkRm47XG4gICAgaWYgKGlzQXN5bmNTcmMob3B0aW9ucy5zcmMpKSB7XG4gICAgICBvbkxvYWRGbiA9IGZ1bmN0aW9uKGVyciwgdGV4LCBpbWcpIHtcbiAgICAgICAgaW1hZ2VzW25hbWVdID0gaW1nO1xuICAgICAgICAtLW51bURvd25sb2FkaW5nO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsQ2FsbGJhY2tJZlJlYWR5KCk7XG4gICAgICB9O1xuICAgICAgKytudW1Eb3dubG9hZGluZztcbiAgICB9XG4gICAgdGV4dHVyZXNbbmFtZV0gPSBjcmVhdGVUZXh0dXJlKGdsLCBvcHRpb25zLCBvbkxvYWRGbik7XG4gIH0pO1xuXG4gIC8vIHF1ZXVlIHRoZSBjYWxsYmFjayBpZiB0aGVyZSBhcmUgbm8gaW1hZ2VzIHRvIGRvd25sb2FkLlxuICAvLyBXZSBkbyB0aGlzIGJlY2F1c2UgaWYgeW91ciBjb2RlIGlzIHN0cnVjdHVyZWQgdG8gd2FpdCBmb3JcbiAgLy8gaW1hZ2VzIHRvIGRvd25sb2FkIGJ1dCB0aGVuIHlvdSBjb21tZW50IG91dCBhbGwgdGhlIGFzeW5jXG4gIC8vIGltYWdlcyB5b3VyIGNvZGUgd291bGQgYnJlYWsuXG4gIGNhbGxDYWxsYmFja0lmUmVhZHkoKTtcblxuICByZXR1cm4gdGV4dHVyZXM7XG59XG5cbnZhciB0ZXh0dXJlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzZXRUZXh0dXJlRGVmYXVsdHNfOiBzZXREZWZhdWx0cyQxLFxuICBjcmVhdGVTYW1wbGVyOiBjcmVhdGVTYW1wbGVyLFxuICBjcmVhdGVTYW1wbGVyczogY3JlYXRlU2FtcGxlcnMsXG4gIHNldFNhbXBsZXJQYXJhbWV0ZXJzOiBzZXRTYW1wbGVyUGFyYW1ldGVycyxcbiAgY3JlYXRlVGV4dHVyZTogY3JlYXRlVGV4dHVyZSxcbiAgc2V0RW1wdHlUZXh0dXJlOiBzZXRFbXB0eVRleHR1cmUsXG4gIHNldFRleHR1cmVGcm9tQXJyYXk6IHNldFRleHR1cmVGcm9tQXJyYXksXG4gIGxvYWRUZXh0dXJlRnJvbVVybDogbG9hZFRleHR1cmVGcm9tVXJsLFxuICBzZXRUZXh0dXJlRnJvbUVsZW1lbnQ6IHNldFRleHR1cmVGcm9tRWxlbWVudCxcbiAgc2V0VGV4dHVyZUZpbHRlcmluZ0ZvclNpemU6IHNldFRleHR1cmVGaWx0ZXJpbmdGb3JTaXplLFxuICBzZXRUZXh0dXJlUGFyYW1ldGVyczogc2V0VGV4dHVyZVBhcmFtZXRlcnMsXG4gIHNldERlZmF1bHRUZXh0dXJlQ29sb3I6IHNldERlZmF1bHRUZXh0dXJlQ29sb3IsXG4gIGNyZWF0ZVRleHR1cmVzOiBjcmVhdGVUZXh0dXJlcyxcbiAgcmVzaXplVGV4dHVyZTogcmVzaXplVGV4dHVyZSxcbiAgY2FuR2VuZXJhdGVNaXBtYXA6IGNhbkdlbmVyYXRlTWlwbWFwLFxuICBjYW5GaWx0ZXI6IGNhbkZpbHRlcixcbiAgZ2V0TnVtQ29tcG9uZW50c0ZvckZvcm1hdDogZ2V0TnVtQ29tcG9uZW50c0ZvckZvcm1hdCxcbiAgZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQ6IGdldEJ5dGVzUGVyRWxlbWVudEZvckludGVybmFsRm9ybWF0LFxuICBnZXRGb3JtYXRBbmRUeXBlRm9ySW50ZXJuYWxGb3JtYXQ6IGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdFxufSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBMb3cgbGV2ZWwgc2hhZGVyIHByb2dyYW0gcmVsYXRlZCBmdW5jdGlvbnNcbiAqXG4gKiBZb3Ugc2hvdWxkIGdlbmVyYWxseSBub3QgbmVlZCB0byB1c2UgdGhlc2UgZnVuY3Rpb25zLiBUaGV5IGFyZSBwcm92aWRlZFxuICogZm9yIHRob3NlIGNhc2VzIHdoZXJlIHlvdSdyZSBkb2luZyBzb21ldGhpbmcgb3V0IG9mIHRoZSBvcmRpbmFyeVxuICogYW5kIHlvdSBuZWVkIGxvd2VyIGxldmVsIGFjY2Vzcy5cbiAqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC5wcm9ncmFtc2AgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL3Byb2dyYW1zXG4gKi9cblxuY29uc3QgZXJyb3IkMSA9IGVycm9yO1xuY29uc3Qgd2FybiQxID0gd2FybjtcbmZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKGlkKSB7XG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZClcbiAgICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpXG4gICAgICA6IG51bGw7XG59XG5cbmNvbnN0IFRFWFRVUkUwICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODRjMDtcbmNvbnN0IERZTkFNSUNfRFJBVyAgICAgICAgICAgICAgICAgICA9IDB4ODhlODtcblxuY29uc3QgQVJSQVlfQlVGRkVSJDEgICAgICAgICAgICAgICAgICAgPSAweDg4OTI7XG5jb25zdCBFTEVNRU5UX0FSUkFZX0JVRkZFUiQxICAgICAgICAgICA9IDB4ODg5MztcbmNvbnN0IFVOSUZPUk1fQlVGRkVSICAgICAgICAgICAgICAgICA9IDB4OGExMTtcbmNvbnN0IFRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIgICAgICA9IDB4OGM4ZTtcblxuY29uc3QgVFJBTlNGT1JNX0ZFRURCQUNLICAgICAgICAgICAgID0gMHg4ZTIyO1xuXG5jb25zdCBDT01QSUxFX1NUQVRVUyAgICAgICAgICAgICAgICAgPSAweDhiODE7XG5jb25zdCBMSU5LX1NUQVRVUyAgICAgICAgICAgICAgICAgICAgPSAweDhiODI7XG5jb25zdCBGUkFHTUVOVF9TSEFERVIgICAgICAgICAgICAgICAgPSAweDhiMzA7XG5jb25zdCBWRVJURVhfU0hBREVSICAgICAgICAgICAgICAgICAgPSAweDhiMzE7XG5jb25zdCBTRVBBUkFURV9BVFRSSUJTICAgICAgICAgICAgICAgPSAweDhjOGQ7XG5cbmNvbnN0IEFDVElWRV9VTklGT1JNUyAgICAgICAgICAgICAgICA9IDB4OGI4NjtcbmNvbnN0IEFDVElWRV9BVFRSSUJVVEVTICAgICAgICAgICAgICA9IDB4OGI4OTtcbmNvbnN0IFRSQU5TRk9STV9GRUVEQkFDS19WQVJZSU5HUyAgICA9IDB4OGM4MztcbmNvbnN0IEFDVElWRV9VTklGT1JNX0JMT0NLUyAgICAgICAgICA9IDB4OGEzNjtcbmNvbnN0IFVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9WRVJURVhfU0hBREVSICAgPSAweDhhNDQ7XG5jb25zdCBVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfRlJBR01FTlRfU0hBREVSID0gMHg4YTQ2O1xuY29uc3QgVU5JRk9STV9CTE9DS19EQVRBX1NJWkUgICAgICAgICAgICAgICAgICAgICA9IDB4OGE0MDtcbmNvbnN0IFVOSUZPUk1fQkxPQ0tfQUNUSVZFX1VOSUZPUk1fSU5ESUNFUyAgICAgICAgPSAweDhhNDM7XG5cbmNvbnN0IEZMT0FUJDMgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDY7XG5jb25zdCBGTE9BVF9WRUMyICAgICAgICAgICAgICAgICAgICA9IDB4OEI1MDtcbmNvbnN0IEZMT0FUX1ZFQzMgICAgICAgICAgICAgICAgICAgID0gMHg4QjUxO1xuY29uc3QgRkxPQVRfVkVDNCAgICAgICAgICAgICAgICAgICAgPSAweDhCNTI7XG5jb25zdCBJTlQkMyAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDA0O1xuY29uc3QgSU5UX1ZFQzIgICAgICAgICAgICAgICAgICAgICAgPSAweDhCNTM7XG5jb25zdCBJTlRfVkVDMyAgICAgICAgICAgICAgICAgICAgICA9IDB4OEI1NDtcbmNvbnN0IElOVF9WRUM0ICAgICAgICAgICAgICAgICAgICAgID0gMHg4QjU1O1xuY29uc3QgQk9PTCAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDhCNTY7XG5jb25zdCBCT09MX1ZFQzIgICAgICAgICAgICAgICAgICAgICA9IDB4OEI1NztcbmNvbnN0IEJPT0xfVkVDMyAgICAgICAgICAgICAgICAgICAgID0gMHg4QjU4O1xuY29uc3QgQk9PTF9WRUM0ICAgICAgICAgICAgICAgICAgICAgPSAweDhCNTk7XG5jb25zdCBGTE9BVF9NQVQyICAgICAgICAgICAgICAgICAgICA9IDB4OEI1QTtcbmNvbnN0IEZMT0FUX01BVDMgICAgICAgICAgICAgICAgICAgID0gMHg4QjVCO1xuY29uc3QgRkxPQVRfTUFUNCAgICAgICAgICAgICAgICAgICAgPSAweDhCNUM7XG5jb25zdCBTQU1QTEVSXzJEICAgICAgICAgICAgICAgICAgICA9IDB4OEI1RTtcbmNvbnN0IFNBTVBMRVJfQ1VCRSAgICAgICAgICAgICAgICAgID0gMHg4QjYwO1xuY29uc3QgU0FNUExFUl8zRCAgICAgICAgICAgICAgICAgICAgPSAweDhCNUY7XG5jb25zdCBTQU1QTEVSXzJEX1NIQURPVyAgICAgICAgICAgICA9IDB4OEI2MjtcbmNvbnN0IEZMT0FUX01BVDJ4MyAgICAgICAgICAgICAgICAgID0gMHg4QjY1O1xuY29uc3QgRkxPQVRfTUFUMng0ICAgICAgICAgICAgICAgICAgPSAweDhCNjY7XG5jb25zdCBGTE9BVF9NQVQzeDIgICAgICAgICAgICAgICAgICA9IDB4OEI2NztcbmNvbnN0IEZMT0FUX01BVDN4NCAgICAgICAgICAgICAgICAgID0gMHg4QjY4O1xuY29uc3QgRkxPQVRfTUFUNHgyICAgICAgICAgICAgICAgICAgPSAweDhCNjk7XG5jb25zdCBGTE9BVF9NQVQ0eDMgICAgICAgICAgICAgICAgICA9IDB4OEI2QTtcbmNvbnN0IFNBTVBMRVJfMkRfQVJSQVkgICAgICAgICAgICAgID0gMHg4REMxO1xuY29uc3QgU0FNUExFUl8yRF9BUlJBWV9TSEFET1cgICAgICAgPSAweDhEQzQ7XG5jb25zdCBTQU1QTEVSX0NVQkVfU0hBRE9XICAgICAgICAgICA9IDB4OERDNTtcbmNvbnN0IFVOU0lHTkVEX0lOVCQzICAgICAgICAgICAgICAgICAgPSAweDE0MDU7XG5jb25zdCBVTlNJR05FRF9JTlRfVkVDMiAgICAgICAgICAgICA9IDB4OERDNjtcbmNvbnN0IFVOU0lHTkVEX0lOVF9WRUMzICAgICAgICAgICAgID0gMHg4REM3O1xuY29uc3QgVU5TSUdORURfSU5UX1ZFQzQgICAgICAgICAgICAgPSAweDhEQzg7XG5jb25zdCBJTlRfU0FNUExFUl8yRCAgICAgICAgICAgICAgICA9IDB4OERDQTtcbmNvbnN0IElOVF9TQU1QTEVSXzNEICAgICAgICAgICAgICAgID0gMHg4RENCO1xuY29uc3QgSU5UX1NBTVBMRVJfQ1VCRSAgICAgICAgICAgICAgPSAweDhEQ0M7XG5jb25zdCBJTlRfU0FNUExFUl8yRF9BUlJBWSAgICAgICAgICA9IDB4OERDRjtcbmNvbnN0IFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEICAgICAgID0gMHg4REQyO1xuY29uc3QgVU5TSUdORURfSU5UX1NBTVBMRVJfM0QgICAgICAgPSAweDhERDM7XG5jb25zdCBVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFICAgICA9IDB4OERENDtcbmNvbnN0IFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZID0gMHg4REQ3O1xuXG5jb25zdCBURVhUVVJFXzJEJDEgICAgICAgICAgICAgICAgICAgID0gMHgwREUxO1xuY29uc3QgVEVYVFVSRV9DVUJFX01BUCQxICAgICAgICAgICAgICA9IDB4ODUxMztcbmNvbnN0IFRFWFRVUkVfM0QkMSAgICAgICAgICAgICAgICAgICAgPSAweDgwNkY7XG5jb25zdCBURVhUVVJFXzJEX0FSUkFZJDEgICAgICAgICAgICAgID0gMHg4QzFBO1xuXG5jb25zdCB0eXBlTWFwID0ge307XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBiaW5kIHBvaW50IGZvciBhIGdpdmVuIHNhbXBsZXIgdHlwZVxuICovXG5mdW5jdGlvbiBnZXRCaW5kUG9pbnRGb3JTYW1wbGVyVHlwZShnbCwgdHlwZSkge1xuICByZXR1cm4gdHlwZU1hcFt0eXBlXS5iaW5kUG9pbnQ7XG59XG5cbi8vIFRoaXMga2luZCBvZiBzdWNrcyEgSWYgeW91IGNvdWxkIGNvbXBvc2UgZnVuY3Rpb25zIGFzIGluIGB2YXIgZm4gPSBnbFtuYW1lXTtgXG4vLyB0aGlzIGNvZGUgY291bGQgYmUgYSBsb3Qgc21hbGxlciBidXQgdGhhdCBpcyBzYWRseSByZWFsbHkgc2xvdyAoVF9UKVxuXG5mdW5jdGlvbiBmbG9hdFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdEFycmF5U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG9hdFZlYzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0VmVjM1NldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvYXRWZWM0U2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50QXJyYXlTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludFZlYzRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTF1aShsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRBcnJheVNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtMXVpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRWZWMyU2V0dGVyKGdsLCBsb2NhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIGdsLnVuaWZvcm0ydWl2KGxvY2F0aW9uLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdWludFZlYzNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybTN1aXYobG9jYXRpb24sIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1aW50VmVjNFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtNHVpdihsb2NhdGlvbiwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MlNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0M1NldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NFNldHRlcihnbCwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MjNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDJ4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MzJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MjRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDJ4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NDJTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDR4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0MzRTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDN4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb2F0TWF0NDNTZXR0ZXIoZ2wsIGxvY2F0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDR4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNhbXBsZXJTZXR0ZXIoZ2wsIHR5cGUsIHVuaXQsIGxvY2F0aW9uKSB7XG4gIGNvbnN0IGJpbmRQb2ludCA9IGdldEJpbmRQb2ludEZvclNhbXBsZXJUeXBlKGdsLCB0eXBlKTtcbiAgcmV0dXJuIGlzV2ViR0wyKGdsKSA/IGZ1bmN0aW9uKHRleHR1cmVPclBhaXIpIHtcbiAgICBsZXQgdGV4dHVyZTtcbiAgICBsZXQgc2FtcGxlcjtcbiAgICBpZiAoaXNUZXh0dXJlKGdsLCB0ZXh0dXJlT3JQYWlyKSkge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXI7XG4gICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZSA9IHRleHR1cmVPclBhaXIudGV4dHVyZTtcbiAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgfVxuICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdW5pdCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShURVhUVVJFMCArIHVuaXQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGJpbmRQb2ludCwgdGV4dHVyZSk7XG4gICAgZ2wuYmluZFNhbXBsZXIodW5pdCwgc2FtcGxlcik7XG4gIH0gOiBmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bml0KTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKFRFWFRVUkUwICsgdW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoYmluZFBvaW50LCB0ZXh0dXJlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlckFycmF5U2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgc2l6ZSkge1xuICBjb25zdCBiaW5kUG9pbnQgPSBnZXRCaW5kUG9pbnRGb3JTYW1wbGVyVHlwZShnbCwgdHlwZSk7XG4gIGNvbnN0IHVuaXRzID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBzaXplOyArK2lpKSB7XG4gICAgdW5pdHNbaWldID0gdW5pdCArIGlpO1xuICB9XG5cbiAgcmV0dXJuIGlzV2ViR0wyKGdsKSA/IGZ1bmN0aW9uKHRleHR1cmVzKSB7XG4gICAgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdW5pdHMpO1xuICAgIHRleHR1cmVzLmZvckVhY2goZnVuY3Rpb24odGV4dHVyZU9yUGFpciwgaW5kZXgpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoVEVYVFVSRTAgKyB1bml0c1tpbmRleF0pO1xuICAgICAgbGV0IHRleHR1cmU7XG4gICAgICBsZXQgc2FtcGxlcjtcbiAgICAgIGlmIChpc1RleHR1cmUoZ2wsIHRleHR1cmVPclBhaXIpKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyO1xuICAgICAgICBzYW1wbGVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlT3JQYWlyLnRleHR1cmU7XG4gICAgICAgIHNhbXBsZXIgPSB0ZXh0dXJlT3JQYWlyLnNhbXBsZXI7XG4gICAgICB9XG4gICAgICBnbC5iaW5kU2FtcGxlcih1bml0LCBzYW1wbGVyKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGJpbmRQb2ludCwgdGV4dHVyZSk7XG4gICAgfSk7XG4gIH0gOiBmdW5jdGlvbih0ZXh0dXJlcykge1xuICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHVuaXRzKTtcbiAgICB0ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKHRleHR1cmUsIGluZGV4KSB7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKFRFWFRVUkUwICsgdW5pdHNbaW5kZXhdKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGJpbmRQb2ludCwgdGV4dHVyZSk7XG4gICAgfSk7XG4gIH07XG59XG5cbnR5cGVNYXBbRkxPQVQkM10gICAgICAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogIDQsIHNldHRlcjogZmxvYXRTZXR0ZXIsICAgICAgYXJyYXlTZXR0ZXI6IGZsb2F0QXJyYXlTZXR0ZXIsIH07XG50eXBlTWFwW0ZMT0FUX1ZFQzJdICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogRmxvYXQzMkFycmF5LCBzaXplOiAgOCwgc2V0dGVyOiBmbG9hdFZlYzJTZXR0ZXIsICBjb2xzOiAyLCB9O1xudHlwZU1hcFtGTE9BVF9WRUMzXSAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogMTIsIHNldHRlcjogZmxvYXRWZWMzU2V0dGVyLCAgY29sczogMywgfTtcbnR5cGVNYXBbRkxPQVRfVkVDNF0gICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6IDE2LCBzZXR0ZXI6IGZsb2F0VmVjNFNldHRlciwgIGNvbHM6IDQsIH07XG50eXBlTWFwW0lOVCQzXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBJbnQzMkFycmF5LCAgIHNpemU6ICA0LCBzZXR0ZXI6IGludFNldHRlciwgICAgICAgIGFycmF5U2V0dGVyOiBpbnRBcnJheVNldHRlciwgfTtcbnR5cGVNYXBbSU5UX1ZFQzJdICAgICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBJbnQzMkFycmF5LCAgIHNpemU6ICA4LCBzZXR0ZXI6IGludFZlYzJTZXR0ZXIsICAgIGNvbHM6IDIsIH07XG50eXBlTWFwW0lOVF9WRUMzXSAgICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogSW50MzJBcnJheSwgICBzaXplOiAxMiwgc2V0dGVyOiBpbnRWZWMzU2V0dGVyLCAgICBjb2xzOiAzLCB9O1xudHlwZU1hcFtJTlRfVkVDNF0gICAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEludDMyQXJyYXksICAgc2l6ZTogMTYsIHNldHRlcjogaW50VmVjNFNldHRlciwgICAgY29sczogNCwgfTtcbnR5cGVNYXBbVU5TSUdORURfSU5UJDNdICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IFVpbnQzMkFycmF5LCAgc2l6ZTogIDQsIHNldHRlcjogdWludFNldHRlciwgICAgICAgYXJyYXlTZXR0ZXI6IHVpbnRBcnJheVNldHRlciwgfTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1ZFQzJdICAgICAgICAgICAgID0geyBUeXBlOiBVaW50MzJBcnJheSwgIHNpemU6ICA4LCBzZXR0ZXI6IHVpbnRWZWMyU2V0dGVyLCAgIGNvbHM6IDIsIH07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMzXSAgICAgICAgICAgICA9IHsgVHlwZTogVWludDMyQXJyYXksICBzaXplOiAxMiwgc2V0dGVyOiB1aW50VmVjM1NldHRlciwgICBjb2xzOiAzLCB9O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfVkVDNF0gICAgICAgICAgICAgPSB7IFR5cGU6IFVpbnQzMkFycmF5LCAgc2l6ZTogMTYsIHNldHRlcjogdWludFZlYzRTZXR0ZXIsICAgY29sczogNCwgfTtcbnR5cGVNYXBbQk9PTF0gICAgICAgICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBVaW50MzJBcnJheSwgIHNpemU6ICA0LCBzZXR0ZXI6IGludFNldHRlciwgICAgICAgIGFycmF5U2V0dGVyOiBpbnRBcnJheVNldHRlciwgfTtcbnR5cGVNYXBbQk9PTF9WRUMyXSAgICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBVaW50MzJBcnJheSwgIHNpemU6ICA4LCBzZXR0ZXI6IGludFZlYzJTZXR0ZXIsICAgIGNvbHM6IDIsIH07XG50eXBlTWFwW0JPT0xfVkVDM10gICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogVWludDMyQXJyYXksICBzaXplOiAxMiwgc2V0dGVyOiBpbnRWZWMzU2V0dGVyLCAgICBjb2xzOiAzLCB9O1xudHlwZU1hcFtCT09MX1ZFQzRdICAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IFVpbnQzMkFycmF5LCAgc2l6ZTogMTYsIHNldHRlcjogaW50VmVjNFNldHRlciwgICAgY29sczogNCwgfTtcbnR5cGVNYXBbRkxPQVRfTUFUMl0gICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6IDMyLCBzZXR0ZXI6IGZsb2F0TWF0MlNldHRlciwgIHJvd3M6IDIsIGNvbHM6IDIsIH07XG50eXBlTWFwW0ZMT0FUX01BVDNdICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogRmxvYXQzMkFycmF5LCBzaXplOiA0OCwgc2V0dGVyOiBmbG9hdE1hdDNTZXR0ZXIsICByb3dzOiAzLCBjb2xzOiAzLCB9O1xudHlwZU1hcFtGTE9BVF9NQVQ0XSAgICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogNjQsIHNldHRlcjogZmxvYXRNYXQ0U2V0dGVyLCAgcm93czogNCwgY29sczogNCwgfTtcbnR5cGVNYXBbRkxPQVRfTUFUMngzXSAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6IDMyLCBzZXR0ZXI6IGZsb2F0TWF0MjNTZXR0ZXIsIHJvd3M6IDIsIGNvbHM6IDMsIH07XG50eXBlTWFwW0ZMT0FUX01BVDJ4NF0gICAgICAgICAgICAgICAgICA9IHsgVHlwZTogRmxvYXQzMkFycmF5LCBzaXplOiAzMiwgc2V0dGVyOiBmbG9hdE1hdDI0U2V0dGVyLCByb3dzOiAyLCBjb2xzOiA0LCB9O1xudHlwZU1hcFtGTE9BVF9NQVQzeDJdICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogNDgsIHNldHRlcjogZmxvYXRNYXQzMlNldHRlciwgcm93czogMywgY29sczogMiwgfTtcbnR5cGVNYXBbRkxPQVRfTUFUM3g0XSAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBGbG9hdDMyQXJyYXksIHNpemU6IDQ4LCBzZXR0ZXI6IGZsb2F0TWF0MzRTZXR0ZXIsIHJvd3M6IDMsIGNvbHM6IDQsIH07XG50eXBlTWFwW0ZMT0FUX01BVDR4Ml0gICAgICAgICAgICAgICAgICA9IHsgVHlwZTogRmxvYXQzMkFycmF5LCBzaXplOiA2NCwgc2V0dGVyOiBmbG9hdE1hdDQyU2V0dGVyLCByb3dzOiA0LCBjb2xzOiAyLCB9O1xudHlwZU1hcFtGTE9BVF9NQVQ0eDNdICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IEZsb2F0MzJBcnJheSwgc2l6ZTogNjQsIHNldHRlcjogZmxvYXRNYXQ0M1NldHRlciwgcm93czogNCwgY29sczogMywgfTtcbnR5cGVNYXBbU0FNUExFUl8yRF0gICAgICAgICAgICAgICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV8yRCQxLCAgICAgICB9O1xudHlwZU1hcFtTQU1QTEVSX0NVQkVdICAgICAgICAgICAgICAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFX0NVQkVfTUFQJDEsIH07XG50eXBlTWFwW1NBTVBMRVJfM0RdICAgICAgICAgICAgICAgICAgICA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfM0QkMSwgICAgICAgfTtcbnR5cGVNYXBbU0FNUExFUl8yRF9TSEFET1ddICAgICAgICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV8yRCQxLCAgICAgICB9O1xudHlwZU1hcFtTQU1QTEVSXzJEX0FSUkFZXSAgICAgICAgICAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZJDEsIH07XG50eXBlTWFwW1NBTVBMRVJfMkRfQVJSQVlfU0hBRE9XXSAgICAgICA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfMkRfQVJSQVkkMSwgfTtcbnR5cGVNYXBbU0FNUExFUl9DVUJFX1NIQURPV10gICAgICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV9DVUJFX01BUCQxLCB9O1xudHlwZU1hcFtJTlRfU0FNUExFUl8yRF0gICAgICAgICAgICAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFXzJEJDEsICAgICAgIH07XG50eXBlTWFwW0lOVF9TQU1QTEVSXzNEXSAgICAgICAgICAgICAgICA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfM0QkMSwgICAgICAgfTtcbnR5cGVNYXBbSU5UX1NBTVBMRVJfQ1VCRV0gICAgICAgICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV9DVUJFX01BUCQxLCB9O1xudHlwZU1hcFtJTlRfU0FNUExFUl8yRF9BUlJBWV0gICAgICAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFXzJEX0FSUkFZJDEsIH07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9TQU1QTEVSXzJEXSAgICAgICA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfMkQkMSwgICAgICAgfTtcbnR5cGVNYXBbVU5TSUdORURfSU5UX1NBTVBMRVJfM0RdICAgICAgID0geyBUeXBlOiBudWxsLCAgICAgICAgIHNpemU6ICAwLCBzZXR0ZXI6IHNhbXBsZXJTZXR0ZXIsICAgIGFycmF5U2V0dGVyOiBzYW1wbGVyQXJyYXlTZXR0ZXIsIGJpbmRQb2ludDogVEVYVFVSRV8zRCQxLCAgICAgICB9O1xudHlwZU1hcFtVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFXSAgICAgPSB7IFR5cGU6IG51bGwsICAgICAgICAgc2l6ZTogIDAsIHNldHRlcjogc2FtcGxlclNldHRlciwgICAgYXJyYXlTZXR0ZXI6IHNhbXBsZXJBcnJheVNldHRlciwgYmluZFBvaW50OiBURVhUVVJFX0NVQkVfTUFQJDEsIH07XG50eXBlTWFwW1VOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZXSA9IHsgVHlwZTogbnVsbCwgICAgICAgICBzaXplOiAgMCwgc2V0dGVyOiBzYW1wbGVyU2V0dGVyLCAgICBhcnJheVNldHRlcjogc2FtcGxlckFycmF5U2V0dGVyLCBiaW5kUG9pbnQ6IFRFWFRVUkVfMkRfQVJSQVkkMSwgfTtcblxuZnVuY3Rpb24gZmxvYXRBdHRyaWJTZXR0ZXIoZ2wsIGluZGV4KSB7XG4gIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgaWYgKGIudmFsdWUpIHtcbiAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICBzd2l0Y2ggKGIudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0ZnYoaW5kZXgsIGIudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZ2wudmVydGV4QXR0cmliM2Z2KGluZGV4LCBiLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjJmdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZnYoaW5kZXgsIGIudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGxlbmd0aCBvZiBhIGZsb2F0IGNvbnN0YW50IHZhbHVlIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA0IScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiQxLCBiLmJ1ZmZlcik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgIGluZGV4LCBiLm51bUNvbXBvbmVudHMgfHwgYi5zaXplLCBiLnR5cGUgfHwgRkxPQVQkMywgYi5ub3JtYWxpemUgfHwgZmFsc2UsIGIuc3RyaWRlIHx8IDAsIGIub2Zmc2V0IHx8IDApO1xuICAgICAgaWYgKGIuZGl2aXNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoaW5kZXgsIGIuZGl2aXNvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRBdHRyaWJTZXR0ZXIoZ2wsIGluZGV4KSB7XG4gIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgaWYgKGIudmFsdWUpIHtcbiAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICBpZiAoYi52YWx1ZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliNGl2KGluZGV4LCBiLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxlbmd0aCBvZiBhbiBpbnRlZ2VyIGNvbnN0YW50IHZhbHVlIG11c3QgYmUgNCEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihBUlJBWV9CVUZGRVIkMSwgYi5idWZmZXIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgICAgZ2wudmVydGV4QXR0cmliSVBvaW50ZXIoXG4gICAgICAgICAgaW5kZXgsIGIubnVtQ29tcG9uZW50cyB8fCBiLnNpemUsIGIudHlwZSB8fCBJTlQkMywgYi5zdHJpZGUgfHwgMCwgYi5vZmZzZXQgfHwgMCk7XG4gICAgICBpZiAoYi5kaXZpc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihpbmRleCwgYi5kaXZpc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVpbnRBdHRyaWJTZXR0ZXIoZ2wsIGluZGV4KSB7XG4gIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgaWYgKGIudmFsdWUpIHtcbiAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICBpZiAoYi52YWx1ZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliNHVpdihpbmRleCwgYi52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsZW5ndGggb2YgYW4gdW5zaWduZWQgaW50ZWdlciBjb25zdGFudCB2YWx1ZSBtdXN0IGJlIDQhJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoQVJSQVlfQlVGRkVSJDEsIGIuYnVmZmVyKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYklQb2ludGVyKFxuICAgICAgICAgIGluZGV4LCBiLm51bUNvbXBvbmVudHMgfHwgYi5zaXplLCBiLnR5cGUgfHwgVU5TSUdORURfSU5UJDMsIGIuc3RyaWRlIHx8IDAsIGIub2Zmc2V0IHx8IDApO1xuICAgICAgaWYgKGIuZGl2aXNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoaW5kZXgsIGIuZGl2aXNvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXRBdHRyaWJTZXR0ZXIoZ2wsIGluZGV4LCB0eXBlSW5mbykge1xuICBjb25zdCBkZWZhdWx0U2l6ZSA9IHR5cGVJbmZvLnNpemU7XG4gIGNvbnN0IGNvdW50ID0gdHlwZUluZm8uY291bnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICBnbC5iaW5kQnVmZmVyKEFSUkFZX0JVRkZFUiQxLCBiLmJ1ZmZlcik7XG4gICAgY29uc3QgbnVtQ29tcG9uZW50cyA9IGIuc2l6ZSB8fCBiLm51bUNvbXBvbmVudHMgfHwgZGVmYXVsdFNpemU7XG4gICAgY29uc3Qgc2l6ZSA9IG51bUNvbXBvbmVudHMgLyBjb3VudDtcbiAgICBjb25zdCB0eXBlID0gYi50eXBlIHx8IEZMT0FUJDM7XG4gICAgY29uc3QgdHlwZUluZm8gPSB0eXBlTWFwW3R5cGVdO1xuICAgIGNvbnN0IHN0cmlkZSA9IHR5cGVJbmZvLnNpemUgKiBudW1Db21wb25lbnRzO1xuICAgIGNvbnN0IG5vcm1hbGl6ZSA9IGIubm9ybWFsaXplIHx8IGZhbHNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGIub2Zmc2V0IHx8IDA7XG4gICAgY29uc3Qgcm93T2Zmc2V0ID0gc3RyaWRlIC8gY291bnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCArIGkpO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICBpbmRleCArIGksIHNpemUsIHR5cGUsIG5vcm1hbGl6ZSwgc3RyaWRlLCBvZmZzZXQgKyByb3dPZmZzZXQgKiBpKTtcbiAgICAgIGlmIChiLmRpdmlzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGluZGV4ICsgaSwgYi5kaXZpc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cblxuXG5jb25zdCBhdHRyVHlwZU1hcCA9IHt9O1xuYXR0clR5cGVNYXBbRkxPQVQkM10gICAgICAgICAgICAgPSB7IHNpemU6ICA0LCBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyLCB9O1xuYXR0clR5cGVNYXBbRkxPQVRfVkVDMl0gICAgICAgID0geyBzaXplOiAgOCwgc2V0dGVyOiBmbG9hdEF0dHJpYlNldHRlciwgfTtcbmF0dHJUeXBlTWFwW0ZMT0FUX1ZFQzNdICAgICAgICA9IHsgc2l6ZTogMTIsIHNldHRlcjogZmxvYXRBdHRyaWJTZXR0ZXIsIH07XG5hdHRyVHlwZU1hcFtGTE9BVF9WRUM0XSAgICAgICAgPSB7IHNpemU6IDE2LCBzZXR0ZXI6IGZsb2F0QXR0cmliU2V0dGVyLCB9O1xuYXR0clR5cGVNYXBbSU5UJDNdICAgICAgICAgICAgICAgPSB7IHNpemU6ICA0LCBzZXR0ZXI6IGludEF0dHJpYlNldHRlciwgICB9O1xuYXR0clR5cGVNYXBbSU5UX1ZFQzJdICAgICAgICAgID0geyBzaXplOiAgOCwgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXIsICAgfTtcbmF0dHJUeXBlTWFwW0lOVF9WRUMzXSAgICAgICAgICA9IHsgc2l6ZTogMTIsIHNldHRlcjogaW50QXR0cmliU2V0dGVyLCAgIH07XG5hdHRyVHlwZU1hcFtJTlRfVkVDNF0gICAgICAgICAgPSB7IHNpemU6IDE2LCBzZXR0ZXI6IGludEF0dHJpYlNldHRlciwgICB9O1xuYXR0clR5cGVNYXBbVU5TSUdORURfSU5UJDNdICAgICAgPSB7IHNpemU6ICA0LCBzZXR0ZXI6IHVpbnRBdHRyaWJTZXR0ZXIsICB9O1xuYXR0clR5cGVNYXBbVU5TSUdORURfSU5UX1ZFQzJdID0geyBzaXplOiAgOCwgc2V0dGVyOiB1aW50QXR0cmliU2V0dGVyLCAgfTtcbmF0dHJUeXBlTWFwW1VOU0lHTkVEX0lOVF9WRUMzXSA9IHsgc2l6ZTogMTIsIHNldHRlcjogdWludEF0dHJpYlNldHRlciwgIH07XG5hdHRyVHlwZU1hcFtVTlNJR05FRF9JTlRfVkVDNF0gPSB7IHNpemU6IDE2LCBzZXR0ZXI6IHVpbnRBdHRyaWJTZXR0ZXIsICB9O1xuYXR0clR5cGVNYXBbQk9PTF0gICAgICAgICAgICAgID0geyBzaXplOiAgNCwgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXIsICAgfTtcbmF0dHJUeXBlTWFwW0JPT0xfVkVDMl0gICAgICAgICA9IHsgc2l6ZTogIDgsIHNldHRlcjogaW50QXR0cmliU2V0dGVyLCAgIH07XG5hdHRyVHlwZU1hcFtCT09MX1ZFQzNdICAgICAgICAgPSB7IHNpemU6IDEyLCBzZXR0ZXI6IGludEF0dHJpYlNldHRlciwgICB9O1xuYXR0clR5cGVNYXBbQk9PTF9WRUM0XSAgICAgICAgID0geyBzaXplOiAxNiwgc2V0dGVyOiBpbnRBdHRyaWJTZXR0ZXIsICAgfTtcbmF0dHJUeXBlTWFwW0ZMT0FUX01BVDJdICAgICAgICA9IHsgc2l6ZTogIDQsIHNldHRlcjogbWF0QXR0cmliU2V0dGVyLCAgIGNvdW50OiAyLCB9O1xuYXR0clR5cGVNYXBbRkxPQVRfTUFUM10gICAgICAgID0geyBzaXplOiAgOSwgc2V0dGVyOiBtYXRBdHRyaWJTZXR0ZXIsICAgY291bnQ6IDMsIH07XG5hdHRyVHlwZU1hcFtGTE9BVF9NQVQ0XSAgICAgICAgPSB7IHNpemU6IDE2LCBzZXR0ZXI6IG1hdEF0dHJpYlNldHRlciwgICBjb3VudDogNCwgfTtcblxuY29uc3QgZXJyb3JSRSA9IC9FUlJPUjpcXHMqXFxkKzooXFxkKykvZ2k7XG5mdW5jdGlvbiBhZGRMaW5lTnVtYmVyc1dpdGhFcnJvcihzcmMsIGxvZyA9ICcnLCBsaW5lT2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBFcnJvciBtZXNzYWdlIGZvcm1hdHMgYXJlIG5vdCBkZWZpbmVkIGJ5IGFueSBzcGVjIHNvIHRoaXMgbWF5IG9yIG1heSBub3Qgd29yay5cbiAgY29uc3QgbWF0Y2hlcyA9IFsuLi5sb2cubWF0Y2hBbGwoZXJyb3JSRSldO1xuICBjb25zdCBsaW5lTm9Ub0Vycm9yTWFwID0gbmV3IE1hcChtYXRjaGVzLm1hcCgobSwgbmR4KSA9PiB7XG4gICAgY29uc3QgbGluZU5vID0gcGFyc2VJbnQobVsxXSk7XG4gICAgY29uc3QgbmV4dCA9IG1hdGNoZXNbbmR4ICsgMV07XG4gICAgY29uc3QgZW5kID0gbmV4dCA/IG5leHQuaW5kZXggOiBsb2cubGVuZ3RoO1xuICAgIGNvbnN0IG1zZyA9IGxvZy5zdWJzdHJpbmcobS5pbmRleCwgZW5kKTtcbiAgICByZXR1cm4gW2xpbmVObyAtIDEsIG1zZ107XG4gIH0pKTtcbiAgcmV0dXJuIHNyYy5zcGxpdCgnXFxuJykubWFwKChsaW5lLCBsaW5lTm8pID0+IHtcbiAgICBjb25zdCBlcnIgPSBsaW5lTm9Ub0Vycm9yTWFwLmdldChsaW5lTm8pO1xuICAgIHJldHVybiBgJHtsaW5lTm8gKyAxICsgbGluZU9mZnNldH06ICR7bGluZX0ke2VyciA/IGBcXG5cXG5eXl4gJHtlcnJ9YCA6ICcnfWA7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIEVycm9yIENhbGxiYWNrXG4gKiBAY2FsbGJhY2sgRXJyb3JDYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IG1zZyBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW5lT2Zmc2V0XSBhbW91bnQgdG8gYWRkIHRvIGxpbmUgbnVtYmVyXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG5jb25zdCBzcGFjZVJFID0gL15bIFxcdF0qXFxuLztcblxuLyoqXG4gKiBMb2FkcyBhIHNoYWRlci5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXJTb3VyY2UgVGhlIHNoYWRlciBzb3VyY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc2hhZGVyVHlwZSBUaGUgdHlwZSBvZiBzaGFkZXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IG9wdF9lcnJvckNhbGxiYWNrIGNhbGxiYWNrIGZvciBlcnJvcnMuXG4gKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gVGhlIGNyZWF0ZWQgc2hhZGVyLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZFNoYWRlcihnbCwgc2hhZGVyU291cmNlLCBzaGFkZXJUeXBlLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICBjb25zdCBlcnJGbiA9IG9wdF9lcnJvckNhbGxiYWNrIHx8IGVycm9yJDE7XG4gIC8vIENyZWF0ZSB0aGUgc2hhZGVyIG9iamVjdFxuICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG5cbiAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBlbmQgb2YgbGluZSBiZWNhdXNlIFdlYkdMIDIuMCByZXF1aXJlc1xuICAvLyAjdmVyc2lvbiAzMDAgZXNcbiAgLy8gYXMgdGhlIGZpcnN0IGxpbmUuIE5vIHdoaXRlc3BhY2UgYWxsb3dlZCBiZWZvcmUgdGhhdCBsaW5lXG4gIC8vIHNvXG4gIC8vXG4gIC8vIDxzY3JpcHQ+XG4gIC8vICN2ZXJzaW9uIDMwMCBlc1xuICAvLyA8L3NjcmlwdD5cbiAgLy9cbiAgLy8gSGFzIG9uZSBsaW5lIGJlZm9yZSBpdCB3aGljaCBpcyBpbnZhbGlkIGFjY29yZGluZyB0byBHTFNMIEVTIDMuMDBcbiAgLy9cbiAgbGV0IGxpbmVPZmZzZXQgPSAwO1xuICBpZiAoc3BhY2VSRS50ZXN0KHNoYWRlclNvdXJjZSkpIHtcbiAgICBsaW5lT2Zmc2V0ID0gMTtcbiAgICBzaGFkZXJTb3VyY2UgPSBzaGFkZXJTb3VyY2UucmVwbGFjZShzcGFjZVJFLCAnJyk7XG4gIH1cblxuICAvLyBMb2FkIHRoZSBzaGFkZXIgc291cmNlXG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG5cbiAgLy8gQ29tcGlsZSB0aGUgc2hhZGVyXG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAvLyBDaGVjayB0aGUgY29tcGlsZSBzdGF0dXNcbiAgY29uc3QgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBDT01QSUxFX1NUQVRVUyk7XG4gIGlmICghY29tcGlsZWQpIHtcbiAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgY29tcGlsYXRpb247IGdldCB0aGUgZXJyb3JcbiAgICBjb25zdCBsYXN0RXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgZXJyRm4oYCR7YWRkTGluZU51bWJlcnNXaXRoRXJyb3Ioc2hhZGVyU291cmNlLCBsYXN0RXJyb3IsIGxpbmVPZmZzZXQpfVxcbkVycm9yIGNvbXBpbGluZyAke2dsRW51bVRvU3RyaW5nKGdsLCBzaGFkZXJUeXBlKX06ICR7bGFzdEVycm9yfWApO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHNoYWRlcjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9ncmFtT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihzdHJpbmcpfSBbZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9yc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSBbYXR0cmliTG9jYXRpb25zXSBhIGF0dHJpYnV0ZSBuYW1lIHRvIGxvY2F0aW9uIG1hcFxuICogQHByb3BlcnR5IHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3QuPHN0cmluZyxtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPnxzdHJpbmdbXSl9IFt0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzXSBJZiBwYXNzZWRcbiAqICAgYSBCdWZmZXJJbmZvIHdpbGwgdXNlIHRoZSBhdHRyaWJzIG5hbWVzIGluc2lkZS4gSWYgcGFzc2VkIGFuIG9iamVjdCBvZiBBdHRyaWJJbmZvcyB3aWxsIHVzZSB0aGUgbmFtZXMgZnJvbSB0aGF0IG9iamVjdC4gT3RoZXJ3aXNlXG4gKiAgIHlvdSBjYW4gcGFzcyBhbiBhcnJheSBvZiBuYW1lcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNmb3JtRmVlZGJhY2tNb2RlXSB0aGUgbW9kZSB0byBwYXNzIGBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzYC4gRGVmYXVsdHMgdG8gYFNFUEFSQVRFX0FUVFJJQlNgLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9ncmFtIG9wdGlvbnMgYmFzZWQgb24gYWxsIHRoZXNlIG9wdGlvbmFsIGFyZ3VtZW50c1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtT3B0aW9uc3xzdHJpbmdbXX0gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfSBbb3B0X2xvY2F0aW9uc10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN9IGFuIGluc3RhbmNlIG9mIFByb2dyYW1PcHRpb25zIGJhc2VkIG9uIHRoZSBhcmd1bWVudHMgcGFzc2VkIGluXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgbGV0IHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M7XG4gIGxldCB0cmFuc2Zvcm1GZWVkYmFja01vZGU7XG4gIGlmICh0eXBlb2Ygb3B0X2xvY2F0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdF9lcnJvckNhbGxiYWNrID0gb3B0X2xvY2F0aW9ucztcbiAgICBvcHRfbG9jYXRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0X2F0dHJpYnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRfZXJyb3JDYWxsYmFjayA9IG9wdF9hdHRyaWJzO1xuICAgIG9wdF9hdHRyaWJzID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKG9wdF9hdHRyaWJzICYmICFBcnJheS5pc0FycmF5KG9wdF9hdHRyaWJzKSkge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gZXJyb3JDYWxsYmFjayB3ZSBjYW4ganVzdCByZXR1cm4gdGhpcyBvYmplY3RcbiAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBjb25zdHJ1Y3Qgb25lIHdpdGggZGVmYXVsdCBlcnJvckNhbGxiYWNrXG4gICAgaWYgKG9wdF9hdHRyaWJzLmVycm9yQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBvcHRfYXR0cmlicztcbiAgICB9XG4gICAgY29uc3Qgb3B0ID0gb3B0X2F0dHJpYnM7XG4gICAgb3B0X2Vycm9yQ2FsbGJhY2sgPSBvcHQuZXJyb3JDYWxsYmFjaztcbiAgICBvcHRfYXR0cmlicyA9IG9wdC5hdHRyaWJMb2NhdGlvbnM7XG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyA9IG9wdC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzO1xuICAgIHRyYW5zZm9ybUZlZWRiYWNrTW9kZSA9IG9wdC50cmFuc2Zvcm1GZWVkYmFja01vZGU7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGVycm9yQ2FsbGJhY2s6IG9wdF9lcnJvckNhbGxiYWNrIHx8IGVycm9yJDEsXG4gICAgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nczogdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyxcbiAgICB0cmFuc2Zvcm1GZWVkYmFja01vZGU6IHRyYW5zZm9ybUZlZWRiYWNrTW9kZSxcbiAgfTtcblxuICBpZiAob3B0X2F0dHJpYnMpIHtcbiAgICBsZXQgYXR0cmliTG9jYXRpb25zID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0X2F0dHJpYnMpKSB7XG4gICAgICBvcHRfYXR0cmlicy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYiwgIG5keCkge1xuICAgICAgICBhdHRyaWJMb2NhdGlvbnNbYXR0cmliXSA9IG9wdF9sb2NhdGlvbnMgPyBvcHRfbG9jYXRpb25zW25keF0gOiBuZHg7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmliTG9jYXRpb25zID0gb3B0X2F0dHJpYnM7XG4gICAgfVxuICAgIG9wdGlvbnMuYXR0cmliTG9jYXRpb25zID0gYXR0cmliTG9jYXRpb25zO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmNvbnN0IGRlZmF1bHRTaGFkZXJUeXBlID0gW1xuICBcIlZFUlRFWF9TSEFERVJcIixcbiAgXCJGUkFHTUVOVF9TSEFERVJcIixcbl07XG5cbmZ1bmN0aW9uIGdldFNoYWRlclR5cGVGcm9tU2NyaXB0VHlwZShnbCwgc2NyaXB0VHlwZSkge1xuICBpZiAoc2NyaXB0VHlwZS5pbmRleE9mKFwiZnJhZ1wiKSA+PSAwKSB7XG4gICAgcmV0dXJuIEZSQUdNRU5UX1NIQURFUjtcbiAgfSBlbHNlIGlmIChzY3JpcHRUeXBlLmluZGV4T2YoXCJ2ZXJ0XCIpID49IDApIHtcbiAgICByZXR1cm4gVkVSVEVYX1NIQURFUjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWxldGVTaGFkZXJzKGdsLCBzaGFkZXJzKSB7XG4gIHNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbihzaGFkZXIpIHtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb2dyYW0sIGF0dGFjaGVzIChhbmQvb3IgY29tcGlsZXMpIHNoYWRlcnMsIGJpbmRzIGF0dHJpYiBsb2NhdGlvbnMsIGxpbmtzIHRoZVxuICogcHJvZ3JhbSBhbmQgY2FsbHMgdXNlUHJvZ3JhbS5cbiAqXG4gKiBOT1RFOiBUaGVyZSBhcmUgNCBzaWduYXR1cmVzIGZvciB0aGlzIGZ1bmN0aW9uXG4gKlxuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdGlvbnMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW0oZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbShnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyRnVuYyk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtXZWJHTFNoYWRlcltdfHN0cmluZ1tdfSBzaGFkZXJzIFRoZSBzaGFkZXJzIHRvIGF0dGFjaCwgb3IgZWxlbWVudCBpZHMgZm9yIHRoZWlyIHNvdXJjZSwgb3Igc3RyaW5ncyB0aGF0IGNvbnRhaW4gdGhlaXIgc291cmNlXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfYXR0cmlic10gT3B0aW9ucyBmb3IgdGhlIHByb2dyYW0gb3IgYW4gYXJyYXkgb2YgYXR0cmlicyBuYW1lcyBvciBhbiBlcnJvciBjYWxsYmFjay4gTG9jYXRpb25zIHdpbGwgYmUgYXNzaWduZWQgYnkgaW5kZXggaWYgbm90IHBhc3NlZCBpblxuICogQHBhcmFtIHtudW1iZXJbXX0gW29wdF9sb2NhdGlvbnN8bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMgb3IgYW4gZXJyb3IgY2FsbGJhY2suXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7V2ViR0xQcm9ncmFtP30gdGhlIGNyZWF0ZWQgcHJvZ3JhbSBvciBudWxsIGlmIGVycm9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oXG4gICAgZ2wsIHNoYWRlcnMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICBjb25zdCBwcm9nT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIGNvbnN0IHJlYWxTaGFkZXJzID0gW107XG4gIGNvbnN0IG5ld1NoYWRlcnMgPSBbXTtcbiAgZm9yIChsZXQgbmR4ID0gMDsgbmR4IDwgc2hhZGVycy5sZW5ndGg7ICsrbmR4KSB7XG4gICAgbGV0IHNoYWRlciA9IHNoYWRlcnNbbmR4XTtcbiAgICBpZiAodHlwZW9mIChzaGFkZXIpID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZWxlbSA9IGdldEVsZW1lbnRCeUlkKHNoYWRlcik7XG4gICAgICBjb25zdCBzcmMgPSBlbGVtID8gZWxlbS50ZXh0IDogc2hhZGVyO1xuICAgICAgbGV0IHR5cGUgPSBnbFtkZWZhdWx0U2hhZGVyVHlwZVtuZHhdXTtcbiAgICAgIGlmIChlbGVtICYmIGVsZW0udHlwZSkge1xuICAgICAgICB0eXBlID0gZ2V0U2hhZGVyVHlwZUZyb21TY3JpcHRUeXBlKGdsLCBlbGVtLnR5cGUpIHx8IHR5cGU7XG4gICAgICB9XG4gICAgICBzaGFkZXIgPSBsb2FkU2hhZGVyKGdsLCBzcmMsIHR5cGUsIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2spO1xuICAgICAgbmV3U2hhZGVycy5wdXNoKHNoYWRlcik7XG4gICAgfVxuICAgIGlmIChpc1NoYWRlcihnbCwgc2hhZGVyKSkge1xuICAgICAgcmVhbFNoYWRlcnMucHVzaChzaGFkZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZWFsU2hhZGVycy5sZW5ndGggIT09IHNoYWRlcnMubGVuZ3RoKSB7XG4gICAgcHJvZ09wdGlvbnMuZXJyb3JDYWxsYmFjayhcIm5vdCBlbm91Z2ggc2hhZGVycyBmb3IgcHJvZ3JhbVwiKTtcbiAgICBkZWxldGVTaGFkZXJzKGdsLCBuZXdTaGFkZXJzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIHJlYWxTaGFkZXJzLmZvckVhY2goZnVuY3Rpb24oc2hhZGVyKSB7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcik7XG4gIH0pO1xuICBpZiAocHJvZ09wdGlvbnMuYXR0cmliTG9jYXRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMocHJvZ09wdGlvbnMuYXR0cmliTG9jYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYikge1xuICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIHByb2dPcHRpb25zLmF0dHJpYkxvY2F0aW9uc1thdHRyaWJdLCBhdHRyaWIpO1xuICAgIH0pO1xuICB9XG4gIGxldCB2YXJ5aW5ncyA9IHByb2dPcHRpb25zLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M7XG4gIGlmICh2YXJ5aW5ncykge1xuICAgIGlmICh2YXJ5aW5ncy5hdHRyaWJzKSB7XG4gICAgICB2YXJ5aW5ncyA9IHZhcnlpbmdzLmF0dHJpYnM7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YXJ5aW5ncykpIHtcbiAgICAgIHZhcnlpbmdzID0gT2JqZWN0LmtleXModmFyeWluZ3MpO1xuICAgIH1cbiAgICBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKHByb2dyYW0sIHZhcnlpbmdzLCBwcm9nT3B0aW9ucy50cmFuc2Zvcm1GZWVkYmFja01vZGUgfHwgU0VQQVJBVEVfQVRUUklCUyk7XG4gIH1cbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgLy8gQ2hlY2sgdGhlIGxpbmsgc3RhdHVzXG4gIGNvbnN0IGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgTElOS19TVEFUVVMpO1xuICBpZiAoIWxpbmtlZCkge1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGggdGhlIGxpbmtcbiAgICBjb25zdCBsYXN0RXJyb3IgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKGAke1xuICAgICAgcmVhbFNoYWRlcnMubWFwKHNoYWRlciA9PiB7XG4gICAgICAgIGNvbnN0IHNyYyA9IGFkZExpbmVOdW1iZXJzV2l0aEVycm9yKGdsLmdldFNoYWRlclNvdXJjZShzaGFkZXIpLCAnJywgMCk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5TSEFERVJfVFlQRSk7XG4gICAgICAgIHJldHVybiBgJHtnbEVudW1Ub1N0cmluZyhnbCwgdHlwZSl9XFxuJHtzcmN9fWA7XG4gICAgICB9KS5qb2luKCdcXG4nKVxuICAgIH1cXG5FcnJvciBpbiBwcm9ncmFtIGxpbmtpbmc6ICR7bGFzdEVycm9yfWApO1xuXG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBkZWxldGVTaGFkZXJzKGdsLCBuZXdTaGFkZXJzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcHJvZ3JhbTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhIHNoYWRlciBmcm9tIGEgc2NyaXB0IHRhZy5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRJZCBUaGUgaWQgb2YgdGhlIHNjcmlwdCB0YWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdF9zaGFkZXJUeXBlXSBUaGUgdHlwZSBvZiBzaGFkZXIuIElmIG5vdCBwYXNzZWQgaW4gaXQgd2lsbFxuICogICAgIGJlIGRlcml2ZWQgZnJvbSB0aGUgdHlwZSBvZiB0aGUgc2NyaXB0IHRhZy5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLlxuICogQHJldHVybiB7V2ViR0xTaGFkZXI/fSBUaGUgY3JlYXRlZCBzaGFkZXIgb3IgbnVsbCBpZiBlcnJvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNoYWRlckZyb21TY3JpcHQoXG4gICAgZ2wsIHNjcmlwdElkLCBvcHRfc2hhZGVyVHlwZSwgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgbGV0IHNoYWRlclNvdXJjZSA9IFwiXCI7XG4gIGNvbnN0IHNoYWRlclNjcmlwdCA9IGdldEVsZW1lbnRCeUlkKHNjcmlwdElkKTtcbiAgaWYgKCFzaGFkZXJTY3JpcHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2NyaXB0IGVsZW1lbnQ6ICR7c2NyaXB0SWR9YCk7XG4gIH1cbiAgc2hhZGVyU291cmNlID0gc2hhZGVyU2NyaXB0LnRleHQ7XG5cbiAgY29uc3Qgc2hhZGVyVHlwZSA9IG9wdF9zaGFkZXJUeXBlIHx8IGdldFNoYWRlclR5cGVGcm9tU2NyaXB0VHlwZShnbCwgc2hhZGVyU2NyaXB0LnR5cGUpO1xuICBpZiAoIXNoYWRlclR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc2hhZGVyIHR5cGUnKTtcbiAgfVxuXG4gIHJldHVybiBsb2FkU2hhZGVyKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUsIG9wdF9lcnJvckNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvZ3JhbSBmcm9tIDIgc2NyaXB0IHRhZ3MuXG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgW3ZzLCBmc10sIG9wdF9vcHRpb25zKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgW3ZzLCBmc10sIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgW3ZzLCBmc10sIG9wdF9hdHRyaWJzLCBvcHRfZXJyRnVuYyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNjcmlwdHMoZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2VyckZ1bmMpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiAgICAgICAgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gc2hhZGVyU2NyaXB0SWRzIEFycmF5IG9mIGlkcyBvZiB0aGUgc2NyaXB0XG4gKiAgICAgICAgdGFncyBmb3IgdGhlIHNoYWRlcnMuIFRoZSBmaXJzdCBpcyBhc3N1bWVkIHRvIGJlIHRoZVxuICogICAgICAgIHZlcnRleCBzaGFkZXIsIHRoZSBzZWNvbmQgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN8c3RyaW5nW118bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzIG9yIGFuIGVycm9yIGNhbGxiYWNrLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfSBbb3B0X2xvY2F0aW9uc3xtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucyBvciBhbiBlcnJvciBjYWxsYmFjay5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW0/fSB0aGUgY3JlYXRlZCBwcm9ncmFtIG9yIG51bGwgaWYgZXJyb3IuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzKFxuICAgIGdsLCBzaGFkZXJTY3JpcHRJZHMsIG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjaykge1xuICBjb25zdCBwcm9nT3B0aW9ucyA9IGdldFByb2dyYW1PcHRpb25zKG9wdF9hdHRyaWJzLCBvcHRfbG9jYXRpb25zLCBvcHRfZXJyb3JDYWxsYmFjayk7XG4gIGNvbnN0IHNoYWRlcnMgPSBbXTtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHNoYWRlclNjcmlwdElkcy5sZW5ndGg7ICsraWkpIHtcbiAgICBjb25zdCBzaGFkZXIgPSBjcmVhdGVTaGFkZXJGcm9tU2NyaXB0KFxuICAgICAgICBnbCwgc2hhZGVyU2NyaXB0SWRzW2lpXSwgZ2xbZGVmYXVsdFNoYWRlclR5cGVbaWldXSwgcHJvZ09wdGlvbnMuZXJyb3JDYWxsYmFjayk7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzaGFkZXJzLnB1c2goc2hhZGVyKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUHJvZ3JhbShnbCwgc2hhZGVycywgcHJvZ09wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm9ncmFtIGZyb20gMiBzb3VyY2VzLlxuICpcbiAqIE5PVEU6IFRoZXJlIGFyZSA0IHNpZ25hdHVyZXMgZm9yIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtRnJvbVNvdXJjZShnbCwgW3ZzLCBmc10sIG9wdF9vcHRpb25zKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1Gcm9tU291cmNlKGdsLCBbdnMsIGZzXSwgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UoZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2VyckZ1bmMpO1xuICogICAgIHR3Z2wuY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2UoZ2wsIFt2cywgZnNdLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2VyckZ1bmMpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiAgICAgICAgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gc2hhZGVyU291cmNlcyBBcnJheSBvZiBzb3VyY2VzIGZvciB0aGVcbiAqICAgICAgICBzaGFkZXJzLiBUaGUgZmlyc3QgaXMgYXNzdW1lZCB0byBiZSB0aGUgdmVydGV4IHNoYWRlcixcbiAqICAgICAgICB0aGUgc2Vjb25kIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1PcHRpb25zfHN0cmluZ1tdfG1vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfYXR0cmlic10gT3B0aW9ucyBmb3IgdGhlIHByb2dyYW0gb3IgYW4gYXJyYXkgb2YgYXR0cmlicyBuYW1lcyBvciBhbiBlcnJvciBjYWxsYmFjay4gTG9jYXRpb25zIHdpbGwgYmUgYXNzaWduZWQgYnkgaW5kZXggaWYgbm90IHBhc3NlZCBpblxuICogQHBhcmFtIHtudW1iZXJbXX0gW29wdF9sb2NhdGlvbnN8bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja10gVGhlIGxvY2F0aW9ucyBmb3IgdGhlLiBBIHBhcmFsbGVsIGFycmF5IHRvIG9wdF9hdHRyaWJzIGxldHRpbmcgeW91IGFzc2lnbiBsb2NhdGlvbnMgb3IgYW4gZXJyb3IgY2FsbGJhY2suXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkVycm9yQ2FsbGJhY2t9IFtvcHRfZXJyb3JDYWxsYmFja10gY2FsbGJhY2sgZm9yIGVycm9ycy4gQnkgZGVmYXVsdCBpdCBqdXN0IHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZVxuICogICAgICAgIG9uIGVycm9yLiBJZiB5b3Ugd2FudCBzb21ldGhpbmcgZWxzZSBwYXNzIGFuIGNhbGxiYWNrLiBJdCdzIHBhc3NlZCBhbiBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybiB7V2ViR0xQcm9ncmFtP30gdGhlIGNyZWF0ZWQgcHJvZ3JhbSBvciBudWxsIGlmIGVycm9yLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyhcbiAgICBnbCwgc2hhZGVyU291cmNlcywgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKSB7XG4gIGNvbnN0IHByb2dPcHRpb25zID0gZ2V0UHJvZ3JhbU9wdGlvbnMob3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJvckNhbGxiYWNrKTtcbiAgY29uc3Qgc2hhZGVycyA9IFtdO1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgc2hhZGVyU291cmNlcy5sZW5ndGg7ICsraWkpIHtcbiAgICBjb25zdCBzaGFkZXIgPSBsb2FkU2hhZGVyKFxuICAgICAgICBnbCwgc2hhZGVyU291cmNlc1tpaV0sIGdsW2RlZmF1bHRTaGFkZXJUeXBlW2lpXV0sIHByb2dPcHRpb25zLmVycm9yQ2FsbGJhY2spO1xuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2hhZGVycy5wdXNoKHNoYWRlcik7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVByb2dyYW0oZ2wsIHNoYWRlcnMsIHByb2dPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYXR0cmlidXRlL3VuaWZvcm0gaXMgYSByZXNlcnZlZC9idWlsdCBpblxuICpcbiAqIEl0IG1ha2VzIG5vIHNlbnNlIHRvIG1lIHdoeSBHTCByZXR1cm5zIHRoZXNlIGJlY2F1c2UgaXQnc1xuICogaWxsZWdhbCB0byBjYWxsIGBnbC5nZXRVbmlmb3JtTG9jYXRpb25gIGFuZCBgZ2wuZ2V0QXR0cmliTG9jYXRpb25gXG4gKiB3aXRoIG5hbWVzIHRoYXQgc3RhcnQgd2l0aCBgZ2xfYCAoYW5kIGB3ZWJnbF9gIGluIFdlYkdMKVxuICpcbiAqIEkgY2FuIG9ubHkgYXNzdW1lIHRoZXkgYXJlIHRoZXJlIGJlY2F1c2UgdGhleSBtaWdodCBjb3VudFxuICogd2hlbiBjb21wdXRpbmcgdGhlIG51bWJlciBvZiB1bmlmb3Jtcy9hdHRyaWJ1dGVzIHVzZWQgd2hlbiB5b3Ugd2FudCB0b1xuICoga25vdyBpZiB5b3UgYXJlIG5lYXIgdGhlIGxpbWl0LiBUaGF0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2VcbiAqIHRvIG1lIGJ1dCB0aGUgZmFjdCB0aGF0IHRoZXNlIGdldCByZXR1cm5lZCBhcmUgaW4gdGhlIHNwZWMuXG4gKlxuICogQHBhcmFtIHtXZWJHTEFjdGl2ZUluZm99IGluZm8gQXMgcmV0dXJuZWQgZnJvbSBgZ2wuZ2V0QWN0aXZlVW5pZm9ybWAgb3JcbiAqICAgIGBnbC5nZXRBY3RpdmVBdHRyaWJgLlxuICogQHJldHVybiB7Ym9vbH0gdHJ1ZSBpZiBpdCdzIHJlc2VydmVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0J1aWx0SW4oaW5mbykge1xuICBjb25zdCBuYW1lID0gaW5mby5uYW1lO1xuICByZXR1cm4gbmFtZS5zdGFydHNXaXRoKFwiZ2xfXCIpIHx8IG5hbWUuc3RhcnRzV2l0aChcIndlYmdsX1wiKTtcbn1cblxuY29uc3QgdG9rZW5SRSA9IC8oXFwufFxcW3xdfFxcdyspL2c7XG5jb25zdCBpc0RpZ2l0ID0gcyA9PiBzID49ICcwJyAmJiBzIDw9ICc5JztcbmZ1bmN0aW9uIGFkZFNldHRlclRvVW5pZm9ybVRyZWUoZnVsbFBhdGgsIHNldHRlciwgbm9kZSwgdW5pZm9ybVNldHRlcnMpIHtcbiAgY29uc3QgdG9rZW5zID0gZnVsbFBhdGguc3BsaXQodG9rZW5SRSkuZmlsdGVyKHMgPT4gcyAhPT0gJycpO1xuICBsZXQgdG9rZW5OZHggPSAwO1xuICBsZXQgcGF0aCA9ICcnO1xuXG4gIGZvciAoOzspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1t0b2tlbk5keCsrXTsgIC8vIGhhcyB0byBiZSBuYW1lIG9yIG51bWJlclxuICAgIHBhdGggKz0gdG9rZW47XG4gICAgY29uc3QgaXNBcnJheUluZGV4ID0gaXNEaWdpdCh0b2tlblswXSk7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBpc0FycmF5SW5kZXhcbiAgICAgICAgPyBwYXJzZUludCh0b2tlbilcbiAgICAgICAgOiB0b2tlbjtcbiAgICBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICBwYXRoICs9IHRva2Vuc1t0b2tlbk5keCsrXTsgIC8vIHNraXAgJ10nXG4gICAgfVxuICAgIGNvbnN0IGlzTGFzdFRva2VuID0gdG9rZW5OZHggPT09IHRva2Vucy5sZW5ndGg7XG4gICAgaWYgKGlzTGFzdFRva2VuKSB7XG4gICAgICBub2RlW2FjY2Vzc29yXSA9IHNldHRlcjtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1t0b2tlbk5keCsrXTsgIC8vIGhhcyB0byBiZSAuIG9yIFtcbiAgICAgIGNvbnN0IGlzQXJyYXkgPSB0b2tlbiA9PT0gJ1snO1xuICAgICAgY29uc3QgY2hpbGQgPSBub2RlW2FjY2Vzc29yXSB8fCAoaXNBcnJheSA/IFtdIDoge30pO1xuICAgICAgbm9kZVthY2Nlc3Nvcl0gPSBjaGlsZDtcbiAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgIHVuaWZvcm1TZXR0ZXJzW3BhdGhdID0gdW5pZm9ybVNldHRlcnNbcGF0aF0gfHwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBzZXRVbmlmb3JtVHJlZShub2RlLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICB9KGNoaWxkKTtcbiAgICAgIHBhdGggKz0gdG9rZW47XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBzZXR0ZXIgZnVuY3Rpb25zIGZvciBhbGwgdW5pZm9ybXMgb2YgYSBzaGFkZXJcbiAqIHByb2dyYW0uXG4gKlxuICogQHNlZSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0VW5pZm9ybXN9XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW0gdGhlIHByb2dyYW0gdG8gY3JlYXRlIHNldHRlcnMgZm9yLlxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IGFuIG9iamVjdCB3aXRoIGEgc2V0dGVyIGJ5IG5hbWUgZm9yIGVhY2ggdW5pZm9ybVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1TZXR0ZXJzKGdsLCBwcm9ncmFtKSB7XG4gIGxldCB0ZXh0dXJlVW5pdCA9IDA7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzZXR0ZXIgZm9yIGEgdW5pZm9ybSBvZiB0aGUgZ2l2ZW4gcHJvZ3JhbSB3aXRoIGl0J3NcbiAgICogbG9jYXRpb24gZW1iZWRkZWQgaW4gdGhlIHNldHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW1cbiAgICogQHBhcmFtIHtXZWJHTFVuaWZvcm1JbmZvfSB1bmlmb3JtSW5mb1xuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRoZSBjcmVhdGVkIHNldHRlci5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1TZXR0ZXIocHJvZ3JhbSwgdW5pZm9ybUluZm8sIGxvY2F0aW9uKSB7XG4gICAgY29uc3QgaXNBcnJheSA9IHVuaWZvcm1JbmZvLm5hbWUuZW5kc1dpdGgoXCJbMF1cIik7XG4gICAgY29uc3QgdHlwZSA9IHVuaWZvcm1JbmZvLnR5cGU7XG4gICAgY29uc3QgdHlwZUluZm8gPSB0eXBlTWFwW3R5cGVdO1xuICAgIGlmICghdHlwZUluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAweCR7dHlwZS50b1N0cmluZygxNil9YCk7IC8vIHdlIHNob3VsZCBuZXZlciBnZXQgaGVyZS5cbiAgICB9XG4gICAgbGV0IHNldHRlcjtcbiAgICBpZiAodHlwZUluZm8uYmluZFBvaW50KSB7XG4gICAgICAvLyBpdCdzIGEgc2FtcGxlclxuICAgICAgY29uc3QgdW5pdCA9IHRleHR1cmVVbml0O1xuICAgICAgdGV4dHVyZVVuaXQgKz0gdW5pZm9ybUluZm8uc2l6ZTtcbiAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgIHNldHRlciA9IHR5cGVJbmZvLmFycmF5U2V0dGVyKGdsLCB0eXBlLCB1bml0LCBsb2NhdGlvbiwgdW5pZm9ybUluZm8uc2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0ZXIgPSB0eXBlSW5mby5zZXR0ZXIoZ2wsIHR5cGUsIHVuaXQsIGxvY2F0aW9uLCB1bmlmb3JtSW5mby5zaXplKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVJbmZvLmFycmF5U2V0dGVyICYmIGlzQXJyYXkpIHtcbiAgICAgICAgc2V0dGVyID0gdHlwZUluZm8uYXJyYXlTZXR0ZXIoZ2wsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldHRlciA9IHR5cGVJbmZvLnNldHRlcihnbCwgbG9jYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXR0ZXIubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICByZXR1cm4gc2V0dGVyO1xuICB9XG5cbiAgY29uc3QgdW5pZm9ybVNldHRlcnMgPSB7fTtcbiAgY29uc3QgdW5pZm9ybVRyZWUgPSB7fTtcbiAgY29uc3QgbnVtVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIEFDVElWRV9VTklGT1JNUyk7XG5cbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG51bVVuaWZvcm1zOyArK2lpKSB7XG4gICAgY29uc3QgdW5pZm9ybUluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGlpKTtcbiAgICBpZiAoaXNCdWlsdEluKHVuaWZvcm1JbmZvKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBuYW1lID0gdW5pZm9ybUluZm8ubmFtZTtcbiAgICAvLyByZW1vdmUgdGhlIGFycmF5IHN1ZmZpeC5cbiAgICBpZiAobmFtZS5lbmRzV2l0aChcIlswXVwiKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gMyk7XG4gICAgfVxuICAgIGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1JbmZvLm5hbWUpO1xuICAgIC8vIHRoZSB1bmlmb3JtIHdpbGwgaGF2ZSBubyBsb2NhdGlvbiBpZiBpdCdzIGluIGEgdW5pZm9ybSBibG9ja1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgY29uc3Qgc2V0dGVyID0gY3JlYXRlVW5pZm9ybVNldHRlcihwcm9ncmFtLCB1bmlmb3JtSW5mbywgbG9jYXRpb24pO1xuICAgICAgdW5pZm9ybVNldHRlcnNbbmFtZV0gPSBzZXR0ZXI7XG4gICAgICBhZGRTZXR0ZXJUb1VuaWZvcm1UcmVlKG5hbWUsIHNldHRlciwgdW5pZm9ybVRyZWUsIHVuaWZvcm1TZXR0ZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pZm9ybVNldHRlcnM7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJhbnNmb3JtRmVlZGJhY2tJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggaW5kZXggb2YgdHJhbnNmb3JtIGZlZWRiYWNrXG4gKiBAcHJvcGVydHkge251bWJlcn0gdHlwZSBHTCB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSAxIC0gNFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgVHJhbnNmb3JtRmVlZGJhY2tJbmZvIGZvciBwYXNzaW5nIHRvIGJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8uXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBhbiBleGlzdGluZyBXZWJHTFByb2dyYW0uXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5UcmFuc2Zvcm1GZWVkYmFja0luZm8+fVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrSW5mbyhnbCwgcHJvZ3JhbSkge1xuICBjb25zdCBpbmZvID0ge307XG4gIGNvbnN0IG51bVZhcnlpbmdzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBUUkFOU0ZPUk1fRkVFREJBQ0tfVkFSWUlOR1MpO1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbnVtVmFyeWluZ3M7ICsraWkpIHtcbiAgICBjb25zdCB2YXJ5aW5nID0gZ2wuZ2V0VHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nKHByb2dyYW0sIGlpKTtcbiAgICBpbmZvW3ZhcnlpbmcubmFtZV0gPSB7XG4gICAgICBpbmRleDogaWksXG4gICAgICB0eXBlOiB2YXJ5aW5nLnR5cGUsXG4gICAgICBzaXplOiB2YXJ5aW5nLnNpemUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBCaW5kcyBidWZmZXJzIGZvciB0cmFuc2Zvcm0gZmVlZGJhY2suXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm98T2JqZWN0PHN0cmluZywgbW9kdWxlOnR3Z2wuVHJhbnNmb3JtRmVlZGJhY2tJbmZvPil9IHRyYW5zZm9ybUZlZWRiYWNrSW5mbyBBIFByb2dyYW1JbmZvIG9yIFRyYW5zZm9ybUZlZWRiYWNrSW5mby5cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLkJ1ZmZlckluZm98T2JqZWN0PHN0cmluZywgbW9kdWxlOnR3Z2wuQXR0cmliSW5mbz4pfSBbYnVmZmVySW5mb10gQSBCdWZmZXJJbmZvIG9yIHNldCBvZiBBdHRyaWJJbmZvcy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5mdW5jdGlvbiBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvKGdsLCB0cmFuc2Zvcm1GZWVkYmFja0luZm8sIGJ1ZmZlckluZm8pIHtcbiAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrSW5mby50cmFuc2Zvcm1GZWVkYmFja0luZm8pIHtcbiAgICB0cmFuc2Zvcm1GZWVkYmFja0luZm8gPSB0cmFuc2Zvcm1GZWVkYmFja0luZm8udHJhbnNmb3JtRmVlZGJhY2tJbmZvO1xuICB9XG4gIGlmIChidWZmZXJJbmZvLmF0dHJpYnMpIHtcbiAgICBidWZmZXJJbmZvID0gYnVmZmVySW5mby5hdHRyaWJzO1xuICB9XG4gIGZvciAoY29uc3QgbmFtZSBpbiBidWZmZXJJbmZvKSB7XG4gICAgY29uc3QgdmFyeWluZyA9IHRyYW5zZm9ybUZlZWRiYWNrSW5mb1tuYW1lXTtcbiAgICBpZiAodmFyeWluZykge1xuICAgICAgY29uc3QgYnVmID0gYnVmZmVySW5mb1tuYW1lXTtcbiAgICAgIGlmIChidWYub2Zmc2V0KSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXJSYW5nZShUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCB2YXJ5aW5nLmluZGV4LCBidWYuYnVmZmVyLCBidWYub2Zmc2V0LCBidWYuc2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kQnVmZmVyQmFzZShUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCB2YXJ5aW5nLmluZGV4LCBidWYuYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIGZlZWRiYWNrIGFuZCBzZXRzIHRoZSBidWZmZXJzXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBBIFByb2dyYW1JbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfVxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xPYmplY3Q8c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPil9IFtidWZmZXJJbmZvXSBBIEJ1ZmZlckluZm8gb3Igc2V0IG9mIEF0dHJpYkluZm9zLlxuICogQHJldHVybiB7V2ViR0xUcmFuc2Zvcm1GZWVkYmFja30gdGhlIGNyZWF0ZWQgdHJhbnNmb3JtIGZlZWRiYWNrXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2soZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJJbmZvKSB7XG4gIGNvbnN0IHRmID0gZ2wuY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2soKTtcbiAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKFRSQU5TRk9STV9GRUVEQkFDSywgdGYpO1xuICBnbC51c2VQcm9ncmFtKHByb2dyYW1JbmZvLnByb2dyYW0pO1xuICBiaW5kVHJhbnNmb3JtRmVlZGJhY2tJbmZvKGdsLCBwcm9ncmFtSW5mbywgYnVmZmVySW5mbyk7XG4gIGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhUUkFOU0ZPUk1fRkVFREJBQ0ssIG51bGwpO1xuICByZXR1cm4gdGY7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5pZm9ybURhdGFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtXG4gKiBAcHJvcGVydHkge251bWJlcn0gdHlwZSBUaGUgV2ViR0wgdHlwZSBlbnVtIGZvciB0aGlzIHVuaWZvcm1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHRoaXMgdW5pZm9ybVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrTmR4IFRoZSBibG9jayBpbmRleCB0aGlzIHVuaWZvcm0gYXBwZWFycyBpblxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCBUaGUgYnl0ZSBvZmZzZXQgaW4gdGhlIGJsb2NrIGZvciB0aGlzIHVuaWZvcm0ncyB2YWx1ZVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBUaGUgc3BlY2lmaWNhdGlvbiBmb3Igb25lIFVuaWZvcm1CbG9ja09iamVjdFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJsb2NrU3BlY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgYmxvY2suXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSBUaGUgc2l6ZSBpbiBieXRlcyBuZWVkZWQgZm9yIHRoZSBibG9ja1xuICogQHByb3BlcnR5IHtudW1iZXJbXX0gdW5pZm9ybUluZGljZXMgVGhlIGluZGljZXMgb2YgdGhlIHVuaWZvcm1zIHVzZWQgYnkgdGhlIGJsb2NrLiBUaGVzZSBpbmRpY2VzXG4gKiAgICBjb3JyZXNwb25kIHRvIGVudHJpZXMgaW4gYSBVbmlmb3JtRGF0YSBhcnJheSBpbiB0aGUge0BsaW5rIG1vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWN9LlxuICogQHByb3BlcnR5IHtib29sfSB1c2VkQnlWZXJ0ZXhTaGFkZXIgU2VsZiBleHBsYW5hdG9yeVxuICogQHByb3BlcnR5IHtib29sfSB1c2VkQnlGcmFnbWVudFNoYWRlciBTZWxmIGV4cGxhbmF0b3J5XG4gKiBAcHJvcGVydHkge2Jvb2x9IHVzZWQgU2VsZiBleHBsYW5hdG9yeVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBBIGBVbmlmb3JtQmxvY2tTcGVjYCByZXByZXNlbnRzIHRoZSBkYXRhIG5lZWRlZCB0byBjcmVhdGUgYW5kIGJpbmRcbiAqIFVuaWZvcm1CbG9ja09iamVjdHMgZm9yIGEgZ2l2ZW4gcHJvZ3JhbVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVuaWZvcm1CbG9ja1NwZWNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkJsb2NrU3BlYz59IGJsb2NrU3BlY3MgVGhlIEJsb2NrU3BlYyBmb3IgZWFjaCBibG9jayBieSBibG9jayBuYW1lXG4gKiBAcHJvcGVydHkge1VuaWZvcm1EYXRhW119IHVuaWZvcm1EYXRhIEFuIGFycmF5IG9mIGRhdGEgZm9yIGVhY2ggdW5pZm9ybSBieSB1bmlmb3JtIGluZGV4LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgVW5pZm9ybUJsb2NrU3BlYyBmb3IgdGhlIGdpdmVuIHByb2dyYW0uXG4gKlxuICogQSBVbmlmb3JtQmxvY2tTcGVjIHJlcHJlc2VudHMgdGhlIGRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhbmQgYmluZFxuICogVW5pZm9ybUJsb2NrT2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTDIgUmVuZGVyaW5nIENvbnRleHRcbiAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIEEgV2ViR0xQcm9ncmFtIGZvciBhIHN1Y2Nlc3NmdWxseSBsaW5rZWQgcHJvZ3JhbVxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30gVGhlIGNyZWF0ZWQgVW5pZm9ybUJsb2NrU3BlY1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1CbG9ja1NwZWNGcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICBjb25zdCBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX1VOSUZPUk1TKTtcbiAgY29uc3QgdW5pZm9ybURhdGEgPSBbXTtcbiAgY29uc3QgdW5pZm9ybUluZGljZXMgPSBbXTtcblxuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbnVtVW5pZm9ybXM7ICsraWkpIHtcbiAgICB1bmlmb3JtSW5kaWNlcy5wdXNoKGlpKTtcbiAgICB1bmlmb3JtRGF0YS5wdXNoKHt9KTtcbiAgICBjb25zdCB1bmlmb3JtSW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaWkpO1xuICAgIHVuaWZvcm1EYXRhW2lpXS5uYW1lID0gdW5pZm9ybUluZm8ubmFtZTtcbiAgfVxuXG4gIFtcbiAgICBbIFwiVU5JRk9STV9UWVBFXCIsIFwidHlwZVwiIF0sXG4gICAgWyBcIlVOSUZPUk1fU0laRVwiLCBcInNpemVcIiBdLCAgLy8gbnVtIGVsZW1lbnRzXG4gICAgWyBcIlVOSUZPUk1fQkxPQ0tfSU5ERVhcIiwgXCJibG9ja05keFwiIF0sXG4gICAgWyBcIlVOSUZPUk1fT0ZGU0VUXCIsIFwib2Zmc2V0XCIsIF0sXG4gIF0uZm9yRWFjaChmdW5jdGlvbihwYWlyKSB7XG4gICAgY29uc3QgcG5hbWUgPSBwYWlyWzBdO1xuICAgIGNvbnN0IGtleSA9IHBhaXJbMV07XG4gICAgZ2wuZ2V0QWN0aXZlVW5pZm9ybXMocHJvZ3JhbSwgdW5pZm9ybUluZGljZXMsIGdsW3BuYW1lXSkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmR4KSB7XG4gICAgICB1bmlmb3JtRGF0YVtuZHhdW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgYmxvY2tTcGVjcyA9IHt9O1xuXG4gIGNvbnN0IG51bVVuaWZvcm1CbG9ja3MgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIEFDVElWRV9VTklGT1JNX0JMT0NLUyk7XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBudW1Vbmlmb3JtQmxvY2tzOyArK2lpKSB7XG4gICAgY29uc3QgbmFtZSA9IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja05hbWUocHJvZ3JhbSwgaWkpO1xuICAgIGNvbnN0IGJsb2NrU3BlYyA9IHtcbiAgICAgIGluZGV4OiBnbC5nZXRVbmlmb3JtQmxvY2tJbmRleChwcm9ncmFtLCBuYW1lKSxcbiAgICAgIHVzZWRCeVZlcnRleFNoYWRlcjogZ2wuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrUGFyYW1ldGVyKHByb2dyYW0sIGlpLCBVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfVkVSVEVYX1NIQURFUiksXG4gICAgICB1c2VkQnlGcmFnbWVudFNoYWRlcjogZ2wuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrUGFyYW1ldGVyKHByb2dyYW0sIGlpLCBVTklGT1JNX0JMT0NLX1JFRkVSRU5DRURfQllfRlJBR01FTlRfU0hBREVSKSxcbiAgICAgIHNpemU6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBpaSwgVU5JRk9STV9CTE9DS19EQVRBX1NJWkUpLFxuICAgICAgdW5pZm9ybUluZGljZXM6IGdsLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBpaSwgVU5JRk9STV9CTE9DS19BQ1RJVkVfVU5JRk9STV9JTkRJQ0VTKSxcbiAgICB9O1xuICAgIGJsb2NrU3BlYy51c2VkID0gYmxvY2tTcGVjLnVzZWRCeVZlcnRleFNoYWRlciB8fCBibG9ja1NwZWMudXNlZEJ5RnJhZ21lbnRTaGFkZXI7XG4gICAgYmxvY2tTcGVjc1tuYW1lXSA9IGJsb2NrU3BlYztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmxvY2tTcGVjczogYmxvY2tTcGVjcyxcbiAgICB1bmlmb3JtRGF0YTogdW5pZm9ybURhdGEsXG4gIH07XG59XG5cbmNvbnN0IGFycmF5U3VmZml4UkUgPSAvXFxbXFxkK1xcXVxcLiQvOyAgLy8gYmV0dGVyIHdheSB0byBjaGVjaz9cblxuY29uc3QgcGFkID0gKHYsIHBhZGRpbmcpID0+ICgodiArIChwYWRkaW5nIC0gMSkpIC8gcGFkZGluZyB8IDApICogcGFkZGluZztcblxuZnVuY3Rpb24gY3JlYXRlVW5pZm9ybUJsb2NrVW5pZm9ybVNldHRlcih2aWV3LCBpc0FycmF5LCByb3dzLCBjb2xzKSB7XG4gIGlmIChpc0FycmF5IHx8IHJvd3MpIHtcbiAgICBjb2xzID0gY29scyB8fCAxO1xuICAgIGNvbnN0IG51bUVsZW1lbnRzID0gdmlldy5sZW5ndGg7XG4gICAgY29uc3QgdG90YWxSb3dzID0gbnVtRWxlbWVudHMgLyA0O1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgbGV0IGRzdCA9IDA7XG4gICAgICBsZXQgc3JjID0gMDtcbiAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRvdGFsUm93czsgKytyb3cpIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sczsgKytjb2wpIHtcbiAgICAgICAgICB2aWV3W2RzdCsrXSA9IHZhbHVlW3NyYysrXTtcbiAgICAgICAgfVxuICAgICAgICBkc3QgKz0gNCAtIGNvbHM7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmlldy5zZXQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld1swXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgVW5pZm9ybUJsb2NrT2JqZWN0IGluY2x1ZGluZyBhbiBBcnJheUJ1ZmZlciB3aXRoIGFsbCB0aGUgdW5pZm9ybSB2YWx1ZXNcbiAqIGFuZCBhIGNvcnJlc3BvbmRpbmcgV2ViR0xCdWZmZXIgdG8gaG9sZCB0aG9zZSB2YWx1ZXMgb24gdGhlIEdQVVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVuaWZvcm1CbG9ja0luZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBibG9ja1xuICogQHByb3BlcnR5IHtBcnJheUJ1ZmZlcn0gYXJyYXkgVGhlIGFycmF5IGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoZSB1bmlmb3JtIHZhbHVlc1xuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGFzRmxvYXQgQSBmbG9hdCB2aWV3IG9uIHRoZSBhcnJheSBidWZmZXIuIFRoaXMgaXMgdXNlZnVsXG4gKiAgICBpbnNwZWN0aW5nIHRoZSBjb250ZW50cyBvZiB0aGUgYnVmZmVyIGluIHRoZSBkZWJ1Z2dlci5cbiAqIEBwcm9wZXJ0eSB7V2ViR0xCdWZmZXJ9IGJ1ZmZlciBBIFdlYkdMIGJ1ZmZlciB0aGF0IHdpbGwgaG9sZCBhIGNvcHkgb2YgdGhlIHVuaWZvcm0gdmFsdWVzIGZvciByZW5kZXJpbmcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldF0gb2Zmc2V0IGludG8gYnVmZmVyXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIEFycmF5QnVmZmVyVmlldz59IHVuaWZvcm1zIEEgdW5pZm9ybSBuYW1lIHRvIEFycmF5QnVmZmVyVmlldyBtYXAuXG4gKiAgIGVhY2ggVW5pZm9ybSBoYXMgYSBjb3JyZWN0bHkgdHlwZWQgYEFycmF5QnVmZmVyVmlld2AgaW50byBhcnJheSBhdCB0aGUgY29ycmVjdCBvZmZzZXRcbiAqICAgYW5kIGxlbmd0aCBvZiB0aGF0IHVuaWZvcm0uIFNvIGZvciBleGFtcGxlIGEgZmxvYXQgdW5pZm9ybSB3b3VsZCBoYXZlIGEgMSBmbG9hdCBgRmxvYXQzMkFycmF5YFxuICogICB2aWV3LiBBIHNpbmdsZSBtYXQ0IHdvdWxkIGhhdmUgYSAxNiBlbGVtZW50IGBGbG9hdDMyQXJyYXlgIHZpZXcuIEFuIGl2ZWMyIHdvdWxkIGhhdmUgYW5cbiAqICAgYEludDMyQXJyYXlgIHZpZXcsIGV0Yy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24+fSBzZXR0ZXJzIEEgc2V0dGVyIGZvciB0aGlzIHVuaWZvcm0uXG4gKiAgIFRoZSByZWFzb24gdG8gdXNlIHNldHRlcnMgaXMgZWxlbWVudHMgb2YgYXJyYXlzIGFyZSBwYWRkZWQgdG8gdmVjNCBzaXplcyB3aGljaFxuICogICBtZWFucyBpZiB5b3Ugd2FudCB0byBzZXQgYW4gYXJyYXkgb2YgNCBmbG9hdHMgeW91J2QgbmVlZCB0byBzZXQgMTYgdmFsdWVzXG4gKiAgIChvciBzZXQgZWxlbWVudHMgMCwgNCwgOCwgMTIpLiBJbiBvdGhlciB3b3Jkc1xuICogICBgc29tZUJsb2NrSW5mby51bmlmb3Jtcy5zb21lNEZsb2F0QXJyYXlVbmlmb3JtLnNldChbMCwgLCAsICwgMSwgLCAsICwgMiwgLCAsICwgM10pYFxuICogICB3aGVyZSBhcyB0aGUgc2V0dGVyIGhhbmRsZXMganVzdCBwYXNzaW5nIGluIFswLCAxLCAyLCAzXSBlaXRoZXIgZGlyZWN0bHkgYXMgaW5cbiAqICAgYHNvbWVCbG9ja0luZm8uc2V0dGVyLnNvbWU0RmxvYXRBcnJheVVuaWZvcm0uc2V0KFswLCAxLCAyLCAzXSlgIChub3QgcmVjb21tZW5kZWQpXG4gKiAgIG9yIHZpYSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QmxvY2tVbmlmb3Jtc31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGBVbmlmb3JtQmxvY2tJbmZvYCBmb3IgdGhlIHNwZWNpZmllZCBibG9ja1xuICpcbiAqIE5vdGU6ICoqSWYgdGhlIGJsb2NrTmFtZSBtYXRjaGVzIG5vIGV4aXN0aW5nIGJsb2NrcyBhIHdhcm5pbmcgaXMgcHJpbnRlZCB0byB0aGUgY29uc29sZSBhbmQgYSBkdW1teVxuICogYFVuaWZvcm1CbG9ja0luZm9gIGlzIHJldHVybmVkKiouIFRoaXMgaXMgYmVjYXVzZSB3aGVuIGRlYnVnZ2luZyBHTFNMXG4gKiBpdCBpcyBjb21tb24gdG8gY29tbWVudCBvdXQgbGFyZ2UgcG9ydGlvbnMgb2YgYSBzaGFkZXIgb3IgZm9yIGV4YW1wbGUgc2V0XG4gKiB0aGUgZmluYWwgb3V0cHV0IHRvIGEgY29uc3RhbnQuIFdoZW4gdGhhdCBoYXBwZW5zIGJsb2NrcyBnZXQgb3B0aW1pemVkIG91dC5cbiAqIElmIHRoaXMgZnVuY3Rpb24gZGlkIG5vdCBjcmVhdGUgZHVtbXkgYmxvY2tzIHlvdXIgY29kZSB3b3VsZCBjcmFzaCB3aGVuIGRlYnVnZ2luZy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtXZWJHTFByb2dyYW19IHByb2dyYW0gQSBXZWJHTFByb2dyYW1cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrU3BlY30gdW5pZm9ybUJsb2NrU3BlYy4gQSBVbmlmb3JtQmxvY2tTcGVjIGFzIHJldHVybmVkXG4gKiAgICAgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja05hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gVGhlIGNyZWF0ZWQgVW5pZm9ybUJsb2NrSW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSwgdW5pZm9ybUJsb2NrU3BlYywgYmxvY2tOYW1lKSB7XG4gIGNvbnN0IGJsb2NrU3BlY3MgPSB1bmlmb3JtQmxvY2tTcGVjLmJsb2NrU3BlY3M7XG4gIGNvbnN0IHVuaWZvcm1EYXRhID0gdW5pZm9ybUJsb2NrU3BlYy51bmlmb3JtRGF0YTtcbiAgY29uc3QgYmxvY2tTcGVjID0gYmxvY2tTcGVjc1tibG9ja05hbWVdO1xuICBpZiAoIWJsb2NrU3BlYykge1xuICAgIHdhcm4kMShcIm5vIHVuaWZvcm0gYmxvY2sgb2JqZWN0IG5hbWVkOlwiLCBibG9ja05hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBibG9ja05hbWUsXG4gICAgICB1bmlmb3Jtczoge30sXG4gICAgfTtcbiAgfVxuICBjb25zdCBhcnJheSA9IG5ldyBBcnJheUJ1ZmZlcihibG9ja1NwZWMuc2l6ZSk7XG4gIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBjb25zdCB1bmlmb3JtQnVmZmVySW5kZXggPSBibG9ja1NwZWMuaW5kZXg7XG4gIGdsLmJpbmRCdWZmZXIoVU5JRk9STV9CVUZGRVIsIGJ1ZmZlcik7XG4gIGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcocHJvZ3JhbSwgYmxvY2tTcGVjLmluZGV4LCB1bmlmb3JtQnVmZmVySW5kZXgpO1xuXG4gIGxldCBwcmVmaXggPSBibG9ja05hbWUgKyBcIi5cIjtcbiAgaWYgKGFycmF5U3VmZml4UkUudGVzdChwcmVmaXgpKSB7XG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoYXJyYXlTdWZmaXhSRSwgXCIuXCIpO1xuICB9XG4gIGNvbnN0IHVuaWZvcm1zID0ge307XG4gIGNvbnN0IHNldHRlcnMgPSB7fTtcbiAgY29uc3Qgc2V0dGVyVHJlZSA9IHt9O1xuICBibG9ja1NwZWMudW5pZm9ybUluZGljZXMuZm9yRWFjaChmdW5jdGlvbih1bmlmb3JtTmR4KSB7XG4gICAgY29uc3QgZGF0YSA9IHVuaWZvcm1EYXRhW3VuaWZvcm1OZHhdO1xuICAgIGxldCBuYW1lID0gZGF0YS5uYW1lO1xuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKHByZWZpeC5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBpc0FycmF5ID0gbmFtZS5lbmRzV2l0aCgnWzBdJyk7XG4gICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIDMpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlSW5mbyA9IHR5cGVNYXBbZGF0YS50eXBlXTtcbiAgICBjb25zdCBUeXBlID0gdHlwZUluZm8uVHlwZTtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gaXNBcnJheVxuICAgICAgICA/IHBhZCh0eXBlSW5mby5zaXplLCAxNikgKiBkYXRhLnNpemVcbiAgICAgICAgOiB0eXBlSW5mby5zaXplICogZGF0YS5zaXplO1xuICAgIGNvbnN0IHVuaWZvcm1WaWV3ID0gbmV3IFR5cGUoYXJyYXksIGRhdGEub2Zmc2V0LCBieXRlTGVuZ3RoIC8gVHlwZS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgdW5pZm9ybXNbbmFtZV0gPSB1bmlmb3JtVmlldztcbiAgICAvLyBOb3RlOiBJJ20gbm90IHN1cmUgd2hhdCB0byBkbyBoZXJlLiBUaGUgb3JpZ2luYWxcbiAgICAvLyBpZGVhIHdhcyB0byBjcmVhdGUgVHlwZWRBcnJheSB2aWV3cyBpbnRvIGVhY2ggcGFydFxuICAgIC8vIG9mIHRoZSBibG9jay4gVGhpcyBpcyB1c2VmdWwsIGZvciBleGFtcGxlIGlmIHlvdSBoYXZlXG4gICAgLy8gYSBibG9jayB3aXRoIHsgbWF0NDogbW9kZWw7IG1hdDQgdmlldzsgbWF0NCBwcm9qZWN0aW9uOyB9XG4gICAgLy8geW91J2xsIGdldCBhIEZsb2F0MzJBcnJheSBmb3IgZWFjaCBvbmUgc3VpdGFibGUgZm9yXG4gICAgLy8gcGFzc2luZyB0byBtb3N0IEpTIG1hdGggbGlicmFyaWVzIGluY2x1ZGluZyB0d2dsJ3MgYW5kIGdsTWF0cml4LmpzLlxuICAgIC8vXG4gICAgLy8gQnV0LCBpZiB5b3UgaGF2ZSBhIGFuIGFycmF5IG9mIHN0cnVjdHVyZXMsIGVzcGVjaWFsbHkgaWYgdGhhdFxuICAgIC8vIGFycmF5IGlzIGxhcmdlLCB5b3UgZ2V0IGEgd2hvbGUgYnVuY2ggb2YgVHlwZWRBcnJheSB2aWV3cy5cbiAgICAvLyBFdmVyeSBvbmUgb2YgdGhlbSBoYXMgb3ZlcmhlYWQgYW5kIHN3aXRjaGluZyBiZXR3ZWVuIHRoZW0gYWxsXG4gICAgLy8gaXMgcHJvYmFibHkgYSBjYWNoZSBtaXNzLiBJbiB0aGF0IGNhc2UgaXQgd291bGQgcmVhbGx5IGJlIGJldHRlclxuICAgIC8vIHRvIGp1c3QgaGF2ZSBvbmUgdmlldyAoYXNGbG9hdCkgYW5kIGhhdmUgYWxsIHRoZSBzZXR0ZXJzXG4gICAgLy8ganVzdCByZWZlcmVuY2UgdGhlIGNvcnJlY3QgcG9ydGlvbi4gQnV0LCB0aGVuIHlvdSBjYW4ndCBlYXNpbHlcbiAgICAvLyB0cmVhdCBhIG1hdHJpeCwgb3IgYSB2ZWM0LCBhcyBhIHN0YW5kYWxvbmUgdGhpbmcgbGlrZSB5b3UgY2FuXG4gICAgLy8gd2l0aCBhbGwgdGhlIHZpZXdzLlxuICAgIC8vXG4gICAgLy8gQW5vdGhlciBwcm9ibGVtIHdpdGggdGhlIHZpZXdzIGlzIHRoZXkgYXJlIG5vdCBzaGFyZWQuIFdpdGhcbiAgICAvLyB1bmlmb3JtcyB5b3UgaGF2ZSBvbmUgc2V0IG9mIHNldHRlcnMuIFdpdGggVW5pZm9ybUJsb2NrSW5mb1xuICAgIC8vIHlvdSBoYXZlIGEgc2V0IG9mIHNldHRlcnMgKnByZSBibG9jayBpbnN0YW5jZSouIFRoYXQncyBiZWNhdXNlXG4gICAgLy8gVHlwZWRBcnJheSB2aWV3cyBjYW4ndCBiZSBtYXBwZWQgdG8gZGlmZmVyZW50IGJ1ZmZlcnMuXG4gICAgLy9cbiAgICAvLyBNeSBndXQgcmlnaHQgbm93IGlzIGlmIHlvdSByZWFsbHkgd2FudCB0aGUgc3BlZWQgYW5kIGNvbXBhY3RuZXNzXG4gICAgLy8gdGhlbiB5b3Ugc2hvdWxkIHByb2JhYmx5IHJvbGwgeW91ciBvd24gc29sdXRpb24uIFRXR0wncyBnb2FsXG4gICAgLy8gaGVyZSBpcyBlYXNlIG9mIHVzZSBhcyBBRkFJQ1QgdGhlcmUgaXMgbm8gc2ltcGxlIGdlbmVyaWMgZWZmaWNpZW50XG4gICAgLy8gc29sdXRpb24uXG4gICAgY29uc3Qgc2V0dGVyID0gY3JlYXRlVW5pZm9ybUJsb2NrVW5pZm9ybVNldHRlcih1bmlmb3JtVmlldywgaXNBcnJheSwgdHlwZUluZm8ucm93cywgdHlwZUluZm8uY29scyk7XG4gICAgc2V0dGVyc1tuYW1lXSA9IHNldHRlcjtcbiAgICBhZGRTZXR0ZXJUb1VuaWZvcm1UcmVlKG5hbWUsIHNldHRlciwgc2V0dGVyVHJlZSwgc2V0dGVycyk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IGJsb2NrTmFtZSxcbiAgICBhcnJheSxcbiAgICBhc0Zsb2F0OiBuZXcgRmxvYXQzMkFycmF5KGFycmF5KSwgIC8vIGZvciBkZWJ1Z2dpbmdcbiAgICBidWZmZXIsXG4gICAgdW5pZm9ybXMsXG4gICAgc2V0dGVycyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYFVuaWZvcm1CbG9ja0luZm9gIGZvciB0aGUgc3BlY2lmaWVkIGJsb2NrXG4gKlxuICogTm90ZTogKipJZiB0aGUgYmxvY2tOYW1lIG1hdGNoZXMgbm8gZXhpc3RpbmcgYmxvY2tzIGEgd2FybmluZyBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlIGFuZCBhIGR1bW15XG4gKiBgVW5pZm9ybUJsb2NrSW5mb2AgaXMgcmV0dXJuZWQqKi4gVGhpcyBpcyBiZWNhdXNlIHdoZW4gZGVidWdnaW5nIEdMU0xcbiAqIGl0IGlzIGNvbW1vbiB0byBjb21tZW50IG91dCBsYXJnZSBwb3J0aW9ucyBvZiBhIHNoYWRlciBvciBmb3IgZXhhbXBsZSBzZXRcbiAqIHRoZSBmaW5hbCBvdXRwdXQgdG8gYSBjb25zdGFudC4gV2hlbiB0aGF0IGhhcHBlbnMgYmxvY2tzIGdldCBvcHRpbWl6ZWQgb3V0LlxuICogSWYgdGhpcyBmdW5jdGlvbiBkaWQgbm90IGNyZWF0ZSBkdW1teSBibG9ja3MgeW91ciBjb2RlIHdvdWxkIGNyYXNoIHdoZW4gZGVidWdnaW5nLlxuICpcbiAqIEBwYXJhbSB7V2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgQSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlByb2dyYW1JbmZvfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb31cbiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja05hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrLlxuICogQHJldHVybiB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gVGhlIGNyZWF0ZWQgVW5pZm9ybUJsb2NrSW5mb1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm8oZ2wsIHByb2dyYW1JbmZvLCBibG9ja05hbWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbUluZm8ucHJvZ3JhbSwgcHJvZ3JhbUluZm8udW5pZm9ybUJsb2NrU3BlYywgYmxvY2tOYW1lKTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIHVuaWZvcm0gYmxvY2sgdG8gdGhlIG1hdGNoaW5nIHVuaWZvcm0gYmxvY2sgcG9pbnQuXG4gKiBNYXRjaGVzIGJ5IGJsb2NrcyBieSBuYW1lIHNvIGJsb2NrcyBtdXN0IGhhdmUgdGhlIHNhbWUgbmFtZSBub3QganVzdCB0aGUgc2FtZVxuICogc3RydWN0dXJlLlxuICpcbiAqIElmIHlvdSBoYXZlIGNoYW5nZWQgYW55IHZhbHVlcyBhbmQgeW91IHVwbG9hZCB0aGUgdmFsdWVzIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgV2ViR0xCdWZmZXJcbiAqIGNhbGwge0BsaW5rIG1vZHVsZTp0d2dsLnNldFVuaWZvcm1CbG9ja30gaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0wgMiByZW5kZXJpbmcgY29udGV4dC5cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfG1vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja1NwZWMpfSBwcm9ncmFtSW5mbyBhIGBQcm9ncmFtSW5mb2BcbiAqICAgICBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVQcm9ncmFtSW5mb30gb3Igb3IgYFVuaWZvcm1CbG9ja1NwZWNgIGFzXG4gKiAgICAgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtfS5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gdW5pZm9ybUJsb2NrSW5mbyBhIGBVbmlmb3JtQmxvY2tJbmZvYCBhcyByZXR1cm5lZCBmcm9tXG4gKiAgICAge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm99LlxuICogQHJldHVybiB7Ym9vbH0gdHJ1ZSBpZiBidWZmZXIgd2FzIGJvdW5kLiBJZiB0aGUgcHJvZ3JhbUluZm8gaGFzIG5vIGJsb2NrIHdpdGggdGhlIHNhbWUgYmxvY2sgbmFtZVxuICogICAgIG5vIGJ1ZmZlciBpcyBib3VuZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBiaW5kVW5pZm9ybUJsb2NrKGdsLCBwcm9ncmFtSW5mbywgdW5pZm9ybUJsb2NrSW5mbykge1xuICBjb25zdCB1bmlmb3JtQmxvY2tTcGVjID0gcHJvZ3JhbUluZm8udW5pZm9ybUJsb2NrU3BlYyB8fCBwcm9ncmFtSW5mbztcbiAgY29uc3QgYmxvY2tTcGVjID0gdW5pZm9ybUJsb2NrU3BlYy5ibG9ja1NwZWNzW3VuaWZvcm1CbG9ja0luZm8ubmFtZV07XG4gIGlmIChibG9ja1NwZWMpIHtcbiAgICBjb25zdCBidWZmZXJCaW5kSW5kZXggPSBibG9ja1NwZWMuaW5kZXg7XG4gICAgZ2wuYmluZEJ1ZmZlclJhbmdlKFVOSUZPUk1fQlVGRkVSLCBidWZmZXJCaW5kSW5kZXgsIHVuaWZvcm1CbG9ja0luZm8uYnVmZmVyLCB1bmlmb3JtQmxvY2tJbmZvLm9mZnNldCB8fCAwLCB1bmlmb3JtQmxvY2tJbmZvLmFycmF5LmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBVcGxvYWRzIHRoZSBjdXJyZW50IHVuaWZvcm0gdmFsdWVzIHRvIHRoZSBjb3JyZXNwb25kaW5nIFdlYkdMQnVmZmVyXG4gKiBhbmQgYmluZHMgdGhhdCBidWZmZXIgdG8gdGhlIHByb2dyYW0ncyBjb3JyZXNwb25kaW5nIGJpbmQgcG9pbnQgZm9yIHRoZSB1bmlmb3JtIGJsb2NrIG9iamVjdC5cbiAqXG4gKiBJZiB5b3UgaGF2ZW4ndCBjaGFuZ2VkIGFueSB2YWx1ZXMgYW5kIHlvdSBvbmx5IG5lZWQgdG8gYmluZCB0aGUgdW5pZm9ybSBibG9jayBvYmplY3RcbiAqIGNhbGwge0BsaW5rIG1vZHVsZTp0d2dsLmJpbmRVbmlmb3JtQmxvY2t9IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMIDIgcmVuZGVyaW5nIGNvbnRleHQuXG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xtb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tTcGVjKX0gcHJvZ3JhbUluZm8gYSBgUHJvZ3JhbUluZm9gXG4gKiAgICAgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99IG9yIG9yIGBVbmlmb3JtQmxvY2tTcGVjYCBhc1xuICogICAgIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja1NwZWNGcm9tUHJvZ3JhbX0uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLlVuaWZvcm1CbG9ja0luZm99IHVuaWZvcm1CbG9ja0luZm8gYSBgVW5pZm9ybUJsb2NrSW5mb2AgYXMgcmV0dXJuZWQgZnJvbVxuICogICAgIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVVbmlmb3JtQmxvY2tJbmZvfS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBzZXRVbmlmb3JtQmxvY2soZ2wsIHByb2dyYW1JbmZvLCB1bmlmb3JtQmxvY2tJbmZvKSB7XG4gIGlmIChiaW5kVW5pZm9ybUJsb2NrKGdsLCBwcm9ncmFtSW5mbywgdW5pZm9ybUJsb2NrSW5mbykpIHtcbiAgICBnbC5idWZmZXJEYXRhKFVOSUZPUk1fQlVGRkVSLCB1bmlmb3JtQmxvY2tJbmZvLmFycmF5LCBEWU5BTUlDX0RSQVcpO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB2YWx1ZXMgb2YgYSB1bmlmb3JtIGJsb2NrIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuVW5pZm9ybUJsb2NrSW5mb30gdW5pZm9ybUJsb2NrSW5mbyBBIFVuaWZvcm1CbG9ja0luZm8gYXMgcmV0dXJuZWQgYnkge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVVuaWZvcm1CbG9ja0luZm99LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IHZhbHVlcyBBIHVuaWZvcm0gbmFtZSB0byB2YWx1ZSBtYXAgd2hlcmUgdGhlIHZhbHVlIGlzIGNvcnJlY3QgZm9yIHRoZSBnaXZlblxuICogICAgdHlwZSBvZiB1bmlmb3JtLiBTbyBmb3IgZXhhbXBsZSBnaXZlbiBhIGJsb2NrIGxpa2VcbiAqXG4gKiAgICAgICB1bmlmb3JtIFNvbWVCbG9jayB7XG4gKiAgICAgICAgIGZsb2F0IHNvbWVGbG9hdDtcbiAqICAgICAgICAgdmVjMiBzb21lVmVjMjtcbiAqICAgICAgICAgdmVjMyBzb21lVmVjM0FycmF5WzJdO1xuICogICAgICAgICBpbnQgc29tZUludDtcbiAqICAgICAgIH1cbiAqXG4gKiAgWW91IGNhbiBzZXQgdGhlIHZhbHVlcyBvZiB0aGUgdW5pZm9ybSBibG9jayB3aXRoXG4gKlxuICogICAgICAgdHdnbC5zZXRCbG9ja1VuaWZvcm1zKHNvbWVCbG9ja0luZm8sIHtcbiAqICAgICAgICAgIHNvbWVGbG9hdDogMTIuMyxcbiAqICAgICAgICAgIHNvbWVWZWMyOiBbMSwgMl0sXG4gKiAgICAgICAgICBzb21lVmVjM0FycmF5OiBbMSwgMiwgMywgNCwgNSwgNl0sXG4gKiAgICAgICAgICBzb21lSW50OiA1LFxuICogICAgICAgfVxuICpcbiAqICBBcnJheXMgY2FuIGJlIEphdmFTY3JpcHQgYXJyYXlzIG9yIHR5cGVkIGFycmF5c1xuICpcbiAqICBZb3UgY2FuIGFsc28gZmlsbCBvdXQgc3RydWN0dXJlIGFuZCBhcnJheSB2YWx1ZXMgZWl0aGVyIHZpYVxuICogIHNob3J0Y3V0LiBFeGFtcGxlXG4gKlxuICogICAgIC8vIC0tIGluIHNoYWRlciAtLVxuICogICAgIHN0cnVjdCBMaWdodCB7XG4gKiAgICAgICBmbG9hdCBpbnRlbnNpdHk7XG4gKiAgICAgICB2ZWM0IGNvbG9yO1xuICogICAgIH07XG4gKiAgICAgdW5pZm9ybSBMaWdodHMge1xuICogICAgICAgTGlnaHQgbGlnaHRzWzJdO1xuICogICAgIH07XG4gKlxuICogICAgIC8vIGluIEphdmFTY3JpcHRcbiAqXG4gKiAgICAgdHdnbC5zZXRCbG9ja1VuaWZvcm1zKHNvbWVCbG9ja0luZm8sIHtcbiAqICAgICAgIGxpZ2h0czogW1xuICogICAgICAgICB7IGludGVuc2l0eTogNS4wLCBjb2xvcjogWzEsIDAsIDAsIDFdIH0sXG4gKiAgICAgICAgIHsgaW50ZW5zaXR5OiAyLjAsIGNvbG9yOiBbMCwgMCwgMSwgMV0gfSxcbiAqICAgICAgIF0sXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIG9yIHRoZSBtb3JlIHRyYWRpdGlvbmFsIHdheVxuICpcbiAqICAgICB0d2dsLnNldEJsb2NrVW5pZm9ybXMoc29tZUJsb2NrSW5mbywge1xuICogICAgICAgXCJsaWdodHNbMF0uaW50ZW5zaXR5XCI6IDUuMCxcbiAqICAgICAgIFwibGlnaHRzWzBdLmNvbG9yXCI6IFsxLCAwLCAwLCAxXSxcbiAqICAgICAgIFwibGlnaHRzWzFdLmludGVuc2l0eVwiOiAyLjAsXG4gKiAgICAgICBcImxpZ2h0c1sxXS5jb2xvclwiOiBbMCwgMCwgMSwgMV0sXG4gKiAgICAgfSk7XG4gKlxuICogICBZb3UgY2FuIGFsc28gc3BlY2lmeSBwYXJ0aWFsIHBhdGhzXG4gKlxuICogICAgIHR3Z2wuc2V0QmxvY2tVbmlmb3Jtcyhzb21lQmxvY2tJbmZvLCB7XG4gKiAgICAgICAnbGlnaHRzWzFdOiB7IGludGVuc2l0eTogNS4wLCBjb2xvcjogWzEsIDAsIDAsIDFdIH0sXG4gKiAgICAgfSk7XG4gKlxuICogICBCdXQgeW91IGNhbiBub3Qgc3BlY2lmeSBsZWFmIGFycmF5IGluZGljZXMuXG4gKlxuICogICoqSU1QT1JUQU5UISoqLCBwYWNraW5nIGluIGEgVW5pZm9ybUJsb2NrIGlzIHVuaW50dWl0aXZlLlxuICogIEZvciBleGFtcGxlIHRoZSBhY3R1YWwgbGF5b3V0IG9mIGBzb21lVmVjM0FycmF5YCBhYm92ZSBpbiBtZW1vcnlcbiAqICBpcyBgMSwgMiwgMywgdW51c2VkLCA0LCA1LCA2LCB1bnVzZWRgLiB0d2dsIHRha2VzIGluIDYgdmFsdWVzXG4gKiAgYXMgc2hvd24gYWJvdXQgYW5kIGNvcGllcyB0aGVtLCBza2lwcGluZyB0aGUgcGFkZGluZy4gVGhpcyBtaWdodFxuICogIGJlIGNvbmZ1c2luZyBpZiB5b3UncmUgYWxyZWFkeSBmYW1pbGlhciB3aXRoIFVuaWZvcm0gYmxvY2tzLlxuICpcbiAqICBJZiB5b3Ugd2FudCB0byBkZWFsIHdpdGggdGhlIHBhZGRpbmcgeW91cnNlbGYgeW91IGNhbiBhY2Nlc3MgdGhlIGFycmF5XG4gKiAgYnVmZmVyIHZpZXdzIGRpcmVjdGx5LiBlZzpcbiAqXG4gKiAgICAgIHNvbWVCbG9ja0luZm8uc29tZVZlYzNBcnJheS5zZXQoWzEsIDIsIDMsIDAsIDQsIDUsIDYsIDBdKTtcbiAqXG4gKiAgQW55IG5hbWUgdGhhdCBkb2Vzbid0IG1hdGNoIHdpbGwgYmUgaWdub3JlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIHNldEJsb2NrVW5pZm9ybXModW5pZm9ybUJsb2NrSW5mbywgdmFsdWVzKSB7XG4gIGNvbnN0IHNldHRlcnMgPSB1bmlmb3JtQmxvY2tJbmZvLnNldHRlcnM7XG4gIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZXMpIHtcbiAgICBjb25zdCBzZXR0ZXIgPSBzZXR0ZXJzW25hbWVdO1xuICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW25hbWVdO1xuICAgICAgc2V0dGVyKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VW5pZm9ybVRyZWUodHJlZSwgdmFsdWVzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZXMpIHtcbiAgICBjb25zdCBwcm9wID0gdHJlZVtuYW1lXTtcbiAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3AodmFsdWVzW25hbWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VW5pZm9ybVRyZWUodHJlZVtuYW1lXSwgdmFsdWVzW25hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgdW5pZm9ybXMgYW5kIGJpbmRzIHJlbGF0ZWQgdGV4dHVyZXMuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSBjcmVhdGVQcm9ncmFtSW5mbyhcbiAqICAgICAgICAgZ2wsIFtcInNvbWUtdnNcIiwgXCJzb21lLWZzXCJdKTtcbiAqXG4gKiAgICAgY29uc3QgdGV4MSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAqICAgICBjb25zdCB0ZXgyID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICpcbiAqICAgICAuLi4gYXNzdW1lIHdlIHNldHVwIHRoZSB0ZXh0dXJlcyB3aXRoIGRhdGEgLi4uXG4gKlxuICogICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICogICAgICAgdV9zb21lU2FtcGxlcjogdGV4MSxcbiAqICAgICAgIHVfc29tZU90aGVyU2FtcGxlcjogdGV4MixcbiAqICAgICAgIHVfc29tZUNvbG9yOiBbMSwwLDAsMV0sXG4gKiAgICAgICB1X3NvbWVQb3NpdGlvbjogWzAsMSwxXSxcbiAqICAgICAgIHVfc29tZU1hdHJpeDogW1xuICogICAgICAgICAxLDAsMCwwLFxuICogICAgICAgICAwLDEsMCwwLFxuICogICAgICAgICAwLDAsMSwwLFxuICogICAgICAgICAwLDAsMCwwLFxuICogICAgICAgXSxcbiAqICAgICB9O1xuICpcbiAqICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICpcbiAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJpbmQgdGhlIHRleHR1cmVzIEFORCBzZXQgdGhlXG4gKiB1bmlmb3Jtcy5cbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgdW5pZm9ybXMpO1xuICpcbiAqIEZvciB0aGUgZXhhbXBsZSBhYm92ZSBpdCBpcyBlcXVpdmFsZW50IHRvXG4gKlxuICogICAgIHZhciB0ZXhVbml0ID0gMDtcbiAqICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4VW5pdCk7XG4gKiAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4MSk7XG4gKiAgICAgZ2wudW5pZm9ybTFpKHVfc29tZVNhbXBsZXJMb2NhdGlvbiwgdGV4VW5pdCsrKTtcbiAqICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4VW5pdCk7XG4gKiAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4Mik7XG4gKiAgICAgZ2wudW5pZm9ybTFpKHVfc29tZVNhbXBsZXJMb2NhdGlvbiwgdGV4VW5pdCsrKTtcbiAqICAgICBnbC51bmlmb3JtNGZ2KHVfc29tZUNvbG9yTG9jYXRpb24sIFsxLCAwLCAwLCAxXSk7XG4gKiAgICAgZ2wudW5pZm9ybTNmdih1X3NvbWVQb3NpdGlvbkxvY2F0aW9uLCBbMCwgMSwgMV0pO1xuICogICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9zb21lTWF0cml4LCBmYWxzZSwgW1xuICogICAgICAgICAxLDAsMCwwLFxuICogICAgICAgICAwLDEsMCwwLFxuICogICAgICAgICAwLDAsMSwwLFxuICogICAgICAgICAwLDAsMCwwLFxuICogICAgICAgXSk7XG4gKlxuICogTm90ZSBpdCBpcyBwZXJmZWN0bHkgcmVhc29uYWJsZSB0byBjYWxsIGBzZXRVbmlmb3Jtc2AgbXVsdGlwbGUgdGltZXMuIEZvciBleGFtcGxlXG4gKlxuICogICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICogICAgICAgdV9zb21lU2FtcGxlcjogdGV4MSxcbiAqICAgICAgIHVfc29tZU90aGVyU2FtcGxlcjogdGV4MixcbiAqICAgICB9O1xuICpcbiAqICAgICBjb25zdCBtb3JlVW5pZm9ybXMge1xuICogICAgICAgdV9zb21lQ29sb3I6IFsxLDAsMCwxXSxcbiAqICAgICAgIHVfc29tZVBvc2l0aW9uOiBbMCwxLDFdLFxuICogICAgICAgdV9zb21lTWF0cml4OiBbXG4gKiAgICAgICAgIDEsMCwwLDAsXG4gKiAgICAgICAgIDAsMSwwLDAsXG4gKiAgICAgICAgIDAsMCwxLDAsXG4gKiAgICAgICAgIDAsMCwwLDAsXG4gKiAgICAgICBdLFxuICogICAgIH07XG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHVuaWZvcm1zKTtcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCBtb3JlVW5pZm9ybXMpO1xuICpcbiAqIFlvdSBjYW4gYWxzbyBhZGQgV2ViR0xTYW1wbGVycyB0byB1bmlmb3JtIHNhbXBsZXJzIGFzIGluXG4gKlxuICogICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICogICAgICAgdV9zb21lU2FtcGxlcjoge1xuICogICAgICAgICB0ZXh0dXJlOiBzb21lV2ViR0xUZXh0dXJlLFxuICogICAgICAgICBzYW1wbGVyOiBzb21lV2ViR0xTYW1wbGVyLFxuICogICAgICAgfSxcbiAqICAgICB9O1xuICpcbiAqIEluIHdoaWNoIGNhc2UgYm90aCB0aGUgc2FtcGxlciBhbmQgdGV4dHVyZSB3aWxsIGJlIGJvdW5kIHRvIHRoZVxuICogc2FtZSB1bml0LlxuICpcbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfE9iamVjdC48c3RyaW5nLCBmdW5jdGlvbj4pfSBzZXR0ZXJzIGEgYFByb2dyYW1JbmZvYCBhcyByZXR1cm5lZCBmcm9tIGBjcmVhdGVQcm9ncmFtSW5mb2Agb3IgdGhlIHNldHRlcnMgcmV0dXJuZWQgZnJvbVxuICogICAgICAgIGBjcmVhdGVVbmlmb3JtU2V0dGVyc2AuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gdmFsdWVzIGFuIG9iamVjdCB3aXRoIHZhbHVlcyBmb3IgdGhlXG4gKiAgICAgICAgdW5pZm9ybXMuXG4gKiAgIFlvdSBjYW4gcGFzcyBtdWx0aXBsZSBvYmplY3RzIGJ5IHB1dHRpbmcgdGhlbSBpbiBhbiBhcnJheSBvciBieSBjYWxsaW5nIHdpdGggbW9yZSBhcmd1bWVudHMuRm9yIGV4YW1wbGVcbiAqXG4gKiAgICAgY29uc3Qgc2hhcmVkVW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X2ZvZ05lYXI6IDEwLFxuICogICAgICAgdV9wcm9qZWN0aW9uOiAuLi5cbiAqICAgICAgIC4uLlxuICogICAgIH07XG4gKlxuICogICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X3dvcmxkOiAuLi5cbiAqICAgICAgIHVfZGlmZnVzZUNvbG9yOiAuLi5cbiAqICAgICB9O1xuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCBzaGFyZWRVbmlmb3JtcywgbG9jYWxVbmlmb3Jtcyk7XG4gKlxuICogICAgIC8vIGlzIHRoZSBzYW1lIGFzXG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIFtzaGFyZWRVbmlmb3JtcywgbG9jYWxVbmlmb3Jtc10pO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICB0d2dsLnNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCBzaGFyZWRVbmlmb3Jtcyk7XG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywgbG9jYWxVbmlmb3Jtc307XG4gKlxuICogICBZb3UgY2FuIGFsc28gZmlsbCBvdXQgc3RydWN0dXJlIGFuZCBhcnJheSB2YWx1ZXMgZWl0aGVyIHZpYVxuICogICBzaG9ydGN1dC4gRXhhbXBsZVxuICpcbiAqICAgICAvLyAtLSBpbiBzaGFkZXIgLS1cbiAqICAgICBzdHJ1Y3QgTGlnaHQge1xuICogICAgICAgZmxvYXQgaW50ZW5zaXR5O1xuICogICAgICAgdmVjNCBjb2xvcjtcbiAqICAgICB9O1xuICogICAgIHVuaWZvcm0gTGlnaHQgbGlnaHRzWzJdO1xuICpcbiAqICAgICAvLyBpbiBKYXZhU2NyaXB0XG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHtcbiAqICAgICAgIGxpZ2h0czogW1xuICogICAgICAgICB7IGludGVuc2l0eTogNS4wLCBjb2xvcjogWzEsIDAsIDAsIDFdIH0sXG4gKiAgICAgICAgIHsgaW50ZW5zaXR5OiAyLjAsIGNvbG9yOiBbMCwgMCwgMSwgMV0gfSxcbiAqICAgICAgIF0sXG4gKiAgICAgfSk7XG4gKlxuICogICBvciB0aGUgbW9yZSB0cmFkaXRpb25hbCB3YXlcbiAqXG4gKiAgICAgdHdnbC5zZXRVbmlmb3Jtcyhwcm9ncmFtSW5mbywge1xuICogICAgICAgXCJsaWdodHNbMF0uaW50ZW5zaXR5XCI6IDUuMCxcbiAqICAgICAgIFwibGlnaHRzWzBdLmNvbG9yXCI6IFsxLCAwLCAwLCAxXSxcbiAqICAgICAgIFwibGlnaHRzWzFdLmludGVuc2l0eVwiOiAyLjAsXG4gKiAgICAgICBcImxpZ2h0c1sxXS5jb2xvclwiOiBbMCwgMCwgMSwgMV0sXG4gKiAgICAgfSk7XG4gKlxuICogICBZb3UgY2FuIGFsc28gc3BlY2lmeSBwYXJ0aWFsIHBhdGhzXG4gKlxuICogICAgIHR3Z2wuc2V0VW5pZm9ybXMocHJvZ3JhbUluZm8sIHtcbiAqICAgICAgICdsaWdodHNbMV06IHsgaW50ZW5zaXR5OiA1LjAsIGNvbG9yOiBbMSwgMCwgMCwgMV0gfSxcbiAqICAgICB9KTtcbiAqXG4gKiAgIEJ1dCB5b3UgY2FuIG5vdCBzcGVjaWZ5IGxlYWYgYXJyYXkgaW5kaWNlc1xuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBzZXRVbmlmb3JtcyhzZXR0ZXJzLCAuLi5hcmdzKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGNvbnN0IGFjdHVhbFNldHRlcnMgPSBzZXR0ZXJzLnVuaWZvcm1TZXR0ZXJzIHx8IHNldHRlcnM7XG4gIGNvbnN0IG51bUFyZ3MgPSBhcmdzLmxlbmd0aDtcbiAgZm9yIChsZXQgYU5keCA9IDA7IGFOZHggPCBudW1BcmdzOyArK2FOZHgpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBhcmdzW2FOZHhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGNvbnN0IG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbnVtVmFsdWVzOyArK2lpKSB7XG4gICAgICAgIHNldFVuaWZvcm1zKGFjdHVhbFNldHRlcnMsIHZhbHVlc1tpaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHNldHRlciA9IGFjdHVhbFNldHRlcnNbbmFtZV07XG4gICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICBzZXR0ZXIodmFsdWVzW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFsaWFzIGZvciBgc2V0VW5pZm9ybXNgXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7KG1vZHVsZTp0d2dsLlByb2dyYW1JbmZvfE9iamVjdC48c3RyaW5nLCBmdW5jdGlvbj4pfSBzZXR0ZXJzIGEgYFByb2dyYW1JbmZvYCBhcyByZXR1cm5lZCBmcm9tIGBjcmVhdGVQcm9ncmFtSW5mb2Agb3IgdGhlIHNldHRlcnMgcmV0dXJuZWQgZnJvbVxuICogICAgICAgIGBjcmVhdGVVbmlmb3JtU2V0dGVyc2AuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gdmFsdWVzIGFuIG9iamVjdCB3aXRoIHZhbHVlcyBmb3IgdGhlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuY29uc3Qgc2V0VW5pZm9ybXNBbmRCaW5kVGV4dHVyZXMgPSBzZXRVbmlmb3JtcztcblxuLyoqXG4gKiBDcmVhdGVzIHNldHRlciBmdW5jdGlvbnMgZm9yIGFsbCBhdHRyaWJ1dGVzIG9mIGEgc2hhZGVyXG4gKiBwcm9ncmFtLiBZb3UgY2FuIHBhc3MgdGhpcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IHRvIHNldCBhbGwgeW91ciBidWZmZXJzIGFuZCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLnNldEF0dHJpYnV0ZXN9IGZvciBleGFtcGxlXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSB0aGUgcHJvZ3JhbSB0byBjcmVhdGUgc2V0dGVycyBmb3IuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fSBhbiBvYmplY3Qgd2l0aCBhIHNldHRlciBmb3IgZWFjaCBhdHRyaWJ1dGUgYnkgbmFtZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9wcm9ncmFtc1xuICovXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzKGdsLCBwcm9ncmFtKSB7XG4gIGNvbnN0IGF0dHJpYlNldHRlcnMgPSB7XG4gIH07XG5cbiAgY29uc3QgbnVtQXR0cmlicyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbnVtQXR0cmliczsgKytpaSkge1xuICAgIGNvbnN0IGF0dHJpYkluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaWkpO1xuICAgIGlmIChpc0J1aWx0SW4oYXR0cmliSW5mbykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYkluZm8ubmFtZSk7XG4gICAgY29uc3QgdHlwZUluZm8gPSBhdHRyVHlwZU1hcFthdHRyaWJJbmZvLnR5cGVdO1xuICAgIGNvbnN0IHNldHRlciA9IHR5cGVJbmZvLnNldHRlcihnbCwgaW5kZXgsIHR5cGVJbmZvKTtcbiAgICBzZXR0ZXIubG9jYXRpb24gPSBpbmRleDtcbiAgICBhdHRyaWJTZXR0ZXJzW2F0dHJpYkluZm8ubmFtZV0gPSBzZXR0ZXI7XG4gIH1cblxuICByZXR1cm4gYXR0cmliU2V0dGVycztcbn1cblxuLyoqXG4gKiBTZXRzIGF0dHJpYnV0ZXMgYW5kIGJpbmRzIGJ1ZmZlcnMgKGRlcHJlY2F0ZWQuLi4gdXNlIHtAbGluayBtb2R1bGU6dHdnbC5zZXRCdWZmZXJzQW5kQXR0cmlidXRlc30pXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhcbiAqICAgICAgICAgZ2wsIFtcInNvbWUtdnNcIiwgXCJzb21lLWZzXCIpO1xuICpcbiAqICAgICBjb25zdCBhdHRyaWJTZXR0ZXJzID0gY3JlYXRlQXR0cmlidXRlU2V0dGVycyhwcm9ncmFtKTtcbiAqXG4gKiAgICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAqICAgICBjb25zdCB0ZXhjb29yZEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICpcbiAqICAgICBjb25zdCBhdHRyaWJzID0ge1xuICogICAgICAgYV9wb3NpdGlvbjoge2J1ZmZlcjogcG9zaXRpb25CdWZmZXIsIG51bUNvbXBvbmVudHM6IDN9LFxuICogICAgICAgYV90ZXhjb29yZDoge2J1ZmZlcjogdGV4Y29vcmRCdWZmZXIsIG51bUNvbXBvbmVudHM6IDJ9LFxuICogICAgIH07XG4gKlxuICogICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gKlxuICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgYmluZCB0aGUgYnVmZmVycyBBTkQgc2V0IHRoZVxuICogYXR0cmlidXRlcy5cbiAqXG4gKiAgICAgc2V0QXR0cmlidXRlcyhhdHRyaWJTZXR0ZXJzLCBhdHRyaWJzKTtcbiAqXG4gKiBQcm9wZXJ0aWVzIG9mIGF0dHJpYnMuIEZvciBlYWNoIGF0dHJpYiB5b3UgY2FuIGFkZFxuICogcHJvcGVydGllczpcbiAqXG4gKiAqICAgdHlwZTogdGhlIHR5cGUgb2YgZGF0YSBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0ID0gZ2wuRkxPQVRcbiAqICogICBub3JtYWxpemU6IHdoZXRoZXIgb3Igbm90IHRvIG5vcm1hbGl6ZSB0aGUgZGF0YS4gRGVmYXVsdCA9IGZhbHNlXG4gKiAqICAgc3RyaWRlOiB0aGUgc3RyaWRlLiBEZWZhdWx0ID0gMFxuICogKiAgIG9mZnNldDogb2Zmc2V0IGludG8gdGhlIGJ1ZmZlci4gRGVmYXVsdCA9IDBcbiAqICogICBkaXZpc29yOiB0aGUgZGl2aXNvciBmb3IgaW5zdGFuY2VzLiBEZWZhdWx0ID0gdW5kZWZpbmVkXG4gKlxuICogRm9yIGV4YW1wbGUgaWYgeW91IGhhZCAzIHZhbHVlIGZsb2F0IHBvc2l0aW9ucywgMiB2YWx1ZVxuICogZmxvYXQgdGV4Y29vcmQgYW5kIDQgdmFsdWUgdWludDggY29sb3JzIHlvdSdkIHNldHVwIHlvdXJcbiAqIGF0dHJpYnMgbGlrZSB0aGlzXG4gKlxuICogICAgIGNvbnN0IGF0dHJpYnMgPSB7XG4gKiAgICAgICBhX3Bvc2l0aW9uOiB7YnVmZmVyOiBwb3NpdGlvbkJ1ZmZlciwgbnVtQ29tcG9uZW50czogM30sXG4gKiAgICAgICBhX3RleGNvb3JkOiB7YnVmZmVyOiB0ZXhjb29yZEJ1ZmZlciwgbnVtQ29tcG9uZW50czogMn0sXG4gKiAgICAgICBhX2NvbG9yOiB7XG4gKiAgICAgICAgIGJ1ZmZlcjogY29sb3JCdWZmZXIsXG4gKiAgICAgICAgIG51bUNvbXBvbmVudHM6IDQsXG4gKiAgICAgICAgIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsXG4gKiAgICAgICAgIG5vcm1hbGl6ZTogdHJ1ZSxcbiAqICAgICAgIH0sXG4gKiAgICAgfTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbj59IHNldHRlcnMgQXR0cmlidXRlIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBtb2R1bGU6dHdnbC5BdHRyaWJJbmZvPn0gYnVmZmVycyBBdHRyaWJJbmZvcyBtYXBwZWQgYnkgYXR0cmlidXRlIG5hbWUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoc2V0dGVycywgYnVmZmVycykge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gYnVmZmVycykge1xuICAgIGNvbnN0IHNldHRlciA9IHNldHRlcnNbbmFtZV07XG4gICAgaWYgKHNldHRlcikge1xuICAgICAgc2V0dGVyKGJ1ZmZlcnNbbmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldHMgYXR0cmlidXRlcyBhbmQgYnVmZmVycyBpbmNsdWRpbmcgdGhlIGBFTEVNRU5UX0FSUkFZX0JVRkZFUmAgaWYgYXBwcm9wcmlhdGVcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IGNyZWF0ZVByb2dyYW1JbmZvKFxuICogICAgICAgICBnbCwgW1wic29tZS12c1wiLCBcInNvbWUtZnNcIik7XG4gKlxuICogICAgIGNvbnN0IGFycmF5cyA9IHtcbiAqICAgICAgIHBvc2l0aW9uOiB7IG51bUNvbXBvbmVudHM6IDMsIGRhdGE6IFswLCAwLCAwLCAxMCwgMCwgMCwgMCwgMTAsIDAsIDEwLCAxMCwgMF0sIH0sXG4gKiAgICAgICB0ZXhjb29yZDogeyBudW1Db21wb25lbnRzOiAyLCBkYXRhOiBbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0sICAgICAgICAgICAgICAgICB9LFxuICogICAgIH07XG4gKlxuICogICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyhnbCwgYXJyYXlzKTtcbiAqXG4gKiAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtSW5mby5wcm9ncmFtKTtcbiAqXG4gKiBUaGlzIHdpbGwgYXV0b21hdGljYWxseSBiaW5kIHRoZSBidWZmZXJzIEFORCBzZXQgdGhlXG4gKiBhdHRyaWJ1dGVzLlxuICpcbiAqICAgICBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuICpcbiAqIEZvciB0aGUgZXhhbXBsZSBhYm92ZSBpdCBpcyBlcXVpdmFsZW50IHRvXG4gKlxuICogICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gKiAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9wb3NpdGlvbkxvY2F0aW9uKTtcbiAqICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfcG9zaXRpb25Mb2NhdGlvbiwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAqICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGV4Y29vcmRCdWZmZXIpO1xuICogICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfdGV4Y29vcmRMb2NhdGlvbik7XG4gKiAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhX3RleGNvb3JkTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm98T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPil9IHNldHRlcnMgQSBgUHJvZ3JhbUluZm9gIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZVByb2dyYW1JbmZvfSBvciBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzfVxuICogQHBhcmFtIHsobW9kdWxlOnR3Z2wuQnVmZmVySW5mb3xtb2R1bGU6dHdnbC5WZXJ0ZXhBcnJheUluZm8pfSBidWZmZXJzIGEgYEJ1ZmZlckluZm9gIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzfS5cbiAqICAgb3IgYSBgVmVydGV4QXJyYXlJbmZvYCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVWZXJ0ZXhBcnJheUluZm99XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuZnVuY3Rpb24gc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMoZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJzKSB7XG4gIGlmIChidWZmZXJzLnZlcnRleEFycmF5T2JqZWN0KSB7XG4gICAgZ2wuYmluZFZlcnRleEFycmF5KGJ1ZmZlcnMudmVydGV4QXJyYXlPYmplY3QpO1xuICB9IGVsc2Uge1xuICAgIHNldEF0dHJpYnV0ZXMocHJvZ3JhbUluZm8uYXR0cmliU2V0dGVycyB8fCBwcm9ncmFtSW5mbywgYnVmZmVycy5hdHRyaWJzKTtcbiAgICBpZiAoYnVmZmVycy5pbmRpY2VzKSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKEVMRU1FTlRfQVJSQVlfQlVGRkVSJDEsIGJ1ZmZlcnMuaW5kaWNlcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvZ3JhbUluZm9cbiAqIEBwcm9wZXJ0eSB7V2ViR0xQcm9ncmFtfSBwcm9ncmFtIEEgc2hhZGVyIHByb2dyYW1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24+fSB1bmlmb3JtU2V0dGVycyBvYmplY3Qgb2Ygc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZVVuaWZvcm1TZXR0ZXJzLFxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbj59IGF0dHJpYlNldHRlcnMgb2JqZWN0IG9mIHNldHRlcnMgYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVBdHRyaWJTZXR0ZXJzLFxuICogQHByb3BlcnR5IHttb2R1bGU6dHdnbC5Vbmlmb3JtQmxvY2tTcGVjfSBbdW5pZm9ybUJsb2NrU3BlY10gYSB1bmlmb3JtIGJsb2NrIHNwZWMgZm9yIG1ha2luZyBVbmlmb3JtQmxvY2tJbmZvcyB3aXRoIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm8gZXRjLi5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgbW9kdWxlOnR3Z2wuVHJhbnNmb3JtRmVlZGJhY2tJbmZvPn0gW3RyYW5zZm9ybUZlZWRiYWNrSW5mb10gaW5mbyBmb3IgdHJhbnNmb3JtIGZlZWRiYWNrc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgUHJvZ3JhbUluZm8gZnJvbSBhbiBleGlzdGluZyBwcm9ncmFtLlxuICpcbiAqIEEgUHJvZ3JhbUluZm8gY29udGFpbnNcbiAqXG4gKiAgICAgcHJvZ3JhbUluZm8gPSB7XG4gKiAgICAgICAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLFxuICogICAgICAgIHVuaWZvcm1TZXR0ZXJzOiBvYmplY3Qgb2Ygc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZVVuaWZvcm1TZXR0ZXJzLFxuICogICAgICAgIGF0dHJpYlNldHRlcnM6IG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmliU2V0dGVycyxcbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqICAgICAgICB0byB1c2UuXG4gKiBAcGFyYW0ge1dlYkdMUHJvZ3JhbX0gcHJvZ3JhbSBhbiBleGlzdGluZyBXZWJHTFByb2dyYW0uXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb30gVGhlIGNyZWF0ZWQgUHJvZ3JhbUluZm8uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvcHJvZ3JhbXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICBjb25zdCB1bmlmb3JtU2V0dGVycyA9IGNyZWF0ZVVuaWZvcm1TZXR0ZXJzKGdsLCBwcm9ncmFtKTtcbiAgY29uc3QgYXR0cmliU2V0dGVycyA9IGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnMoZ2wsIHByb2dyYW0pO1xuICBjb25zdCBwcm9ncmFtSW5mbyA9IHtcbiAgICBwcm9ncmFtLFxuICAgIHVuaWZvcm1TZXR0ZXJzLFxuICAgIGF0dHJpYlNldHRlcnMsXG4gIH07XG5cbiAgaWYgKGlzV2ViR0wyKGdsKSkge1xuICAgIHByb2dyYW1JbmZvLnVuaWZvcm1CbG9ja1NwZWMgPSBjcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgIHByb2dyYW1JbmZvLnRyYW5zZm9ybUZlZWRiYWNrSW5mbyA9IGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrSW5mbyhnbCwgcHJvZ3JhbSk7XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbUluZm87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb2dyYW1JbmZvIGZyb20gMiBzb3VyY2VzLlxuICpcbiAqIEEgUHJvZ3JhbUluZm8gY29udGFpbnNcbiAqXG4gKiAgICAgcHJvZ3JhbUluZm8gPSB7XG4gKiAgICAgICAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLFxuICogICAgICAgIHVuaWZvcm1TZXR0ZXJzOiBvYmplY3Qgb2Ygc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZVVuaWZvcm1TZXR0ZXJzLFxuICogICAgICAgIGF0dHJpYlNldHRlcnM6IG9iamVjdCBvZiBzZXR0ZXJzIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQXR0cmliU2V0dGVycyxcbiAqICAgICB9XG4gKlxuICogTk9URTogVGhlcmUgYXJlIDQgc2lnbmF0dXJlcyBmb3IgdGhpcyBmdW5jdGlvblxuICpcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1JbmZvKGdsLCBbdnMsIGZzXSwgb3B0aW9ucyk7XG4gKiAgICAgdHdnbC5jcmVhdGVQcm9ncmFtSW5mbyhnbCwgW3ZzLCBmc10sIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1JbmZvKGdsLCBbdnMsIGZzXSwgb3B0X2F0dHJpYnMsIG9wdF9lcnJGdW5jKTtcbiAqICAgICB0d2dsLmNyZWF0ZVByb2dyYW1JbmZvKGdsLCBbdnMsIGZzXSwgb3B0X2F0dHJpYnMsIG9wdF9sb2NhdGlvbnMsIG9wdF9lcnJGdW5jKTtcbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogICAgICAgIHRvIHVzZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHNoYWRlclNvdXJjZXMgQXJyYXkgb2Ygc291cmNlcyBmb3IgdGhlXG4gKiAgICAgICAgc2hhZGVycyBvciBpZHMuIFRoZSBmaXJzdCBpcyBhc3N1bWVkIHRvIGJlIHRoZSB2ZXJ0ZXggc2hhZGVyLFxuICogICAgICAgIHRoZSBzZWNvbmQgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbU9wdGlvbnN8c3RyaW5nW118bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9hdHRyaWJzXSBPcHRpb25zIGZvciB0aGUgcHJvZ3JhbSBvciBhbiBhcnJheSBvZiBhdHRyaWJzIG5hbWVzIG9yIGFuIGVycm9yIGNhbGxiYWNrLiBMb2NhdGlvbnMgd2lsbCBiZSBhc3NpZ25lZCBieSBpbmRleCBpZiBub3QgcGFzc2VkIGluXG4gKiBAcGFyYW0ge251bWJlcltdfSBbb3B0X2xvY2F0aW9uc3xtb2R1bGU6dHdnbC5FcnJvckNhbGxiYWNrXSBUaGUgbG9jYXRpb25zIGZvciB0aGUuIEEgcGFyYWxsZWwgYXJyYXkgdG8gb3B0X2F0dHJpYnMgbGV0dGluZyB5b3UgYXNzaWduIGxvY2F0aW9ucyBvciBhbiBlcnJvciBjYWxsYmFjay5cbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRXJyb3JDYWxsYmFja30gW29wdF9lcnJvckNhbGxiYWNrXSBjYWxsYmFjayBmb3IgZXJyb3JzLiBCeSBkZWZhdWx0IGl0IGp1c3QgcHJpbnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlXG4gKiAgICAgICAgb24gZXJyb3IuIElmIHlvdSB3YW50IHNvbWV0aGluZyBlbHNlIHBhc3MgYW4gY2FsbGJhY2suIEl0J3MgcGFzc2VkIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mbz99IFRoZSBjcmVhdGVkIFByb2dyYW1JbmZvIG9yIG51bGwgaWYgaXQgZmFpbGVkIHRvIGxpbmsgb3IgY29tcGlsZVxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3Byb2dyYW1zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1JbmZvKFxuICAgIGdsLCBzaGFkZXJTb3VyY2VzLCBvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spIHtcbiAgY29uc3QgcHJvZ09wdGlvbnMgPSBnZXRQcm9ncmFtT3B0aW9ucyhvcHRfYXR0cmlicywgb3B0X2xvY2F0aW9ucywgb3B0X2Vycm9yQ2FsbGJhY2spO1xuICBsZXQgZ29vZCA9IHRydWU7XG4gIHNoYWRlclNvdXJjZXMgPSBzaGFkZXJTb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAvLyBMZXRzIGFzc3VtZSBpZiB0aGVyZSBpcyBubyBcXG4gaXQncyBhbiBpZFxuICAgIGlmIChzb3VyY2UuaW5kZXhPZihcIlxcblwiKSA8IDApIHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGdldEVsZW1lbnRCeUlkKHNvdXJjZSk7XG4gICAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICBwcm9nT3B0aW9ucy5lcnJvckNhbGxiYWNrKFwibm8gZWxlbWVudCB3aXRoIGlkOiBcIiArIHNvdXJjZSk7XG4gICAgICAgIGdvb2QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZSA9IHNjcmlwdC50ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9KTtcbiAgaWYgKCFnb29kKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyhnbCwgc2hhZGVyU291cmNlcywgcHJvZ09wdGlvbnMpO1xuICBpZiAoIXByb2dyYW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG59XG5cbnZhciBwcm9ncmFtcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzOiBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzLFxuICBjcmVhdGVQcm9ncmFtOiBjcmVhdGVQcm9ncmFtLFxuICBjcmVhdGVQcm9ncmFtRnJvbVNjcmlwdHM6IGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyxcbiAgY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzOiBjcmVhdGVQcm9ncmFtRnJvbVNvdXJjZXMsXG4gIGNyZWF0ZVByb2dyYW1JbmZvOiBjcmVhdGVQcm9ncmFtSW5mbyxcbiAgY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbTogY3JlYXRlUHJvZ3JhbUluZm9Gcm9tUHJvZ3JhbSxcbiAgY3JlYXRlVW5pZm9ybVNldHRlcnM6IGNyZWF0ZVVuaWZvcm1TZXR0ZXJzLFxuICBjcmVhdGVVbmlmb3JtQmxvY2tTcGVjRnJvbVByb2dyYW06IGNyZWF0ZVVuaWZvcm1CbG9ja1NwZWNGcm9tUHJvZ3JhbSxcbiAgY3JlYXRlVW5pZm9ybUJsb2NrSW5mb0Zyb21Qcm9ncmFtOiBjcmVhdGVVbmlmb3JtQmxvY2tJbmZvRnJvbVByb2dyYW0sXG4gIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm86IGNyZWF0ZVVuaWZvcm1CbG9ja0luZm8sXG4gIGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrOiBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayxcbiAgY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2tJbmZvOiBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8sXG4gIGJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm86IGJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8sXG4gIHNldEF0dHJpYnV0ZXM6IHNldEF0dHJpYnV0ZXMsXG4gIHNldEJ1ZmZlcnNBbmRBdHRyaWJ1dGVzOiBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcyxcbiAgc2V0VW5pZm9ybXM6IHNldFVuaWZvcm1zLFxuICBzZXRVbmlmb3Jtc0FuZEJpbmRUZXh0dXJlczogc2V0VW5pZm9ybXNBbmRCaW5kVGV4dHVyZXMsXG4gIHNldFVuaWZvcm1CbG9jazogc2V0VW5pZm9ybUJsb2NrLFxuICBzZXRCbG9ja1VuaWZvcm1zOiBzZXRCbG9ja1VuaWZvcm1zLFxuICBiaW5kVW5pZm9ybUJsb2NrOiBiaW5kVW5pZm9ybUJsb2NrXG59KTtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBUUklBTkdMRVMgICAgICAgICAgICAgICAgICAgICAgPSAweDAwMDQ7XG5jb25zdCBVTlNJR05FRF9TSE9SVCQzICAgICAgICAgICAgICAgICA9IDB4MTQwMztcblxuLyoqXG4gKiBEcmF3aW5nIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgdGhleSBhcmUgYXZhaWxhYmxlIGF0IGJvdGggYHR3Z2wuZHJhd2AgYW5kIGB0d2dsYFxuICogaXRzZWxmXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6dHdnbH0gZm9yIGNvcmUgZnVuY3Rpb25zXG4gKlxuICogQG1vZHVsZSB0d2dsL2RyYXdcbiAqL1xuXG4vKipcbiAqIENhbGxzIGBnbC5kcmF3RWxlbWVudHNgIG9yIGBnbC5kcmF3QXJyYXlzYCwgd2hpY2hldmVyIGlzIGFwcHJvcHJpYXRlXG4gKlxuICogbm9ybWFsbHkgeW91J2QgY2FsbCBgZ2wuZHJhd0VsZW1lbnRzYCBvciBgZ2wuZHJhd0FycmF5c2AgeW91cnNlbGZcbiAqIGJ1dCBjYWxsaW5nIHRoaXMgbWVhbnMgaWYgeW91IHN3aXRjaCBmcm9tIGluZGV4ZWQgZGF0YSB0byBub24taW5kZXhlZFxuICogZGF0YSB5b3UgZG9uJ3QgaGF2ZSB0byByZW1lbWJlciB0byB1cGRhdGUgeW91ciBkcmF3IGNhbGwuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIEEgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0geyhtb2R1bGU6dHdnbC5CdWZmZXJJbmZvfG1vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mbyl9IGJ1ZmZlckluZm8gQSBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUJ1ZmZlckluZm9Gcm9tQXJyYXlzfSBvclxuICogICBhIFZlcnRleEFycmF5SW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVWZXJ0ZXhBcnJheUluZm99XG4gKiBAcGFyYW0ge251bWJlcn0gW3R5cGVdIGVnIChnbC5UUklBTkdMRVMsIGdsLkxJTkVTLCBnbC5QT0lOVFMsIGdsLlRSSUFOR0xFX1NUUklQLCAuLi4pLiBEZWZhdWx0cyB0byBgZ2wuVFJJQU5HTEVTYFxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gQW4gb3B0aW9uYWwgY291bnQuIERlZmF1bHRzIHRvIGJ1ZmZlckluZm8ubnVtRWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0XSBBbiBvcHRpb25hbCBvZmZzZXQuIERlZmF1bHRzIHRvIDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2luc3RhbmNlQ291bnRdIEFuIG9wdGlvbmFsIGluc3RhbmNlQ291bnQuIGlmIHNldCB0aGVuIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCBvciBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkYCB3aWxsIGJlIGNhbGxlZFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2RyYXdcbiAqL1xuZnVuY3Rpb24gZHJhd0J1ZmZlckluZm8oZ2wsIGJ1ZmZlckluZm8sIHR5cGUsIGNvdW50LCBvZmZzZXQsIGluc3RhbmNlQ291bnQpIHtcbiAgdHlwZSA9IHR5cGUgPT09IHVuZGVmaW5lZCA/IFRSSUFOR0xFUyA6IHR5cGU7XG4gIGNvbnN0IGluZGljZXMgPSBidWZmZXJJbmZvLmluZGljZXM7XG4gIGNvbnN0IGVsZW1lbnRUeXBlID0gYnVmZmVySW5mby5lbGVtZW50VHlwZTtcbiAgY29uc3QgbnVtRWxlbWVudHMgPSBjb3VudCA9PT0gdW5kZWZpbmVkID8gYnVmZmVySW5mby5udW1FbGVtZW50cyA6IGNvdW50O1xuICBvZmZzZXQgPSBvZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAgOiBvZmZzZXQ7XG4gIGlmIChlbGVtZW50VHlwZSB8fCBpbmRpY2VzKSB7XG4gICAgaWYgKGluc3RhbmNlQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkKHR5cGUsIG51bUVsZW1lbnRzLCBlbGVtZW50VHlwZSA9PT0gdW5kZWZpbmVkID8gVU5TSUdORURfU0hPUlQkMyA6IGJ1ZmZlckluZm8uZWxlbWVudFR5cGUsIG9mZnNldCwgaW5zdGFuY2VDb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBudW1FbGVtZW50cywgZWxlbWVudFR5cGUgPT09IHVuZGVmaW5lZCA/IFVOU0lHTkVEX1NIT1JUJDMgOiBidWZmZXJJbmZvLmVsZW1lbnRUeXBlLCBvZmZzZXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5zdGFuY2VDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKHR5cGUsIG9mZnNldCwgbnVtRWxlbWVudHMsIGluc3RhbmNlQ291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5kcmF3QXJyYXlzKHR5cGUsIG9mZnNldCwgbnVtRWxlbWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgRHJhd09iamVjdCBpcyB1c2VmdWwgZm9yIHB1dHRpbmcgb2JqZWN0cyBpbiB0byBhbiBhcnJheSBhbmQgcGFzc2luZyB0aGVtIHRvIHtAbGluayBtb2R1bGU6dHdnbC5kcmF3T2JqZWN0TGlzdH0uXG4gKlxuICogWW91IG5lZWQgZWl0aGVyIGEgYEJ1ZmZlckluZm9gIG9yIGEgYFZlcnRleEFycmF5SW5mb2AuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRHJhd09iamVjdFxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWN0aXZlXSB3aGV0aGVyIG9yIG5vdCB0byBkcmF3LiBEZWZhdWx0ID0gYHRydWVgIChtdXN0IGJlIGBmYWxzZWAgdG8gYmUgbm90IHRydWUpLiBJbiBvdGhlciB3b3JkcyBgdW5kZWZpbmVkYCA9IGB0cnVlYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0eXBlXSB0eXBlIHRvIGRyYXcgZWcuIGBnbC5UUklBTkdMRVNgLCBgZ2wuTElORVNgLCBldGMuLi5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnR3Z2wuUHJvZ3JhbUluZm99IHByb2dyYW1JbmZvIEEgUHJvZ3JhbUluZm8gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99XG4gKiBAcHJvcGVydHkge21vZHVsZTp0d2dsLkJ1ZmZlckluZm99IFtidWZmZXJJbmZvXSBBIEJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXN9XG4gKiBAcHJvcGVydHkge21vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mb30gW3ZlcnRleEFycmF5SW5mb10gQSBWZXJ0ZXhBcnJheUluZm8gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlVmVydGV4QXJyYXlJbmZvfVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCA/Pn0gdW5pZm9ybXMgVGhlIHZhbHVlcyBmb3IgdGhlIHVuaWZvcm1zLlxuICogICBZb3UgY2FuIHBhc3MgbXVsdGlwbGUgb2JqZWN0cyBieSBwdXR0aW5nIHRoZW0gaW4gYW4gYXJyYXkuIEZvciBleGFtcGxlXG4gKlxuICogICAgIHZhciBzaGFyZWRVbmlmb3JtcyA9IHtcbiAqICAgICAgIHVfZm9nTmVhcjogMTAsXG4gKiAgICAgICB1X3Byb2plY3Rpb246IC4uLlxuICogICAgICAgLi4uXG4gKiAgICAgfTtcbiAqXG4gKiAgICAgdmFyIGxvY2FsVW5pZm9ybXMgPSB7XG4gKiAgICAgICB1X3dvcmxkOiAuLi5cbiAqICAgICAgIHVfZGlmZnVzZUNvbG9yOiAuLi5cbiAqICAgICB9O1xuICpcbiAqICAgICB2YXIgZHJhd09iaiA9IHtcbiAqICAgICAgIC4uLlxuICogICAgICAgdW5pZm9ybXM6IFtzaGFyZWRVbmlmb3JtcywgbG9jYWxVbmlmb3Jtc10sXG4gKiAgICAgfTtcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldF0gdGhlIG9mZnNldCB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC4gRGVmYXVsdHMgdG8gMC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY291bnRdIHRoZSBjb3VudCB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC4gRGVmYXVsdHMgdG8gYnVmZmVySW5mby5udW1FbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW5zdGFuY2VDb3VudF0gdGhlIG51bWJlciBvZiBpbnN0YW5jZXMuIERlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogRHJhd3MgYSBsaXN0IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHtEcmF3T2JqZWN0W119IG9iamVjdHNUb0RyYXcgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBkcmF3LlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2RyYXdcbiAqL1xuZnVuY3Rpb24gZHJhd09iamVjdExpc3QoZ2wsIG9iamVjdHNUb0RyYXcpIHtcbiAgbGV0IGxhc3RVc2VkUHJvZ3JhbUluZm8gPSBudWxsO1xuICBsZXQgbGFzdFVzZWRCdWZmZXJJbmZvID0gbnVsbDtcblxuICBvYmplY3RzVG9EcmF3LmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5hY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPSBvYmplY3QucHJvZ3JhbUluZm87XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IG9iamVjdC52ZXJ0ZXhBcnJheUluZm8gfHwgb2JqZWN0LmJ1ZmZlckluZm87XG4gICAgbGV0IGJpbmRCdWZmZXJzID0gZmFsc2U7XG4gICAgY29uc3QgdHlwZSA9IG9iamVjdC50eXBlID09PSB1bmRlZmluZWQgPyBUUklBTkdMRVMgOiBvYmplY3QudHlwZTtcblxuICAgIGlmIChwcm9ncmFtSW5mbyAhPT0gbGFzdFVzZWRQcm9ncmFtSW5mbykge1xuICAgICAgbGFzdFVzZWRQcm9ncmFtSW5mbyA9IHByb2dyYW1JbmZvO1xuICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtSW5mby5wcm9ncmFtKTtcblxuICAgICAgLy8gV2UgaGF2ZSB0byByZWJpbmQgYnVmZmVycyB3aGVuIGNoYW5naW5nIHByb2dyYW1zIGJlY2F1c2Ugd2VcbiAgICAgIC8vIG9ubHkgYmluZCBidWZmZXJzIHRoZSBwcm9ncmFtIHVzZXMuIFNvIGlmIDIgcHJvZ3JhbXMgdXNlIHRoZSBzYW1lXG4gICAgICAvLyBidWZmZXJJbmZvIGJ1dCB0aGUgMXN0IG9uZSB1c2VzIG9ubHkgcG9zaXRpb25zIHRoZSB3aGVuIHRoZVxuICAgICAgLy8gd2Ugc3dpdGNoIHRvIHRoZSAybmQgb25lIHNvbWUgb2YgdGhlIGF0dHJpYnV0ZXMgd2lsbCBub3QgYmUgb24uXG4gICAgICBiaW5kQnVmZmVycyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgYWxsIHRoZSBuZWVkZWQgYXR0cmlidXRlcy5cbiAgICBpZiAoYmluZEJ1ZmZlcnMgfHwgYnVmZmVySW5mbyAhPT0gbGFzdFVzZWRCdWZmZXJJbmZvKSB7XG4gICAgICBpZiAobGFzdFVzZWRCdWZmZXJJbmZvICYmIGxhc3RVc2VkQnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCAmJiAhYnVmZmVySW5mby52ZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICB9XG4gICAgICBsYXN0VXNlZEJ1ZmZlckluZm8gPSBidWZmZXJJbmZvO1xuICAgICAgc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXMoZ2wsIHByb2dyYW1JbmZvLCBidWZmZXJJbmZvKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIHVuaWZvcm1zLlxuICAgIHNldFVuaWZvcm1zKHByb2dyYW1JbmZvLCBvYmplY3QudW5pZm9ybXMpO1xuXG4gICAgLy8gRHJhd1xuICAgIGRyYXdCdWZmZXJJbmZvKGdsLCBidWZmZXJJbmZvLCB0eXBlLCBvYmplY3QuY291bnQsIG9iamVjdC5vZmZzZXQsIG9iamVjdC5pbnN0YW5jZUNvdW50KTtcbiAgfSk7XG5cbiAgaWYgKGxhc3RVc2VkQnVmZmVySW5mbyAmJiBsYXN0VXNlZEJ1ZmZlckluZm8udmVydGV4QXJyYXlPYmplY3QpIHtcbiAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gIH1cbn1cblxudmFyIGRyYXcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZHJhd0J1ZmZlckluZm86IGRyYXdCdWZmZXJJbmZvLFxuICBkcmF3T2JqZWN0TGlzdDogZHJhd09iamVjdExpc3Rcbn0pO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTkgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IEZSQU1FQlVGRkVSICAgICAgICAgICAgICAgICAgICA9IDB4OGQ0MDtcbmNvbnN0IFJFTkRFUkJVRkZFUiAgICAgICAgICAgICAgICAgICA9IDB4OGQ0MTtcbmNvbnN0IFRFWFRVUkVfMkQkMiAgICAgICAgICAgICAgICAgICAgID0gMHgwZGUxO1xuXG5jb25zdCBVTlNJR05FRF9CWVRFJDMgICAgICAgICAgICAgICAgICA9IDB4MTQwMTtcblxuLyogUGl4ZWxGb3JtYXQgKi9cbmNvbnN0IERFUFRIX0NPTVBPTkVOVCQxICAgICAgICAgICAgICAgID0gMHgxOTAyO1xuY29uc3QgUkdCQSQxICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE5MDg7XG5jb25zdCBERVBUSF9DT01QT05FTlQyNCQxICAgICAgICAgICAgICA9IDB4ODFhNjtcbmNvbnN0IERFUFRIX0NPTVBPTkVOVDMyRiQxICAgICAgICAgICAgID0gMHg4Y2FjO1xuY29uc3QgREVQVEgyNF9TVEVOQ0lMOCQxICAgICAgICAgICAgICAgPSAweDg4ZjA7XG5jb25zdCBERVBUSDMyRl9TVEVOQ0lMOCQxICAgICAgICAgICAgICA9IDB4OGNhZDtcblxuLyogRnJhbWVidWZmZXIgT2JqZWN0LiAqL1xuY29uc3QgUkdCQTQkMSAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDgwNTY7XG5jb25zdCBSR0I1X0ExJDEgICAgICAgICAgICAgICAgICAgICAgICA9IDB4ODA1NztcbmNvbnN0IFJHQjU2NSQxICAgICAgICAgICAgICAgICAgICAgICAgID0gMHg4RDYyO1xuY29uc3QgREVQVEhfQ09NUE9ORU5UMTYkMSAgICAgICAgICAgICAgPSAweDgxQTU7XG5jb25zdCBTVEVOQ0lMX0lOREVYICAgICAgICAgICAgICAgICAgPSAweDE5MDE7XG5jb25zdCBTVEVOQ0lMX0lOREVYOCAgICAgICAgICAgICAgICAgPSAweDhENDg7XG5jb25zdCBERVBUSF9TVEVOQ0lMJDEgICAgICAgICAgICAgICAgICA9IDB4ODRGOTtcbmNvbnN0IENPTE9SX0FUVEFDSE1FTlQwICAgICAgICAgICAgICA9IDB4OENFMDtcbmNvbnN0IERFUFRIX0FUVEFDSE1FTlQgICAgICAgICAgICAgICA9IDB4OEQwMDtcbmNvbnN0IFNURU5DSUxfQVRUQUNITUVOVCAgICAgICAgICAgICA9IDB4OEQyMDtcbmNvbnN0IERFUFRIX1NURU5DSUxfQVRUQUNITUVOVCAgICAgICA9IDB4ODIxQTtcblxuLyogVGV4dHVyZVdyYXBNb2RlICovXG5jb25zdCBDTEFNUF9UT19FREdFJDEgICAgICAgICAgICAgICAgICA9IDB4ODEyRjtcblxuLyogVGV4dHVyZU1hZ0ZpbHRlciAqL1xuY29uc3QgTElORUFSJDEgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDI2MDE7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZm9yIGEgZnJhbWVidWZmZXIgYXR0YWNobWVudC5cbiAqXG4gKiBOb3RlOiBGb3IgYSBgZm9ybWF0YCB0aGF0IGlzIGEgdGV4dHVyZSBpbmNsdWRlIGFsbCB0aGUgdGV4dHVyZVxuICogb3B0aW9ucyBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5UZXh0dXJlT3B0aW9uc30gZm9yIGV4YW1wbGVcbiAqIGBtaW5gLCBgbWFnYCwgYGNsYW1wYCwgZXRjLi4uIE5vdGUgdGhhdCB1bmxpa2Uge0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfVxuICogYGF1dG9gIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIGF0dGFjaG1lbnQgdGV4dHVyZXMgYnV0IGBtaW5gIGFuZCBgbWFnYCBkZWZhdWx0XG4gKiB0byBgZ2wuTElORUFSYCBhbmQgYHdyYXBgIGRlZmF1bHRzIHRvIGBDTEFNUF9UT19FREdFYFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF0dGFjaG1lbnRPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2F0dGFjaG1lbnRQb2ludF0gVGhlIGF0dGFjaG1lbnQgcG9pbnQuIERlZmF1bHRzXG4gKiAgIHRvIGBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIG5keGAgdW5sZXNzIHR5cGUgaXMgYSBkZXB0aCBvciBzdGVuY2lsIHR5cGVcbiAqICAgdGhlbiBpdCdzIGdsLkRFUFRIX0FUVEFDSE1FTlQgb3IgYGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVGAgZGVwZW5kaW5nXG4gKiAgIG9uIHRoZSBmb3JtYXQgb3IgYXR0YWNobWVudCB0eXBlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmb3JtYXRdIFRoZSBmb3JtYXQuIElmIG9uZSBvZiBgZ2wuUkdCQTRgLFxuICogICBgZ2wuUkdCNTY1YCwgYGdsLlJHQjVfQTFgLCBgZ2wuREVQVEhfQ09NUE9ORU5UMTZgLFxuICogICBgZ2wuU1RFTkNJTF9JTkRFWDhgIG9yIGBnbC5ERVBUSF9TVEVOQ0lMYCB0aGVuIHdpbGwgY3JlYXRlIGFcbiAqICAgcmVuZGVyYnVmZmVyLiBPdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSB0ZXh0dXJlLiBEZWZhdWx0ID0gYGdsLlJHQkFgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3R5cGVdIFRoZSB0eXBlLiBVc2VkIGZvciB0ZXh0dXJlLiBEZWZhdWx0ID0gYGdsLlVOU0lHTkVEX0JZVEVgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRdIFRoZSB0ZXh0dXJlIHRhcmdldCBmb3IgYGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEYC5cbiAqICAgRGVmYXVsdHMgdG8gYGdsLlRFWFRVUkVfMkRgLiBTZXQgdG8gYXBwcm9wcmlhdGUgZmFjZSBmb3IgY3ViZSBtYXBzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZXZlbF0gbGV2ZWwgZm9yIGBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRGAuIERlZmF1bHRzIHRvIDAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xheWVyXSBsYXllciBmb3IgYGdsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyYC4gRGVmYXVsdHMgdG8gdW5kZWZpbmVkLlxuICogICBJZiBzZXQgdGhlbiBgZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXJgIGlzIGNhbGxlZCwgaWYgbm90IHRoZW4gYGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEYFxuICogQHByb3BlcnR5IHsoV2ViR0xSZW5kZXJidWZmZXIgfCBXZWJHTFRleHR1cmUpfSBbYXR0YWNobWVudF0gQW4gZXhpc3RpbmcgcmVuZGVyYnVmZmVyIG9yIHRleHR1cmUuXG4gKiAgICBJZiBwcm92aWRlZCB3aWxsIGF0dGFjaCB0aGlzIE9iamVjdC4gVGhpcyBhbGxvd3MgeW91IHRvIHNoYXJlXG4gKiAgICBhdHRhY2htZW50cyBhY3Jvc3MgZnJhbWVidWZmZXJzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKiBAbWl4ZXMgbW9kdWxlOnR3Z2wuVGV4dHVyZU9wdGlvbnNcbiAqL1xuXG5jb25zdCBkZWZhdWx0QXR0YWNobWVudHMgPSBbXG4gIHsgZm9ybWF0OiBSR0JBJDEsIHR5cGU6IFVOU0lHTkVEX0JZVEUkMywgbWluOiBMSU5FQVIkMSwgd3JhcDogQ0xBTVBfVE9fRURHRSQxLCB9LFxuICB7IGZvcm1hdDogREVQVEhfU1RFTkNJTCQxLCB9LFxuXTtcblxuY29uc3QgYXR0YWNobWVudHNCeUZvcm1hdCA9IHt9O1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSF9TVEVOQ0lMJDFdID0gREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtTVEVOQ0lMX0lOREVYXSA9IFNURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbU1RFTkNJTF9JTkRFWDhdID0gU1RFTkNJTF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSF9DT01QT05FTlQkMV0gPSBERVBUSF9BVFRBQ0hNRU5UO1xuYXR0YWNobWVudHNCeUZvcm1hdFtERVBUSF9DT01QT05FTlQxNiQxXSA9IERFUFRIX0FUVEFDSE1FTlQ7XG5hdHRhY2htZW50c0J5Rm9ybWF0W0RFUFRIX0NPTVBPTkVOVDI0JDFdID0gREVQVEhfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEhfQ09NUE9ORU5UMzJGJDFdID0gREVQVEhfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEgyNF9TVEVOQ0lMOCQxXSA9IERFUFRIX1NURU5DSUxfQVRUQUNITUVOVDtcbmF0dGFjaG1lbnRzQnlGb3JtYXRbREVQVEgzMkZfU1RFTkNJTDgkMV0gPSBERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ7XG5cbmZ1bmN0aW9uIGdldEF0dGFjaG1lbnRQb2ludEZvckZvcm1hdChmb3JtYXQsIGludGVybmFsRm9ybWF0KSB7XG4gIHJldHVybiBhdHRhY2htZW50c0J5Rm9ybWF0W2Zvcm1hdF0gfHwgYXR0YWNobWVudHNCeUZvcm1hdFtpbnRlcm5hbEZvcm1hdF07XG59XG5cbmNvbnN0IHJlbmRlcmJ1ZmZlckZvcm1hdHMgPSB7fTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbUkdCQTQkMV0gPSB0cnVlO1xucmVuZGVyYnVmZmVyRm9ybWF0c1tSR0I1X0ExJDFdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbUkdCNTY1JDFdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbREVQVEhfU1RFTkNJTCQxXSA9IHRydWU7XG5yZW5kZXJidWZmZXJGb3JtYXRzW0RFUFRIX0NPTVBPTkVOVDE2JDFdID0gdHJ1ZTtcbnJlbmRlcmJ1ZmZlckZvcm1hdHNbU1RFTkNJTF9JTkRFWF0gPSB0cnVlO1xucmVuZGVyYnVmZmVyRm9ybWF0c1tTVEVOQ0lMX0lOREVYOF0gPSB0cnVlO1xuXG5mdW5jdGlvbiBpc1JlbmRlcmJ1ZmZlckZvcm1hdChmb3JtYXQpIHtcbiAgcmV0dXJuIHJlbmRlcmJ1ZmZlckZvcm1hdHNbZm9ybWF0XTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGcmFtZWJ1ZmZlckluZm9cbiAqIEBwcm9wZXJ0eSB7V2ViR0xGcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXIgVGhlIFdlYkdMRnJhbWVidWZmZXIgZm9yIHRoaXMgZnJhbWVidWZmZXJJbmZvXG4gKiBAcHJvcGVydHkge0FycmF5LjwoV2ViR0xSZW5kZXJidWZmZXIgfCBXZWJHTFRleHR1cmUpPn0gYXR0YWNobWVudHMgVGhlIGNyZWF0ZWQgYXR0YWNobWVudHMgaW4gdGhlIHNhbWUgb3JkZXIgYXMgcGFzc2VkIGluIHRvIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm99LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgZnJhbWVidWZmZXIgYW5kIGl0cyBhdHRhY2htZW50c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCBUaGUgd2lkdGggb2YgdGhlIGZyYW1lYnVmZmVyIGFuZCBpdHMgYXR0YWNobWVudHNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyYW1lYnVmZmVyIGFuZCBhdHRhY2htZW50cy5cbiAqXG4gKiBUaGlzIHJldHVybnMgYSB7QGxpbmsgbW9kdWxlOnR3Z2wuRnJhbWVidWZmZXJJbmZvfSBiZWNhdXNlIGl0IG5lZWRzIHRvIHJldHVybiB0aGUgYXR0YWNobWVudHMgYXMgd2VsbCBhcyB0aGUgZnJhbWVidWZmZXIuXG4gKlxuICogVGhlIHNpbXBsZXN0IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0JBL1VOU0lHTkVEX0JZVEUgdGV4dHVyZSBhbmQgREVQVEhfU1RFTkNJTCByZW5kZXJidWZmZXJcbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCk7XG4gKlxuICogTW9yZSBjb21wbGV4IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0I1NjUgcmVuZGVyYnVmZmVyIGFuZCBhIFNURU5DSUxfSU5ERVg4IHJlbmRlcmJ1ZmZlclxuICogICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gW1xuICogICAgICAgeyBmb3JtYXQ6IFJHQjU2NSwgbWFnOiBORUFSRVNUIH0sXG4gKiAgICAgICB7IGZvcm1hdDogU1RFTkNJTF9JTkRFWDggfSxcbiAqICAgICBdXG4gKiAgICAgY29uc3QgZmJpID0gdHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm8oZ2wsIGF0dGFjaG1lbnRzKTtcbiAqXG4gKiBQYXNzaW5nIGluIGEgc3BlY2lmaWMgc2l6ZVxuICpcbiAqICAgICBjb25zdCB3aWR0aCA9IDI1NjtcbiAqICAgICBjb25zdCBoZWlnaHQgPSAyNTY7XG4gKiAgICAgY29uc3QgZmJpID0gdHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm8oZ2wsIGF0dGFjaG1lbnRzLCB3aWR0aCwgaGVpZ2h0KTtcbiAqXG4gKiAqKk5vdGUhISoqIEl0IGlzIHVwIHRvIHlvdSB0byBjaGVjayBpZiB0aGUgZnJhbWVidWZmZXIgaXMgcmVuZGVyYWJsZSBieSBjYWxsaW5nIGBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzYC5cbiAqIFtXZWJHTDEgb25seSBndWFyYW50ZWVzIDMgY29tYmluYXRpb25zIG9mIGF0dGFjaG1lbnRzIHdvcmtdKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzL2xhdGVzdC8xLjAvIzYuNikuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQXR0YWNobWVudE9wdGlvbnNbXX0gW2F0dGFjaG1lbnRzXSB3aGljaCBhdHRhY2htZW50cyB0byBjcmVhdGUuIElmIG5vdCBwcm92aWRlZCB0aGUgZGVmYXVsdCBpcyBhIGZyYW1lYnVmZmVyIHdpdGggYW5cbiAqICAgIGBSR0JBYCwgYFVOU0lHTkVEX0JZVEVgIHRleHR1cmUgYENPTE9SX0FUVEFDSE1FTlQwYCBhbmQgYSBgREVQVEhfU1RFTkNJTGAgcmVuZGVyYnVmZmVyIGBERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlRgLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gdGhlIHdpZHRoIGZvciB0aGUgYXR0YWNobWVudHMuIERlZmF1bHQgPSBzaXplIG9mIGRyYXdpbmdCdWZmZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSB0aGUgaGVpZ2h0IGZvciB0aGUgYXR0YWNobWVudHMuIERlZmF1bHQgPSBzaXplIG9mIGRyYXdpbmdCdWZmZXJcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLkZyYW1lYnVmZmVySW5mb30gdGhlIGZyYW1lYnVmZmVyIGFuZCBhdHRhY2htZW50cy5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbC9mcmFtZWJ1ZmZlcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXJJbmZvKGdsLCBhdHRhY2htZW50cywgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCB0YXJnZXQgPSBGUkFNRUJVRkZFUjtcbiAgY29uc3QgZmIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICBnbC5iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmYik7XG4gIHdpZHRoICA9IHdpZHRoICB8fCBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gIGhlaWdodCA9IGhlaWdodCB8fCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICBhdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzIHx8IGRlZmF1bHRBdHRhY2htZW50cztcbiAgbGV0IGNvbG9yQXR0YWNobWVudENvdW50ID0gMDtcbiAgY29uc3QgZnJhbWVidWZmZXJJbmZvID0ge1xuICAgIGZyYW1lYnVmZmVyOiBmYixcbiAgICBhdHRhY2htZW50czogW10sXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICB9O1xuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGF0dGFjaG1lbnRPcHRpb25zKSB7XG4gICAgbGV0IGF0dGFjaG1lbnQgPSBhdHRhY2htZW50T3B0aW9ucy5hdHRhY2htZW50O1xuICAgIGNvbnN0IGZvcm1hdCA9IGF0dGFjaG1lbnRPcHRpb25zLmZvcm1hdDtcbiAgICBsZXQgYXR0YWNobWVudFBvaW50ID0gYXR0YWNobWVudE9wdGlvbnMuYXR0YWNobWVudFBvaW50IHx8IGdldEF0dGFjaG1lbnRQb2ludEZvckZvcm1hdChmb3JtYXQsIGF0dGFjaG1lbnRPcHRpb25zLmludGVybmFsRm9ybWF0KTtcbiAgICBpZiAoIWF0dGFjaG1lbnRQb2ludCkge1xuICAgICAgYXR0YWNobWVudFBvaW50ID0gQ09MT1JfQVRUQUNITUVOVDAgKyBjb2xvckF0dGFjaG1lbnRDb3VudCsrO1xuICAgIH1cbiAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgIGlmIChpc1JlbmRlcmJ1ZmZlckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIGF0dGFjaG1lbnQgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihSRU5ERVJCVUZGRVIsIGF0dGFjaG1lbnQpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKFJFTkRFUkJVRkZFUiwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0YWNobWVudE9wdGlvbnMpO1xuICAgICAgICB0ZXh0dXJlT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0ZXh0dXJlT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmICh0ZXh0dXJlT3B0aW9ucy5hdXRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ZXh0dXJlT3B0aW9ucy5hdXRvID0gZmFsc2U7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMubWluID0gdGV4dHVyZU9wdGlvbnMubWluIHx8IHRleHR1cmVPcHRpb25zLm1pbk1hZyB8fCBMSU5FQVIkMTtcbiAgICAgICAgICB0ZXh0dXJlT3B0aW9ucy5tYWcgPSB0ZXh0dXJlT3B0aW9ucy5tYWcgfHwgdGV4dHVyZU9wdGlvbnMubWluTWFnIHx8IExJTkVBUiQxO1xuICAgICAgICAgIHRleHR1cmVPcHRpb25zLndyYXBTID0gdGV4dHVyZU9wdGlvbnMud3JhcFMgfHwgdGV4dHVyZU9wdGlvbnMud3JhcCB8fCBDTEFNUF9UT19FREdFJDE7XG4gICAgICAgICAgdGV4dHVyZU9wdGlvbnMud3JhcFQgPSB0ZXh0dXJlT3B0aW9ucy53cmFwVCB8fCB0ZXh0dXJlT3B0aW9ucy53cmFwIHx8IENMQU1QX1RPX0VER0UkMTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2htZW50ID0gY3JlYXRlVGV4dHVyZShnbCwgdGV4dHVyZU9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZW5kZXJidWZmZXIoZ2wsIGF0dGFjaG1lbnQpKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0YXJnZXQsIGF0dGFjaG1lbnRQb2ludCwgUkVOREVSQlVGRkVSLCBhdHRhY2htZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dHVyZShnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIGlmIChhdHRhY2htZW50T3B0aW9ucy5sYXllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBhdHRhY2htZW50UG9pbnQsXG4gICAgICAgICAgYXR0YWNobWVudCxcbiAgICAgICAgICBhdHRhY2htZW50T3B0aW9ucy5sZXZlbCB8fCAwLFxuICAgICAgICAgIGF0dGFjaG1lbnRPcHRpb25zLmxheWVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgYXR0YWNobWVudFBvaW50LFxuICAgICAgICAgICAgYXR0YWNobWVudE9wdGlvbnMudGFyZ2V0IHx8IFRFWFRVUkVfMkQkMixcbiAgICAgICAgICAgIGF0dGFjaG1lbnQsXG4gICAgICAgICAgICBhdHRhY2htZW50T3B0aW9ucy5sZXZlbCB8fCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGF0dGFjaG1lbnQgdHlwZScpO1xuICAgIH1cbiAgICBmcmFtZWJ1ZmZlckluZm8uYXR0YWNobWVudHMucHVzaChhdHRhY2htZW50KTtcbiAgfSk7XG4gIHJldHVybiBmcmFtZWJ1ZmZlckluZm87XG59XG5cbi8qKlxuICogUmVzaXplcyB0aGUgYXR0YWNobWVudHMgb2YgYSBmcmFtZWJ1ZmZlci5cbiAqXG4gKiBZb3UgbmVlZCB0byBwYXNzIGluIHRoZSBzYW1lIGBhdHRhY2htZW50c2AgYXMgeW91IHBhc3NlZCBpbiB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlRnJhbWVidWZmZXJJbmZvfVxuICogYmVjYXVzZSBUV0dMIGhhcyBubyBpZGVhIHRoZSBmb3JtYXQvdHlwZSBvZiBlYWNoIGF0dGFjaG1lbnQuXG4gKlxuICogVGhlIHNpbXBsZXN0IHVzYWdlXG4gKlxuICogICAgIC8vIGNyZWF0ZSBhbiBSR0JBL1VOU0lHTkVEX0JZVEUgdGV4dHVyZSBhbmQgREVQVEhfU1RFTkNJTCByZW5kZXJidWZmZXJcbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCk7XG4gKlxuICogICAgIC4uLlxuICpcbiAqICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gKiAgICAgICBpZiAodHdnbC5yZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplKGdsLmNhbnZhcykpIHtcbiAqICAgICAgICAgLy8gcmVzaXplIHRoZSBhdHRhY2htZW50c1xuICogICAgICAgICB0d2dsLnJlc2l6ZUZyYW1lYnVmZmVySW5mbyhnbCwgZmJpKTtcbiAqICAgICAgIH1cbiAqXG4gKiBNb3JlIGNvbXBsZXggdXNhZ2VcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGFuIFJHQjU2NSByZW5kZXJidWZmZXIgYW5kIGEgU1RFTkNJTF9JTkRFWDggcmVuZGVyYnVmZmVyXG4gKiAgICAgY29uc3QgYXR0YWNobWVudHMgPSBbXG4gKiAgICAgICB7IGZvcm1hdDogUkdCNTY1LCBtYWc6IE5FQVJFU1QgfSxcbiAqICAgICAgIHsgZm9ybWF0OiBTVEVOQ0lMX0lOREVYOCB9LFxuICogICAgIF1cbiAqICAgICBjb25zdCBmYmkgPSB0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mbyhnbCwgYXR0YWNobWVudHMpO1xuICpcbiAqICAgICAuLi5cbiAqXG4gKiAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICogICAgICAgaWYgKHR3Z2wucmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZShnbC5jYW52YXMpKSB7XG4gKiAgICAgICAgIC8vIHJlc2l6ZSB0aGUgYXR0YWNobWVudHMgdG8gbWF0Y2hcbiAqICAgICAgICAgdHdnbC5yZXNpemVGcmFtZWJ1ZmZlckluZm8oZ2wsIGZiaSwgYXR0YWNobWVudHMpO1xuICogICAgICAgfVxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkZyYW1lYnVmZmVySW5mb30gZnJhbWVidWZmZXJJbmZvIGEgZnJhbWVidWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkF0dGFjaG1lbnRPcHRpb25zW119IFthdHRhY2htZW50c10gdGhlIHNhbWUgYXR0YWNobWVudHMgb3B0aW9ucyBhcyBwYXNzZWQgdG8ge0BsaW5rIG1vZHVsZTp0d2dsLmNyZWF0ZUZyYW1lYnVmZmVySW5mb30uXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSB0aGUgd2lkdGggZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIHRoZSBoZWlnaHQgZm9yIHRoZSBhdHRhY2htZW50cy4gRGVmYXVsdCA9IHNpemUgb2YgZHJhd2luZ0J1ZmZlclxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5mdW5jdGlvbiByZXNpemVGcmFtZWJ1ZmZlckluZm8oZ2wsIGZyYW1lYnVmZmVySW5mbywgYXR0YWNobWVudHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgd2lkdGggID0gd2lkdGggIHx8IGdsLmRyYXdpbmdCdWZmZXJXaWR0aDtcbiAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XG4gIGZyYW1lYnVmZmVySW5mby53aWR0aCA9IHdpZHRoO1xuICBmcmFtZWJ1ZmZlckluZm8uaGVpZ2h0ID0gaGVpZ2h0O1xuICBhdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzIHx8IGRlZmF1bHRBdHRhY2htZW50cztcbiAgYXR0YWNobWVudHMuZm9yRWFjaChmdW5jdGlvbihhdHRhY2htZW50T3B0aW9ucywgbmR4KSB7XG4gICAgY29uc3QgYXR0YWNobWVudCA9IGZyYW1lYnVmZmVySW5mby5hdHRhY2htZW50c1tuZHhdO1xuICAgIGNvbnN0IGZvcm1hdCA9IGF0dGFjaG1lbnRPcHRpb25zLmZvcm1hdDtcbiAgICBpZiAoaXNSZW5kZXJidWZmZXIoZ2wsIGF0dGFjaG1lbnQpKSB7XG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKFJFTkRFUkJVRkZFUiwgYXR0YWNobWVudCk7XG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKFJFTkRFUkJVRkZFUiwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dHVyZShnbCwgYXR0YWNobWVudCkpIHtcbiAgICAgIHJlc2l6ZVRleHR1cmUoZ2wsIGF0dGFjaG1lbnQsIGF0dGFjaG1lbnRPcHRpb25zLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGF0dGFjaG1lbnQgdHlwZScpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQmluZHMgYSBmcmFtZWJ1ZmZlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcHJldHR5IG11Y2ggc29sZWx5IGV4aXN0cyBiZWNhdXNlIEkgc3BlbnQgaG91cnNcbiAqIHRyeWluZyB0byBmaWd1cmUgb3V0IHdoeSBzb21ldGhpbmcgSSB3cm90ZSB3YXNuJ3Qgd29ya2luZyBvbmx5XG4gKiB0byByZWFsaXplIEkgZm9yZ2V0IHRvIHNldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy5cbiAqIE15IGhvcGUgaXMgdGhpcyBmdW5jdGlvbiB3aWxsIGZpeCB0aGF0LlxuICpcbiAqIEl0IGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzXG4gKlxuICogICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgc29tZUZyYW1lYnVmZmVySW5mby5mcmFtZWJ1ZmZlcik7XG4gKiAgICAgZ2wudmlld3BvcnQoMCwgMCwgc29tZUZyYW1lYnVmZmVySW5mby53aWR0aCwgc29tZUZyYW1lYnVmZmVySW5mby5oZWlnaHQpO1xuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp0d2dsLkZyYW1lYnVmZmVySW5mb3xudWxsfSBbZnJhbWVidWZmZXJJbmZvXSBhIGZyYW1lYnVmZmVySW5mbyBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6dHdnbC5jcmVhdGVGcmFtZWJ1ZmZlckluZm99LlxuICogICBJZiBmYWxzeSB3aWxsIGJpbmQgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGFyZ2V0XSBUaGUgdGFyZ2V0LiBJZiBub3QgcGFzc2VkIGBnbC5GUkFNRUJVRkZFUmAgd2lsbCBiZSB1c2VkLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL2ZyYW1lYnVmZmVyc1xuICovXG5cbmZ1bmN0aW9uIGJpbmRGcmFtZWJ1ZmZlckluZm8oZ2wsIGZyYW1lYnVmZmVySW5mbywgdGFyZ2V0KSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCBGUkFNRUJVRkZFUjtcbiAgaWYgKGZyYW1lYnVmZmVySW5mbykge1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZyYW1lYnVmZmVySW5mby5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZnJhbWVidWZmZXJJbmZvLndpZHRoLCBmcmFtZWJ1ZmZlckluZm8uaGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBudWxsKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICB9XG59XG5cbnZhciBmcmFtZWJ1ZmZlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYmluZEZyYW1lYnVmZmVySW5mbzogYmluZEZyYW1lYnVmZmVySW5mbyxcbiAgY3JlYXRlRnJhbWVidWZmZXJJbmZvOiBjcmVhdGVGcmFtZWJ1ZmZlckluZm8sXG4gIHJlc2l6ZUZyYW1lYnVmZmVySW5mbzogcmVzaXplRnJhbWVidWZmZXJJbmZvXG59KTtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIHZlcnRleCBhcnJheSBvYmplY3QgcmVsYXRlZCBmdW5jdGlvbnNcbiAqXG4gKiBZb3Ugc2hvdWxkIGdlbmVyYWxseSBub3QgbmVlZCB0byB1c2UgdGhlc2UgZnVuY3Rpb25zLiBUaGV5IGFyZSBwcm92aWRlZFxuICogZm9yIHRob3NlIGNhc2VzIHdoZXJlIHlvdSdyZSBkb2luZyBzb21ldGhpbmcgb3V0IG9mIHRoZSBvcmRpbmFyeVxuICogYW5kIHlvdSBuZWVkIGxvd2VyIGxldmVsIGFjY2Vzcy5cbiAqXG4gKiBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB0aGV5IGFyZSBhdmFpbGFibGUgYXQgYm90aCBgdHdnbC5hdHRyaWJ1dGVzYCBhbmQgYHR3Z2xgXG4gKiBpdHNlbGZcbiAqXG4gKiBTZWUge0BsaW5rIG1vZHVsZTp0d2dsfSBmb3IgY29yZSBmdW5jdGlvbnNcbiAqXG4gKiBAbW9kdWxlIHR3Z2wvdmVydGV4QXJyYXlzXG4gKi9cblxuY29uc3QgRUxFTUVOVF9BUlJBWV9CVUZGRVIkMiAgICAgICAgICAgPSAweDg4OTM7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVmVydGV4QXJyYXlJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtRWxlbWVudHMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBwYXNzIHRvIGBnbC5kcmF3QXJyYXlzYCBvciBgZ2wuZHJhd0VsZW1lbnRzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZWxlbWVudFR5cGVdIFRoZSB0eXBlIG9mIGluZGljZXMgYFVOU0lHTkVEX0JZVEVgLCBgVU5TSUdORURfU0hPUlRgIGV0Yy4uXG4gKiBAcHJvcGVydHkge1dlYkdMVmVydGV4QXJyYXlPYmplY3R9IFt2ZXJ0ZXhBcnJheU9iamVjdF0gYSB2ZXJ0ZXggYXJyYXkgb2JqZWN0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBWZXJ0ZXhBcnJheUluZm8gZnJvbSBhIEJ1ZmZlckluZm8gYW5kIG9uZSBvciBtb3JlIFByb2dyYW1JbmZvc1xuICpcbiAqIFRoaXMgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZXN9IGFuZCB0b1xuICoge0BsaW5rIG1vZHVsZTp0d2dsOmRyYXdCdWZmZXJJbmZvfS5cbiAqXG4gKiA+ICoqSU1QT1JUQU5UOioqIFZlcnRleCBBcnJheSBPYmplY3RzIGFyZSAqKm5vdCoqIGEgZGlyZWN0IGFuYWxvZyBmb3IgYSBCdWZmZXJJbmZvLiBWZXJ0ZXggQXJyYXkgT2JqZWN0c1xuICogICBhc3NpZ24gYnVmZmVycyB0byBzcGVjaWZpYyBhdHRyaWJ1dGVzIGF0IGNyZWF0aW9uIHRpbWUuIFRoYXQgbWVhbnMgdGhleSBjYW4gb25seSBiZSB1c2VkIHdpdGggcHJvZ3JhbXNcbiAqICAgd2hvJ3MgYXR0cmlidXRlcyB1c2UgdGhlIHNhbWUgYXR0cmlidXRlIGxvY2F0aW9ucyBmb3IgdGhlIHNhbWUgcHVycG9zZXMuXG4gKlxuICogPiBCaW5kIHlvdXIgYXR0cmlidXRlIGxvY2F0aW9ucyBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byB7QGxpbmsgbW9kdWxlOnR3Z2wuY3JlYXRlUHJvZ3JhbUluZm99XG4gKiAgIG9yIHVzZSBXZWJHTCAyJ3MgR0xTTCBFUyAzJ3MgYGxheW91dChsb2NhdGlvbiA9IDxudW0+KWAgdG8gbWFrZSBzdXJlIGxvY2F0aW9ucyBtYXRjaC5cbiAqXG4gKiBhbHNvXG4gKlxuICogPiAqKklNUE9SVEFOVDoqKiBBZnRlciBjYWxsaW5nIHR3Z2wuc2V0QnVmZmVyc0FuZEF0dHJpYnV0ZSB3aXRoIGEgQnVmZmVySW5mbyB0aGF0IHVzZXMgYSBWZXJ0ZXggQXJyYXkgT2JqZWN0XG4gKiAgIHRoYXQgVmVydGV4IEFycmF5IE9iamVjdCB3aWxsIGJlIGJvdW5kLiBUaGF0IG1lYW5zICoqQU5ZIE1BTklQVUxBVElPTiBPRiBFTEVNRU5UX0FSUkFZX0JVRkZFUiBvciBBVFRSSUJVVEVTKipcbiAqICAgd2lsbCBhZmZlY3QgdGhlIFZlcnRleCBBcnJheSBPYmplY3Qgc3RhdGUuXG4gKlxuICogPiBDYWxsIGBnbC5iaW5kVmVydGV4QXJyYXkobnVsbClgIHRvIGdldCBiYWNrIG1hbmlwdWxhdGluZyB0aGUgZ2xvYmFsIGF0dHJpYnV0ZXMgYW5kIEVMRU1FTlRfQVJSQVlfQlVGRkVSLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQHBhcmFtIHttb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb3xtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb1tdfSBwcm9ncmFtSW5mbyBhIHByb2dyYW1JbmZvIG9yIGFycmF5IG9mIHByb2dyYW1JbmZvc1xuICogQHBhcmFtIHttb2R1bGU6dHdnbC5CdWZmZXJJbmZvfSBidWZmZXJJbmZvIEJ1ZmZlckluZm8gYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cyBldGMuLi5cbiAqXG4gKiAgICBZb3UgbmVlZCB0byBtYWtlIHN1cmUgZXZlcnkgYXR0cmlidXRlIHRoYXQgd2lsbCBiZSB1c2VkIGlzIGJvdW5kLiBTbyBmb3IgZXhhbXBsZSBhc3N1bWUgc2hhZGVyIDFcbiAqICAgIHVzZXMgYXR0cmlidXRlcyBBLCBCLCBDIGFuZCBzaGFkZXIgMiB1c2VzIGF0dHJpYnV0ZXMgQSwgQiwgRC4gSWYgeW91IG9ubHkgcGFzcyBpbiB0aGUgcHJvZ3JhbUluZm9cbiAqICAgIGZvciBzaGFkZXIgMSB0aGVuIG9ubHkgYXR0cmlidXRlcyBBLCBCLCBhbmQgQyB3aWxsIGhhdmUgdGhlaXIgYXR0cmlidXRlcyBzZXQgYmVjYXVzZSBUV0dMIGRvZXNuJ3RcbiAqICAgIG5vdyBhdHRyaWJ1dGUgRCdzIGxvY2F0aW9uLlxuICpcbiAqICAgIFNvLCB5b3UgY2FuIHBhc3MgaW4gYm90aCBzaGFkZXIgMSBhbmQgc2hhZGVyIDIncyBwcm9ncmFtSW5mb1xuICpcbiAqIEByZXR1cm4ge21vZHVsZTp0d2dsLlZlcnRleEFycmF5SW5mb30gVGhlIGNyZWF0ZWQgVmVydGV4QXJyYXlJbmZvXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ZlcnRleEFycmF5c1xuICovXG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhBcnJheUluZm8oZ2wsIHByb2dyYW1JbmZvcywgYnVmZmVySW5mbykge1xuICBjb25zdCB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcbiAgaWYgKCFwcm9ncmFtSW5mb3MubGVuZ3RoKSB7XG4gICAgcHJvZ3JhbUluZm9zID0gW3Byb2dyYW1JbmZvc107XG4gIH1cbiAgcHJvZ3JhbUluZm9zLmZvckVhY2goZnVuY3Rpb24ocHJvZ3JhbUluZm8pIHtcbiAgICBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pO1xuICB9KTtcbiAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICByZXR1cm4ge1xuICAgIG51bUVsZW1lbnRzOiBidWZmZXJJbmZvLm51bUVsZW1lbnRzLFxuICAgIGVsZW1lbnRUeXBlOiBidWZmZXJJbmZvLmVsZW1lbnRUeXBlLFxuICAgIHZlcnRleEFycmF5T2JqZWN0OiB2YW8sXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHZlcnRleCBhcnJheSBvYmplY3QgYW5kIHRoZW4gc2V0cyB0aGUgYXR0cmlidXRlcyBvbiBpdFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPn0gc2V0dGVycyBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp0d2dsLkF0dHJpYkluZm8+fSBhdHRyaWJzIEF0dHJpYkluZm9zIG1hcHBlZCBieSBhdHRyaWJ1dGUgbmFtZS5cbiAqIEBwYXJhbSB7V2ViR0xCdWZmZXJ9IFtpbmRpY2VzXSBhbiBvcHRpb25hbCBFTEVNRU5UX0FSUkFZX0JVRkZFUiBvZiBpbmRpY2VzXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2wvdmVydGV4QXJyYXlzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZBT0FuZFNldEF0dHJpYnV0ZXMoZ2wsIHNldHRlcnMsIGF0dHJpYnMsIGluZGljZXMpIHtcbiAgY29uc3QgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gIHNldEF0dHJpYnV0ZXMoc2V0dGVycywgYXR0cmlicyk7XG4gIGlmIChpbmRpY2VzKSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihFTEVNRU5UX0FSUkFZX0JVRkZFUiQyLCBpbmRpY2VzKTtcbiAgfVxuICAvLyBXZSB1bmJpbmQgdGhpcyBiZWNhdXNlIG90aGVyd2lzZSBhbnkgY2hhbmdlIHRvIEVMRU1FTlRfQVJSQVlfQlVGRkVSXG4gIC8vIGxpa2Ugd2hlbiBjcmVhdGluZyBidWZmZXJzIGZvciBvdGhlciBzdHVmZiB3aWxsIG1lc3MgdXAgdGhpcyBWQU8ncyBiaW5kaW5nXG4gIGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgcmV0dXJuIHZhbztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdmVydGV4IGFycmF5IG9iamVjdCBhbmQgdGhlbiBzZXRzIHRoZSBhdHRyaWJ1dGVzXG4gKiBvbiBpdFxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gKiAgICAgICAgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+fCBtb2R1bGU6dHdnbC5Qcm9ncmFtSW5mb30gcHJvZ3JhbUluZm8gYXMgcmV0dXJuZWQgZnJvbSBjcmVhdGVQcm9ncmFtSW5mbyBvciBBdHRyaWJ1dGUgc2V0dGVycyBhcyByZXR1cm5lZCBmcm9tIGNyZWF0ZUF0dHJpYnV0ZVNldHRlcnNcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuQnVmZmVySW5mb30gYnVmZmVySW5mbyBCdWZmZXJJbmZvIGFzIHJldHVybmVkIGZyb20gY3JlYXRlQnVmZmVySW5mb0Zyb21BcnJheXMgZXRjLi4uXG4gKiBAcGFyYW0ge1dlYkdMQnVmZmVyfSBbaW5kaWNlc10gYW4gb3B0aW9uYWwgRUxFTUVOVF9BUlJBWV9CVUZGRVIgb2YgaW5kaWNlc1xuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsL3ZlcnRleEFycmF5c1xuICovXG5mdW5jdGlvbiBjcmVhdGVWQU9Gcm9tQnVmZmVySW5mbyhnbCwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8pIHtcbiAgcmV0dXJuIGNyZWF0ZVZBT0FuZFNldEF0dHJpYnV0ZXMoZ2wsIHByb2dyYW1JbmZvLmF0dHJpYlNldHRlcnMgfHwgcHJvZ3JhbUluZm8sIGJ1ZmZlckluZm8uYXR0cmlicywgYnVmZmVySW5mby5pbmRpY2VzKTtcbn1cblxudmFyIHZlcnRleEFycmF5cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGVWZXJ0ZXhBcnJheUluZm86IGNyZWF0ZVZlcnRleEFycmF5SW5mbyxcbiAgY3JlYXRlVkFPQW5kU2V0QXR0cmlidXRlczogY3JlYXRlVkFPQW5kU2V0QXR0cmlidXRlcyxcbiAgY3JlYXRlVkFPRnJvbUJ1ZmZlckluZm86IGNyZWF0ZVZBT0Zyb21CdWZmZXJJbmZvXG59KTtcblxuLypcbiAqIENvcHlyaWdodCAyMDE5IEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuY29uc3QgZGVmYXVsdHMkMiA9IHtcbiAgYWRkRXh0ZW5zaW9uc1RvQ29udGV4dDogdHJ1ZSxcbn07XG5cbi8qKlxuICogVmFyaW91cyBkZWZhdWx0IHNldHRpbmdzIGZvciB0d2dsLlxuICpcbiAqIE5vdGU6IFlvdSBjYW4gY2FsbCB0aGlzIGFueSBudW1iZXIgb2YgdGltZXMuIEV4YW1wbGU6XG4gKlxuICogICAgIHR3Z2wuc2V0RGVmYXVsdHMoeyB0ZXh0dXJlQ29sb3I6IFsxLCAwLCAwLCAxXSB9KTtcbiAqICAgICB0d2dsLnNldERlZmF1bHRzKHsgYXR0cmliUHJlZml4OiAnYV8nIH0pO1xuICpcbiAqIGlzIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiAgICAgdHdnbC5zZXREZWZhdWx0cyh7XG4gKiAgICAgICB0ZXh0dXJlQ29sb3I6IFsxLCAwLCAwLCAxXSxcbiAqICAgICAgIGF0dHJpYlByZWZpeDogJ2FfJyxcbiAqICAgICB9KTtcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJQcmVmaXhdIFRoZSBwcmVmaXggdG8gc3RpY2sgb24gYXR0cmlidXRlc1xuICpcbiAqICAgV2hlbiB3cml0aW5nIHNoYWRlcnMgSSBwcmVmZXIgdG8gbmFtZSBhdHRyaWJ1dGVzIHdpdGggYGFfYCwgdW5pZm9ybXMgd2l0aCBgdV9gIGFuZCB2YXJ5aW5ncyB3aXRoIGB2X2BcbiAqICAgYXMgaXQgbWFrZXMgaXQgY2xlYXIgd2hlcmUgdGhleSBjYW1lIGZyb20uIEJ1dCwgd2hlbiBidWlsZGluZyBnZW9tZXRyeSBJIHByZWZlciB1c2luZyB1bi1wcmVmaXhlZCBuYW1lcy5cbiAqXG4gKiAgIEluIG90aGVyIHdvcmRzIEknbGwgY3JlYXRlIGFycmF5cyBvZiBnZW9tZXRyeSBsaWtlIHRoaXNcbiAqXG4gKiAgICAgICBjb25zdCBhcnJheXMgPSB7XG4gKiAgICAgICAgIHBvc2l0aW9uOiAuLi5cbiAqICAgICAgICAgbm9ybWFsOiAuLi5cbiAqICAgICAgICAgdGV4Y29vcmQ6IC4uLlxuICogICAgICAgfTtcbiAqXG4gKiAgIEJ1dCBuZWVkIHRob3NlIG1hcHBlZCB0byBhdHRyaWJ1dGVzIGFuZCBteSBhdHRyaWJ1dGVzIHN0YXJ0IHdpdGggYGFfYC5cbiAqXG4gKiAgIERlZmF1bHQ6IGBcIlwiYFxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IFt0ZXh0dXJlQ29sb3JdIEFycmF5IG9mIDQgdmFsdWVzIGluIHRoZSByYW5nZSAwIHRvIDFcbiAqXG4gKiAgIFRoZSBkZWZhdWx0IHRleHR1cmUgY29sb3IgaXMgdXNlZCB3aGVuIGxvYWRpbmcgdGV4dHVyZXMgZnJvbVxuICogICB1cmxzLiBCZWNhdXNlIHRoZSBVUkwgd2lsbCBiZSBsb2FkZWQgYXN5bmMgd2UnZCBsaWtlIHRvIGJlXG4gKiAgIGFibGUgdG8gdXNlIHRoZSB0ZXh0dXJlIGltbWVkaWF0ZWx5LiBCeSBwdXR0aW5nIGEgMXgxIHBpeGVsXG4gKiAgIGNvbG9yIGluIHRoZSB0ZXh0dXJlIHdlIGNhbiBzdGFydCB1c2luZyB0aGUgdGV4dHVyZSBiZWZvcmVcbiAqICAgdGhlIFVSTCBoYXMgbG9hZGVkLlxuICpcbiAqICAgRGVmYXVsdDogYFswLjUsIDAuNzUsIDEsIDFdYFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3Jvc3NPcmlnaW5dXG4gKlxuICogICBJZiBub3QgdW5kZWZpbmVkIHNldHMgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBvbiBpbWFnZXNcbiAqICAgdGhhdCB0d2dsIGNyZWF0ZXMgd2hlbiBkb3dubG9hZGluZyBpbWFnZXMgZm9yIHRleHR1cmVzLlxuICpcbiAqICAgQWxzbyBzZWUge0BsaW5rIG1vZHVsZTp0d2dsLlRleHR1cmVPcHRpb25zfS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2x9IFthZGRFeHRlbnNpb25zVG9Db250ZXh0XVxuICpcbiAqICAgSWYgdHJ1ZSwgdGhlbiwgd2hlbiB0d2dsIHdpbGwgdHJ5IHRvIGFkZCBhbnkgc3VwcG9ydGVkIFdlYkdMIGV4dGVuc2lvbnNcbiAqICAgZGlyZWN0bHkgdG8gdGhlIGNvbnRleHQgdW5kZXIgdGhlaXIgbm9ybWFsIEdMIG5hbWVzLiBGb3IgZXhhbXBsZVxuICogICBpZiBBTkdMRV9pbnN0YW5jZXNfYXJyYXlzIGV4aXN0cyB0aGVuIHR3Z2wgd291bGQgZW5hYmxlIGl0LFxuICogICBhZGQgdGhlIGZ1bmN0aW9ucyBgdmVydGV4QXR0cmliRGl2aXNvcmAsIGBkcmF3QXJyYXlzSW5zdGFuY2VkYCxcbiAqICAgYGRyYXdFbGVtZW50c0luc3RhbmNlZGAsIGFuZCB0aGUgY29uc3RhbnQgYFZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUmBcbiAqICAgdG8gdGhlIGBXZWJHTFJlbmRlcmluZ0NvbnRleHRgLlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5cbi8qKlxuICogU2V0cyB2YXJpb3VzIGRlZmF1bHRzIGZvciB0d2dsLlxuICpcbiAqIEluIHRoZSBpbnRlcmVzdCBvZiB0ZXJzZW5lc3Mgd2hpY2ggaXMga2luZCBvZiB0aGUgcG9pbnRcbiAqIG9mIHR3Z2wgSSd2ZSBpbnRlZ3JhdGVkIGEgZmV3IG9mIHRoZSBvbGRlciBmdW5jdGlvbnMgaGVyZVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnR3Z2wuRGVmYXVsdHN9IG5ld0RlZmF1bHRzIFRoZSBkZWZhdWx0IHNldHRpbmdzLlxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRzJDIobmV3RGVmYXVsdHMpIHtcbiAgY29weUV4aXN0aW5nUHJvcGVydGllcyhuZXdEZWZhdWx0cywgZGVmYXVsdHMkMik7XG4gIHNldERlZmF1bHRzKG5ld0RlZmF1bHRzKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgc2V0RGVmYXVsdHMkMShuZXdEZWZhdWx0cyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59XG5cbmNvbnN0IHByZWZpeFJFID0gL14oLio/KV8vO1xuZnVuY3Rpb24gYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBleHRlbnNpb25OYW1lKSB7XG4gIGdsRW51bVRvU3RyaW5nKGdsLCAwKTtcbiAgY29uc3QgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpO1xuICBpZiAoZXh0KSB7XG4gICAgY29uc3QgZW51bXMgPSB7fTtcbiAgICBjb25zdCBmblN1ZmZpeCA9IHByZWZpeFJFLmV4ZWMoZXh0ZW5zaW9uTmFtZSlbMV07XG4gICAgY29uc3QgZW51bVN1ZmZpeCA9ICdfJyArIGZuU3VmZml4O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4dCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBleHRba2V5XTtcbiAgICAgIGNvbnN0IGlzRnVuYyA9IHR5cGVvZiAodmFsdWUpID09PSAnZnVuY3Rpb24nO1xuICAgICAgY29uc3Qgc3VmZml4ID0gaXNGdW5jID8gZm5TdWZmaXggOiBlbnVtU3VmZml4O1xuICAgICAgbGV0IG5hbWUgPSBrZXk7XG4gICAgICAvLyBleGFtcGxlcyBvZiB3aGVyZSB0aGlzIGlzIG5vdCB0cnVlIGFyZSBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAgICAgLy8gYW5kIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xuICAgICAgaWYgKGtleS5lbmRzV2l0aChzdWZmaXgpKSB7XG4gICAgICAgIG5hbWUgPSBrZXkuc3Vic3RyaW5nKDAsIGtleS5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChnbFtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaXNGdW5jICYmIGdsW25hbWVdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHdhcm4obmFtZSwgZ2xbbmFtZV0sIHZhbHVlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgZ2xbbmFtZV0gPSBmdW5jdGlvbihvcmlnRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdGbi5hcHBseShleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0odmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgZW51bXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBwYXNzIHRoZSBtb2RpZmllZCBlbnVtcyB0byBnbEVudW1Ub1N0cmluZ1xuICAgIGVudW1zLmNvbnN0cnVjdG9yID0ge1xuICAgICAgbmFtZTogZXh0LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgfTtcbiAgICBnbEVudW1Ub1N0cmluZyhlbnVtcywgMCk7XG4gIH1cbiAgcmV0dXJuIGV4dDtcbn1cblxuLypcbiAqIElmIHlvdSdyZSB3b25kZXJpbmcgd2h5IHRoZSBjb2RlIGRvZXNuJ3QganVzdCBpdGVyYXRlXG4gKiBvdmVyIGFsbCBleHRlbnNpb25zIHVzaW5nIGBnbC5nZXRFeHRlbnNpb25zYCBpcyB0aGF0IGl0J3MgcG9zc2libGVcbiAqIHNvbWUgZnV0dXJlIGV4dGVuc2lvbiBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGlzIGNvZGUuIFJhdGhlciB0aGFuXG4gKiBoYXZlIHRoaW5nIHN1ZGRlbmx5IGJyZWFrIGl0IHNlZW1zIGJldHRlciB0byBtYW51YWxseSBhZGQgdG8gdGhpc1xuICogbGlzdC5cbiAqXG4gKi9cbmNvbnN0IHN1cHBvcnRlZEV4dGVuc2lvbnMgPSBbXG4gICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyxcbiAgJ0VYVF9ibGVuZF9taW5tYXgnLFxuICAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcsXG4gICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnLFxuICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JyxcbiAgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInLFxuICAnRVhUX2ZyYWdfZGVwdGgnLFxuICAnRVhUX3NSR0InLFxuICAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcsXG4gICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnLFxuICAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcsXG4gICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnLFxuICAnT0VTX3RleHR1cmVfZmxvYXQnLFxuICAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyxcbiAgJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnLFxuICAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInLFxuICAnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLFxuICAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyxcbiAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGMnLFxuICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnLFxuICAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyxcbiAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyxcbiAgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InLFxuICAnV0VCR0xfZGVwdGhfdGV4dHVyZScsXG4gICdXRUJHTF9kcmF3X2J1ZmZlcnMnLFxuXTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmFibGUgYWxsIG9mIHRoZSBmb2xsb3dpbmcgZXh0ZW5zaW9uc1xuICogYW5kIGFkZCB0aGVpciBmdW5jdGlvbnMgYW5kIGNvbnN0YW50cyB0byB0aGVcbiAqIGBXZWJHTFJlbmRlcmluZ0NvbnRleHRgIHVzaW5nIHRoZWlyIG5vcm1hbCBub24tZXh0ZW5zaW9uIGxpa2UgbmFtZXMuXG4gKlxuICogICAgICBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXG4gKiAgICAgIEVYVF9ibGVuZF9taW5tYXhcbiAqICAgICAgRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFxuICogICAgICBFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcbiAqICAgICAgRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XG4gKiAgICAgIEVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcbiAqICAgICAgRVhUX2ZyYWdfZGVwdGhcbiAqICAgICAgRVhUX3NSR0JcbiAqICAgICAgRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxuICogICAgICBFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcbiAqICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludFxuICogICAgICBPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcbiAqICAgICAgT0VTX3RleHR1cmVfZmxvYXRcbiAqICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXG4gKiAgICAgIE9FU190ZXh0dXJlX2hhbGZfZmxvYXRcbiAqICAgICAgT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXJcbiAqICAgICAgT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcbiAqICAgICAgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGNcbiAqICAgICAgV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcbiAqICAgICAgV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXG4gKiAgICAgIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2JcbiAqICAgICAgV0VCR0xfZGVwdGhfdGV4dHVyZVxuICogICAgICBXRUJHTF9kcmF3X2J1ZmZlcnNcbiAqXG4gKiBGb3IgZXhhbXBsZSBpZiBgQU5HTEVfaW5zdGFuY2VkX2FycmF5c2AgZXhpc3RzIHRoZW4gdGhlIGZ1bmN0aW9uc1xuICogYGRyYXdBcnJheXNJbnN0YW5jZWRgLCBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkYCwgYHZlcnRleEF0dHJpYkRpdmlzb3JgXG4gKiBhbmQgdGhlIGNvbnN0YW50IGBWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JgIGFyZSBhZGRlZCB0byB0aGVcbiAqIGBXZWJHTFJlbmRlcmluZ0NvbnRleHRgLlxuICpcbiAqIE5vdGUgdGhhdCBpZiB5b3Ugd2FudCB0byBrbm93IGlmIHRoZSBleHRlbnNpb24gZXhpc3RzIHlvdSBzaG91bGRcbiAqIHByb2JhYmx5IGNhbGwgYGdsLmdldEV4dGVuc2lvbmAgZm9yIGVhY2ggZXh0ZW5zaW9uLiBBbHRlcm5hdGl2ZWx5XG4gKiB5b3UgY2FuIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHRoZSBmdW5jdGlvbnMgb3IgY29uc3RhbnRzIHRoYXRcbiAqIGFyZSBleHBlY3RlZCB0byBiZSBhZGRlZC4gRm9yIGV4YW1wbGVcbiAqXG4gKiAgICBpZiAoZ2wuZHJhd0J1ZmZlcnMpIHtcbiAqICAgICAgLy8gRWl0aGVyIFdFQkdMX2RyYXdfYnVmZmVycyB3YXMgZW5hYmxlZCBPUiB5b3UncmUgcnVubmluZyBpbiBXZWJHTDJcbiAqICAgICAgLi4uLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBBIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogQG1lbWJlck9mIG1vZHVsZTp0d2dsXG4gKi9cbmZ1bmN0aW9uIGFkZEV4dGVuc2lvbnNUb0NvbnRleHQoZ2wpIHtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHN1cHBvcnRlZEV4dGVuc2lvbnMubGVuZ3RoOyArK2lpKSB7XG4gICAgYWRkRXh0ZW5zaW9uVG9Db250ZXh0KGdsLCBzdXBwb3J0ZWRFeHRlbnNpb25zW2lpXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgd2ViZ2wgY29udGV4dC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBUaGUgY2FudmFzIHRhZyB0byBnZXRcbiAqICAgICBjb250ZXh0IGZyb20uIElmIG9uZSBpcyBub3QgcGFzc2VkIGluIG9uZSB3aWxsIGJlXG4gKiAgICAgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGNyZWF0ZWQgY29udGV4dC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gIGNvbnN0IG5hbWVzID0gW1wid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gIGxldCBjb250ZXh0ID0gbnVsbDtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG5hbWVzLmxlbmd0aDsgKytpaSkge1xuICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpaV0sIG9wdF9hdHRyaWJzKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaWYgKGRlZmF1bHRzJDIuYWRkRXh0ZW5zaW9uc1RvQ29udGV4dCkge1xuICAgICAgICBhZGRFeHRlbnNpb25zVG9Db250ZXh0KGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIEdldHMgYSBXZWJHTDEgY29udGV4dC5cbiAqXG4gKiBOb3RlOiBXaWxsIGF0dGVtcHQgdG8gZW5hYmxlIFZlcnRleCBBcnJheSBPYmplY3RzXG4gKiBhbmQgYWRkIFdlYkdMMiBlbnRyeSBwb2ludHMuICh1bmxlc3MgeW91IGZpcnN0IHNldCBkZWZhdWx0cyB3aXRoXG4gKiBgdHdnbC5zZXREZWZhdWx0cyh7ZW5hYmxlVmVydGV4QXJyYXlPYmplY3RzOiBmYWxzZX0pYDtcbiAqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgYSBjYW52YXMgZWxlbWVudC5cbiAqIEBwYXJhbSB7V2ViR0xDb250ZXh0QXR0cmlidXRlc30gW29wdF9hdHRyaWJzXSBvcHRpb25hbCB3ZWJnbCBjb250ZXh0IGNyZWF0aW9uIGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGNyZWF0ZWQgY29udGV4dC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6dHdnbFxuICovXG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoY2FudmFzLCBvcHRfYXR0cmlicykge1xuICBjb25zdCBnbCA9IGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgcmV0dXJuIGdsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB3ZWJnbCBjb250ZXh0LlxuICpcbiAqIFdpbGwgcmV0dXJuIGEgV2ViR0wyIGNvbnRleHQgaWYgcG9zc2libGUuXG4gKlxuICogWW91IGNhbiBjaGVjayBpZiBpdCdzIFdlYkdMMiB3aXRoXG4gKlxuICogICAgIHR3Z2wuaXNXZWJHTDIoZ2wpO1xuICpcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBUaGUgY2FudmFzIHRhZyB0byBnZXRcbiAqICAgICBjb250ZXh0IGZyb20uIElmIG9uZSBpcyBub3QgcGFzc2VkIGluIG9uZSB3aWxsIGJlXG4gKiAgICAgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGNyZWF0ZWQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gIGNvbnN0IG5hbWVzID0gW1wid2ViZ2wyXCIsIFwid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIl07XG4gIGxldCBjb250ZXh0ID0gbnVsbDtcbiAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG5hbWVzLmxlbmd0aDsgKytpaSkge1xuICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpaV0sIG9wdF9hdHRyaWJzKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaWYgKGRlZmF1bHRzJDIuYWRkRXh0ZW5zaW9uc1RvQ29udGV4dCkge1xuICAgICAgICBhZGRFeHRlbnNpb25zVG9Db250ZXh0KGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIEdldHMgYSBXZWJHTCBjb250ZXh0LiAgV2lsbCBjcmVhdGUgYSBXZWJHTDIgY29udGV4dCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBZb3UgY2FuIGNoZWNrIGlmIGl0J3MgV2ViR0wyIHdpdGhcbiAqXG4gKiAgICBmdW5jdGlvbiBpc1dlYkdMMihnbCkge1xuICogICAgICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pLmluZGV4T2YoXCJXZWJHTCAyLjAgXCIpID09IDA7XG4gKiAgICB9XG4gKlxuICogTm90ZTogRm9yIGEgV2ViR0wxIGNvbnRleHQgd2lsbCBhdHRlbXB0IHRvIGVuYWJsZSBWZXJ0ZXggQXJyYXkgT2JqZWN0c1xuICogYW5kIGFkZCBXZWJHTDIgZW50cnkgcG9pbnRzLiAodW5sZXNzIHlvdSBmaXJzdCBzZXQgZGVmYXVsdHMgd2l0aFxuICogYHR3Z2wuc2V0RGVmYXVsdHMoe2VuYWJsZVZlcnRleEFycmF5T2JqZWN0czogZmFsc2V9KWA7XG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIGEgY2FudmFzIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dEF0dHJpYnV0ZXN9IFtvcHRfYXR0cmlic10gb3B0aW9uYWwgd2ViZ2wgY29udGV4dCBjcmVhdGlvbiBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjcmVhdGVkIGNvbnRleHQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKSB7XG4gIGNvbnN0IGdsID0gY3JlYXRlQ29udGV4dChjYW52YXMsIG9wdF9hdHRyaWJzKTtcbiAgcmV0dXJuIGdsO1xufVxuXG4vKipcbiAqIFJlc2l6ZSBhIGNhbnZhcyB0byBtYXRjaCB0aGUgc2l6ZSBpdCdzIGRpc3BsYXllZC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyBUaGUgY2FudmFzIHRvIHJlc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXVsdGlwbGllcl0gU28geW91IGNhbiBwYXNzIGluIGB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb2Agb3Igb3RoZXIgc2NhbGUgdmFsdWUgaWYgeW91IHdhbnQgdG8uXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjYW52YXMgd2FzIHJlc2l6ZWQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnR3Z2xcbiAqL1xuZnVuY3Rpb24gcmVzaXplQ2FudmFzVG9EaXNwbGF5U2l6ZShjYW52YXMsIG11bHRpcGxpZXIpIHtcbiAgbXVsdGlwbGllciA9IG11bHRpcGxpZXIgfHwgMTtcbiAgbXVsdGlwbGllciA9IE1hdGgubWF4KDAsIG11bHRpcGxpZXIpO1xuICBjb25zdCB3aWR0aCAgPSBjYW52YXMuY2xpZW50V2lkdGggICogbXVsdGlwbGllciB8IDA7XG4gIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQgKiBtdWx0aXBsaWVyIHwgMDtcbiAgaWYgKGNhbnZhcy53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB7IGFkZEV4dGVuc2lvbnNUb0NvbnRleHQsIGF0dHJpYnV0ZXMsIGJpbmRGcmFtZWJ1ZmZlckluZm8sIGJpbmRUcmFuc2Zvcm1GZWVkYmFja0luZm8sIGJpbmRVbmlmb3JtQmxvY2ssIGNhbkZpbHRlciwgY2FuR2VuZXJhdGVNaXBtYXAsIGNyZWF0ZUF0dHJpYnNGcm9tQXJyYXlzLCBjcmVhdGVBdHRyaWJ1dGVTZXR0ZXJzLCBjcmVhdGVCdWZmZXJGcm9tQXJyYXksIGNyZWF0ZUJ1ZmZlckZyb21UeXBlZEFycmF5LCBjcmVhdGVCdWZmZXJJbmZvRnJvbUFycmF5cywgY3JlYXRlQnVmZmVyc0Zyb21BcnJheXMsIGNyZWF0ZUZyYW1lYnVmZmVySW5mbywgY3JlYXRlUHJvZ3JhbSwgY3JlYXRlUHJvZ3JhbUZyb21TY3JpcHRzLCBjcmVhdGVQcm9ncmFtRnJvbVNvdXJjZXMsIGNyZWF0ZVByb2dyYW1JbmZvLCBjcmVhdGVQcm9ncmFtSW5mb0Zyb21Qcm9ncmFtLCBjcmVhdGVTYW1wbGVyLCBjcmVhdGVTYW1wbGVycywgY3JlYXRlVGV4dHVyZSwgY3JlYXRlVGV4dHVyZXMsIGNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrLCBjcmVhdGVUcmFuc2Zvcm1GZWVkYmFja0luZm8sIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm8sIGNyZWF0ZVVuaWZvcm1CbG9ja0luZm9Gcm9tUHJvZ3JhbSwgY3JlYXRlVW5pZm9ybUJsb2NrU3BlY0Zyb21Qcm9ncmFtLCBjcmVhdGVVbmlmb3JtU2V0dGVycywgY3JlYXRlVkFPQW5kU2V0QXR0cmlidXRlcywgY3JlYXRlVkFPRnJvbUJ1ZmZlckluZm8sIGNyZWF0ZVZlcnRleEFycmF5SW5mbywgZHJhdywgZHJhd0J1ZmZlckluZm8sIGRyYXdPYmplY3RMaXN0LCBmcmFtZWJ1ZmZlcnMsIGdldEFycmF5IGFzIGdldEFycmF5XywgZ2V0Qnl0ZXNQZXJFbGVtZW50Rm9ySW50ZXJuYWxGb3JtYXQsIGdldENvbnRleHQsIGdldEZvcm1hdEFuZFR5cGVGb3JJbnRlcm5hbEZvcm1hdCwgZ2V0R0xUeXBlRm9yVHlwZWRBcnJheSwgZ2V0R0xUeXBlRm9yVHlwZWRBcnJheVR5cGUsIGdldE51bUNvbXBvbmVudHNGb3JGb3JtYXQsIGdldE51bUNvbXBvbmVudHMgYXMgZ2V0TnVtQ29tcG9uZW50c18sIGdldFR5cGVkQXJyYXlUeXBlRm9yR0xUeXBlLCBnZXRXZWJHTENvbnRleHQsIGdsRW51bVRvU3RyaW5nLCBpc0FycmF5QnVmZmVyLCBpc1dlYkdMMSwgaXNXZWJHTDIsIGxvYWRUZXh0dXJlRnJvbVVybCwgbTQsIHByaW1pdGl2ZXMsIHByb2dyYW1zLCByZXNpemVDYW52YXNUb0Rpc3BsYXlTaXplLCByZXNpemVGcmFtZWJ1ZmZlckluZm8sIHJlc2l6ZVRleHR1cmUsIHNldEF0dHJpYkluZm9CdWZmZXJGcm9tQXJyYXksIHNldERlZmF1bHRzIGFzIHNldEF0dHJpYnV0ZURlZmF1bHRzXywgc2V0QXR0cmlidXRlUHJlZml4LCBzZXRBdHRyaWJ1dGVzLCBzZXRCbG9ja1VuaWZvcm1zLCBzZXRCdWZmZXJzQW5kQXR0cmlidXRlcywgc2V0RGVmYXVsdFRleHR1cmVDb2xvciwgc2V0RGVmYXVsdHMkMiBhcyBzZXREZWZhdWx0cywgc2V0RW1wdHlUZXh0dXJlLCBzZXRTYW1wbGVyUGFyYW1ldGVycywgc2V0RGVmYXVsdHMkMSBhcyBzZXRUZXh0dXJlRGVmYXVsdHNfLCBzZXRUZXh0dXJlRmlsdGVyaW5nRm9yU2l6ZSwgc2V0VGV4dHVyZUZyb21BcnJheSwgc2V0VGV4dHVyZUZyb21FbGVtZW50LCBzZXRUZXh0dXJlUGFyYW1ldGVycywgc2V0VW5pZm9ybUJsb2NrLCBzZXRVbmlmb3Jtcywgc2V0VW5pZm9ybXNBbmRCaW5kVGV4dHVyZXMsIHRleHR1cmVzLCB0eXBlZGFycmF5cywgdXRpbHMsIHYzLCB2ZXJ0ZXhBcnJheXMgfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyAgX19fICBfX18gIF8gICAgX19fICBfX18gXHJcbi8vIHwgLiBcXHwgLiB8fCB8ICB8IC4gfDxfICA+XHJcbi8vIHwgIF8vfCAgIHx8IHxfIHwgfCB8IC8gLyBcclxuLy8gfF98ICB8X3xffHxfX198YF9fXyc8X19fPlxyXG4vL1xyXG4vLyA4NeuQmOyXiOyImOuLpCEgMTAwSyDsiqTtjpjshZwgLyDsgq3soJzrkJjsl4jsiJjri6QhICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cclxuaW1wb3J0IHsgYXBwbGljYXRpb24sIHN0YWdlLCBFdmVudCwgQXBwbGljYXRpb24sIFNvdW5kLCBUaW1lciwgRXZlbnREaXNwYXRjaGVyLCBTcHJpdGUsIFRleHR1cmUgfSBmcm9tICdAZW5naW5lL2ZsYXRmYXN0JztcclxuaW1wb3J0IHsgVnNQYWQsIHZzU3RhZ2UsIFZzU3RhZ2UgfSBmcm9tIFwiLi92c1dyYXBwZXIvdnNcIjtcclxuXHJcbi8vIDI1NngyMDAg7ZSE66CI7J6E67KE7Y28XHJcbmFwcGxpY2F0aW9uLmluaXQoIDI1NiwyMDAgLDYwLEFwcGxpY2F0aW9uLlNjYWxlTW9kZXMuTEVUVEVSQk9YICk7XHJcbi8vIERPU+yLnOygiCDsk7DrjZggVmlzdWFsU2hvY2tlciBFbmdpbmVcclxuVnNTdGFnZS5pbml0KCk7XHJcbmFwcGxpY2F0aW9uLnNldEJhY2tncm91bmRDb2xvciggMHgwMDAwMDAgKTtcclxuXHJcbmltcG9ydCBcIi4vaW50cm9cIjtcclxuaW1wb3J0IFwiLi90aXRsZVwiO1xyXG5pbXBvcnQgXCIuL2RpYWxvZ1wiO1xyXG5pbXBvcnQgXCIuL2dhbWVFdmVudFwiO1xyXG5pbXBvcnQgXCIuL3pha29cIjtcclxuaW1wb3J0IFwiLi9wbGF5ZXJcIjtcclxuaW1wb3J0IFwiLi9nYW1lTG9vcFwiO1xyXG5cclxuLy8gdnNTdGFnZS5zZXRDYWNoZU1vZGUoIDIgKTtcclxuXHJcbnN0YWdlLmFkZENoaWxkKCBuZXcgVnNQYWQoICkgKTtcclxuc3RhZ2Uub24oIEV2ZW50LlNUQUdFX1ZJU0lCTEUsKCBlICk9PntcclxuICAgIC8vIOyduO2KuOuhnOyXkOyEnCDrrLjsoJzqsIAg65Cc64ukXHJcbiAgICBpZiAoICFlLnZpc2libGUgKSB7XHJcbiAgICAgICAgU291bmQuc3RvcEFsbFNpbmdsZVNvdW5kKCk7XHJcbiAgICB9XHJcbiAgICBhcHBsaWNhdGlvbi5zZXRQYXVzZWQoICFlLnZpc2libGUgKTtcclxufSApO1xyXG5hcHBsaWNhdGlvbi5kaXNwYXRjaEV2ZW50KCBcIm1vZGU6dGl0bGVcIiApOyBcclxuXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==